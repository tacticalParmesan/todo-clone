(self["webpackChunktodo_clone"] = self["webpackChunktodo_clone"] || []).push([["main"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/content.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/content.css ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#content {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 2rem;
}

#content-view {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    width: clamp(360px, 680px, 800px);
    height: 100%;
    overflow-y: scroll;
    scrollbar-width: none;
}

#upperContentPanel,
#projectDescription {
    display: flex;
    justify-content: space-between;
    align-content: center;

    width: 100%;
    padding: 0rem 2rem;
}

#projectButtons {
    display: flex;
    gap: .4rem;
}

.projectButton {
    width: 1.5rem;
    height: 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    background: none;
    border: none;
    padding: 1rem;
}

.projectButton:hover {
    cursor: pointer;
    background-color: rgba(0,0,0,0.040);
    border-radius: 0.5rem;
    transition: ease 0.1s;
}

.projectButton.delete {
    color: rgba(195, 40, 13, 0.745);
}

#projectName {
    font-size: 2rem;
    margin-bottom: 1rem;
}

#insideProjectAddButton {
    padding: 0.5rem;
    padding-left: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;

    border: none;
    background: none;
    color: red;
    font-weight: 700;
}

#emptyProjectScreen {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 1rem;
    align-self: center;
    margin-top: 25%;
    text-align: center;
}

#filterSelectionPanel[style*="display: flex"] ~ #emptyProjectScreen {
    margin-top: 5%;
}


#emptyImage {
    width: 300px;
    height: 300px;
}

.foldButton.content {
    transition: 2s ease; 
    transform: scaleX(-1);
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
}

#filterSelectionPanel {
    display: none;
    padding: 2rem;
    gap: .5rem
}

#filterSelectionPanel #prop,
#filterSelectionPanel #value {
    border-radius: 0.4rem;
    border: 1px solid rgba(0, 0, 0, 0.25);
    padding: 0.25rem;
    display: flex;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.0);
    color: rgba(0, 0, 0, 0.50);
}

#dialogOverlay {
    width: 100%;
    height: 100%;
    display: none;
    position: absolute;
    z-index: 5;
}
`, "",{"version":3,"sources":["webpack://./src/style/content.css"],"names":[],"mappings":"AAAA;IACI,OAAO;IACP,aAAa;IACb,sBAAsB;IACtB,mBAAmB;IACnB,uBAAuB;IACvB,WAAW;IACX,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,iCAAiC;IACjC,YAAY;IACZ,kBAAkB;IAClB,qBAAqB;AACzB;;AAEA;;IAEI,aAAa;IACb,8BAA8B;IAC9B,qBAAqB;;IAErB,WAAW;IACX,kBAAkB;AACtB;;AAEA;IACI,aAAa;IACb,UAAU;AACd;;AAEA;IACI,aAAa;IACb,cAAc;IACd,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,gBAAgB;IAChB,YAAY;IACZ,aAAa;AACjB;;AAEA;IACI,eAAe;IACf,mCAAmC;IACnC,qBAAqB;IACrB,qBAAqB;AACzB;;AAEA;IACI,+BAA+B;AACnC;;AAEA;IACI,eAAe;IACf,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,WAAW;;IAEX,YAAY;IACZ,gBAAgB;IAChB,UAAU;IACV,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,sBAAsB;IACtB,SAAS;IACT,kBAAkB;IAClB,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,cAAc;AAClB;;;AAGA;IACI,YAAY;IACZ,aAAa;AACjB;;AAEA;IACI,mBAAmB;IACnB,qBAAqB;IACrB,kBAAkB;IAClB,YAAY;IACZ,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,aAAa;IACb;AACJ;;AAEA;;IAEI,qBAAqB;IACrB,qCAAqC;IACrC,gBAAgB;IAChB,aAAa;IACb,uBAAuB;IACvB,oCAAoC;IACpC,0BAA0B;AAC9B;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,aAAa;IACb,kBAAkB;IAClB,UAAU;AACd","sourcesContent":["#content {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n    padding: 2rem;\n}\n\n#content-view {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    width: clamp(360px, 680px, 800px);\n    height: 100%;\n    overflow-y: scroll;\n    scrollbar-width: none;\n}\n\n#upperContentPanel,\n#projectDescription {\n    display: flex;\n    justify-content: space-between;\n    align-content: center;\n\n    width: 100%;\n    padding: 0rem 2rem;\n}\n\n#projectButtons {\n    display: flex;\n    gap: .4rem;\n}\n\n.projectButton {\n    width: 1.5rem;\n    height: 1.5rem;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    background: none;\n    border: none;\n    padding: 1rem;\n}\n\n.projectButton:hover {\n    cursor: pointer;\n    background-color: rgba(0,0,0,0.040);\n    border-radius: 0.5rem;\n    transition: ease 0.1s;\n}\n\n.projectButton.delete {\n    color: rgba(195, 40, 13, 0.745);\n}\n\n#projectName {\n    font-size: 2rem;\n    margin-bottom: 1rem;\n}\n\n#insideProjectAddButton {\n    padding: 0.5rem;\n    padding-left: 0;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n\n    border: none;\n    background: none;\n    color: red;\n    font-weight: 700;\n}\n\n#emptyProjectScreen {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    gap: 1rem;\n    align-self: center;\n    margin-top: 25%;\n    text-align: center;\n}\n\n#filterSelectionPanel[style*=\"display: flex\"] ~ #emptyProjectScreen {\n    margin-top: 5%;\n}\n\n\n#emptyImage {\n    width: 300px;\n    height: 300px;\n}\n\n.foldButton.content {\n    transition: 2s ease; \n    transform: scaleX(-1);\n    position: absolute;\n    top: 0.75rem;\n    left: 0.75rem;\n}\n\n#filterSelectionPanel {\n    display: none;\n    padding: 2rem;\n    gap: .5rem\n}\n\n#filterSelectionPanel #prop,\n#filterSelectionPanel #value {\n    border-radius: 0.4rem;\n    border: 1px solid rgba(0, 0, 0, 0.25);\n    padding: 0.25rem;\n    display: flex;\n    justify-content: center;\n    background-color: rgba(0, 0, 0, 0.0);\n    color: rgba(0, 0, 0, 0.50);\n}\n\n#dialogOverlay {\n    width: 100%;\n    height: 100%;\n    display: none;\n    position: absolute;\n    z-index: 5;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/main.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/main.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_sidebar_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./sidebar.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/sidebar.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_content_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./content.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/content.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_todo_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./todo.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/todo.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_todoform_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./todoform.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/todoform.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_projectform_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./projectform.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/projectform.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_mobile_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./mobile.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/mobile.css");
// Imports








var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap);"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_sidebar_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_content_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_todo_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_todoform_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_projectform_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_mobile_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*#region CSS Reset */
:root {
    font-family: "Roboto Mono", Arial, sans-serif;
    font-size: 16px;
}

* {
    padding: 0;
    margin: 0;
    list-style: none;
    font-size: inherit;
    font-family: inherit;
    box-sizing: border-box;
}
/*#endregion*/

/*#region Page Layout */

body {
    height: 100vh;
    background-color: rgba(0, 0, 0, 0);
}

.app {
    height: 100vh;
    display: flex;
    overflow: hidden;
}

/*#endregion */


`, "",{"version":3,"sources":["webpack://./src/style/main.css"],"names":[],"mappings":"AAQA,qBAAqB;AACrB;IACI,6CAA6C;IAC7C,eAAe;AACnB;;AAEA;IACI,UAAU;IACV,SAAS;IACT,gBAAgB;IAChB,kBAAkB;IAClB,oBAAoB;IACpB,sBAAsB;AAC1B;AACA,aAAa;;AAEb,uBAAuB;;AAEvB;IACI,aAAa;IACb,kCAAkC;AACtC;;AAEA;IACI,aAAa;IACb,aAAa;IACb,gBAAgB;AACpB;;AAEA,cAAc","sourcesContent":["@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap');\n@import \"sidebar.css\";\n@import \"content.css\";\n@import \"todo.css\";\n@import \"todoform.css\";\n@import \"projectform.css\";\n@import \"mobile.css\";\n\n/*#region CSS Reset */\n:root {\n    font-family: \"Roboto Mono\", Arial, sans-serif;\n    font-size: 16px;\n}\n\n* {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n    font-size: inherit;\n    font-family: inherit;\n    box-sizing: border-box;\n}\n/*#endregion*/\n\n/*#region Page Layout */\n\nbody {\n    height: 100vh;\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.app {\n    height: 100vh;\n    display: flex;\n    overflow: hidden;\n}\n\n/*#endregion */\n\n\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/mobile.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/mobile.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ``, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/projectform.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/projectform.css ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#projectDetails {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    width: 480px;
}

#projectDetails input, textarea {
    padding: 0.2rem;
    border: none;
}

#projectDetails textarea {
    resize: none;
}

#projectDetails input, textarea:focus {
    outline: none;
    border: none;
    box-shadow: none;
}

#projectFormName {
    font-size: 1.5rem;
    font-weight: 700;;
}

#colorSection {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

#colorSection select {
    flex: 1;
}
#colorSection select:focus {
    outline: none;
}

#colorCircle {
    background-color: black;
    border-radius: 50%;
    width: 1rem;
    height: 1rem;
}

#buttonsTab {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

#buttonsTab button {
    padding: 0.25rem 0.6rem;
    border-radius: 0.4rem;
    border: none;
}

#saveProject {
    background-color: rgba(0, 49, 83, 0.50);
    color: rgba(255, 255, 255, 0.85);
}

#saveProjectbody {
    background-color: rgba(0, 49, 83, 0.25);
}

#saveProject:disabled:hover {
    cursor: not-allowed;
}

#closeProjectForm {
    background-color: rgba(195, 40, 13, 0.745);
    color: rgba(255, 255, 255, 0.85);
}

#saveProject:not([disabled]):hover {
    cursor: pointer;
    background-color: rgba(0, 49, 83, 0.75);
    color: rgba(255, 255, 255, 0.85);
}

#closeProjectForm:hover {
    cursor: pointer;
    background-color: rgba(195, 40, 13, 0.95);
    color: rgba(255, 255, 255, 0.85);
}`, "",{"version":3,"sources":["webpack://./src/style/projectform.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,sBAAsB;IACtB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,WAAW;AACf;;AAEA;IACI,OAAO;AACX;AACA;IACI,aAAa;AACjB;;AAEA;IACI,uBAAuB;IACvB,kBAAkB;IAClB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,yBAAyB;IACzB,WAAW;AACf;;AAEA;IACI,uBAAuB;IACvB,qBAAqB;IACrB,YAAY;AAChB;;AAEA;IACI,uCAAuC;IACvC,gCAAgC;AACpC;;AAEA;IACI,uCAAuC;AAC3C;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,0CAA0C;IAC1C,gCAAgC;AACpC;;AAEA;IACI,eAAe;IACf,uCAAuC;IACvC,gCAAgC;AACpC;;AAEA;IACI,eAAe;IACf,yCAAyC;IACzC,gCAAgC;AACpC","sourcesContent":["#projectDetails {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    width: 480px;\n}\n\n#projectDetails input, textarea {\n    padding: 0.2rem;\n    border: none;\n}\n\n#projectDetails textarea {\n    resize: none;\n}\n\n#projectDetails input, textarea:focus {\n    outline: none;\n    border: none;\n    box-shadow: none;\n}\n\n#projectFormName {\n    font-size: 1.5rem;\n    font-weight: 700;;\n}\n\n#colorSection {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n#colorSection select {\n    flex: 1;\n}\n#colorSection select:focus {\n    outline: none;\n}\n\n#colorCircle {\n    background-color: black;\n    border-radius: 50%;\n    width: 1rem;\n    height: 1rem;\n}\n\n#buttonsTab {\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.5rem;\n}\n\n#buttonsTab button {\n    padding: 0.25rem 0.6rem;\n    border-radius: 0.4rem;\n    border: none;\n}\n\n#saveProject {\n    background-color: rgba(0, 49, 83, 0.50);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#saveProjectbody {\n    background-color: rgba(0, 49, 83, 0.25);\n}\n\n#saveProject:disabled:hover {\n    cursor: not-allowed;\n}\n\n#closeProjectForm {\n    background-color: rgba(195, 40, 13, 0.745);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#saveProject:not([disabled]):hover {\n    cursor: pointer;\n    background-color: rgba(0, 49, 83, 0.75);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#closeProjectForm:hover {\n    cursor: pointer;\n    background-color: rgba(195, 40, 13, 0.95);\n    color: rgba(255, 255, 255, 0.85);\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/sidebar.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/sidebar.css ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#sidebar {
    background-color: rgba(0,49,83,0.025);
    min-width: 240px;
    padding: 0.5rem;
    height: 100%;
    overflow: hidden;
    box-sizing: content-box;
    flex-basis: 0px;

}

#sidebar.foldable {
    transition: 0.75s ease;
}

#sidebar.folded {
    padding: 0px;
    min-width: 0px;
    width: 0px;
}

#sidebar,
.sidebarPanel {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    
}

#sidebar {
    gap: 1rem;
}

#sidebar p {
    color: rgba(0,0,0,0.75);
}

#userInfo:hover,
.foldButton:hover,
#addTodoButton:hover,
#addProject:hover,
.tab:hover,
.options:hover {
    cursor: pointer;
    background-color: rgba(0,0,0,0.040);
    transition: ease 0.1s;
}

/*#region User Panel */

#userPanel {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
}

#userPanel > * {
    display: flex;
    align-items: center;
}

#userInfo {
    padding: 0.5rem;
    gap: 0.5rem;
}

.circle #userCircle {
    text-align: center;
    font-weight: 700;
    color: rgba(255, 255, 255, 0.75);

    padding: 0.3rem;
    border-radius: 50%;
}

.foldButton {
    padding: 0.5rem;
    appearance: none;
    background: none;
    border: none;
    cursor: pointer;
    border-radius: 0.35rem;
}

/*#endregion */

/*#region Main Panel */

.tab {
    padding: 0.5rem;
    display: flex;
    align-items: center;
    border-radius: 0.35rem;
    gap: 0.5rem;
}

.tab #todoNumber {
    margin-left: auto;
    margin-right: 0.5rem;
    color: rgba(0, 49, 83, 0.9);
}

#addTodoButton {
    padding: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;

    border: none;
    background: none;
    font-weight: 700;
    border-radius: 0.35rem;
}

.circle {
    color: rgba(255, 255, 255, 0.75);
    background-color: rgba(0, 49, 83, 0.75);
    border-radius: 50%;

    display: flex;
    justify-content: center;
    align-items: center;
}

#addTodoButton span {
    text-align: center;
    font-weight: none;
}

#addTodoButton p {
    color: rgba(0, 49, 83, 0.75);
}

/*#endregion */

/*#region Projects Panel */

#projectHead {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#projectHead:hover {
    cursor: default;
}

#projectHead > p {
    padding-left: 0.5rem;
    color: rgba(0,0,0,0.5)
}

#addProject {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0.5rem;

    background: none;
    border: none;
    border-radius: 0.35rem;

}

.options {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 1.5rem;
    height: 1.5rem;
    background: none;
    border: none;

    margin-left: auto;
}

.projectName {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}


/*#endregion */

/*#region Shared */

.current {
    background-color: rgba(0,49,83,0.25);

}

#sidebar .current .panelText,
#sidebar .current .projectName  {
    color: rgba(0,49,83,1);
}

.current:hover{
    background-color: rgba(0,49,83,0.25);
}

/*#endregion */
`, "",{"version":3,"sources":["webpack://./src/style/sidebar.css"],"names":[],"mappings":"AAAA;IACI,qCAAqC;IACrC,gBAAgB;IAChB,eAAe;IACf,YAAY;IACZ,gBAAgB;IAChB,uBAAuB;IACvB,eAAe;;AAEnB;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,cAAc;IACd,UAAU;AACd;;AAEA;;IAEI,aAAa;IACb,sBAAsB;IACtB,YAAY;;AAEhB;;AAEA;IACI,SAAS;AACb;;AAEA;IACI,uBAAuB;AAC3B;;AAEA;;;;;;IAMI,eAAe;IACf,mCAAmC;IACnC,qBAAqB;AACzB;;AAEA,sBAAsB;;AAEtB;IACI,mBAAmB;IACnB,8BAA8B;IAC9B,mBAAmB;AACvB;;AAEA;IACI,aAAa;IACb,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,WAAW;AACf;;AAEA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,gCAAgC;;IAEhC,eAAe;IACf,kBAAkB;AACtB;;AAEA;IACI,eAAe;IACf,gBAAgB;IAChB,gBAAgB;IAChB,YAAY;IACZ,eAAe;IACf,sBAAsB;AAC1B;;AAEA,cAAc;;AAEd,sBAAsB;;AAEtB;IACI,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,sBAAsB;IACtB,WAAW;AACf;;AAEA;IACI,iBAAiB;IACjB,oBAAoB;IACpB,2BAA2B;AAC/B;;AAEA;IACI,eAAe;IACf,aAAa;IACb,mBAAmB;IACnB,WAAW;;IAEX,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,sBAAsB;AAC1B;;AAEA;IACI,gCAAgC;IAChC,uCAAuC;IACvC,kBAAkB;;IAElB,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA;IACI,4BAA4B;AAChC;;AAEA,cAAc;;AAEd,0BAA0B;;AAE1B;IACI,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;AACvB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,oBAAoB;IACpB;AACJ;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,eAAe;;IAEf,gBAAgB;IAChB,YAAY;IACZ,sBAAsB;;AAE1B;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,aAAa;IACb,cAAc;IACd,gBAAgB;IAChB,YAAY;;IAEZ,iBAAiB;AACrB;;AAEA;IACI,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;;AAGA,cAAc;;AAEd,kBAAkB;;AAElB;IACI,oCAAoC;;AAExC;;AAEA;;IAEI,sBAAsB;AAC1B;;AAEA;IACI,oCAAoC;AACxC;;AAEA,cAAc","sourcesContent":["#sidebar {\n    background-color: rgba(0,49,83,0.025);\n    min-width: 240px;\n    padding: 0.5rem;\n    height: 100%;\n    overflow: hidden;\n    box-sizing: content-box;\n    flex-basis: 0px;\n\n}\n\n#sidebar.foldable {\n    transition: 0.75s ease;\n}\n\n#sidebar.folded {\n    padding: 0px;\n    min-width: 0px;\n    width: 0px;\n}\n\n#sidebar,\n.sidebarPanel {\n    display: flex;\n    flex-direction: column;\n    gap: 0.25rem;\n    \n}\n\n#sidebar {\n    gap: 1rem;\n}\n\n#sidebar p {\n    color: rgba(0,0,0,0.75);\n}\n\n#userInfo:hover,\n.foldButton:hover,\n#addTodoButton:hover,\n#addProject:hover,\n.tab:hover,\n.options:hover {\n    cursor: pointer;\n    background-color: rgba(0,0,0,0.040);\n    transition: ease 0.1s;\n}\n\n/*#region User Panel */\n\n#userPanel {\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n}\n\n#userPanel > * {\n    display: flex;\n    align-items: center;\n}\n\n#userInfo {\n    padding: 0.5rem;\n    gap: 0.5rem;\n}\n\n.circle #userCircle {\n    text-align: center;\n    font-weight: 700;\n    color: rgba(255, 255, 255, 0.75);\n\n    padding: 0.3rem;\n    border-radius: 50%;\n}\n\n.foldButton {\n    padding: 0.5rem;\n    appearance: none;\n    background: none;\n    border: none;\n    cursor: pointer;\n    border-radius: 0.35rem;\n}\n\n/*#endregion */\n\n/*#region Main Panel */\n\n.tab {\n    padding: 0.5rem;\n    display: flex;\n    align-items: center;\n    border-radius: 0.35rem;\n    gap: 0.5rem;\n}\n\n.tab #todoNumber {\n    margin-left: auto;\n    margin-right: 0.5rem;\n    color: rgba(0, 49, 83, 0.9);\n}\n\n#addTodoButton {\n    padding: 0.5rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n\n    border: none;\n    background: none;\n    font-weight: 700;\n    border-radius: 0.35rem;\n}\n\n.circle {\n    color: rgba(255, 255, 255, 0.75);\n    background-color: rgba(0, 49, 83, 0.75);\n    border-radius: 50%;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n#addTodoButton span {\n    text-align: center;\n    font-weight: none;\n}\n\n#addTodoButton p {\n    color: rgba(0, 49, 83, 0.75);\n}\n\n/*#endregion */\n\n/*#region Projects Panel */\n\n#projectHead {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n#projectHead:hover {\n    cursor: default;\n}\n\n#projectHead > p {\n    padding-left: 0.5rem;\n    color: rgba(0,0,0,0.5)\n}\n\n#addProject {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 0.5rem;\n\n    background: none;\n    border: none;\n    border-radius: 0.35rem;\n\n}\n\n.options {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 1.5rem;\n    height: 1.5rem;\n    background: none;\n    border: none;\n\n    margin-left: auto;\n}\n\n.projectName {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n\n/*#endregion */\n\n/*#region Shared */\n\n.current {\n    background-color: rgba(0,49,83,0.25);\n\n}\n\n#sidebar .current .panelText,\n#sidebar .current .projectName  {\n    color: rgba(0,49,83,1);\n}\n\n.current:hover{\n    background-color: rgba(0,49,83,0.25);\n}\n\n/*#endregion */\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/todo.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/todo.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#todoView {
    width: 100%;
}

.todo {
    display: flex;
    flex: 1;
    gap: 1rem;
    align-items: center;
    
    padding: 1rem;
    width: 90%;
}

.doneCheck {
    appearance: none;
    border-radius: 50%;
    width: 1.25rem;
    height: 1.25rem;
    outline: 1px solid rgba(0,0,0,0.40);
    display: grid;
    place-content: center;
}

.doneCheck:checked{
    padding: 0.5rem;
    background-color: rgba(0, 49, 83, 0.50);
}

.doneCheck::before{
    content: "";
    transform: scale(0);
    width: 0.65em;
    height: 0.65em;
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em rgba(255, 255, 255, 0.85);
    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
}

.doneCheck:checked::before {
    transform: scale(1);
}

.todoInfoTab {
    align-self: flex-start;
    display: flex;
    flex-direction: column;
}

.todoDesc {
    margin-top: auto;
    width: 240px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.rightTab {
    margin-left: auto;
}

.todoDateProjectTab {
    align-self: flex-end;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.todoDateProjectTab span, time {
    font-size: 1rem;
    color: rgba(0, 49, 83, 0.75);
}

.todoDateProjectTab .projectSymbol {
    color: initial;
}

.buttonsTab {
    display: flex;
    align-items: center;
    justify-content: end;
    gap: 0.5rem;
}

.todoButton {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 1.5rem;
    height: 1.5rem;

    padding: 1rem;
    appearance: none;
    background: none;
    border: none;
    cursor: pointer;
}

.todoButton:hover {
    cursor: pointer;
    background-color: rgba(0,0,0,0.040);
    border-radius: 0.5rem;
    transition: ease 0.1s;
}

.done .todoTitle,
.done .todoDesc {
    text-decoration: line-through
}
`, "",{"version":3,"sources":["webpack://./src/style/todo.css"],"names":[],"mappings":"AAAA;IACI,WAAW;AACf;;AAEA;IACI,aAAa;IACb,OAAO;IACP,SAAS;IACT,mBAAmB;;IAEnB,aAAa;IACb,UAAU;AACd;;AAEA;IACI,gBAAgB;IAChB,kBAAkB;IAClB,cAAc;IACd,eAAe;IACf,mCAAmC;IACnC,aAAa;IACb,qBAAqB;AACzB;;AAEA;IACI,eAAe;IACf,uCAAuC;AAC3C;;AAEA;IACI,WAAW;IACX,mBAAmB;IACnB,aAAa;IACb,cAAc;IACd,uCAAuC;IACvC,mDAAmD;IACnD,uEAAuE;AAC3E;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,sBAAsB;IACtB,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,gBAAgB;IAChB,YAAY;IACZ,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,oBAAoB;IACpB,aAAa;IACb,mBAAmB;IACnB,uBAAuB;IACvB,WAAW;AACf;;AAEA;IACI,eAAe;IACf,4BAA4B;AAChC;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,oBAAoB;IACpB,WAAW;AACf;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,aAAa;IACb,cAAc;;IAEd,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,YAAY;IACZ,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,mCAAmC;IACnC,qBAAqB;IACrB,qBAAqB;AACzB;;AAEA;;IAEI;AACJ","sourcesContent":["#todoView {\n    width: 100%;\n}\n\n.todo {\n    display: flex;\n    flex: 1;\n    gap: 1rem;\n    align-items: center;\n    \n    padding: 1rem;\n    width: 90%;\n}\n\n.doneCheck {\n    appearance: none;\n    border-radius: 50%;\n    width: 1.25rem;\n    height: 1.25rem;\n    outline: 1px solid rgba(0,0,0,0.40);\n    display: grid;\n    place-content: center;\n}\n\n.doneCheck:checked{\n    padding: 0.5rem;\n    background-color: rgba(0, 49, 83, 0.50);\n}\n\n.doneCheck::before{\n    content: \"\";\n    transform: scale(0);\n    width: 0.65em;\n    height: 0.65em;\n    transition: 120ms transform ease-in-out;\n    box-shadow: inset 1em 1em rgba(255, 255, 255, 0.85);\n    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);\n}\n\n.doneCheck:checked::before {\n    transform: scale(1);\n}\n\n.todoInfoTab {\n    align-self: flex-start;\n    display: flex;\n    flex-direction: column;\n}\n\n.todoDesc {\n    margin-top: auto;\n    width: 240px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.rightTab {\n    margin-left: auto;\n}\n\n.todoDateProjectTab {\n    align-self: flex-end;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n}\n\n.todoDateProjectTab span, time {\n    font-size: 1rem;\n    color: rgba(0, 49, 83, 0.75);\n}\n\n.todoDateProjectTab .projectSymbol {\n    color: initial;\n}\n\n.buttonsTab {\n    display: flex;\n    align-items: center;\n    justify-content: end;\n    gap: 0.5rem;\n}\n\n.todoButton {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 1.5rem;\n    height: 1.5rem;\n\n    padding: 1rem;\n    appearance: none;\n    background: none;\n    border: none;\n    cursor: pointer;\n}\n\n.todoButton:hover {\n    cursor: pointer;\n    background-color: rgba(0,0,0,0.040);\n    border-radius: 0.5rem;\n    transition: ease 0.1s;\n}\n\n.done .todoTitle,\n.done .todoDesc {\n    text-decoration: line-through\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/todoform.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/todoform.css ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `dialog{
    opacity: 0;
    transition: .25s ease;
	transform: scale(0);
    top: 20%;
    justify-self: center;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-content: center;
    justify-content: center;
    gap: 1rem;
    padding: 1.5rem; 
}


dialog[open] {
    border: none;
    border-radius: 0.6rem;
    box-shadow: 0 0 2rem 3px rgba(0, 0, 0, 0.25);
    
    visibility: visible;
    opacity: 1;
	transform: scale(1);
}

dialog[open]::backdrop {
    z-index: 5;
    backdrop-filter: blur(10px);
    background-color: aqua;
}

#todoForm {
    display: flex;
    flex-direction: column;
    width: 480px;
    gap: 0.5rem;
}

#upperPanel {
    display: flex;
    flex-direction: column;
}

#upperPanel input {
    padding: 0.2rem;
    border: none
}

#upperPanel input:focus {
    outline: none;
    border: none;
    box-shadow: none;
}

#formTitle {
    font-size: 1.5rem;
    font-weight: 700;
}

#formDesc {
    max-width: 100%;
    overflow-y: auto;
    resize: vertical;
}

#formDesc:active,
#formDesc:focus {
  overflow-y: visible; 
}

#formOptions {
    display: flex;
    align-items: center;
    justify-items: flex-start;
    gap: 0.5rem;
}

#formOptions input, select{
    border-radius: 0.4rem;
    border: 1px solid rgba(0, 0, 0, 0.25);
    padding: 0.25rem;
    display: flex;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.0);
    color: rgba(0, 0, 0, 0.50);
}

#todoForm hr {
    border: none;
    margin-top: 0.4rem;
    margin-bottom: 0.4rem;
    border-bottom: 0.5px solid rgba(0, 0, 0, 0.25);
}

#lowerPanel {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

#lowerPanel button {
    padding: 0.25rem 0.6rem;
    border-radius: 0.4rem;
    border: none;
}

#saveTodo {
    background-color: rgba(0, 49, 83, 0.70);
    color: rgba(255, 255, 255, 0.85);
}

#saveTodo:disabled {
    background-color: rgba(0, 49, 83, 0.25);
}

#saveTodo:disabled:hover {
    cursor: not-allowed;
}

#closeForm {
    background-color: rgba(195, 40, 13, 0.745);
    color: rgba(255, 255, 255, 0.85);
}

#saveTodo:not([disabled]):hover {
    cursor: pointer;
    background-color: rgba(0, 49, 83, 0.75);
    color: rgba(255, 255, 255, 0.85);
}

#closeForm:hover {
    cursor: pointer;
    background-color: rgba(195, 40, 13, 0.95);
    color: rgba(255, 255, 255, 0.85);
}


`, "",{"version":3,"sources":["webpack://./src/style/todoform.css"],"names":[],"mappings":"AAAA;IACI,UAAU;IACV,qBAAqB;CACxB,mBAAmB;IAChB,QAAQ;IACR,oBAAoB;IACpB,WAAW;IACX,aAAa;IACb,sBAAsB;IACtB,qBAAqB;IACrB,uBAAuB;IACvB,SAAS;IACT,eAAe;AACnB;;;AAGA;IACI,YAAY;IACZ,qBAAqB;IACrB,4CAA4C;;IAE5C,mBAAmB;IACnB,UAAU;CACb,mBAAmB;AACpB;;AAEA;IACI,UAAU;IACV,2BAA2B;IAC3B,sBAAsB;AAC1B;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,YAAY;IACZ,WAAW;AACf;;AAEA;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,eAAe;IACf;AACJ;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,yBAAyB;IACzB,WAAW;AACf;;AAEA;IACI,qBAAqB;IACrB,qCAAqC;IACrC,gBAAgB;IAChB,aAAa;IACb,uBAAuB;IACvB,oCAAoC;IACpC,0BAA0B;AAC9B;;AAEA;IACI,YAAY;IACZ,kBAAkB;IAClB,qBAAqB;IACrB,8CAA8C;AAClD;;AAEA;IACI,aAAa;IACb,yBAAyB;IACzB,WAAW;AACf;;AAEA;IACI,uBAAuB;IACvB,qBAAqB;IACrB,YAAY;AAChB;;AAEA;IACI,uCAAuC;IACvC,gCAAgC;AACpC;;AAEA;IACI,uCAAuC;AAC3C;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,0CAA0C;IAC1C,gCAAgC;AACpC;;AAEA;IACI,eAAe;IACf,uCAAuC;IACvC,gCAAgC;AACpC;;AAEA;IACI,eAAe;IACf,yCAAyC;IACzC,gCAAgC;AACpC","sourcesContent":["dialog{\n    opacity: 0;\n    transition: .25s ease;\n\ttransform: scale(0);\n    top: 20%;\n    justify-self: center;\n    z-index: 10;\n    display: flex;\n    flex-direction: column;\n    align-content: center;\n    justify-content: center;\n    gap: 1rem;\n    padding: 1.5rem; \n}\n\n\ndialog[open] {\n    border: none;\n    border-radius: 0.6rem;\n    box-shadow: 0 0 2rem 3px rgba(0, 0, 0, 0.25);\n    \n    visibility: visible;\n    opacity: 1;\n\ttransform: scale(1);\n}\n\ndialog[open]::backdrop {\n    z-index: 5;\n    backdrop-filter: blur(10px);\n    background-color: aqua;\n}\n\n#todoForm {\n    display: flex;\n    flex-direction: column;\n    width: 480px;\n    gap: 0.5rem;\n}\n\n#upperPanel {\n    display: flex;\n    flex-direction: column;\n}\n\n#upperPanel input {\n    padding: 0.2rem;\n    border: none\n}\n\n#upperPanel input:focus {\n    outline: none;\n    border: none;\n    box-shadow: none;\n}\n\n#formTitle {\n    font-size: 1.5rem;\n    font-weight: 700;\n}\n\n#formDesc {\n    max-width: 100%;\n    overflow-y: auto;\n    resize: vertical;\n}\n\n#formDesc:active,\n#formDesc:focus {\n  overflow-y: visible; \n}\n\n#formOptions {\n    display: flex;\n    align-items: center;\n    justify-items: flex-start;\n    gap: 0.5rem;\n}\n\n#formOptions input, select{\n    border-radius: 0.4rem;\n    border: 1px solid rgba(0, 0, 0, 0.25);\n    padding: 0.25rem;\n    display: flex;\n    justify-content: center;\n    background-color: rgba(0, 0, 0, 0.0);\n    color: rgba(0, 0, 0, 0.50);\n}\n\n#todoForm hr {\n    border: none;\n    margin-top: 0.4rem;\n    margin-bottom: 0.4rem;\n    border-bottom: 0.5px solid rgba(0, 0, 0, 0.25);\n}\n\n#lowerPanel {\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.5rem;\n}\n\n#lowerPanel button {\n    padding: 0.25rem 0.6rem;\n    border-radius: 0.4rem;\n    border: none;\n}\n\n#saveTodo {\n    background-color: rgba(0, 49, 83, 0.70);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#saveTodo:disabled {\n    background-color: rgba(0, 49, 83, 0.25);\n}\n\n#saveTodo:disabled:hover {\n    cursor: not-allowed;\n}\n\n#closeForm {\n    background-color: rgba(195, 40, 13, 0.745);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#saveTodo:not([disabled]):hover {\n    cursor: pointer;\n    background-color: rgba(0, 49, 83, 0.75);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n#closeForm:hover {\n    cursor: pointer;\n    background-color: rgba(195, 40, 13, 0.95);\n    color: rgba(255, 255, 255, 0.85);\n}\n\n\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/date-fns/_lib/addLeadingZeros.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/_lib/addLeadingZeros.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.addLeadingZeros = addLeadingZeros;
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/_lib/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "defaultLocale", ({
  enumerable: true,
  get: function () {
    return _index.enUS;
  },
}));
var _index = __webpack_require__(/*! ../locale/en-US.js */ "./node_modules/date-fns/locale/en-US.js");


/***/ }),

/***/ "./node_modules/date-fns/_lib/defaultOptions.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/_lib/defaultOptions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.getDefaultOptions = getDefaultOptions;
exports.setDefaultOptions = setDefaultOptions;

let defaultOptions = {};

function getDefaultOptions() {
  return defaultOptions;
}

function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/formatters.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/formatters.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatters = void 0;
var _index = __webpack_require__(/*! ../../getDayOfYear.js */ "./node_modules/date-fns/getDayOfYear.js");
var _index2 = __webpack_require__(/*! ../../getISOWeek.js */ "./node_modules/date-fns/getISOWeek.js");
var _index3 = __webpack_require__(/*! ../../getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
var _index4 = __webpack_require__(/*! ../../getWeek.js */ "./node_modules/date-fns/getWeek.js");
var _index5 = __webpack_require__(/*! ../../getWeekYear.js */ "./node_modules/date-fns/getWeekYear.js");

var _index6 = __webpack_require__(/*! ../addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");
var _index7 = __webpack_require__(/*! ./lightFormatters.js */ "./node_modules/date-fns/_lib/format/lightFormatters.js");

const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night",
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

const formatters = (exports.formatters = {
  // Era
  G: function (date, token, localize) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize.era(era, { width: "wide" });
    }
  },

  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === "yo") {
      const signedYear = date.getFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, { unit: "year" });
    }

    return _index7.lightFormatters.y(date, token);
  },

  // Local week-numbering year
  Y: function (date, token, localize, options) {
    const signedWeekYear = (0, _index5.getWeekYear)(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return (0, _index6.addLeadingZeros)(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, { unit: "year" });
    }

    // Padding
    return (0, _index6.addLeadingZeros)(weekYear, token.length);
  },

  // ISO week-numbering year
  R: function (date, token) {
    const isoWeekYear = (0, _index3.getISOWeekYear)(date);

    // Padding
    return (0, _index6.addLeadingZeros)(isoWeekYear, token.length);
  },

  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    const year = date.getFullYear();
    return (0, _index6.addLeadingZeros)(year, token.length);
  },

  // Quarter
  Q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return (0, _index6.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone quarter
  q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return (0, _index6.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // Month
  M: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return _index7.lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting",
        });
      // J, F, ..., D
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize.month(month, { width: "wide", context: "formatting" });
    }
  },

  // Stand-alone month
  L: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return (0, _index6.addLeadingZeros)(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone",
        });
      // J, F, ..., D
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize.month(month, { width: "wide", context: "standalone" });
    }
  },

  // Local week of year
  w: function (date, token, localize, options) {
    const week = (0, _index4.getWeek)(date, options);

    if (token === "wo") {
      return localize.ordinalNumber(week, { unit: "week" });
    }

    return (0, _index6.addLeadingZeros)(week, token.length);
  },

  // ISO week of year
  I: function (date, token, localize) {
    const isoWeek = (0, _index2.getISOWeek)(date);

    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, { unit: "week" });
    }

    return (0, _index6.addLeadingZeros)(isoWeek, token.length);
  },

  // Day of the month
  d: function (date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getDate(), { unit: "date" });
    }

    return _index7.lightFormatters.d(date, token);
  },

  // Day of year
  D: function (date, token, localize) {
    const dayOfYear = (0, _index.getDayOfYear)(date);

    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }

    return (0, _index6.addLeadingZeros)(dayOfYear, token.length);
  },

  // Day of week
  E: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Local day of week
  e: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return (0, _index6.addLeadingZeros)(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return (0, _index6.addLeadingZeros)(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone",
        });
      // T
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone",
        });
      // Tuesday
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // ISO day of week
  i: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return (0, _index6.addLeadingZeros)(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM or PM
  a: function (date, token, localize) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "aaa":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }

    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "bbb":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return _index7.lightFormatters.h(date, token);
  },

  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
    }

    return _index7.lightFormatters.H(date, token);
  },

  // Hour [0-11]
  K: function (date, token, localize) {
    const hours = date.getHours() % 12;

    if (token === "Ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0, _index6.addLeadingZeros)(hours, token.length);
  },

  // Hour [1-24]
  k: function (date, token, localize) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;

    if (token === "ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0, _index6.addLeadingZeros)(hours, token.length);
  },

  // Minute
  m: function (date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }

    return _index7.lightFormatters.m(date, token);
  },

  // Second
  s: function (date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
    }

    return _index7.lightFormatters.s(date, token);
  },

  // Fraction of second
  S: function (date, token) {
    return _index7.lightFormatters.S(date, token);
  },

  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return "Z";
    }

    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (GMT)
  O: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (specific non-location)
  z: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Seconds timestamp
  t: function (date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1000);
    return (0, _index6.addLeadingZeros)(timestamp, token.length);
  },

  // Milliseconds timestamp
  T: function (date, token, _localize) {
    const timestamp = date.getTime();
    return (0, _index6.addLeadingZeros)(timestamp, token.length);
  },
});

function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return (
    sign + String(hours) + delimiter + (0, _index6.addLeadingZeros)(minutes, 2)
  );
}

function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + (0, _index6.addLeadingZeros)(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}

function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = (0, _index6.addLeadingZeros)(Math.trunc(absOffset / 60), 2);
  const minutes = (0, _index6.addLeadingZeros)(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/lightFormatters.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/lightFormatters.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lightFormatters = void 0;
var _index = __webpack_require__(/*! ../addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

const lightFormatters = (exports.lightFormatters = {
  // Year
  y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    const signedYear = date.getFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0, _index.addLeadingZeros)(
      token === "yy" ? year % 100 : year,
      token.length,
    );
  },

  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M"
      ? String(month + 1)
      : (0, _index.addLeadingZeros)(month + 1, 2);
  },

  // Day of the month
  d(date, token) {
    return (0, _index.addLeadingZeros)(date.getDate(), token.length);
  },

  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },

  // Hour [1-12]
  h(date, token) {
    return (0, _index.addLeadingZeros)(
      date.getHours() % 12 || 12,
      token.length,
    );
  },

  // Hour [0-23]
  H(date, token) {
    return (0, _index.addLeadingZeros)(date.getHours(), token.length);
  },

  // Minute
  m(date, token) {
    return (0, _index.addLeadingZeros)(date.getMinutes(), token.length);
  },

  // Second
  s(date, token) {
    return (0, _index.addLeadingZeros)(date.getSeconds(), token.length);
  },

  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3),
    );
    return (0, _index.addLeadingZeros)(fractionalSeconds, token.length);
  },
});


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/longFormatters.js":
/*!*************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/longFormatters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.longFormatters = void 0;

const dateLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong.date({ width: "full" });
  }
};

const timeLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    case "pppp":
    default:
      return formatLong.time({ width: "full" });
  }
};

const dateTimeLongFormatter = (pattern, formatLong) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  let dateTimeFormat;

  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
      break;
  }

  return dateTimeFormat
    .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
    .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};

const longFormatters = (exports.longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter,
});


/***/ }),

/***/ "./node_modules/date-fns/_lib/getRoundingMethod.js":
/*!*********************************************************!*\
  !*** ./node_modules/date-fns/_lib/getRoundingMethod.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.getRoundingMethod = getRoundingMethod;

function getRoundingMethod(method) {
  return (number) => {
    const round = method ? Math[method] : Math.trunc;
    const result = round(number);
    // Prevent negative zero
    return result === 0 ? 0 : result;
  };
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getTimezoneOffsetInMilliseconds = getTimezoneOffsetInMilliseconds;
var _index = __webpack_require__(/*! ../toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  const _date = (0, _index.toDate)(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds(),
    ),
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/protectedTokens.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/_lib/protectedTokens.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
exports.warnOrThrowProtectedError = warnOrThrowProtectedError;
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;

const throwTokens = ["D", "DD", "YY", "YYYY"];

function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}

function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}

function warnOrThrowProtectedError(token, format, input) {
  const _message = message(token, format, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}

function message(token, format, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}


/***/ }),

/***/ "./node_modules/date-fns/add.js":
/*!**************************************!*\
  !*** ./node_modules/date-fns/add.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.add = add;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./addMonths.js */ "./node_modules/date-fns/addMonths.js");
var _index3 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name add
 * @category Common Helpers
 * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @description
 * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * | Key            | Description                        |
 * |----------------|------------------------------------|
 * | years          | Amount of years to be added        |
 * | months         | Amount of months to be added       |
 * | weeks          | Amount of weeks to be added        |
 * | days           | Amount of days to be added         |
 * | hours          | Amount of hours to be added        |
 * | minutes        | Amount of minutes to be added      |
 * | seconds        | Amount of seconds to be added      |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add the following duration to 1 September 2014, 10:19:50
 * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,\\-7
 *   minutes: 9,
 *   seconds: 30,
 * })
 * //=> Thu Jun 15 2017 15:29:20
 */
function add(date, duration) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  // Add years and months
  const _date = (0, _index4.toDate)(date);
  const dateWithMonths =
    months || years
      ? (0, _index2.addMonths)(_date, months + years * 12)
      : _date;

  // Add weeks and days
  const dateWithDays =
    days || weeks
      ? (0, _index.addDays)(dateWithMonths, days + weeks * 7)
      : dateWithMonths;

  // Add days, hours, minutes and seconds
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1000;
  const finalDate = (0, _index3.constructFrom)(
    date,
    dateWithDays.getTime() + msToAdd,
  );

  return finalDate;
}


/***/ }),

/***/ "./node_modules/date-fns/addBusinessDays.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/addBusinessDays.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addBusinessDays = addBusinessDays;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./isSaturday.js */ "./node_modules/date-fns/isSaturday.js");
var _index3 = __webpack_require__(/*! ./isSunday.js */ "./node_modules/date-fns/isSunday.js");
var _index4 = __webpack_require__(/*! ./isWeekend.js */ "./node_modules/date-fns/isWeekend.js");
var _index5 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name addBusinessDays
 * @category Date Extension Helpers
 * @summary Add the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be added.
 *
 * @returns The new date with the business days added
 *
 * @example
 * // Add 10 business days to 1 September 2014:
 * const result = addBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)
 */
function addBusinessDays(date, amount) {
  const _date = (0, _index5.toDate)(date);
  const startedOnWeekend = (0, _index4.isWeekend)(_date);

  if (isNaN(amount)) return (0, _index.constructFrom)(date, NaN);

  const hours = _date.getHours();
  const sign = amount < 0 ? -1 : 1;
  const fullWeeks = Math.trunc(amount / 5);

  _date.setDate(_date.getDate() + fullWeeks * 7);

  // Get remaining days not part of a full week
  let restDays = Math.abs(amount % 5);

  // Loops over remaining days
  while (restDays > 0) {
    _date.setDate(_date.getDate() + sign);
    if (!(0, _index4.isWeekend)(_date)) restDays -= 1;
  }

  // If the date is a weekend day and we reduce a dividable of
  // 5 from it, we land on a weekend date.
  // To counter this, we add days accordingly to land on the next business day
  if (startedOnWeekend && (0, _index4.isWeekend)(_date) && amount !== 0) {
    // If we're reducing days, we want to add days until we land on a weekday
    // If we're adding days we want to reduce days until we land on a weekday
    if ((0, _index2.isSaturday)(_date))
      _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));
    if ((0, _index3.isSunday)(_date))
      _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));
  }

  // Restore hours to avoid DST lag
  _date.setHours(hours);

  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/addDays.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/addDays.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addDays = addDays;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be added.
 *
 * @returns The new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(date, amount) {
  const _date = (0, _index.toDate)(date);
  if (isNaN(amount)) return (0, _index2.constructFrom)(date, NaN);
  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/addHours.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/addHours.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addHours = addHours;
var _index = __webpack_require__(/*! ./addMilliseconds.js */ "./node_modules/date-fns/addMilliseconds.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be added.
 *
 * @returns The new date with the hours added
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */
function addHours(date, amount) {
  return (0, _index.addMilliseconds)(date, amount * _index2.millisecondsInHour);
}


/***/ }),

/***/ "./node_modules/date-fns/addISOWeekYears.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/addISOWeekYears.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addISOWeekYears = addISOWeekYears;
var _index = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
var _index2 = __webpack_require__(/*! ./setISOWeekYear.js */ "./node_modules/date-fns/setISOWeekYear.js");

/**
 * @name addISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Add the specified number of ISO week-numbering years to the given date.
 *
 * @description
 * Add the specified number of ISO week-numbering years to the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be added.
 *
 * @returns The new date with the ISO week-numbering years added
 *
 * @example
 * // Add 5 ISO week-numbering years to 2 July 2010:
 * const result = addISOWeekYears(new Date(2010, 6, 2), 5)
 * //=> Fri Jn 26 2015 00:00:00
 */
function addISOWeekYears(date, amount) {
  return (0, _index2.setISOWeekYear)(
    date,
    (0, _index.getISOWeekYear)(date) + amount,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/addMilliseconds.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/addMilliseconds.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addMilliseconds = addMilliseconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be added.
 *
 * @returns The new date with the milliseconds added
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(date, amount) {
  const timestamp = +(0, _index.toDate)(date);
  return (0, _index2.constructFrom)(date, timestamp + amount);
}


/***/ }),

/***/ "./node_modules/date-fns/addMinutes.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/addMinutes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addMinutes = addMinutes;
var _index = __webpack_require__(/*! ./addMilliseconds.js */ "./node_modules/date-fns/addMilliseconds.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be added.
 *
 * @returns The new date with the minutes added
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */
function addMinutes(date, amount) {
  return (0, _index.addMilliseconds)(
    date,
    amount * _index2.millisecondsInMinute,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/addMonths.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/addMonths.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addMonths = addMonths;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be added.
 *
 * @returns The new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 *
 * // Add one month to 30 January 2023:
 * const result = addMonths(new Date(2023, 0, 30), 1)
 * //=> Tue Feb 28 2023 00:00:00
 */
function addMonths(date, amount) {
  const _date = (0, _index.toDate)(date);
  if (isNaN(amount)) return (0, _index2.constructFrom)(date, NaN);
  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return _date;
  }
  const dayOfMonth = _date.getDate();

  // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.
  const endOfDesiredMonth = (0, _index2.constructFrom)(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth,
    );
    return _date;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/addQuarters.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/addQuarters.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addQuarters = addQuarters;
var _index = __webpack_require__(/*! ./addMonths.js */ "./node_modules/date-fns/addMonths.js");

/**
 * @name addQuarters
 * @category Quarter Helpers
 * @summary Add the specified number of year quarters to the given date.
 *
 * @description
 * Add the specified number of year quarters to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be added.
 *
 * @returns The new date with the quarters added
 *
 * @example
 * // Add 1 quarter to 1 September 2014:
 * const result = addQuarters(new Date(2014, 8, 1), 1)
 * //=> Mon Dec 01 2014 00:00:00
 */
function addQuarters(date, amount) {
  const months = amount * 3;
  return (0, _index.addMonths)(date, months);
}


/***/ }),

/***/ "./node_modules/date-fns/addSeconds.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/addSeconds.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addSeconds = addSeconds;
var _index = __webpack_require__(/*! ./addMilliseconds.js */ "./node_modules/date-fns/addMilliseconds.js");

/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be added.
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */
function addSeconds(date, amount) {
  return (0, _index.addMilliseconds)(date, amount * 1000);
}


/***/ }),

/***/ "./node_modules/date-fns/addWeeks.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/addWeeks.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addWeeks = addWeeks;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be added.
 *
 * @returns The new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(date, amount) {
  const days = amount * 7;
  return (0, _index.addDays)(date, days);
}


/***/ }),

/***/ "./node_modules/date-fns/addYears.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/addYears.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.addYears = addYears;
var _index = __webpack_require__(/*! ./addMonths.js */ "./node_modules/date-fns/addMonths.js");

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be added.
 *
 * @returns The new date with the years added
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */
function addYears(date, amount) {
  return (0, _index.addMonths)(date, amount * 12);
}


/***/ }),

/***/ "./node_modules/date-fns/areIntervalsOverlapping.js":
/*!**********************************************************!*\
  !*** ./node_modules/date-fns/areIntervalsOverlapping.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.areIntervalsOverlapping = areIntervalsOverlapping;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link areIntervalsOverlapping} function options.
 */

/**
 * @name areIntervalsOverlapping
 * @category Interval Helpers
 * @summary Is the given time interval overlapping with another time interval?
 *
 * @description
 * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 * @param options - The object with options
 *
 * @returns Whether the time intervals are overlapping
 *
 * @example
 * // For overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> true
 *
 * @example
 * // For non-overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> false
 *
 * @example
 * // For adjacent time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }
 * )
 * //=> false
 *
 * @example
 * // Using the inclusive option:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }
 * )
 * //=> false
 *
 * @example
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },
 *   { inclusive: true }
 * )
 * //=> true
 */
function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
  const [leftStartTime, leftEndTime] = [
    +(0, _index.toDate)(intervalLeft.start),
    +(0, _index.toDate)(intervalLeft.end),
  ].sort((a, b) => a - b);
  const [rightStartTime, rightEndTime] = [
    +(0, _index.toDate)(intervalRight.start),
    +(0, _index.toDate)(intervalRight.end),
  ].sort((a, b) => a - b);

  if (options?.inclusive)
    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;

  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}


/***/ }),

/***/ "./node_modules/date-fns/clamp.js":
/*!****************************************!*\
  !*** ./node_modules/date-fns/clamp.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.clamp = clamp;
var _index = __webpack_require__(/*! ./max.js */ "./node_modules/date-fns/max.js");
var _index2 = __webpack_require__(/*! ./min.js */ "./node_modules/date-fns/min.js");

/**
 * @name clamp
 * @category Interval Helpers
 * @summary Return a date bounded by the start and the end of the given interval
 *
 * @description
 * Clamps a date to the lower bound with the start of the interval and the upper
 * bound with the end of the interval.
 *
 * - When the date is less than the start of the interval, the start is returned.
 * - When the date is greater than the end of the interval, the end is returned.
 * - Otherwise the date is returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be bounded
 * @param interval - The interval to bound to
 *
 * @returns The date bounded by the start and the end of the interval
 *
 * @example
 * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021
 * const result = clamp(new Date(2021, 2, 21), {
 *   start: new Date(2021, 2, 22),
 *   end: new Date(2021, 3, 1),
 * })
 * //=> Mon Mar 22 2021 00:00:00
 */
function clamp(date, interval) {
  return (0, _index2.min)([
    (0, _index.max)([date, interval.start]),
    interval.end,
  ]);
}


/***/ }),

/***/ "./node_modules/date-fns/closestIndexTo.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/closestIndexTo.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.closestIndexTo = closestIndexTo;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name closestIndexTo
 * @category Common Helpers
 * @summary Return an index of the closest date from the array comparing to the given date.
 *
 * @description
 * Return an index of the closest date from the array comparing to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns An index of the date closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015?
 * const dateToCompare = new Date(2015, 8, 6)
 * const datesArray = [
 *   new Date(2015, 0, 1),
 *   new Date(2016, 0, 1),
 *   new Date(2017, 0, 1)
 * ]
 * const result = closestIndexTo(dateToCompare, datesArray)
 * //=> 1
 */
function closestIndexTo(dateToCompare, dates) {
  const date = (0, _index.toDate)(dateToCompare);

  if (isNaN(Number(date))) return NaN;

  const timeToCompare = date.getTime();

  let result;
  let minDistance;
  dates.forEach(function (dirtyDate, index) {
    const currentDate = (0, _index.toDate)(dirtyDate);

    if (isNaN(Number(currentDate))) {
      result = NaN;
      minDistance = NaN;
      return;
    }

    const distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < minDistance) {
      result = index;
      minDistance = distance;
    }
  });

  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/closestTo.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/closestTo.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.closestTo = closestTo;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name closestTo
 * @category Common Helpers
 * @summary Return a date from the array closest to the given date.
 *
 * @description
 * Return a date from the array closest to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns The date from the array closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015: 1 January 2000 or 1 January 2030?
 * const dateToCompare = new Date(2015, 8, 6)
 * const result = closestTo(dateToCompare, [
 *   new Date(2000, 0, 1),
 *   new Date(2030, 0, 1)
 * ])
 * //=> Tue Jan 01 2030 00:00:00
 */
function closestTo(dateToCompare, dates) {
  const date = (0, _index2.toDate)(dateToCompare);

  if (isNaN(Number(date))) return (0, _index.constructFrom)(dateToCompare, NaN);

  const timeToCompare = date.getTime();

  let result;
  let minDistance;
  dates.forEach((dirtyDate) => {
    const currentDate = (0, _index2.toDate)(dirtyDate);

    if (isNaN(Number(currentDate))) {
      result = (0, _index.constructFrom)(dateToCompare, NaN);
      minDistance = NaN;
      return;
    }

    const distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < minDistance) {
      result = currentDate;
      minDistance = distance;
    }
  });

  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/compareAsc.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/compareAsc.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.compareAsc = compareAsc;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */
function compareAsc(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);

  const diff = _dateLeft.getTime() - _dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/compareDesc.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/compareDesc.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.compareDesc = compareDesc;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name compareDesc
 * @category Common Helpers
 * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return -1 if the first date is after the second,
 * 1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
 * const result = compareDesc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> 1
 *
 * @example
 * // Sort the array of dates in reverse chronological order:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareDesc)
 * //=> [
 * //   Sun Jul 02 1995 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Wed Feb 11 1987 00:00:00
 * // ]
 */
function compareDesc(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);

  const diff = _dateLeft.getTime() - _dateRight.getTime();

  if (diff > 0) {
    return -1;
  } else if (diff < 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/constants.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/constants.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.secondsInYear =
  exports.secondsInWeek =
  exports.secondsInQuarter =
  exports.secondsInMonth =
  exports.secondsInMinute =
  exports.secondsInHour =
  exports.secondsInDay =
  exports.quartersInYear =
  exports.monthsInYear =
  exports.monthsInQuarter =
  exports.minutesInYear =
  exports.minutesInMonth =
  exports.minutesInHour =
  exports.minutesInDay =
  exports.minTime =
  exports.millisecondsInWeek =
  exports.millisecondsInSecond =
  exports.millisecondsInMinute =
  exports.millisecondsInHour =
  exports.millisecondsInDay =
  exports.maxTime =
  exports.daysInYear =
  exports.daysInWeek =
    void 0; /**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */

/**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */
const daysInWeek = (exports.daysInWeek = 7);

/**
 * @constant
 * @name daysInYear
 * @summary Days in 1 year.
 *
 * @description
 * How many days in a year.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 */
const daysInYear = (exports.daysInYear = 365.2425);

/**
 * @constant
 * @name maxTime
 * @summary Maximum allowed time.
 *
 * @example
 * import { maxTime } from "date-fns/constants";
 *
 * const isValid = 8640000000000001 <= maxTime;
 * //=> false
 *
 * new Date(8640000000000001);
 * //=> Invalid Date
 */
const maxTime = (exports.maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000);

/**
 * @constant
 * @name minTime
 * @summary Minimum allowed time.
 *
 * @example
 * import { minTime } from "date-fns/constants";
 *
 * const isValid = -8640000000000001 >= minTime;
 * //=> false
 *
 * new Date(-8640000000000001)
 * //=> Invalid Date
 */
const minTime = (exports.minTime = -maxTime);

/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */
const millisecondsInWeek = (exports.millisecondsInWeek = 604800000);

/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */
const millisecondsInDay = (exports.millisecondsInDay = 86400000);

/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */
const millisecondsInMinute = (exports.millisecondsInMinute = 60000);

/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */
const millisecondsInHour = (exports.millisecondsInHour = 3600000);

/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */
const millisecondsInSecond = (exports.millisecondsInSecond = 1000);

/**
 * @constant
 * @name minutesInYear
 * @summary Minutes in 1 year.
 */
const minutesInYear = (exports.minutesInYear = 525600);

/**
 * @constant
 * @name minutesInMonth
 * @summary Minutes in 1 month.
 */
const minutesInMonth = (exports.minutesInMonth = 43200);

/**
 * @constant
 * @name minutesInDay
 * @summary Minutes in 1 day.
 */
const minutesInDay = (exports.minutesInDay = 1440);

/**
 * @constant
 * @name minutesInHour
 * @summary Minutes in 1 hour.
 */
const minutesInHour = (exports.minutesInHour = 60);

/**
 * @constant
 * @name monthsInQuarter
 * @summary Months in 1 quarter.
 */
const monthsInQuarter = (exports.monthsInQuarter = 3);

/**
 * @constant
 * @name monthsInYear
 * @summary Months in 1 year.
 */
const monthsInYear = (exports.monthsInYear = 12);

/**
 * @constant
 * @name quartersInYear
 * @summary Quarters in 1 year
 */
const quartersInYear = (exports.quartersInYear = 4);

/**
 * @constant
 * @name secondsInHour
 * @summary Seconds in 1 hour.
 */
const secondsInHour = (exports.secondsInHour = 3600);

/**
 * @constant
 * @name secondsInMinute
 * @summary Seconds in 1 minute.
 */
const secondsInMinute = (exports.secondsInMinute = 60);

/**
 * @constant
 * @name secondsInDay
 * @summary Seconds in 1 day.
 */
const secondsInDay = (exports.secondsInDay = secondsInHour * 24);

/**
 * @constant
 * @name secondsInWeek
 * @summary Seconds in 1 week.
 */
const secondsInWeek = (exports.secondsInWeek = secondsInDay * 7);

/**
 * @constant
 * @name secondsInYear
 * @summary Seconds in 1 year.
 */
const secondsInYear = (exports.secondsInYear = secondsInDay * daysInYear);

/**
 * @constant
 * @name secondsInMonth
 * @summary Seconds in 1 month
 */
const secondsInMonth = (exports.secondsInMonth = secondsInYear / 12);

/**
 * @constant
 * @name secondsInQuarter
 * @summary Seconds in 1 quarter.
 */
const secondsInQuarter = (exports.secondsInQuarter = secondsInMonth * 3);


/***/ }),

/***/ "./node_modules/date-fns/constructFrom.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/constructFrom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.constructFrom = constructFrom;

/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from 'date-fns'
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use contrustor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   )
 * }
 */
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}


/***/ }),

/***/ "./node_modules/date-fns/constructNow.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/constructNow.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.constructNow = constructNow;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name constructNow
 * @category Generic Helpers
 * @summary Constructs a new current date using the passed value constructor.
 * @pure false
 *
 * @description
 * The function constructs a new current date using the constructor from
 * the reference date. It helps to build generic functions that accept date
 * extensions and use the current date.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 *
 * @returns Current date initialized using the given date constructor
 *
 * @example
 * import { constructNow, isSameDay } from 'date-fns'
 *
 * function isToday<DateType extends Date>(
 *   date: DateType | number | string,
 * ): boolean {
 *   // If we were to use `new Date()` directly, the function would  behave
 *   // differently in different timezones and return false for the same date.
 *   return isSameDay(date, constructNow(date));
 * }
 */
function constructNow(date) {
  return (0, _index.constructFrom)(date, Date.now());
}


/***/ }),

/***/ "./node_modules/date-fns/daysToWeeks.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/daysToWeeks.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.daysToWeeks = daysToWeeks;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name daysToWeeks
 * @category Conversion Helpers
 * @summary Convert days to weeks.
 *
 * @description
 * Convert a number of days to a full number of weeks.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param days - The number of days to be converted
 *
 * @returns The number of days converted in weeks
 *
 * @example
 * // Convert 14 days to weeks:
 * const result = daysToWeeks(14)
 * //=> 2
 *
 * @example
 * // It uses trunc rounding:
 * const result = daysToWeeks(13)
 * //=> 1
 */
function daysToWeeks(days) {
  const weeks = days / _index.daysInWeek;
  const result = Math.trunc(weeks);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInBusinessDays.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/differenceInBusinessDays.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInBusinessDays = differenceInBusinessDays;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index3 = __webpack_require__(/*! ./isSameDay.js */ "./node_modules/date-fns/isSameDay.js");
var _index4 = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index5 = __webpack_require__(/*! ./isWeekend.js */ "./node_modules/date-fns/isWeekend.js");
var _index6 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInBusinessDays
 * @category Day Helpers
 * @summary Get the number of business days between the given dates.
 *
 * @description
 * Get the number of business day periods between the given dates.
 * Business days being days that arent in the weekend.
 * Like `differenceInCalendarDays`, the function removes the times from
 * the dates before calculating the difference.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of business days
 *
 * @example
 * // How many business days are between
 * // 10 January 2014 and 20 July 2014?
 * const result = differenceInBusinessDays(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 0, 10)
 * )
 * //=> 136
 *
 * // How many business days are between
 * // 30 November 2021 and 1 November 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 30),
 *   new Date(2021, 10, 1)
 * )
 * //=> 21
 *
 * // How many business days are between
 * // 1 November 2021 and 1 December 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 11, 1)
 * )
 * //=> -22
 *
 * // How many business days are between
 * // 1 November 2021 and 1 November 2021 ?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 10, 1)
 * )
 * //=> 0
 */
function differenceInBusinessDays(dateLeft, dateRight) {
  const _dateLeft = (0, _index6.toDate)(dateLeft);
  let _dateRight = (0, _index6.toDate)(dateRight);

  if (!(0, _index4.isValid)(_dateLeft) || !(0, _index4.isValid)(_dateRight))
    return NaN;

  const calendarDifference = (0, _index2.differenceInCalendarDays)(
    _dateLeft,
    _dateRight,
  );
  const sign = calendarDifference < 0 ? -1 : 1;

  const weeks = Math.trunc(calendarDifference / 7);

  let result = weeks * 5;
  _dateRight = (0, _index.addDays)(_dateRight, weeks * 7);

  // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week
  while (!(0, _index3.isSameDay)(_dateLeft, _dateRight)) {
    // sign is used to account for both negative and positive differences
    result += (0, _index5.isWeekend)(_dateRight) ? 0 : sign;
    _dateRight = (0, _index.addDays)(_dateRight, sign);
  }

  // Prevent negative zero
  return result === 0 ? 0 : result;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarDays.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarDays.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarDays = differenceInCalendarDays;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index2 = __webpack_require__(/*! ./startOfDay.js */ "./node_modules/date-fns/startOfDay.js");
var _index3 = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");

/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = (0, _index2.startOfDay)(dateLeft);
  const startOfDayRight = (0, _index2.startOfDay)(dateRight);

  const timestampLeft =
    +startOfDayLeft -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
  const timestampRight =
    +startOfDayRight -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayRight);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a day is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index.millisecondsInDay,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarISOWeekYears.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarISOWeekYears.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarISOWeekYears = differenceInCalendarISOWeekYears;
var _index = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");

/**
 * @name differenceInCalendarISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of calendar ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of calendar ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO week-numbering years
 *
 * @example
 * // How many calendar ISO week-numbering years are 1 January 2010 and 1 January 2012?
 * const result = differenceInCalendarISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 2
 */
function differenceInCalendarISOWeekYears(dateLeft, dateRight) {
  return (
    (0, _index.getISOWeekYear)(dateLeft) - (0, _index.getISOWeekYear)(dateRight)
  );
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarISOWeeks.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarISOWeeks.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarISOWeeks = differenceInCalendarISOWeeks;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");

/**
 * @name differenceInCalendarISOWeeks
 * @category ISO Week Helpers
 * @summary Get the number of calendar ISO weeks between the given dates.
 *
 * @description
 * Get the number of calendar ISO weeks between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO weeks
 *
 * @example
 * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?
 * const result = differenceInCalendarISOWeeks(
 *   new Date(2014, 6, 21),
 *   new Date(2014, 6, 6)
 * )
 * //=> 3
 */
function differenceInCalendarISOWeeks(dateLeft, dateRight) {
  const startOfISOWeekLeft = (0, _index2.startOfISOWeek)(dateLeft);
  const startOfISOWeekRight = (0, _index2.startOfISOWeek)(dateRight);

  const timestampLeft =
    +startOfISOWeekLeft -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfISOWeekLeft);
  const timestampRight =
    +startOfISOWeekRight -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfISOWeekRight);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index.millisecondsInWeek,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarMonths.js":
/*!*************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarMonths.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarMonths = differenceInCalendarMonths;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar months
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);

  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();

  return yearDiff * 12 + monthDiff;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarQuarters.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarQuarters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarQuarters = differenceInCalendarQuarters;
var _index = __webpack_require__(/*! ./getQuarter.js */ "./node_modules/date-fns/getQuarter.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInCalendarQuarters
 * @category Quarter Helpers
 * @summary Get the number of calendar quarters between the given dates.
 *
 * @description
 * Get the number of calendar quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar quarters
 *
 * @example
 * // How many calendar quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInCalendarQuarters(
 *   new Date(2014, 6, 2),
 *   new Date(2013, 11, 31)
 * )
 * //=> 3
 */
function differenceInCalendarQuarters(dateLeft, dateRight) {
  const _dateLeft = (0, _index2.toDate)(dateLeft);
  const _dateRight = (0, _index2.toDate)(dateRight);

  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const quarterDiff =
    (0, _index.getQuarter)(_dateLeft) - (0, _index.getQuarter)(_dateRight);

  return yearDiff * 4 + quarterDiff;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarWeeks.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarWeeks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarWeeks = differenceInCalendarWeeks;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index2 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");

var _index3 = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");

/**
 * The {@link differenceInCalendarWeeks} function options.
 */

/**
 * @name differenceInCalendarWeeks
 * @category Week Helpers
 * @summary Get the number of calendar weeks between the given dates.
 *
 * @description
 * Get the number of calendar weeks between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5)
 * )
 * //=> 3
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5),
 *   { weekStartsOn: 1 }
 * )
 * //=> 2
 */
function differenceInCalendarWeeks(dateLeft, dateRight, options) {
  const startOfWeekLeft = (0, _index2.startOfWeek)(dateLeft, options);
  const startOfWeekRight = (0, _index2.startOfWeek)(dateRight, options);

  const timestampLeft =
    +startOfWeekLeft -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfWeekLeft);
  const timestampRight =
    +startOfWeekRight -
    (0, _index3.getTimezoneOffsetInMilliseconds)(startOfWeekRight);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a days is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index.millisecondsInWeek,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarYears.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarYears.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInCalendarYears = differenceInCalendarYears;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar years
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */
function differenceInCalendarYears(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);

  return _dateLeft.getFullYear() - _dateRight.getFullYear();
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInDays.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/differenceInDays.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInDays = differenceInDays;
var _index = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.trunc(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full days according to the local timezone
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 *
 * @example
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
 * //=> 92
 */
function differenceInDays(dateLeft, dateRight) {
  const _dateLeft = (0, _index2.toDate)(dateLeft);
  const _dateRight = (0, _index2.toDate)(dateRight);

  const sign = compareLocalAsc(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index.differenceInCalendarDays)(_dateLeft, _dateRight),
  );

  _dateLeft.setDate(_dateLeft.getDate() - sign * difference);

  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastDayNotFull = Number(
    compareLocalAsc(_dateLeft, _dateRight) === -sign,
  );
  const result = sign * (difference - isLastDayNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}

// Like `compareAsc` but uses local time not UTC, which is needed
// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.
function compareLocalAsc(dateLeft, dateRight) {
  const diff =
    dateLeft.getFullYear() - dateRight.getFullYear() ||
    dateLeft.getMonth() - dateRight.getMonth() ||
    dateLeft.getDate() - dateRight.getDate() ||
    dateLeft.getHours() - dateRight.getHours() ||
    dateLeft.getMinutes() - dateRight.getMinutes() ||
    dateLeft.getSeconds() - dateRight.getSeconds() ||
    dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInHours.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/differenceInHours.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInHours = differenceInHours;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index3 = __webpack_require__(/*! ./differenceInMilliseconds.js */ "./node_modules/date-fns/differenceInMilliseconds.js");

/**
 * The {@link differenceInHours} function options.
 */

/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of hours
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */
function differenceInHours(dateLeft, dateRight, options) {
  const diff =
    (0, _index3.differenceInMilliseconds)(dateLeft, dateRight) /
    _index2.millisecondsInHour;
  return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInISOWeekYears.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/differenceInISOWeekYears.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInISOWeekYears = differenceInISOWeekYears;
var _index = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarISOWeekYears.js */ "./node_modules/date-fns/differenceInCalendarISOWeekYears.js");
var _index3 = __webpack_require__(/*! ./subISOWeekYears.js */ "./node_modules/date-fns/subISOWeekYears.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of full ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of full ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full ISO week-numbering years
 *
 * @example
 * // How many full ISO week-numbering years are between 1 January 2010 and 1 January 2012?
 * const result = differenceInISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 1
 */
function differenceInISOWeekYears(dateLeft, dateRight) {
  let _dateLeft = (0, _index4.toDate)(dateLeft);
  const _dateRight = (0, _index4.toDate)(dateRight);

  const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2.differenceInCalendarISOWeekYears)(_dateLeft, _dateRight),
  );
  _dateLeft = (0, _index3.subISOWeekYears)(_dateLeft, sign * difference);

  // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1
  // if last calendar ISO year is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastISOWeekYearNotFull = Number(
    (0, _index.compareAsc)(_dateLeft, _dateRight) === -sign,
  );
  const result = sign * (difference - isLastISOWeekYearNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInMilliseconds.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/differenceInMilliseconds.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInMilliseconds = differenceInMilliseconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of milliseconds
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */
function differenceInMilliseconds(dateLeft, dateRight) {
  return +(0, _index.toDate)(dateLeft) - +(0, _index.toDate)(dateRight);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInMinutes.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/differenceInMinutes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInMinutes = differenceInMinutes;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index3 = __webpack_require__(/*! ./differenceInMilliseconds.js */ "./node_modules/date-fns/differenceInMilliseconds.js");

/**
 * The {@link differenceInMinutes} function options.
 */

/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of minutes
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * const result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are between 10:01:59 and 10:00:00
 * const result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff =
    (0, _index3.differenceInMilliseconds)(dateLeft, dateRight) /
    _index2.millisecondsInMinute;
  return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInMonths.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/differenceInMonths.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInMonths = differenceInMonths;
var _index = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarMonths.js */ "./node_modules/date-fns/differenceInCalendarMonths.js");
var _index3 = __webpack_require__(/*! ./isLastDayOfMonth.js */ "./node_modules/date-fns/isLastDayOfMonth.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full months
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */
function differenceInMonths(dateLeft, dateRight) {
  const _dateLeft = (0, _index4.toDate)(dateLeft);
  const _dateRight = (0, _index4.toDate)(dateRight);

  const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2.differenceInCalendarMonths)(_dateLeft, _dateRight),
  );
  let result;

  // Check for the difference of less than month
  if (difference < 1) {
    result = 0;
  } else {
    if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
      // This will check if the date is end of Feb and assign a higher end of month date
      // to compare it with Jan
      _dateLeft.setDate(30);
    }

    _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);

    // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value
    let isLastMonthNotFull =
      (0, _index.compareAsc)(_dateLeft, _dateRight) === -sign;

    // Check for cases of one full calendar month
    if (
      (0, _index3.isLastDayOfMonth)((0, _index4.toDate)(dateLeft)) &&
      difference === 1 &&
      (0, _index.compareAsc)(dateLeft, _dateRight) === 1
    ) {
      isLastMonthNotFull = false;
    }

    result = sign * (difference - Number(isLastMonthNotFull));
  }

  // Prevent negative zero
  return result === 0 ? 0 : result;
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInQuarters.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/differenceInQuarters.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInQuarters = differenceInQuarters;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./differenceInMonths.js */ "./node_modules/date-fns/differenceInMonths.js");

/**
 * The {@link differenceInQuarters} function options.
 */

/**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of quarters between the given dates.
 *
 * @description
 * Get the number of quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of full quarters
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */
function differenceInQuarters(dateLeft, dateRight, options) {
  const diff = (0, _index2.differenceInMonths)(dateLeft, dateRight) / 3;
  return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInSeconds.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/differenceInSeconds.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInSeconds = differenceInSeconds;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./differenceInMilliseconds.js */ "./node_modules/date-fns/differenceInMilliseconds.js");

/**
 * The {@link differenceInSeconds} function options.
 */

/**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of seconds
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * const result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */
function differenceInSeconds(dateLeft, dateRight, options) {
  const diff =
    (0, _index2.differenceInMilliseconds)(dateLeft, dateRight) / 1000;
  return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInWeeks.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/differenceInWeeks.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInWeeks = differenceInWeeks;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./differenceInDays.js */ "./node_modules/date-fns/differenceInDays.js");

/**
 * The {@link differenceInWeeks} function options.
 */

/**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero by default.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.trunc(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options
 *
 * @returns The number of full weeks
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * @example
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * const result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */
function differenceInWeeks(dateLeft, dateRight, options) {
  const diff = (0, _index2.differenceInDays)(dateLeft, dateRight) / 7;
  return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}


/***/ }),

/***/ "./node_modules/date-fns/differenceInYears.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/differenceInYears.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.differenceInYears = differenceInYears;
var _index = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarYears.js */ "./node_modules/date-fns/differenceInCalendarYears.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full years
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */
function differenceInYears(dateLeft, dateRight) {
  const _dateLeft = (0, _index3.toDate)(dateLeft);
  const _dateRight = (0, _index3.toDate)(dateRight);

  const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2.differenceInCalendarYears)(_dateLeft, _dateRight),
  );

  // Set both dates to a valid leap year for accurate comparison when dealing
  // with leap days
  _dateLeft.setFullYear(1584);
  _dateRight.setFullYear(1584);

  // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastYearNotFull =
    (0, _index.compareAsc)(_dateLeft, _dateRight) === -sign;
  const result = sign * (difference - +isLastYearNotFull);

  // Prevent negative zero
  return result === 0 ? 0 : result;
}


/***/ }),

/***/ "./node_modules/date-fns/eachDayOfInterval.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/eachDayOfInterval.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachDayOfInterval = eachDayOfInterval;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachDayOfInterval} function options.
 */

/**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of days from the day of the interval start to the day of the interval end
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * const result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */
function eachDayOfInterval(interval, options) {
  const startDate = (0, _index.toDate)(interval.start);
  const endDate = (0, _index.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index.toDate)(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachHourOfInterval.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/eachHourOfInterval.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachHourOfInterval = eachHourOfInterval;
var _index = __webpack_require__(/*! ./addHours.js */ "./node_modules/date-fns/addHours.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachHourOfInterval} function options.
 */

/**
 * @name eachHourOfInterval
 * @category Interval Helpers
 * @summary Return the array of hours within the specified time interval.
 *
 * @description
 * Return the array of hours within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of hours from the hour of the interval start to the hour of the interval end
 *
 * @example
 * // Each hour between 6 October 2014, 12:00 and 6 October 2014, 15:00
 * const result = eachHourOfInterval({
 *   start: new Date(2014, 9, 6, 12),
 *   end: new Date(2014, 9, 6, 15)
 * })
 * //=> [
 * //   Mon Oct 06 2014 12:00:00,
 * //   Mon Oct 06 2014 13:00:00,
 * //   Mon Oct 06 2014 14:00:00,
 * //   Mon Oct 06 2014 15:00:00
 * // ]
 */
function eachHourOfInterval(interval, options) {
  const startDate = (0, _index2.toDate)(interval.start);
  const endDate = (0, _index2.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  let currentDate = reversed ? endDate : startDate;
  currentDate.setMinutes(0, 0, 0);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index2.toDate)(currentDate));
    currentDate = (0, _index.addHours)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachMinuteOfInterval.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/eachMinuteOfInterval.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachMinuteOfInterval = eachMinuteOfInterval;
var _index = __webpack_require__(/*! ./addMinutes.js */ "./node_modules/date-fns/addMinutes.js");
var _index2 = __webpack_require__(/*! ./startOfMinute.js */ "./node_modules/date-fns/startOfMinute.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachMinuteOfInterval} function options.
 */

/**
 * @name eachMinuteOfInterval
 * @category Interval Helpers
 * @summary Return the array of minutes within the specified time interval.
 *
 * @description
 * Returns the array of minutes within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of minutes from the minute of the interval start to the minute of the interval end
 *
 * @example
 * // Each minute between 14 October 2020, 13:00 and 14 October 2020, 13:03
 * const result = eachMinuteOfInterval({
 *   start: new Date(2014, 9, 14, 13),
 *   end: new Date(2014, 9, 14, 13, 3)
 * })
 * //=> [
 * //   Wed Oct 14 2014 13:00:00,
 * //   Wed Oct 14 2014 13:01:00,
 * //   Wed Oct 14 2014 13:02:00,
 * //   Wed Oct 14 2014 13:03:00
 * // ]
 */
function eachMinuteOfInterval(interval, options) {
  const startDate = (0, _index2.startOfMinute)(
    (0, _index3.toDate)(interval.start),
  );
  const endDate = (0, _index3.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  let currentDate = reversed ? endDate : startDate;

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index3.toDate)(currentDate));
    currentDate = (0, _index.addMinutes)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachMonthOfInterval.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/eachMonthOfInterval.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachMonthOfInterval = eachMonthOfInterval;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachMonthOfInterval} function options.
 */

/**
 * @name eachMonthOfInterval
 * @category Interval Helpers
 * @summary Return the array of months within the specified time interval.
 *
 * @description
 * Return the array of months within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of months from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each month between 6 February 2014 and 10 August 2014:
 * const result = eachMonthOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Sat Feb 01 2014 00:00:00,
 * //   Sat Mar 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Thu May 01 2014 00:00:00,
 * //   Sun Jun 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * //   Fri Aug 01 2014 00:00:00
 * // ]
 */
function eachMonthOfInterval(interval, options) {
  const startDate = (0, _index.toDate)(interval.start);
  const endDate = (0, _index.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setDate(1);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index.toDate)(currentDate));
    currentDate.setMonth(currentDate.getMonth() + step);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachQuarterOfInterval.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/eachQuarterOfInterval.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachQuarterOfInterval = eachQuarterOfInterval;
var _index = __webpack_require__(/*! ./addQuarters.js */ "./node_modules/date-fns/addQuarters.js");
var _index2 = __webpack_require__(/*! ./startOfQuarter.js */ "./node_modules/date-fns/startOfQuarter.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachQuarterOfInterval} function options.
 */

/**
 * @name eachQuarterOfInterval
 * @category Interval Helpers
 * @summary Return the array of quarters within the specified time interval.
 *
 * @description
 * Return the array of quarters within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of quarters from the quarter of the interval start to the quarter of the interval end
 *
 * @example
 * // Each quarter within interval 6 February 2014 - 10 August 2014:
 * const result = eachQuarterOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * // ]
 */
function eachQuarterOfInterval(interval, options) {
  const startDate = (0, _index3.toDate)(interval.start);
  const endDate = (0, _index3.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed
    ? +(0, _index2.startOfQuarter)(startDate)
    : +(0, _index2.startOfQuarter)(endDate);
  let currentDate = reversed
    ? (0, _index2.startOfQuarter)(endDate)
    : (0, _index2.startOfQuarter)(startDate);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index3.toDate)(currentDate));
    currentDate = (0, _index.addQuarters)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachWeekOfInterval.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/eachWeekOfInterval.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachWeekOfInterval = eachWeekOfInterval;
var _index = __webpack_require__(/*! ./addWeeks.js */ "./node_modules/date-fns/addWeeks.js");
var _index2 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachWeekOfInterval} function options.
 */

/**
 * @name eachWeekOfInterval
 * @category Interval Helpers
 * @summary Return the array of weeks within the specified time interval.
 *
 * @description
 * Return the array of weeks within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of weeks from the week of the interval start to the week of the interval end
 *
 * @example
 * // Each week within interval 6 October 2014 - 23 November 2014:
 * const result = eachWeekOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 10, 23)
 * })
 * //=> [
 * //   Sun Oct 05 2014 00:00:00,
 * //   Sun Oct 12 2014 00:00:00,
 * //   Sun Oct 19 2014 00:00:00,
 * //   Sun Oct 26 2014 00:00:00,
 * //   Sun Nov 02 2014 00:00:00,
 * //   Sun Nov 09 2014 00:00:00,
 * //   Sun Nov 16 2014 00:00:00,
 * //   Sun Nov 23 2014 00:00:00
 * // ]
 */
function eachWeekOfInterval(interval, options) {
  const startDate = (0, _index3.toDate)(interval.start);
  const endDate = (0, _index3.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const startDateWeek = reversed
    ? (0, _index2.startOfWeek)(endDate, options)
    : (0, _index2.startOfWeek)(startDate, options);
  const endDateWeek = reversed
    ? (0, _index2.startOfWeek)(startDate, options)
    : (0, _index2.startOfWeek)(endDate, options);

  // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet
  startDateWeek.setHours(15);
  endDateWeek.setHours(15);

  const endTime = +endDateWeek.getTime();
  let currentDate = startDateWeek;

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    currentDate.setHours(0);
    dates.push((0, _index3.toDate)(currentDate));
    currentDate = (0, _index.addWeeks)(currentDate, step);
    currentDate.setHours(15);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/eachWeekendOfInterval.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/eachWeekendOfInterval.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachWeekendOfInterval = eachWeekendOfInterval;
var _index = __webpack_require__(/*! ./eachDayOfInterval.js */ "./node_modules/date-fns/eachDayOfInterval.js");
var _index2 = __webpack_require__(/*! ./isWeekend.js */ "./node_modules/date-fns/isWeekend.js");

/**
 * @name eachWeekendOfInterval
 * @category Interval Helpers
 * @summary List all the Saturdays and Sundays in the given date interval.
 *
 * @description
 * Get all the Saturdays and Sundays in the given date interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The given interval
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given date interval
 * const result = eachWeekendOfInterval({
 *   start: new Date(2018, 8, 17),
 *   end: new Date(2018, 8, 30)
 * })
 * //=> [
 * //   Sat Sep 22 2018 00:00:00,
 * //   Sun Sep 23 2018 00:00:00,
 * //   Sat Sep 29 2018 00:00:00,
 * //   Sun Sep 30 2018 00:00:00
 * // ]
 */
function eachWeekendOfInterval(interval) {
  const dateInterval = (0, _index.eachDayOfInterval)(interval);
  const weekends = [];
  let index = 0;
  while (index < dateInterval.length) {
    const date = dateInterval[index++];
    if ((0, _index2.isWeekend)(date)) weekends.push(date);
  }
  return weekends;
}


/***/ }),

/***/ "./node_modules/date-fns/eachWeekendOfMonth.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/eachWeekendOfMonth.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachWeekendOfMonth = eachWeekendOfMonth;
var _index = __webpack_require__(/*! ./eachWeekendOfInterval.js */ "./node_modules/date-fns/eachWeekendOfInterval.js");
var _index2 = __webpack_require__(/*! ./endOfMonth.js */ "./node_modules/date-fns/endOfMonth.js");
var _index3 = __webpack_require__(/*! ./startOfMonth.js */ "./node_modules/date-fns/startOfMonth.js");

/**
 * @name eachWeekendOfMonth
 * @category Month Helpers
 * @summary List all the Saturdays and Sundays in the given month.
 *
 * @description
 * Get all the Saturdays and Sundays in the given month.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given month
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given month
 * const result = eachWeekendOfMonth(new Date(2022, 1, 1))
 * //=> [
 * //   Sat Feb 05 2022 00:00:00,
 * //   Sun Feb 06 2022 00:00:00,
 * //   Sat Feb 12 2022 00:00:00,
 * //   Sun Feb 13 2022 00:00:00,
 * //   Sat Feb 19 2022 00:00:00,
 * //   Sun Feb 20 2022 00:00:00,
 * //   Sat Feb 26 2022 00:00:00,
 * //   Sun Feb 27 2022 00:00:00
 * // ]
 */
function eachWeekendOfMonth(date) {
  const start = (0, _index3.startOfMonth)(date);
  const end = (0, _index2.endOfMonth)(date);
  return (0, _index.eachWeekendOfInterval)({ start, end });
}


/***/ }),

/***/ "./node_modules/date-fns/eachWeekendOfYear.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/eachWeekendOfYear.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachWeekendOfYear = eachWeekendOfYear;
var _index = __webpack_require__(/*! ./eachWeekendOfInterval.js */ "./node_modules/date-fns/eachWeekendOfInterval.js");
var _index2 = __webpack_require__(/*! ./endOfYear.js */ "./node_modules/date-fns/endOfYear.js");
var _index3 = __webpack_require__(/*! ./startOfYear.js */ "./node_modules/date-fns/startOfYear.js");

/**
 * @name eachWeekendOfYear
 * @category Year Helpers
 * @summary List all the Saturdays and Sundays in the year.
 *
 * @description
 * Get all the Saturdays and Sundays in the year.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given year
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the year
 * const result = eachWeekendOfYear(new Date(2020, 1, 1))
 * //=> [
 * //   Sat Jan 03 2020 00:00:00,
 * //   Sun Jan 04 2020 00:00:00,
 * //   ...
 * //   Sun Dec 27 2020 00:00:00
 * // ]
 * ]
 */
function eachWeekendOfYear(date) {
  const start = (0, _index3.startOfYear)(date);
  const end = (0, _index2.endOfYear)(date);
  return (0, _index.eachWeekendOfInterval)({ start, end });
}


/***/ }),

/***/ "./node_modules/date-fns/eachYearOfInterval.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/eachYearOfInterval.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.eachYearOfInterval = eachYearOfInterval;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link eachYearOfInterval} function options.
 */

/**
 * @name eachYearOfInterval
 * @category Interval Helpers
 * @summary Return the array of yearly timestamps within the specified time interval.
 *
 * @description
 * Return the array of yearly timestamps within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 *
 * @returns The array with starts of yearly timestamps from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each year between 6 February 2014 and 10 August 2017:
 * const result = eachYearOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2017, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Thu Jan 01 2015 00:00:00,
 * //   Fri Jan 01 2016 00:00:00,
 * //   Sun Jan 01 2017 00:00:00
 * // ]
 */
function eachYearOfInterval(interval, options) {
  const startDate = (0, _index.toDate)(interval.start);
  const endDate = (0, _index.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setMonth(0, 1);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index.toDate)(currentDate));
    currentDate.setFullYear(currentDate.getFullYear() + step);
  }

  return reversed ? dates.reverse() : dates;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfDay.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/endOfDay.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfDay = endOfDay;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a day
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */
function endOfDay(date) {
  const _date = (0, _index.toDate)(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfDecade.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/endOfDecade.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfDecade = endOfDecade;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfDecade
 * @category Decade Helpers
 * @summary Return the end of a decade for the given date.
 *
 * @description
 * Return the end of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a decade
 *
 * @example
 * // The end of a decade for 12 May 1984 00:00:00:
 * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))
 * //=> Dec 31 1989 23:59:59.999
 */
function endOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  const decade = 9 + Math.floor(year / 10) * 10;
  _date.setFullYear(decade, 11, 31);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfHour.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/endOfHour.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfHour = endOfHour;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfHour
 * @category Hour Helpers
 * @summary Return the end of an hour for the given date.
 *
 * @description
 * Return the end of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an hour
 *
 * @example
 * // The end of an hour for 2 September 2014 11:55:00:
 * const result = endOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:59:59.999
 */
function endOfHour(date) {
  const _date = (0, _index.toDate)(date);
  _date.setMinutes(59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfISOWeek.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/endOfISOWeek.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfISOWeek = endOfISOWeek;
var _index = __webpack_require__(/*! ./endOfWeek.js */ "./node_modules/date-fns/endOfWeek.js");

/**
 * @name endOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the end of an ISO week for the given date.
 *
 * @description
 * Return the end of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week
 *
 * @example
 * // The end of an ISO week for 2 September 2014 11:55:00:
 * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfISOWeek(date) {
  return (0, _index.endOfWeek)(date, { weekStartsOn: 1 });
}


/***/ }),

/***/ "./node_modules/date-fns/endOfISOWeekYear.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/endOfISOWeekYear.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfISOWeekYear = endOfISOWeekYear;
var _index = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name endOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the end of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the end of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The end of an ISO week-numbering year for 2 July 2005:
 * const result = endOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 23:59:59.999
 */
function endOfISOWeekYear(date) {
  const year = (0, _index.getISOWeekYear)(date);
  const fourthOfJanuaryOfNextYear = (0, _index3.constructFrom)(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const _date = (0, _index2.startOfISOWeek)(fourthOfJanuaryOfNextYear);
  _date.setMilliseconds(_date.getMilliseconds() - 1);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfMinute.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/endOfMinute.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfMinute = endOfMinute;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfMinute
 * @category Minute Helpers
 * @summary Return the end of a minute for the given date.
 *
 * @description
 * Return the end of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a minute
 *
 * @example
 * // The end of a minute for 1 December 2014 22:15:45.400:
 * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:59.999
 */
function endOfMinute(date) {
  const _date = (0, _index.toDate)(date);
  _date.setSeconds(59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfMonth.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/endOfMonth.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfMonth = endOfMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a month
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfMonth(date) {
  const _date = (0, _index.toDate)(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfQuarter.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/endOfQuarter.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfQuarter = endOfQuarter;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfQuarter
 * @category Quarter Helpers
 * @summary Return the end of a year quarter for the given date.
 *
 * @description
 * Return the end of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a quarter
 *
 * @example
 * // The end of a quarter for 2 September 2014 11:55:00:
 * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfQuarter(date) {
  const _date = (0, _index.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3) + 3;
  _date.setMonth(month, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfSecond.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/endOfSecond.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfSecond = endOfSecond;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfSecond
 * @category Second Helpers
 * @summary Return the end of a second for the given date.
 *
 * @description
 * Return the end of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a second
 *
 * @example
 * // The end of a second for 1 December 2014 22:15:45.400:
 * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.999
 */
function endOfSecond(date) {
  const _date = (0, _index.toDate)(date);
  _date.setMilliseconds(999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfToday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/endOfToday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfToday = endOfToday;
var _index = __webpack_require__(/*! ./endOfDay.js */ "./node_modules/date-fns/endOfDay.js");

/**
 * @name endOfToday
 * @category Day Helpers
 * @summary Return the end of today.
 * @pure false
 *
 * @description
 * Return the end of today.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfToday()
 * //=> Mon Oct 6 2014 23:59:59.999
 */
function endOfToday() {
  return (0, _index.endOfDay)(Date.now());
}


/***/ }),

/***/ "./node_modules/date-fns/endOfTomorrow.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/endOfTomorrow.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.endOfTomorrow = endOfTomorrow; /**
 * @name endOfTomorrow
 * @category Day Helpers
 * @summary Return the end of tomorrow.
 * @pure false
 *
 * @description
 * Return the end of tomorrow.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfTomorrow()
 * //=> Tue Oct 7 2014 23:59:59.999
 */
function endOfTomorrow() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(23, 59, 59, 999);
  return date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfWeek.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/endOfWeek.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfWeek = endOfWeek;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link endOfWeek} function options.
 */

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The end of a week
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(date, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfYear.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/endOfYear.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.endOfYear = endOfYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a year
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */
function endOfYear(date) {
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/endOfYesterday.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/endOfYesterday.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.endOfYesterday = endOfYesterday; /**
 * @name endOfYesterday
 * @category Day Helpers
 * @summary Return the end of yesterday.
 * @pure false
 *
 * @description
 * Return the end of yesterday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfYesterday()
 * //=> Sun Oct 5 2014 23:59:59.999
 */
function endOfYesterday() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(23, 59, 59, 999);
  return date;
}


/***/ }),

/***/ "./node_modules/date-fns/format.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/format.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.format = exports.formatDate = format;
Object.defineProperty(exports, "formatters", ({
  enumerable: true,
  get: function () {
    return _index3.formatters;
  },
}));
Object.defineProperty(exports, "longFormatters", ({
  enumerable: true,
  get: function () {
    return _index4.longFormatters;
  },
}));
var _index = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");
var _index3 = __webpack_require__(/*! ./_lib/format/formatters.js */ "./node_modules/date-fns/_lib/format/formatters.js");
var _index4 = __webpack_require__(/*! ./_lib/format/longFormatters.js */ "./node_modules/date-fns/_lib/format/longFormatters.js");
var _index5 = __webpack_require__(/*! ./_lib/protectedTokens.js */ "./node_modules/date-fns/_lib/protectedTokens.js");

var _index6 = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index7 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * The {@link format} function options.
 */

/**
 * @name format
 * @alias formatDate
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 * @param options - An object with options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */
function format(date, formatStr, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;

  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const originalDate = (0, _index7.toDate)(date);

  if (!(0, _index6.isValid)(originalDate)) {
    throw new RangeError("Invalid time value");
  }

  let parts = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = _index4.longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp)
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }

      if (_index3.formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return { isToken: false, value: substring };
    });

  // invoke localize preprocessor (only for french locales at the moment)
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }

  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  return parts
    .map((part) => {
      if (!part.isToken) return part.value;

      const token = part.value;

      if (
        (!options?.useAdditionalWeekYearTokens &&
          (0, _index5.isProtectedWeekYearToken)(token)) ||
        (!options?.useAdditionalDayOfYearTokens &&
          (0, _index5.isProtectedDayOfYearToken)(token))
      ) {
        (0, _index5.warnOrThrowProtectedError)(token, formatStr, String(date));
      }

      const formatter = _index3.formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    })
    .join("");
}

function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}


/***/ }),

/***/ "./node_modules/date-fns/formatDistance.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/formatDistance.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatDistance = formatDistance;
var _index = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index3 = __webpack_require__(/*! ./differenceInMonths.js */ "./node_modules/date-fns/differenceInMonths.js");
var _index4 = __webpack_require__(/*! ./differenceInSeconds.js */ "./node_modules/date-fns/differenceInSeconds.js");
var _index5 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index6 = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index7 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");
var _index8 = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");

/**
 * The {@link formatDistance} function options.
 */

/**
 * @name formatDistance
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words.
 *
 * | Distance between dates                                            | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance between dates | Result               |
 * |------------------------|----------------------|
 * | 0 secs ... 5 secs      | less than 5 seconds  |
 * | 5 secs ... 10 secs     | less than 10 seconds |
 * | 10 secs ... 20 secs    | less than 20 seconds |
 * | 20 secs ... 40 secs    | half a minute        |
 * | 40 secs ... 60 secs    | less than a minute   |
 * | 60 secs ... 90 secs    | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00, including seconds?
 * const result = formatDistance(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0),
 *   { includeSeconds: true }
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> 'about 1 year ago'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> 'pli ol 1 jaro'
 */

function formatDistance(date, baseDate, options) {
  const defaultOptions = (0, _index7.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index6.defaultLocale;
  const minutesInAlmostTwoDays = 2520;

  const comparison = (0, _index.compareAsc)(date, baseDate);

  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }

  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison: comparison,
  });

  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index5.toDate)(baseDate);
    dateRight = (0, _index5.toDate)(date);
  } else {
    dateLeft = (0, _index5.toDate)(date);
    dateRight = (0, _index5.toDate)(baseDate);
  }

  const seconds = (0, _index4.differenceInSeconds)(dateRight, dateLeft);
  const offsetInSeconds =
    ((0, _index8.getTimezoneOffsetInMilliseconds)(dateRight) -
      (0, _index8.getTimezoneOffsetInMilliseconds)(dateLeft)) /
    1000;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;

  // 0 up to 2 mins
  if (minutes < 2) {
    if (options?.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }

    // 2 mins up to 0.75 hrs
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);

    // 0.75 hrs up to 1.5 hrs
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);

    // 1.5 hrs up to 24 hrs
  } else if (minutes < _index2.minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);

    // 1 day up to 1.75 days
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);

    // 1.75 days up to 30 days
  } else if (minutes < _index2.minutesInMonth) {
    const days = Math.round(minutes / _index2.minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);

    // 1 month up to 2 months
  } else if (minutes < _index2.minutesInMonth * 2) {
    months = Math.round(minutes / _index2.minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }

  months = (0, _index3.differenceInMonths)(dateRight, dateLeft);

  // 2 months up to 12 months
  if (months < 12) {
    const nearestMonth = Math.round(minutes / _index2.minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);

    // 1 year up to max Date
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);

    // N years up to 1 years 3 months
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);

      // N years 3 months up to N years 9 months
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);

      // N years 9 months up to N year 12 months
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}


/***/ }),

/***/ "./node_modules/date-fns/formatDistanceStrict.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/formatDistanceStrict.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatDistanceStrict = formatDistanceStrict;
var _index = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");
var _index3 = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index4 = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");
var _index5 = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
var _index6 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

var _index7 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link formatDistanceStrict} function options.
 */

/**
 * The unit used to format the distance in {@link formatDistanceStrict}.
 */

/**
 * @name formatDistanceStrict
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00?
 * const result = formatDistanceStrict(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> '1 year ago'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, in minutes?
 * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
 *   unit: 'minute'
 * })
 * //=> '525600 minutes'
 *
 * @example
 * // What is the distance from 1 January 2015
 * // to 28 January 2015, in months, rounded up?
 * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> '1 jaro'
 */

function formatDistanceStrict(date, baseDate, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;

  const comparison = (0, _index5.compareAsc)(date, baseDate);

  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }

  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison: comparison,
  });

  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index7.toDate)(baseDate);
    dateRight = (0, _index7.toDate)(date);
  } else {
    dateLeft = (0, _index7.toDate)(date);
    dateRight = (0, _index7.toDate)(baseDate);
  }

  const roundingMethod = (0, _index3.getRoundingMethod)(
    options?.roundingMethod ?? "round",
  );

  const milliseconds = dateRight.getTime() - dateLeft.getTime();
  const minutes = milliseconds / _index6.millisecondsInMinute;

  const timezoneOffset =
    (0, _index4.getTimezoneOffsetInMilliseconds)(dateRight) -
    (0, _index4.getTimezoneOffsetInMilliseconds)(dateLeft);

  // Use DST-normalized difference in minutes for years, months and days;
  // use regular difference in minutes for hours, minutes and seconds.
  const dstNormalizedMinutes =
    (milliseconds - timezoneOffset) / _index6.millisecondsInMinute;

  const defaultUnit = options?.unit;
  let unit;
  if (!defaultUnit) {
    if (minutes < 1) {
      unit = "second";
    } else if (minutes < 60) {
      unit = "minute";
    } else if (minutes < _index6.minutesInDay) {
      unit = "hour";
    } else if (dstNormalizedMinutes < _index6.minutesInMonth) {
      unit = "day";
    } else if (dstNormalizedMinutes < _index6.minutesInYear) {
      unit = "month";
    } else {
      unit = "year";
    }
  } else {
    unit = defaultUnit;
  }

  // 0 up to 60 seconds
  if (unit === "second") {
    const seconds = roundingMethod(milliseconds / 1000);
    return locale.formatDistance("xSeconds", seconds, localizeOptions);

    // 1 up to 60 mins
  } else if (unit === "minute") {
    const roundedMinutes = roundingMethod(minutes);
    return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);

    // 1 up to 24 hours
  } else if (unit === "hour") {
    const hours = roundingMethod(minutes / 60);
    return locale.formatDistance("xHours", hours, localizeOptions);

    // 1 up to 30 days
  } else if (unit === "day") {
    const days = roundingMethod(dstNormalizedMinutes / _index6.minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);

    // 1 up to 12 months
  } else if (unit === "month") {
    const months = roundingMethod(
      dstNormalizedMinutes / _index6.minutesInMonth,
    );
    return months === 12 && defaultUnit !== "month"
      ? locale.formatDistance("xYears", 1, localizeOptions)
      : locale.formatDistance("xMonths", months, localizeOptions);

    // 1 year up to max Date
  } else {
    const years = roundingMethod(dstNormalizedMinutes / _index6.minutesInYear);
    return locale.formatDistance("xYears", years, localizeOptions);
  }
}


/***/ }),

/***/ "./node_modules/date-fns/formatDistanceToNow.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/formatDistanceToNow.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatDistanceToNow = formatDistanceToNow;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");

var _index2 = __webpack_require__(/*! ./formatDistance.js */ "./node_modules/date-fns/formatDistance.js");

/**
 * The {@link formatDistanceToNow} function options.
 */

/**
 * @name formatDistanceToNow
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given date and now in words.
 *
 * | Distance to now                                                   | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance to now     | Result               |
 * |---------------------|----------------------|
 * | 0 secs ... 5 secs   | less than 5 seconds  |
 * | 5 secs ... 10 secs  | less than 10 seconds |
 * | 10 secs ... 20 secs | less than 20 seconds |
 * | 20 secs ... 40 secs | half a minute        |
 * | 40 secs ... 60 secs | less than a minute   |
 * | 60 secs ... 90 secs | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - The object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNow(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNow(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNow(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in about 1 year'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 August 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNow(
 *   new Date(2016, 7, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */
function formatDistanceToNow(date, options) {
  return (0, _index2.formatDistance)(
    date,
    (0, _index.constructNow)(date),
    options,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/formatDistanceToNowStrict.js":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/formatDistanceToNowStrict.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatDistanceToNowStrict = formatDistanceToNowStrict;
var _index = __webpack_require__(/*! ./formatDistanceStrict.js */ "./node_modules/date-fns/formatDistanceStrict.js");
var _index2 = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");

/**
 * The {@link formatDistanceToNowStrict} function options.
 */

/**
 * @name formatDistanceToNowStrict
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNowStrict(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNowStrict(
 *   new Date(2015, 0, 1, 0, 0, 15)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in 1 year'
 *
 * @example
 * // If today is 28 January 2015,
 * // what is the distance to 1 January 2015, in months, rounded up??
 * const result = formatDistanceToNowStrict(new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {locale: eoLocale}
 * )
 * //=> '1 jaro'
 */
function formatDistanceToNowStrict(date, options) {
  return (0, _index.formatDistanceStrict)(
    date,
    (0, _index2.constructNow)(date),
    options,
  );
}


/***/ }),

/***/ "./node_modules/date-fns/formatDuration.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/formatDuration.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatDuration = formatDuration;

var _index = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link formatDuration} function options.
 */

const defaultFormat = [
  "years",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
];

/**
 * @name formatDuration
 * @category Common Helpers
 * @summary Formats a duration in human-readable format
 *
 * @description
 * Return human-readable duration string i.e. "9 months 2 days"
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param duration - The duration to format
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @example
 * // Format full duration
 * formatDuration({
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> '2 years 9 months 1 week 7 days 5 hours 9 minutes 30 seconds'
 *
 * @example
 * // Format partial duration
 * formatDuration({ months: 9, days: 2 })
 * //=> '9 months 2 days'
 *
 * @example
 * // Customize the format
 * formatDuration(
 *   {
 *     years: 2,
 *     months: 9,
 *     weeks: 1,
 *     days: 7,
 *     hours: 5,
 *     minutes: 9,
 *     seconds: 30
 *   },
 *   { format: ['months', 'weeks'] }
 * ) === '9 months 1 week'
 *
 * @example
 * // Customize the zeros presence
 * formatDuration({ years: 0, months: 9 })
 * //=> '9 months'
 * formatDuration({ years: 0, months: 9 }, { zero: true })
 * //=> '0 years 9 months'
 *
 * @example
 * // Customize the delimiter
 * formatDuration({ years: 2, months: 9, weeks: 3 }, { delimiter: ', ' })
 * //=> '2 years, 9 months, 3 weeks'
 */
function formatDuration(duration, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;
  const format = options?.format ?? defaultFormat;
  const zero = options?.zero ?? false;
  const delimiter = options?.delimiter ?? " ";

  if (!locale.formatDistance) {
    return "";
  }

  const result = format
    .reduce((acc, unit) => {
      const token = `x${unit.replace(/(^.)/, (m) => m.toUpperCase())}`;
      const value = duration[unit];
      if (value !== undefined && (zero || duration[unit])) {
        return acc.concat(locale.formatDistance(token, value));
      }
      return acc;
    }, [])
    .join(delimiter);

  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/formatISO.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/formatISO.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatISO = formatISO;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index2 = __webpack_require__(/*! ./_lib/addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");

/**
 * The {@link formatISO} function options.
 */

/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string (in loca.l time zone)
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */
function formatISO(date, options) {
  const _date = (0, _index.toDate)(date);

  if (isNaN(_date.getTime())) {
    throw new RangeError("Invalid time value");
  }

  const format = options?.format ?? "extended";
  const representation = options?.representation ?? "complete";

  let result = "";
  let tzOffset = "";

  const dateDelimiter = format === "extended" ? "-" : "";
  const timeDelimiter = format === "extended" ? ":" : "";

  // Representation is either 'date' or 'complete'
  if (representation !== "time") {
    const day = (0, _index2.addLeadingZeros)(_date.getDate(), 2);
    const month = (0, _index2.addLeadingZeros)(_date.getMonth() + 1, 2);
    const year = (0, _index2.addLeadingZeros)(_date.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
  }

  // Representation is either 'time' or 'complete'
  if (representation !== "date") {
    // Add the timezone.
    const offset = _date.getTimezoneOffset();

    if (offset !== 0) {
      const absoluteOffset = Math.abs(offset);
      const hourOffset = (0, _index2.addLeadingZeros)(
        Math.trunc(absoluteOffset / 60),
        2,
      );
      const minuteOffset = (0, _index2.addLeadingZeros)(absoluteOffset % 60, 2);
      // If less than 0, the sign is +, because it is ahead of time.
      const sign = offset < 0 ? "+" : "-";

      tzOffset = `${sign}${hourOffset}:${minuteOffset}`;
    } else {
      tzOffset = "Z";
    }

    const hour = (0, _index2.addLeadingZeros)(_date.getHours(), 2);
    const minute = (0, _index2.addLeadingZeros)(_date.getMinutes(), 2);
    const second = (0, _index2.addLeadingZeros)(_date.getSeconds(), 2);

    // If there's also date, separate it with time with 'T'
    const separator = result === "" ? "" : "T";

    // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
    const time = [hour, minute, second].join(timeDelimiter);

    // HHmmss or HH:mm:ss.
    result = `${result}${separator}${time}${tzOffset}`;
  }

  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/formatISO9075.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/formatISO9075.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatISO9075 = formatISO9075;
var _index = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index3 = __webpack_require__(/*! ./_lib/addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");

/**
 * The {@link formatISO9075} function options.
 */

/**
 * @name formatISO9075
 * @category Common Helpers
 * @summary Format the date according to the ISO 9075 standard (https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_get-format).
 *
 * @description
 * Return the formatted date string in ISO 9075 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18 19:00:52'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075, short format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918 190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, date only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, time only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52'
 */
function formatISO9075(date, options) {
  const _date = (0, _index2.toDate)(date);

  if (!(0, _index.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const format = options?.format ?? "extended";
  const representation = options?.representation ?? "complete";

  let result = "";

  const dateDelimiter = format === "extended" ? "-" : "";
  const timeDelimiter = format === "extended" ? ":" : "";

  // Representation is either 'date' or 'complete'
  if (representation !== "time") {
    const day = (0, _index3.addLeadingZeros)(_date.getDate(), 2);
    const month = (0, _index3.addLeadingZeros)(_date.getMonth() + 1, 2);
    const year = (0, _index3.addLeadingZeros)(_date.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
  }

  // Representation is either 'time' or 'complete'
  if (representation !== "date") {
    const hour = (0, _index3.addLeadingZeros)(_date.getHours(), 2);
    const minute = (0, _index3.addLeadingZeros)(_date.getMinutes(), 2);
    const second = (0, _index3.addLeadingZeros)(_date.getSeconds(), 2);

    // If there's also date, separate it with time with a space
    const separator = result === "" ? "" : " ";

    // HHmmss or HH:mm:ss.
    result = `${result}${separator}${hour}${timeDelimiter}${minute}${timeDelimiter}${second}`;
  }

  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/formatISODuration.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/formatISODuration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.formatISODuration = formatISODuration;

/**
 * @name formatISODuration
 * @category Common Helpers
 * @summary Format a duration object according as ISO 8601 duration string
 *
 * @description
 * Format a duration object according to the ISO 8601 duration standard (https://www.digi.com/resources/documentation/digidocs//90001488-13/reference/r_iso_8601_duration_format.htm)
 *
 * @param duration - The duration to format
 *
 * @returns The ISO 8601 duration string
 *
 * @example
 * // Format the given duration as ISO 8601 string
 * const result = formatISODuration({
 *   years: 39,
 *   months: 2,
 *   days: 20,
 *   hours: 7,
 *   minutes: 5,
 *   seconds: 0
 * })
 * //=> 'P39Y2M20DT0H0M0S'
 */
function formatISODuration(duration) {
  const {
    years = 0,
    months = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  return `P${years}Y${months}M${days}DT${hours}H${minutes}M${seconds}S`;
}


/***/ }),

/***/ "./node_modules/date-fns/formatRFC3339.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/formatRFC3339.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatRFC3339 = formatRFC3339;
var _index = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index3 = __webpack_require__(/*! ./_lib/addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");

/**
 * The {@link formatRFC3339} function options.
 */

/**
 * @name formatRFC3339
 * @category Common Helpers
 * @summary Format the date according to the RFC 3339 standard (https://tools.ietf.org/html/rfc3339#section-5.6).
 *
 * @description
 * Return the formatted date string in RFC 3339 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format:
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format, 3 digits of second fraction
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), {
 *   fractionDigits: 3
 * })
 * //=> '2019-09-18T19:00:52.234Z'
 */
function formatRFC3339(date, options) {
  const _date = (0, _index2.toDate)(date);

  if (!(0, _index.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const fractionDigits = options?.fractionDigits ?? 0;

  const day = (0, _index3.addLeadingZeros)(_date.getDate(), 2);
  const month = (0, _index3.addLeadingZeros)(_date.getMonth() + 1, 2);
  const year = _date.getFullYear();

  const hour = (0, _index3.addLeadingZeros)(_date.getHours(), 2);
  const minute = (0, _index3.addLeadingZeros)(_date.getMinutes(), 2);
  const second = (0, _index3.addLeadingZeros)(_date.getSeconds(), 2);

  let fractionalSecond = "";
  if (fractionDigits > 0) {
    const milliseconds = _date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, fractionDigits - 3),
    );
    fractionalSecond =
      "." + (0, _index3.addLeadingZeros)(fractionalSeconds, fractionDigits);
  }

  let offset = "";
  const tzOffset = _date.getTimezoneOffset();

  if (tzOffset !== 0) {
    const absoluteOffset = Math.abs(tzOffset);
    const hourOffset = (0, _index3.addLeadingZeros)(
      Math.trunc(absoluteOffset / 60),
      2,
    );
    const minuteOffset = (0, _index3.addLeadingZeros)(absoluteOffset % 60, 2);
    // If less than 0, the sign is +, because it is ahead of time.
    const sign = tzOffset < 0 ? "+" : "-";

    offset = `${sign}${hourOffset}:${minuteOffset}`;
  } else {
    offset = "Z";
  }

  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}${offset}`;
}


/***/ }),

/***/ "./node_modules/date-fns/formatRFC7231.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/formatRFC7231.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatRFC7231 = formatRFC7231;
var _index = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index3 = __webpack_require__(/*! ./_lib/addLeadingZeros.js */ "./node_modules/date-fns/_lib/addLeadingZeros.js");

const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

/**
 * @name formatRFC7231
 * @category Common Helpers
 * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).
 *
 * @description
 * Return the formatted date string in RFC 7231 format.
 * The result will always be in UTC timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 7231 format:
 * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))
 * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'
 */
function formatRFC7231(date) {
  const _date = (0, _index2.toDate)(date);

  if (!(0, _index.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const dayName = days[_date.getUTCDay()];
  const dayOfMonth = (0, _index3.addLeadingZeros)(_date.getUTCDate(), 2);
  const monthName = months[_date.getUTCMonth()];
  const year = _date.getUTCFullYear();

  const hour = (0, _index3.addLeadingZeros)(_date.getUTCHours(), 2);
  const minute = (0, _index3.addLeadingZeros)(_date.getUTCMinutes(), 2);
  const second = (0, _index3.addLeadingZeros)(_date.getUTCSeconds(), 2);

  // Result variables.
  return `${dayName}, ${dayOfMonth} ${monthName} ${year} ${hour}:${minute}:${second} GMT`;
}


/***/ }),

/***/ "./node_modules/date-fns/formatRelative.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/formatRelative.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatRelative = formatRelative;
var _index = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index2 = __webpack_require__(/*! ./format.js */ "./node_modules/date-fns/format.js");

var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index4 = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index5 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link formatRelative} function options.
 */

/**
 * @name formatRelative
 * @category Common Helpers
 * @summary Represent the date in words relative to the given base date.
 *
 * @description
 * Represent the date in words relative to the given base date.
 *
 * | Distance to the base date | Result                    |
 * |---------------------------|---------------------------|
 * | Previous 6 days           | last Sunday at 04:30 AM   |
 * | Last day                  | yesterday at 04:30 AM     |
 * | Same day                  | today at 04:30 AM         |
 * | Next day                  | tomorrow at 04:30 AM      |
 * | Next 6 days               | Sunday at 04:30 AM        |
 * | Other                     | 12/31/2017                |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The date in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws `options.locale` must contain `formatRelative` property
 *
 * @example
 * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
 * const result = formatRelative(subDays(new Date(), 6), new Date())
 * //=> "last Thursday at 12:45 AM"
 */
function formatRelative(date, baseDate, options) {
  const _date = (0, _index3.toDate)(date);
  const _baseDate = (0, _index3.toDate)(baseDate);

  const defaultOptions = (0, _index5.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index4.defaultLocale;
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const diff = (0, _index.differenceInCalendarDays)(_date, _baseDate);

  if (isNaN(diff)) {
    throw new RangeError("Invalid time value");
  }

  let token;
  if (diff < -6) {
    token = "other";
  } else if (diff < -1) {
    token = "lastWeek";
  } else if (diff < 0) {
    token = "yesterday";
  } else if (diff < 1) {
    token = "today";
  } else if (diff < 2) {
    token = "tomorrow";
  } else if (diff < 7) {
    token = "nextWeek";
  } else {
    token = "other";
  }

  const formatStr = locale.formatRelative(token, _date, _baseDate, {
    locale,
    weekStartsOn,
  });
  return (0, _index2.format)(_date, formatStr, { locale, weekStartsOn });
}


/***/ }),

/***/ "./node_modules/date-fns/fromUnixTime.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/fromUnixTime.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.fromUnixTime = fromUnixTime;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name fromUnixTime
 * @category Timestamp Helpers
 * @summary Create a date from a Unix timestamp.
 *
 * @description
 * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
 *
 * @param unixTime - The given Unix timestamp (in seconds)
 *
 * @returns The date
 *
 * @example
 * // Create the date 29 February 2012 11:45:05:
 * const result = fromUnixTime(1330515905)
 * //=> Wed Feb 29 2012 11:45:05
 */
function fromUnixTime(unixTime) {
  return (0, _index.toDate)(unixTime * 1000);
}


/***/ }),

/***/ "./node_modules/date-fns/getDate.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/getDate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDate = getDate;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of month
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */
function getDate(date) {
  const _date = (0, _index.toDate)(date);
  const dayOfMonth = _date.getDate();
  return dayOfMonth;
}


/***/ }),

/***/ "./node_modules/date-fns/getDay.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/getDay.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDay = getDay;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of week, 0 represents Sunday
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */
function getDay(date) {
  const _date = (0, _index.toDate)(date);
  const day = _date.getDay();
  return day;
}


/***/ }),

/***/ "./node_modules/date-fns/getDayOfYear.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/getDayOfYear.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDayOfYear = getDayOfYear;
var _index = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index2 = __webpack_require__(/*! ./startOfYear.js */ "./node_modules/date-fns/startOfYear.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(date) {
  const _date = (0, _index3.toDate)(date);
  const diff = (0, _index.differenceInCalendarDays)(
    _date,
    (0, _index2.startOfYear)(_date),
  );
  const dayOfYear = diff + 1;
  return dayOfYear;
}


/***/ }),

/***/ "./node_modules/date-fns/getDaysInMonth.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/getDaysInMonth.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDaysInMonth = getDaysInMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */
function getDaysInMonth(date) {
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = (0, _index2.constructFrom)(date, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}


/***/ }),

/***/ "./node_modules/date-fns/getDaysInYear.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/getDaysInYear.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDaysInYear = getDaysInYear;
var _index = __webpack_require__(/*! ./isLeapYear.js */ "./node_modules/date-fns/isLeapYear.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getDaysInYear
 * @category Year Helpers
 * @summary Get the number of days in a year of the given date.
 *
 * @description
 * Get the number of days in a year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a year
 *
 * @example
 * // How many days are in 2012?
 * const result = getDaysInYear(new Date(2012, 0, 1))
 * //=> 366
 */
function getDaysInYear(date) {
  const _date = (0, _index2.toDate)(date);

  if (String(new Date(_date)) === "Invalid Date") {
    return NaN;
  }

  return (0, _index.isLeapYear)(_date) ? 366 : 365;
}


/***/ }),

/***/ "./node_modules/date-fns/getDecade.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/getDecade.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDecade = getDecade;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getDecade
 * @category Decade Helpers
 * @summary Get the decade of the given date.
 *
 * @description
 * Get the decade of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year of decade
 *
 * @example
 * // Which decade belongs 27 November 1942?
 * const result = getDecade(new Date(1942, 10, 27))
 * //=> 1940
 */
function getDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  const decade = Math.floor(year / 10) * 10;
  return decade;
}


/***/ }),

/***/ "./node_modules/date-fns/getDefaultOptions.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/getDefaultOptions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getDefaultOptions = getDefaultOptions;

var _index = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * @name getDefaultOptions
 * @category Common Helpers
 * @summary Get default options.
 * @pure false
 *
 * @description
 * Returns an object that contains defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
 *
 * @returns The default options
 *
 * @example
 * const result = getDefaultOptions()
 * //=> {}
 *
 * @example
 * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
 * const result = getDefaultOptions()
 * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
 */
function getDefaultOptions() {
  return Object.assign({}, (0, _index.getDefaultOptions)());
}


/***/ }),

/***/ "./node_modules/date-fns/getHours.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/getHours.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getHours = getHours;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The hours
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */
function getHours(date) {
  const _date = (0, _index.toDate)(date);
  const hours = _date.getHours();
  return hours;
}


/***/ }),

/***/ "./node_modules/date-fns/getISODay.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/getISODay.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getISODay = getISODay;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getISODay
 * @category Weekday Helpers
 * @summary Get the day of the ISO week of the given date.
 *
 * @description
 * Get the day of the ISO week of the given date,
 * which is 7 for Sunday, 1 for Monday etc.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of ISO week
 *
 * @example
 * // Which day of the ISO week is 26 February 2012?
 * const result = getISODay(new Date(2012, 1, 26))
 * //=> 7
 */
function getISODay(date) {
  const _date = (0, _index.toDate)(date);
  let day = _date.getDay();

  if (day === 0) {
    day = 7;
  }

  return day;
}


/***/ }),

/***/ "./node_modules/date-fns/getISOWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/getISOWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getISOWeek = getISOWeek;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./startOfISOWeekYear.js */ "./node_modules/date-fns/startOfISOWeekYear.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(date) {
  const _date = (0, _index4.toDate)(date);
  const diff =
    +(0, _index2.startOfISOWeek)(_date) -
    +(0, _index3.startOfISOWeekYear)(_date);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index.millisecondsInWeek) + 1;
}


/***/ }),

/***/ "./node_modules/date-fns/getISOWeekYear.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/getISOWeekYear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getISOWeekYear = getISOWeekYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOWeekYear(date) {
  const _date = (0, _index3.toDate)(date);
  const year = _date.getFullYear();

  const fourthOfJanuaryOfNextYear = (0, _index.constructFrom)(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0, _index2.startOfISOWeek)(
    fourthOfJanuaryOfNextYear,
  );

  const fourthOfJanuaryOfThisYear = (0, _index.constructFrom)(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0, _index2.startOfISOWeek)(
    fourthOfJanuaryOfThisYear,
  );

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/getISOWeeksInYear.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/getISOWeeksInYear.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getISOWeeksInYear = getISOWeeksInYear;
var _index = __webpack_require__(/*! ./addWeeks.js */ "./node_modules/date-fns/addWeeks.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index3 = __webpack_require__(/*! ./startOfISOWeekYear.js */ "./node_modules/date-fns/startOfISOWeekYear.js");

/**
 * @name getISOWeeksInYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * @description
 * Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of ISO weeks in a year
 *
 * @example
 * // How many weeks are in ISO week-numbering year 2015?
 * const result = getISOWeeksInYear(new Date(2015, 1, 11))
 * //=> 53
 */
function getISOWeeksInYear(date) {
  const thisYear = (0, _index3.startOfISOWeekYear)(date);
  const nextYear = (0, _index3.startOfISOWeekYear)(
    (0, _index.addWeeks)(thisYear, 60),
  );
  const diff = +nextYear - +thisYear;

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index2.millisecondsInWeek);
}


/***/ }),

/***/ "./node_modules/date-fns/getMilliseconds.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/getMilliseconds.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getMilliseconds = getMilliseconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getMilliseconds
 * @category Millisecond Helpers
 * @summary Get the milliseconds of the given date.
 *
 * @description
 * Get the milliseconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The milliseconds
 *
 * @example
 * // Get the milliseconds of 29 February 2012 11:45:05.123:
 * const result = getMilliseconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 123
 */
function getMilliseconds(date) {
  const _date = (0, _index.toDate)(date);
  const milliseconds = _date.getMilliseconds();
  return milliseconds;
}


/***/ }),

/***/ "./node_modules/date-fns/getMinutes.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/getMinutes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getMinutes = getMinutes;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The minutes
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */
function getMinutes(date) {
  const _date = (0, _index.toDate)(date);
  const minutes = _date.getMinutes();
  return minutes;
}


/***/ }),

/***/ "./node_modules/date-fns/getMonth.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/getMonth.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getMonth = getMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The month index (0-11)
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */
function getMonth(date) {
  const _date = (0, _index.toDate)(date);
  const month = _date.getMonth();
  return month;
}


/***/ }),

/***/ "./node_modules/date-fns/getOverlappingDaysInIntervals.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/getOverlappingDaysInIntervals.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getOverlappingDaysInIntervals = getOverlappingDaysInIntervals;
var _index = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");
var _index2 = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getOverlappingDaysInIntervals
 * @category Interval Helpers
 * @summary Get the number of days that overlap in two time intervals
 *
 * @description
 * Get the number of days that overlap in two time intervals. It uses the time
 * between dates to calculate the number of days, rounding it up to include
 * partial days.
 *
 * Two equal 0-length intervals will result in 0. Two equal 1ms intervals will
 * result in 1.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 *
 * @returns The number of days that overlap in two time intervals
 *
 * @example
 * // For overlapping time intervals adds 1 for each started overlapping day:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> 3
 *
 * @example
 * // For non-overlapping time intervals returns 0:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> 0
 */

function getOverlappingDaysInIntervals(intervalLeft, intervalRight) {
  const [leftStart, leftEnd] = [
    +(0, _index3.toDate)(intervalLeft.start),
    +(0, _index3.toDate)(intervalLeft.end),
  ].sort((a, b) => a - b);
  const [rightStart, rightEnd] = [
    +(0, _index3.toDate)(intervalRight.start),
    +(0, _index3.toDate)(intervalRight.end),
  ].sort((a, b) => a - b);

  // Prevent NaN result if intervals don't overlap at all.
  const isOverlapping = leftStart < rightEnd && rightStart < leftEnd;
  if (!isOverlapping) return 0;

  // Remove the timezone offset to negate the DST effect on calculations.
  const overlapLeft = rightStart < leftStart ? leftStart : rightStart;
  const left =
    overlapLeft - (0, _index.getTimezoneOffsetInMilliseconds)(overlapLeft);
  const overlapRight = rightEnd > leftEnd ? leftEnd : rightEnd;
  const right =
    overlapRight - (0, _index.getTimezoneOffsetInMilliseconds)(overlapRight);

  // Ceil the number to include partial days too.
  return Math.ceil((right - left) / _index2.millisecondsInDay);
}


/***/ }),

/***/ "./node_modules/date-fns/getQuarter.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/getQuarter.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getQuarter = getQuarter;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getQuarter
 * @category Quarter Helpers
 * @summary Get the year quarter of the given date.
 *
 * @description
 * Get the year quarter of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The quarter
 *
 * @example
 * // Which quarter is 2 July 2014?
 * const result = getQuarter(new Date(2014, 6, 2))
 * //=> 3
 */
function getQuarter(date) {
  const _date = (0, _index.toDate)(date);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}


/***/ }),

/***/ "./node_modules/date-fns/getSeconds.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/getSeconds.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getSeconds = getSeconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The seconds
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */
function getSeconds(date) {
  const _date = (0, _index.toDate)(date);
  const seconds = _date.getSeconds();
  return seconds;
}


/***/ }),

/***/ "./node_modules/date-fns/getTime.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/getTime.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getTime = getTime;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */
function getTime(date) {
  const _date = (0, _index.toDate)(date);
  const timestamp = _date.getTime();
  return timestamp;
}


/***/ }),

/***/ "./node_modules/date-fns/getUnixTime.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/getUnixTime.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getUnixTime = getUnixTime;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */
function getUnixTime(date) {
  return Math.trunc(+(0, _index.toDate)(date) / 1000);
}


/***/ }),

/***/ "./node_modules/date-fns/getWeek.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/getWeek.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getWeek = getWeek;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");
var _index2 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
var _index3 = __webpack_require__(/*! ./startOfWeekYear.js */ "./node_modules/date-fns/startOfWeekYear.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link getWeek} function options.
 */

/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The week
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(date, options) {
  const _date = (0, _index4.toDate)(date);
  const diff =
    +(0, _index2.startOfWeek)(_date, options) -
    +(0, _index3.startOfWeekYear)(_date, options);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index.millisecondsInWeek) + 1;
}


/***/ }),

/***/ "./node_modules/date-fns/getWeekOfMonth.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/getWeekOfMonth.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getWeekOfMonth = getWeekOfMonth;
var _index = __webpack_require__(/*! ./getDate.js */ "./node_modules/date-fns/getDate.js");
var _index2 = __webpack_require__(/*! ./getDay.js */ "./node_modules/date-fns/getDay.js");
var _index3 = __webpack_require__(/*! ./startOfMonth.js */ "./node_modules/date-fns/startOfMonth.js");

var _index4 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link getWeekOfMonth} function options.
 */

/**
 * @name getWeekOfMonth
 * @category Week Helpers
 * @summary Get the week of the month of the given date.
 *
 * @description
 * Get the week of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The week of month
 *
 * @example
 * // Which week of the month is 9 November 2017?
 * const result = getWeekOfMonth(new Date(2017, 10, 9))
 * //=> 2
 */
function getWeekOfMonth(date, options) {
  const defaultOptions = (0, _index4.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const currentDayOfMonth = (0, _index.getDate)(date);
  if (isNaN(currentDayOfMonth)) return NaN;

  const startWeekDay = (0, _index2.getDay)((0, _index3.startOfMonth)(date));

  let lastDayOfFirstWeek = weekStartsOn - startWeekDay;
  if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;

  const remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
  return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}


/***/ }),

/***/ "./node_modules/date-fns/getWeekYear.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/getWeekYear.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getWeekYear = getWeekYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index4 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link getWeekYear} function options.
 */

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The local week-numbering year
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(date, options) {
  const _date = (0, _index3.toDate)(date);
  const year = _date.getFullYear();

  const defaultOptions = (0, _index4.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const firstWeekOfNextYear = (0, _index.constructFrom)(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0, _index2.startOfWeek)(
    firstWeekOfNextYear,
    options,
  );

  const firstWeekOfThisYear = (0, _index.constructFrom)(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0, _index2.startOfWeek)(
    firstWeekOfThisYear,
    options,
  );

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}


/***/ }),

/***/ "./node_modules/date-fns/getWeeksInMonth.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/getWeeksInMonth.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getWeeksInMonth = getWeeksInMonth;
var _index = __webpack_require__(/*! ./differenceInCalendarWeeks.js */ "./node_modules/date-fns/differenceInCalendarWeeks.js");
var _index2 = __webpack_require__(/*! ./lastDayOfMonth.js */ "./node_modules/date-fns/lastDayOfMonth.js");
var _index3 = __webpack_require__(/*! ./startOfMonth.js */ "./node_modules/date-fns/startOfMonth.js");

/**
 * The {@link getWeeksInMonth} function options.
 */

/**
 * @name getWeeksInMonth
 * @category Week Helpers
 * @summary Get the number of calendar weeks a month spans.
 *
 * @description
 * Get the number of calendar weeks the month in the given date spans.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks does February 2015 span?
 * const result = getWeeksInMonth(new Date(2015, 1, 8))
 * //=> 4
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks does July 2017 span?
 * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
 * //=> 6
 */
function getWeeksInMonth(date, options) {
  return (
    (0, _index.differenceInCalendarWeeks)(
      (0, _index2.lastDayOfMonth)(date),
      (0, _index3.startOfMonth)(date),
      options,
    ) + 1
  );
}


/***/ }),

/***/ "./node_modules/date-fns/getYear.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/getYear.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.getYear = getYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */
function getYear(date) {
  return (0, _index.toDate)(date).getFullYear();
}


/***/ }),

/***/ "./node_modules/date-fns/hoursToMilliseconds.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/hoursToMilliseconds.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.hoursToMilliseconds = hoursToMilliseconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name hoursToMilliseconds
 * @category  Conversion Helpers
 * @summary Convert hours to milliseconds.
 *
 * @description
 * Convert a number of hours to a full number of milliseconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted to milliseconds
 *
 * @example
 * // Convert 2 hours to milliseconds:
 * const result = hoursToMilliseconds(2)
 * //=> 7200000
 */
function hoursToMilliseconds(hours) {
  return Math.trunc(hours * _index.millisecondsInHour);
}


/***/ }),

/***/ "./node_modules/date-fns/hoursToMinutes.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/hoursToMinutes.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.hoursToMinutes = hoursToMinutes;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name hoursToMinutes
 * @category Conversion Helpers
 * @summary Convert hours to minutes.
 *
 * @description
 * Convert a number of hours to a full number of minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted in minutes
 *
 * @example
 * // Convert 2 hours to minutes:
 * const result = hoursToMinutes(2)
 * //=> 120
 */
function hoursToMinutes(hours) {
  return Math.trunc(hours * _index.minutesInHour);
}


/***/ }),

/***/ "./node_modules/date-fns/hoursToSeconds.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/hoursToSeconds.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.hoursToSeconds = hoursToSeconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name hoursToSeconds
 * @category Conversion Helpers
 * @summary Convert hours to seconds.
 *
 * @description
 * Convert a number of hours to a full number of seconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - The number of hours to be converted
 *
 * @returns The number of hours converted in seconds
 *
 * @example
 * // Convert 2 hours to seconds:
 * const result = hoursToSeconds(2)
 * //=> 7200
 */
function hoursToSeconds(hours) {
  return Math.trunc(hours * _index.secondsInHour);
}


/***/ }),

/***/ "./node_modules/date-fns/index.js":
/*!****************************************!*\
  !*** ./node_modules/date-fns/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _index = __webpack_require__(/*! ./add.js */ "./node_modules/date-fns/add.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    },
  });
});
var _index2 = __webpack_require__(/*! ./addBusinessDays.js */ "./node_modules/date-fns/addBusinessDays.js");
Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    },
  });
});
var _index3 = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index3[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index3[key];
    },
  });
});
var _index4 = __webpack_require__(/*! ./addHours.js */ "./node_modules/date-fns/addHours.js");
Object.keys(_index4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index4[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index4[key];
    },
  });
});
var _index5 = __webpack_require__(/*! ./addISOWeekYears.js */ "./node_modules/date-fns/addISOWeekYears.js");
Object.keys(_index5).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index5[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index5[key];
    },
  });
});
var _index6 = __webpack_require__(/*! ./addMilliseconds.js */ "./node_modules/date-fns/addMilliseconds.js");
Object.keys(_index6).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index6[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index6[key];
    },
  });
});
var _index7 = __webpack_require__(/*! ./addMinutes.js */ "./node_modules/date-fns/addMinutes.js");
Object.keys(_index7).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index7[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index7[key];
    },
  });
});
var _index8 = __webpack_require__(/*! ./addMonths.js */ "./node_modules/date-fns/addMonths.js");
Object.keys(_index8).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index8[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index8[key];
    },
  });
});
var _index9 = __webpack_require__(/*! ./addQuarters.js */ "./node_modules/date-fns/addQuarters.js");
Object.keys(_index9).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index9[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index9[key];
    },
  });
});
var _index10 = __webpack_require__(/*! ./addSeconds.js */ "./node_modules/date-fns/addSeconds.js");
Object.keys(_index10).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index10[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index10[key];
    },
  });
});
var _index11 = __webpack_require__(/*! ./addWeeks.js */ "./node_modules/date-fns/addWeeks.js");
Object.keys(_index11).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index11[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index11[key];
    },
  });
});
var _index12 = __webpack_require__(/*! ./addYears.js */ "./node_modules/date-fns/addYears.js");
Object.keys(_index12).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index12[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index12[key];
    },
  });
});
var _index13 = __webpack_require__(/*! ./areIntervalsOverlapping.js */ "./node_modules/date-fns/areIntervalsOverlapping.js");
Object.keys(_index13).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index13[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index13[key];
    },
  });
});
var _index14 = __webpack_require__(/*! ./clamp.js */ "./node_modules/date-fns/clamp.js");
Object.keys(_index14).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index14[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index14[key];
    },
  });
});
var _index15 = __webpack_require__(/*! ./closestIndexTo.js */ "./node_modules/date-fns/closestIndexTo.js");
Object.keys(_index15).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index15[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index15[key];
    },
  });
});
var _index16 = __webpack_require__(/*! ./closestTo.js */ "./node_modules/date-fns/closestTo.js");
Object.keys(_index16).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index16[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index16[key];
    },
  });
});
var _index17 = __webpack_require__(/*! ./compareAsc.js */ "./node_modules/date-fns/compareAsc.js");
Object.keys(_index17).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index17[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index17[key];
    },
  });
});
var _index18 = __webpack_require__(/*! ./compareDesc.js */ "./node_modules/date-fns/compareDesc.js");
Object.keys(_index18).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index18[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index18[key];
    },
  });
});
var _index19 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
Object.keys(_index19).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index19[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index19[key];
    },
  });
});
var _index20 = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
Object.keys(_index20).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index20[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index20[key];
    },
  });
});
var _index21 = __webpack_require__(/*! ./daysToWeeks.js */ "./node_modules/date-fns/daysToWeeks.js");
Object.keys(_index21).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index21[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index21[key];
    },
  });
});
var _index22 = __webpack_require__(/*! ./differenceInBusinessDays.js */ "./node_modules/date-fns/differenceInBusinessDays.js");
Object.keys(_index22).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index22[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index22[key];
    },
  });
});
var _index23 = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
Object.keys(_index23).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index23[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index23[key];
    },
  });
});
var _index24 = __webpack_require__(/*! ./differenceInCalendarISOWeekYears.js */ "./node_modules/date-fns/differenceInCalendarISOWeekYears.js");
Object.keys(_index24).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index24[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index24[key];
    },
  });
});
var _index25 = __webpack_require__(/*! ./differenceInCalendarISOWeeks.js */ "./node_modules/date-fns/differenceInCalendarISOWeeks.js");
Object.keys(_index25).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index25[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index25[key];
    },
  });
});
var _index26 = __webpack_require__(/*! ./differenceInCalendarMonths.js */ "./node_modules/date-fns/differenceInCalendarMonths.js");
Object.keys(_index26).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index26[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index26[key];
    },
  });
});
var _index27 = __webpack_require__(/*! ./differenceInCalendarQuarters.js */ "./node_modules/date-fns/differenceInCalendarQuarters.js");
Object.keys(_index27).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index27[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index27[key];
    },
  });
});
var _index28 = __webpack_require__(/*! ./differenceInCalendarWeeks.js */ "./node_modules/date-fns/differenceInCalendarWeeks.js");
Object.keys(_index28).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index28[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index28[key];
    },
  });
});
var _index29 = __webpack_require__(/*! ./differenceInCalendarYears.js */ "./node_modules/date-fns/differenceInCalendarYears.js");
Object.keys(_index29).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index29[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index29[key];
    },
  });
});
var _index30 = __webpack_require__(/*! ./differenceInDays.js */ "./node_modules/date-fns/differenceInDays.js");
Object.keys(_index30).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index30[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index30[key];
    },
  });
});
var _index31 = __webpack_require__(/*! ./differenceInHours.js */ "./node_modules/date-fns/differenceInHours.js");
Object.keys(_index31).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index31[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index31[key];
    },
  });
});
var _index32 = __webpack_require__(/*! ./differenceInISOWeekYears.js */ "./node_modules/date-fns/differenceInISOWeekYears.js");
Object.keys(_index32).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index32[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index32[key];
    },
  });
});
var _index33 = __webpack_require__(/*! ./differenceInMilliseconds.js */ "./node_modules/date-fns/differenceInMilliseconds.js");
Object.keys(_index33).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index33[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index33[key];
    },
  });
});
var _index34 = __webpack_require__(/*! ./differenceInMinutes.js */ "./node_modules/date-fns/differenceInMinutes.js");
Object.keys(_index34).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index34[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index34[key];
    },
  });
});
var _index35 = __webpack_require__(/*! ./differenceInMonths.js */ "./node_modules/date-fns/differenceInMonths.js");
Object.keys(_index35).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index35[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index35[key];
    },
  });
});
var _index36 = __webpack_require__(/*! ./differenceInQuarters.js */ "./node_modules/date-fns/differenceInQuarters.js");
Object.keys(_index36).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index36[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index36[key];
    },
  });
});
var _index37 = __webpack_require__(/*! ./differenceInSeconds.js */ "./node_modules/date-fns/differenceInSeconds.js");
Object.keys(_index37).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index37[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index37[key];
    },
  });
});
var _index38 = __webpack_require__(/*! ./differenceInWeeks.js */ "./node_modules/date-fns/differenceInWeeks.js");
Object.keys(_index38).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index38[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index38[key];
    },
  });
});
var _index39 = __webpack_require__(/*! ./differenceInYears.js */ "./node_modules/date-fns/differenceInYears.js");
Object.keys(_index39).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index39[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index39[key];
    },
  });
});
var _index40 = __webpack_require__(/*! ./eachDayOfInterval.js */ "./node_modules/date-fns/eachDayOfInterval.js");
Object.keys(_index40).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index40[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index40[key];
    },
  });
});
var _index41 = __webpack_require__(/*! ./eachHourOfInterval.js */ "./node_modules/date-fns/eachHourOfInterval.js");
Object.keys(_index41).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index41[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index41[key];
    },
  });
});
var _index42 = __webpack_require__(/*! ./eachMinuteOfInterval.js */ "./node_modules/date-fns/eachMinuteOfInterval.js");
Object.keys(_index42).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index42[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index42[key];
    },
  });
});
var _index43 = __webpack_require__(/*! ./eachMonthOfInterval.js */ "./node_modules/date-fns/eachMonthOfInterval.js");
Object.keys(_index43).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index43[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index43[key];
    },
  });
});
var _index44 = __webpack_require__(/*! ./eachQuarterOfInterval.js */ "./node_modules/date-fns/eachQuarterOfInterval.js");
Object.keys(_index44).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index44[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index44[key];
    },
  });
});
var _index45 = __webpack_require__(/*! ./eachWeekOfInterval.js */ "./node_modules/date-fns/eachWeekOfInterval.js");
Object.keys(_index45).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index45[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index45[key];
    },
  });
});
var _index46 = __webpack_require__(/*! ./eachWeekendOfInterval.js */ "./node_modules/date-fns/eachWeekendOfInterval.js");
Object.keys(_index46).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index46[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index46[key];
    },
  });
});
var _index47 = __webpack_require__(/*! ./eachWeekendOfMonth.js */ "./node_modules/date-fns/eachWeekendOfMonth.js");
Object.keys(_index47).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index47[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index47[key];
    },
  });
});
var _index48 = __webpack_require__(/*! ./eachWeekendOfYear.js */ "./node_modules/date-fns/eachWeekendOfYear.js");
Object.keys(_index48).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index48[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index48[key];
    },
  });
});
var _index49 = __webpack_require__(/*! ./eachYearOfInterval.js */ "./node_modules/date-fns/eachYearOfInterval.js");
Object.keys(_index49).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index49[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index49[key];
    },
  });
});
var _index50 = __webpack_require__(/*! ./endOfDay.js */ "./node_modules/date-fns/endOfDay.js");
Object.keys(_index50).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index50[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index50[key];
    },
  });
});
var _index51 = __webpack_require__(/*! ./endOfDecade.js */ "./node_modules/date-fns/endOfDecade.js");
Object.keys(_index51).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index51[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index51[key];
    },
  });
});
var _index52 = __webpack_require__(/*! ./endOfHour.js */ "./node_modules/date-fns/endOfHour.js");
Object.keys(_index52).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index52[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index52[key];
    },
  });
});
var _index53 = __webpack_require__(/*! ./endOfISOWeek.js */ "./node_modules/date-fns/endOfISOWeek.js");
Object.keys(_index53).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index53[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index53[key];
    },
  });
});
var _index54 = __webpack_require__(/*! ./endOfISOWeekYear.js */ "./node_modules/date-fns/endOfISOWeekYear.js");
Object.keys(_index54).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index54[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index54[key];
    },
  });
});
var _index55 = __webpack_require__(/*! ./endOfMinute.js */ "./node_modules/date-fns/endOfMinute.js");
Object.keys(_index55).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index55[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index55[key];
    },
  });
});
var _index56 = __webpack_require__(/*! ./endOfMonth.js */ "./node_modules/date-fns/endOfMonth.js");
Object.keys(_index56).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index56[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index56[key];
    },
  });
});
var _index57 = __webpack_require__(/*! ./endOfQuarter.js */ "./node_modules/date-fns/endOfQuarter.js");
Object.keys(_index57).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index57[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index57[key];
    },
  });
});
var _index58 = __webpack_require__(/*! ./endOfSecond.js */ "./node_modules/date-fns/endOfSecond.js");
Object.keys(_index58).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index58[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index58[key];
    },
  });
});
var _index59 = __webpack_require__(/*! ./endOfToday.js */ "./node_modules/date-fns/endOfToday.js");
Object.keys(_index59).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index59[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index59[key];
    },
  });
});
var _index60 = __webpack_require__(/*! ./endOfTomorrow.js */ "./node_modules/date-fns/endOfTomorrow.js");
Object.keys(_index60).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index60[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index60[key];
    },
  });
});
var _index61 = __webpack_require__(/*! ./endOfWeek.js */ "./node_modules/date-fns/endOfWeek.js");
Object.keys(_index61).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index61[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index61[key];
    },
  });
});
var _index62 = __webpack_require__(/*! ./endOfYear.js */ "./node_modules/date-fns/endOfYear.js");
Object.keys(_index62).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index62[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index62[key];
    },
  });
});
var _index63 = __webpack_require__(/*! ./endOfYesterday.js */ "./node_modules/date-fns/endOfYesterday.js");
Object.keys(_index63).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index63[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index63[key];
    },
  });
});
var _index64 = __webpack_require__(/*! ./format.js */ "./node_modules/date-fns/format.js");
Object.keys(_index64).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index64[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index64[key];
    },
  });
});
var _index65 = __webpack_require__(/*! ./formatDistance.js */ "./node_modules/date-fns/formatDistance.js");
Object.keys(_index65).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index65[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index65[key];
    },
  });
});
var _index66 = __webpack_require__(/*! ./formatDistanceStrict.js */ "./node_modules/date-fns/formatDistanceStrict.js");
Object.keys(_index66).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index66[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index66[key];
    },
  });
});
var _index67 = __webpack_require__(/*! ./formatDistanceToNow.js */ "./node_modules/date-fns/formatDistanceToNow.js");
Object.keys(_index67).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index67[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index67[key];
    },
  });
});
var _index68 = __webpack_require__(/*! ./formatDistanceToNowStrict.js */ "./node_modules/date-fns/formatDistanceToNowStrict.js");
Object.keys(_index68).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index68[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index68[key];
    },
  });
});
var _index69 = __webpack_require__(/*! ./formatDuration.js */ "./node_modules/date-fns/formatDuration.js");
Object.keys(_index69).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index69[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index69[key];
    },
  });
});
var _index70 = __webpack_require__(/*! ./formatISO.js */ "./node_modules/date-fns/formatISO.js");
Object.keys(_index70).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index70[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index70[key];
    },
  });
});
var _index71 = __webpack_require__(/*! ./formatISO9075.js */ "./node_modules/date-fns/formatISO9075.js");
Object.keys(_index71).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index71[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index71[key];
    },
  });
});
var _index72 = __webpack_require__(/*! ./formatISODuration.js */ "./node_modules/date-fns/formatISODuration.js");
Object.keys(_index72).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index72[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index72[key];
    },
  });
});
var _index73 = __webpack_require__(/*! ./formatRFC3339.js */ "./node_modules/date-fns/formatRFC3339.js");
Object.keys(_index73).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index73[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index73[key];
    },
  });
});
var _index74 = __webpack_require__(/*! ./formatRFC7231.js */ "./node_modules/date-fns/formatRFC7231.js");
Object.keys(_index74).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index74[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index74[key];
    },
  });
});
var _index75 = __webpack_require__(/*! ./formatRelative.js */ "./node_modules/date-fns/formatRelative.js");
Object.keys(_index75).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index75[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index75[key];
    },
  });
});
var _index76 = __webpack_require__(/*! ./fromUnixTime.js */ "./node_modules/date-fns/fromUnixTime.js");
Object.keys(_index76).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index76[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index76[key];
    },
  });
});
var _index77 = __webpack_require__(/*! ./getDate.js */ "./node_modules/date-fns/getDate.js");
Object.keys(_index77).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index77[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index77[key];
    },
  });
});
var _index78 = __webpack_require__(/*! ./getDay.js */ "./node_modules/date-fns/getDay.js");
Object.keys(_index78).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index78[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index78[key];
    },
  });
});
var _index79 = __webpack_require__(/*! ./getDayOfYear.js */ "./node_modules/date-fns/getDayOfYear.js");
Object.keys(_index79).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index79[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index79[key];
    },
  });
});
var _index80 = __webpack_require__(/*! ./getDaysInMonth.js */ "./node_modules/date-fns/getDaysInMonth.js");
Object.keys(_index80).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index80[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index80[key];
    },
  });
});
var _index81 = __webpack_require__(/*! ./getDaysInYear.js */ "./node_modules/date-fns/getDaysInYear.js");
Object.keys(_index81).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index81[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index81[key];
    },
  });
});
var _index82 = __webpack_require__(/*! ./getDecade.js */ "./node_modules/date-fns/getDecade.js");
Object.keys(_index82).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index82[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index82[key];
    },
  });
});
var _index83 = __webpack_require__(/*! ./getDefaultOptions.js */ "./node_modules/date-fns/getDefaultOptions.js");
Object.keys(_index83).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index83[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index83[key];
    },
  });
});
var _index84 = __webpack_require__(/*! ./getHours.js */ "./node_modules/date-fns/getHours.js");
Object.keys(_index84).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index84[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index84[key];
    },
  });
});
var _index85 = __webpack_require__(/*! ./getISODay.js */ "./node_modules/date-fns/getISODay.js");
Object.keys(_index85).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index85[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index85[key];
    },
  });
});
var _index86 = __webpack_require__(/*! ./getISOWeek.js */ "./node_modules/date-fns/getISOWeek.js");
Object.keys(_index86).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index86[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index86[key];
    },
  });
});
var _index87 = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
Object.keys(_index87).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index87[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index87[key];
    },
  });
});
var _index88 = __webpack_require__(/*! ./getISOWeeksInYear.js */ "./node_modules/date-fns/getISOWeeksInYear.js");
Object.keys(_index88).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index88[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index88[key];
    },
  });
});
var _index89 = __webpack_require__(/*! ./getMilliseconds.js */ "./node_modules/date-fns/getMilliseconds.js");
Object.keys(_index89).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index89[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index89[key];
    },
  });
});
var _index90 = __webpack_require__(/*! ./getMinutes.js */ "./node_modules/date-fns/getMinutes.js");
Object.keys(_index90).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index90[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index90[key];
    },
  });
});
var _index91 = __webpack_require__(/*! ./getMonth.js */ "./node_modules/date-fns/getMonth.js");
Object.keys(_index91).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index91[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index91[key];
    },
  });
});
var _index92 = __webpack_require__(/*! ./getOverlappingDaysInIntervals.js */ "./node_modules/date-fns/getOverlappingDaysInIntervals.js");
Object.keys(_index92).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index92[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index92[key];
    },
  });
});
var _index93 = __webpack_require__(/*! ./getQuarter.js */ "./node_modules/date-fns/getQuarter.js");
Object.keys(_index93).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index93[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index93[key];
    },
  });
});
var _index94 = __webpack_require__(/*! ./getSeconds.js */ "./node_modules/date-fns/getSeconds.js");
Object.keys(_index94).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index94[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index94[key];
    },
  });
});
var _index95 = __webpack_require__(/*! ./getTime.js */ "./node_modules/date-fns/getTime.js");
Object.keys(_index95).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index95[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index95[key];
    },
  });
});
var _index96 = __webpack_require__(/*! ./getUnixTime.js */ "./node_modules/date-fns/getUnixTime.js");
Object.keys(_index96).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index96[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index96[key];
    },
  });
});
var _index97 = __webpack_require__(/*! ./getWeek.js */ "./node_modules/date-fns/getWeek.js");
Object.keys(_index97).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index97[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index97[key];
    },
  });
});
var _index98 = __webpack_require__(/*! ./getWeekOfMonth.js */ "./node_modules/date-fns/getWeekOfMonth.js");
Object.keys(_index98).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index98[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index98[key];
    },
  });
});
var _index99 = __webpack_require__(/*! ./getWeekYear.js */ "./node_modules/date-fns/getWeekYear.js");
Object.keys(_index99).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index99[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index99[key];
    },
  });
});
var _index100 = __webpack_require__(/*! ./getWeeksInMonth.js */ "./node_modules/date-fns/getWeeksInMonth.js");
Object.keys(_index100).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index100[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index100[key];
    },
  });
});
var _index101 = __webpack_require__(/*! ./getYear.js */ "./node_modules/date-fns/getYear.js");
Object.keys(_index101).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index101[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index101[key];
    },
  });
});
var _index102 = __webpack_require__(/*! ./hoursToMilliseconds.js */ "./node_modules/date-fns/hoursToMilliseconds.js");
Object.keys(_index102).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index102[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index102[key];
    },
  });
});
var _index103 = __webpack_require__(/*! ./hoursToMinutes.js */ "./node_modules/date-fns/hoursToMinutes.js");
Object.keys(_index103).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index103[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index103[key];
    },
  });
});
var _index104 = __webpack_require__(/*! ./hoursToSeconds.js */ "./node_modules/date-fns/hoursToSeconds.js");
Object.keys(_index104).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index104[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index104[key];
    },
  });
});
var _index105 = __webpack_require__(/*! ./interval.js */ "./node_modules/date-fns/interval.js");
Object.keys(_index105).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index105[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index105[key];
    },
  });
});
var _index106 = __webpack_require__(/*! ./intervalToDuration.js */ "./node_modules/date-fns/intervalToDuration.js");
Object.keys(_index106).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index106[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index106[key];
    },
  });
});
var _index107 = __webpack_require__(/*! ./intlFormat.js */ "./node_modules/date-fns/intlFormat.js");
Object.keys(_index107).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index107[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index107[key];
    },
  });
});
var _index108 = __webpack_require__(/*! ./intlFormatDistance.js */ "./node_modules/date-fns/intlFormatDistance.js");
Object.keys(_index108).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index108[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index108[key];
    },
  });
});
var _index109 = __webpack_require__(/*! ./isAfter.js */ "./node_modules/date-fns/isAfter.js");
Object.keys(_index109).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index109[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index109[key];
    },
  });
});
var _index110 = __webpack_require__(/*! ./isBefore.js */ "./node_modules/date-fns/isBefore.js");
Object.keys(_index110).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index110[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index110[key];
    },
  });
});
var _index111 = __webpack_require__(/*! ./isDate.js */ "./node_modules/date-fns/isDate.js");
Object.keys(_index111).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index111[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index111[key];
    },
  });
});
var _index112 = __webpack_require__(/*! ./isEqual.js */ "./node_modules/date-fns/isEqual.js");
Object.keys(_index112).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index112[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index112[key];
    },
  });
});
var _index113 = __webpack_require__(/*! ./isExists.js */ "./node_modules/date-fns/isExists.js");
Object.keys(_index113).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index113[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index113[key];
    },
  });
});
var _index114 = __webpack_require__(/*! ./isFirstDayOfMonth.js */ "./node_modules/date-fns/isFirstDayOfMonth.js");
Object.keys(_index114).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index114[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index114[key];
    },
  });
});
var _index115 = __webpack_require__(/*! ./isFriday.js */ "./node_modules/date-fns/isFriday.js");
Object.keys(_index115).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index115[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index115[key];
    },
  });
});
var _index116 = __webpack_require__(/*! ./isFuture.js */ "./node_modules/date-fns/isFuture.js");
Object.keys(_index116).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index116[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index116[key];
    },
  });
});
var _index117 = __webpack_require__(/*! ./isLastDayOfMonth.js */ "./node_modules/date-fns/isLastDayOfMonth.js");
Object.keys(_index117).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index117[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index117[key];
    },
  });
});
var _index118 = __webpack_require__(/*! ./isLeapYear.js */ "./node_modules/date-fns/isLeapYear.js");
Object.keys(_index118).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index118[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index118[key];
    },
  });
});
var _index119 = __webpack_require__(/*! ./isMatch.js */ "./node_modules/date-fns/isMatch.js");
Object.keys(_index119).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index119[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index119[key];
    },
  });
});
var _index120 = __webpack_require__(/*! ./isMonday.js */ "./node_modules/date-fns/isMonday.js");
Object.keys(_index120).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index120[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index120[key];
    },
  });
});
var _index121 = __webpack_require__(/*! ./isPast.js */ "./node_modules/date-fns/isPast.js");
Object.keys(_index121).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index121[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index121[key];
    },
  });
});
var _index122 = __webpack_require__(/*! ./isSameDay.js */ "./node_modules/date-fns/isSameDay.js");
Object.keys(_index122).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index122[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index122[key];
    },
  });
});
var _index123 = __webpack_require__(/*! ./isSameHour.js */ "./node_modules/date-fns/isSameHour.js");
Object.keys(_index123).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index123[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index123[key];
    },
  });
});
var _index124 = __webpack_require__(/*! ./isSameISOWeek.js */ "./node_modules/date-fns/isSameISOWeek.js");
Object.keys(_index124).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index124[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index124[key];
    },
  });
});
var _index125 = __webpack_require__(/*! ./isSameISOWeekYear.js */ "./node_modules/date-fns/isSameISOWeekYear.js");
Object.keys(_index125).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index125[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index125[key];
    },
  });
});
var _index126 = __webpack_require__(/*! ./isSameMinute.js */ "./node_modules/date-fns/isSameMinute.js");
Object.keys(_index126).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index126[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index126[key];
    },
  });
});
var _index127 = __webpack_require__(/*! ./isSameMonth.js */ "./node_modules/date-fns/isSameMonth.js");
Object.keys(_index127).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index127[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index127[key];
    },
  });
});
var _index128 = __webpack_require__(/*! ./isSameQuarter.js */ "./node_modules/date-fns/isSameQuarter.js");
Object.keys(_index128).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index128[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index128[key];
    },
  });
});
var _index129 = __webpack_require__(/*! ./isSameSecond.js */ "./node_modules/date-fns/isSameSecond.js");
Object.keys(_index129).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index129[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index129[key];
    },
  });
});
var _index130 = __webpack_require__(/*! ./isSameWeek.js */ "./node_modules/date-fns/isSameWeek.js");
Object.keys(_index130).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index130[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index130[key];
    },
  });
});
var _index131 = __webpack_require__(/*! ./isSameYear.js */ "./node_modules/date-fns/isSameYear.js");
Object.keys(_index131).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index131[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index131[key];
    },
  });
});
var _index132 = __webpack_require__(/*! ./isSaturday.js */ "./node_modules/date-fns/isSaturday.js");
Object.keys(_index132).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index132[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index132[key];
    },
  });
});
var _index133 = __webpack_require__(/*! ./isSunday.js */ "./node_modules/date-fns/isSunday.js");
Object.keys(_index133).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index133[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index133[key];
    },
  });
});
var _index134 = __webpack_require__(/*! ./isThisHour.js */ "./node_modules/date-fns/isThisHour.js");
Object.keys(_index134).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index134[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index134[key];
    },
  });
});
var _index135 = __webpack_require__(/*! ./isThisISOWeek.js */ "./node_modules/date-fns/isThisISOWeek.js");
Object.keys(_index135).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index135[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index135[key];
    },
  });
});
var _index136 = __webpack_require__(/*! ./isThisMinute.js */ "./node_modules/date-fns/isThisMinute.js");
Object.keys(_index136).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index136[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index136[key];
    },
  });
});
var _index137 = __webpack_require__(/*! ./isThisMonth.js */ "./node_modules/date-fns/isThisMonth.js");
Object.keys(_index137).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index137[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index137[key];
    },
  });
});
var _index138 = __webpack_require__(/*! ./isThisQuarter.js */ "./node_modules/date-fns/isThisQuarter.js");
Object.keys(_index138).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index138[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index138[key];
    },
  });
});
var _index139 = __webpack_require__(/*! ./isThisSecond.js */ "./node_modules/date-fns/isThisSecond.js");
Object.keys(_index139).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index139[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index139[key];
    },
  });
});
var _index140 = __webpack_require__(/*! ./isThisWeek.js */ "./node_modules/date-fns/isThisWeek.js");
Object.keys(_index140).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index140[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index140[key];
    },
  });
});
var _index141 = __webpack_require__(/*! ./isThisYear.js */ "./node_modules/date-fns/isThisYear.js");
Object.keys(_index141).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index141[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index141[key];
    },
  });
});
var _index142 = __webpack_require__(/*! ./isThursday.js */ "./node_modules/date-fns/isThursday.js");
Object.keys(_index142).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index142[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index142[key];
    },
  });
});
var _index143 = __webpack_require__(/*! ./isToday.js */ "./node_modules/date-fns/isToday.js");
Object.keys(_index143).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index143[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index143[key];
    },
  });
});
var _index144 = __webpack_require__(/*! ./isTomorrow.js */ "./node_modules/date-fns/isTomorrow.js");
Object.keys(_index144).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index144[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index144[key];
    },
  });
});
var _index145 = __webpack_require__(/*! ./isTuesday.js */ "./node_modules/date-fns/isTuesday.js");
Object.keys(_index145).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index145[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index145[key];
    },
  });
});
var _index146 = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
Object.keys(_index146).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index146[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index146[key];
    },
  });
});
var _index147 = __webpack_require__(/*! ./isWednesday.js */ "./node_modules/date-fns/isWednesday.js");
Object.keys(_index147).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index147[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index147[key];
    },
  });
});
var _index148 = __webpack_require__(/*! ./isWeekend.js */ "./node_modules/date-fns/isWeekend.js");
Object.keys(_index148).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index148[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index148[key];
    },
  });
});
var _index149 = __webpack_require__(/*! ./isWithinInterval.js */ "./node_modules/date-fns/isWithinInterval.js");
Object.keys(_index149).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index149[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index149[key];
    },
  });
});
var _index150 = __webpack_require__(/*! ./isYesterday.js */ "./node_modules/date-fns/isYesterday.js");
Object.keys(_index150).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index150[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index150[key];
    },
  });
});
var _index151 = __webpack_require__(/*! ./lastDayOfDecade.js */ "./node_modules/date-fns/lastDayOfDecade.js");
Object.keys(_index151).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index151[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index151[key];
    },
  });
});
var _index152 = __webpack_require__(/*! ./lastDayOfISOWeek.js */ "./node_modules/date-fns/lastDayOfISOWeek.js");
Object.keys(_index152).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index152[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index152[key];
    },
  });
});
var _index153 = __webpack_require__(/*! ./lastDayOfISOWeekYear.js */ "./node_modules/date-fns/lastDayOfISOWeekYear.js");
Object.keys(_index153).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index153[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index153[key];
    },
  });
});
var _index154 = __webpack_require__(/*! ./lastDayOfMonth.js */ "./node_modules/date-fns/lastDayOfMonth.js");
Object.keys(_index154).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index154[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index154[key];
    },
  });
});
var _index155 = __webpack_require__(/*! ./lastDayOfQuarter.js */ "./node_modules/date-fns/lastDayOfQuarter.js");
Object.keys(_index155).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index155[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index155[key];
    },
  });
});
var _index156 = __webpack_require__(/*! ./lastDayOfWeek.js */ "./node_modules/date-fns/lastDayOfWeek.js");
Object.keys(_index156).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index156[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index156[key];
    },
  });
});
var _index157 = __webpack_require__(/*! ./lastDayOfYear.js */ "./node_modules/date-fns/lastDayOfYear.js");
Object.keys(_index157).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index157[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index157[key];
    },
  });
});
var _index158 = __webpack_require__(/*! ./lightFormat.js */ "./node_modules/date-fns/lightFormat.js");
Object.keys(_index158).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index158[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index158[key];
    },
  });
});
var _index159 = __webpack_require__(/*! ./max.js */ "./node_modules/date-fns/max.js");
Object.keys(_index159).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index159[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index159[key];
    },
  });
});
var _index160 = __webpack_require__(/*! ./milliseconds.js */ "./node_modules/date-fns/milliseconds.js");
Object.keys(_index160).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index160[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index160[key];
    },
  });
});
var _index161 = __webpack_require__(/*! ./millisecondsToHours.js */ "./node_modules/date-fns/millisecondsToHours.js");
Object.keys(_index161).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index161[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index161[key];
    },
  });
});
var _index162 = __webpack_require__(/*! ./millisecondsToMinutes.js */ "./node_modules/date-fns/millisecondsToMinutes.js");
Object.keys(_index162).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index162[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index162[key];
    },
  });
});
var _index163 = __webpack_require__(/*! ./millisecondsToSeconds.js */ "./node_modules/date-fns/millisecondsToSeconds.js");
Object.keys(_index163).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index163[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index163[key];
    },
  });
});
var _index164 = __webpack_require__(/*! ./min.js */ "./node_modules/date-fns/min.js");
Object.keys(_index164).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index164[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index164[key];
    },
  });
});
var _index165 = __webpack_require__(/*! ./minutesToHours.js */ "./node_modules/date-fns/minutesToHours.js");
Object.keys(_index165).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index165[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index165[key];
    },
  });
});
var _index166 = __webpack_require__(/*! ./minutesToMilliseconds.js */ "./node_modules/date-fns/minutesToMilliseconds.js");
Object.keys(_index166).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index166[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index166[key];
    },
  });
});
var _index167 = __webpack_require__(/*! ./minutesToSeconds.js */ "./node_modules/date-fns/minutesToSeconds.js");
Object.keys(_index167).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index167[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index167[key];
    },
  });
});
var _index168 = __webpack_require__(/*! ./monthsToQuarters.js */ "./node_modules/date-fns/monthsToQuarters.js");
Object.keys(_index168).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index168[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index168[key];
    },
  });
});
var _index169 = __webpack_require__(/*! ./monthsToYears.js */ "./node_modules/date-fns/monthsToYears.js");
Object.keys(_index169).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index169[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index169[key];
    },
  });
});
var _index170 = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");
Object.keys(_index170).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index170[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index170[key];
    },
  });
});
var _index171 = __webpack_require__(/*! ./nextFriday.js */ "./node_modules/date-fns/nextFriday.js");
Object.keys(_index171).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index171[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index171[key];
    },
  });
});
var _index172 = __webpack_require__(/*! ./nextMonday.js */ "./node_modules/date-fns/nextMonday.js");
Object.keys(_index172).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index172[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index172[key];
    },
  });
});
var _index173 = __webpack_require__(/*! ./nextSaturday.js */ "./node_modules/date-fns/nextSaturday.js");
Object.keys(_index173).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index173[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index173[key];
    },
  });
});
var _index174 = __webpack_require__(/*! ./nextSunday.js */ "./node_modules/date-fns/nextSunday.js");
Object.keys(_index174).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index174[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index174[key];
    },
  });
});
var _index175 = __webpack_require__(/*! ./nextThursday.js */ "./node_modules/date-fns/nextThursday.js");
Object.keys(_index175).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index175[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index175[key];
    },
  });
});
var _index176 = __webpack_require__(/*! ./nextTuesday.js */ "./node_modules/date-fns/nextTuesday.js");
Object.keys(_index176).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index176[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index176[key];
    },
  });
});
var _index177 = __webpack_require__(/*! ./nextWednesday.js */ "./node_modules/date-fns/nextWednesday.js");
Object.keys(_index177).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index177[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index177[key];
    },
  });
});
var _index178 = __webpack_require__(/*! ./parse.js */ "./node_modules/date-fns/parse.js");
Object.keys(_index178).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index178[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index178[key];
    },
  });
});
var _index179 = __webpack_require__(/*! ./parseISO.js */ "./node_modules/date-fns/parseISO.js");
Object.keys(_index179).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index179[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index179[key];
    },
  });
});
var _index180 = __webpack_require__(/*! ./parseJSON.js */ "./node_modules/date-fns/parseJSON.js");
Object.keys(_index180).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index180[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index180[key];
    },
  });
});
var _index181 = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");
Object.keys(_index181).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index181[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index181[key];
    },
  });
});
var _index182 = __webpack_require__(/*! ./previousFriday.js */ "./node_modules/date-fns/previousFriday.js");
Object.keys(_index182).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index182[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index182[key];
    },
  });
});
var _index183 = __webpack_require__(/*! ./previousMonday.js */ "./node_modules/date-fns/previousMonday.js");
Object.keys(_index183).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index183[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index183[key];
    },
  });
});
var _index184 = __webpack_require__(/*! ./previousSaturday.js */ "./node_modules/date-fns/previousSaturday.js");
Object.keys(_index184).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index184[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index184[key];
    },
  });
});
var _index185 = __webpack_require__(/*! ./previousSunday.js */ "./node_modules/date-fns/previousSunday.js");
Object.keys(_index185).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index185[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index185[key];
    },
  });
});
var _index186 = __webpack_require__(/*! ./previousThursday.js */ "./node_modules/date-fns/previousThursday.js");
Object.keys(_index186).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index186[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index186[key];
    },
  });
});
var _index187 = __webpack_require__(/*! ./previousTuesday.js */ "./node_modules/date-fns/previousTuesday.js");
Object.keys(_index187).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index187[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index187[key];
    },
  });
});
var _index188 = __webpack_require__(/*! ./previousWednesday.js */ "./node_modules/date-fns/previousWednesday.js");
Object.keys(_index188).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index188[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index188[key];
    },
  });
});
var _index189 = __webpack_require__(/*! ./quartersToMonths.js */ "./node_modules/date-fns/quartersToMonths.js");
Object.keys(_index189).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index189[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index189[key];
    },
  });
});
var _index190 = __webpack_require__(/*! ./quartersToYears.js */ "./node_modules/date-fns/quartersToYears.js");
Object.keys(_index190).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index190[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index190[key];
    },
  });
});
var _index191 = __webpack_require__(/*! ./roundToNearestHours.js */ "./node_modules/date-fns/roundToNearestHours.js");
Object.keys(_index191).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index191[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index191[key];
    },
  });
});
var _index192 = __webpack_require__(/*! ./roundToNearestMinutes.js */ "./node_modules/date-fns/roundToNearestMinutes.js");
Object.keys(_index192).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index192[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index192[key];
    },
  });
});
var _index193 = __webpack_require__(/*! ./secondsToHours.js */ "./node_modules/date-fns/secondsToHours.js");
Object.keys(_index193).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index193[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index193[key];
    },
  });
});
var _index194 = __webpack_require__(/*! ./secondsToMilliseconds.js */ "./node_modules/date-fns/secondsToMilliseconds.js");
Object.keys(_index194).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index194[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index194[key];
    },
  });
});
var _index195 = __webpack_require__(/*! ./secondsToMinutes.js */ "./node_modules/date-fns/secondsToMinutes.js");
Object.keys(_index195).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index195[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index195[key];
    },
  });
});
var _index196 = __webpack_require__(/*! ./set.js */ "./node_modules/date-fns/set.js");
Object.keys(_index196).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index196[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index196[key];
    },
  });
});
var _index197 = __webpack_require__(/*! ./setDate.js */ "./node_modules/date-fns/setDate.js");
Object.keys(_index197).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index197[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index197[key];
    },
  });
});
var _index198 = __webpack_require__(/*! ./setDay.js */ "./node_modules/date-fns/setDay.js");
Object.keys(_index198).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index198[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index198[key];
    },
  });
});
var _index199 = __webpack_require__(/*! ./setDayOfYear.js */ "./node_modules/date-fns/setDayOfYear.js");
Object.keys(_index199).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index199[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index199[key];
    },
  });
});
var _index200 = __webpack_require__(/*! ./setDefaultOptions.js */ "./node_modules/date-fns/setDefaultOptions.js");
Object.keys(_index200).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index200[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index200[key];
    },
  });
});
var _index201 = __webpack_require__(/*! ./setHours.js */ "./node_modules/date-fns/setHours.js");
Object.keys(_index201).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index201[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index201[key];
    },
  });
});
var _index202 = __webpack_require__(/*! ./setISODay.js */ "./node_modules/date-fns/setISODay.js");
Object.keys(_index202).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index202[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index202[key];
    },
  });
});
var _index203 = __webpack_require__(/*! ./setISOWeek.js */ "./node_modules/date-fns/setISOWeek.js");
Object.keys(_index203).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index203[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index203[key];
    },
  });
});
var _index204 = __webpack_require__(/*! ./setISOWeekYear.js */ "./node_modules/date-fns/setISOWeekYear.js");
Object.keys(_index204).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index204[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index204[key];
    },
  });
});
var _index205 = __webpack_require__(/*! ./setMilliseconds.js */ "./node_modules/date-fns/setMilliseconds.js");
Object.keys(_index205).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index205[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index205[key];
    },
  });
});
var _index206 = __webpack_require__(/*! ./setMinutes.js */ "./node_modules/date-fns/setMinutes.js");
Object.keys(_index206).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index206[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index206[key];
    },
  });
});
var _index207 = __webpack_require__(/*! ./setMonth.js */ "./node_modules/date-fns/setMonth.js");
Object.keys(_index207).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index207[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index207[key];
    },
  });
});
var _index208 = __webpack_require__(/*! ./setQuarter.js */ "./node_modules/date-fns/setQuarter.js");
Object.keys(_index208).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index208[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index208[key];
    },
  });
});
var _index209 = __webpack_require__(/*! ./setSeconds.js */ "./node_modules/date-fns/setSeconds.js");
Object.keys(_index209).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index209[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index209[key];
    },
  });
});
var _index210 = __webpack_require__(/*! ./setWeek.js */ "./node_modules/date-fns/setWeek.js");
Object.keys(_index210).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index210[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index210[key];
    },
  });
});
var _index211 = __webpack_require__(/*! ./setWeekYear.js */ "./node_modules/date-fns/setWeekYear.js");
Object.keys(_index211).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index211[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index211[key];
    },
  });
});
var _index212 = __webpack_require__(/*! ./setYear.js */ "./node_modules/date-fns/setYear.js");
Object.keys(_index212).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index212[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index212[key];
    },
  });
});
var _index213 = __webpack_require__(/*! ./startOfDay.js */ "./node_modules/date-fns/startOfDay.js");
Object.keys(_index213).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index213[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index213[key];
    },
  });
});
var _index214 = __webpack_require__(/*! ./startOfDecade.js */ "./node_modules/date-fns/startOfDecade.js");
Object.keys(_index214).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index214[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index214[key];
    },
  });
});
var _index215 = __webpack_require__(/*! ./startOfHour.js */ "./node_modules/date-fns/startOfHour.js");
Object.keys(_index215).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index215[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index215[key];
    },
  });
});
var _index216 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
Object.keys(_index216).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index216[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index216[key];
    },
  });
});
var _index217 = __webpack_require__(/*! ./startOfISOWeekYear.js */ "./node_modules/date-fns/startOfISOWeekYear.js");
Object.keys(_index217).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index217[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index217[key];
    },
  });
});
var _index218 = __webpack_require__(/*! ./startOfMinute.js */ "./node_modules/date-fns/startOfMinute.js");
Object.keys(_index218).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index218[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index218[key];
    },
  });
});
var _index219 = __webpack_require__(/*! ./startOfMonth.js */ "./node_modules/date-fns/startOfMonth.js");
Object.keys(_index219).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index219[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index219[key];
    },
  });
});
var _index220 = __webpack_require__(/*! ./startOfQuarter.js */ "./node_modules/date-fns/startOfQuarter.js");
Object.keys(_index220).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index220[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index220[key];
    },
  });
});
var _index221 = __webpack_require__(/*! ./startOfSecond.js */ "./node_modules/date-fns/startOfSecond.js");
Object.keys(_index221).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index221[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index221[key];
    },
  });
});
var _index222 = __webpack_require__(/*! ./startOfToday.js */ "./node_modules/date-fns/startOfToday.js");
Object.keys(_index222).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index222[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index222[key];
    },
  });
});
var _index223 = __webpack_require__(/*! ./startOfTomorrow.js */ "./node_modules/date-fns/startOfTomorrow.js");
Object.keys(_index223).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index223[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index223[key];
    },
  });
});
var _index224 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
Object.keys(_index224).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index224[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index224[key];
    },
  });
});
var _index225 = __webpack_require__(/*! ./startOfWeekYear.js */ "./node_modules/date-fns/startOfWeekYear.js");
Object.keys(_index225).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index225[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index225[key];
    },
  });
});
var _index226 = __webpack_require__(/*! ./startOfYear.js */ "./node_modules/date-fns/startOfYear.js");
Object.keys(_index226).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index226[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index226[key];
    },
  });
});
var _index227 = __webpack_require__(/*! ./startOfYesterday.js */ "./node_modules/date-fns/startOfYesterday.js");
Object.keys(_index227).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index227[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index227[key];
    },
  });
});
var _index228 = __webpack_require__(/*! ./sub.js */ "./node_modules/date-fns/sub.js");
Object.keys(_index228).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index228[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index228[key];
    },
  });
});
var _index229 = __webpack_require__(/*! ./subBusinessDays.js */ "./node_modules/date-fns/subBusinessDays.js");
Object.keys(_index229).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index229[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index229[key];
    },
  });
});
var _index230 = __webpack_require__(/*! ./subDays.js */ "./node_modules/date-fns/subDays.js");
Object.keys(_index230).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index230[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index230[key];
    },
  });
});
var _index231 = __webpack_require__(/*! ./subHours.js */ "./node_modules/date-fns/subHours.js");
Object.keys(_index231).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index231[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index231[key];
    },
  });
});
var _index232 = __webpack_require__(/*! ./subISOWeekYears.js */ "./node_modules/date-fns/subISOWeekYears.js");
Object.keys(_index232).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index232[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index232[key];
    },
  });
});
var _index233 = __webpack_require__(/*! ./subMilliseconds.js */ "./node_modules/date-fns/subMilliseconds.js");
Object.keys(_index233).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index233[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index233[key];
    },
  });
});
var _index234 = __webpack_require__(/*! ./subMinutes.js */ "./node_modules/date-fns/subMinutes.js");
Object.keys(_index234).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index234[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index234[key];
    },
  });
});
var _index235 = __webpack_require__(/*! ./subMonths.js */ "./node_modules/date-fns/subMonths.js");
Object.keys(_index235).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index235[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index235[key];
    },
  });
});
var _index236 = __webpack_require__(/*! ./subQuarters.js */ "./node_modules/date-fns/subQuarters.js");
Object.keys(_index236).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index236[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index236[key];
    },
  });
});
var _index237 = __webpack_require__(/*! ./subSeconds.js */ "./node_modules/date-fns/subSeconds.js");
Object.keys(_index237).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index237[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index237[key];
    },
  });
});
var _index238 = __webpack_require__(/*! ./subWeeks.js */ "./node_modules/date-fns/subWeeks.js");
Object.keys(_index238).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index238[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index238[key];
    },
  });
});
var _index239 = __webpack_require__(/*! ./subYears.js */ "./node_modules/date-fns/subYears.js");
Object.keys(_index239).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index239[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index239[key];
    },
  });
});
var _index240 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
Object.keys(_index240).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index240[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index240[key];
    },
  });
});
var _index241 = __webpack_require__(/*! ./transpose.js */ "./node_modules/date-fns/transpose.js");
Object.keys(_index241).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index241[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index241[key];
    },
  });
});
var _index242 = __webpack_require__(/*! ./weeksToDays.js */ "./node_modules/date-fns/weeksToDays.js");
Object.keys(_index242).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index242[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index242[key];
    },
  });
});
var _index243 = __webpack_require__(/*! ./yearsToDays.js */ "./node_modules/date-fns/yearsToDays.js");
Object.keys(_index243).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index243[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index243[key];
    },
  });
});
var _index244 = __webpack_require__(/*! ./yearsToMonths.js */ "./node_modules/date-fns/yearsToMonths.js");
Object.keys(_index244).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index244[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index244[key];
    },
  });
});
var _index245 = __webpack_require__(/*! ./yearsToQuarters.js */ "./node_modules/date-fns/yearsToQuarters.js");
Object.keys(_index245).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index245[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index245[key];
    },
  });
});


/***/ }),

/***/ "./node_modules/date-fns/interval.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/interval.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.interval = interval;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link interval} function options.
 */

/**
 * @name interval
 * @category Interval Helpers
 * @summary Creates an interval object and validates its values.
 *
 * @description
 * Creates a normalized interval object and validates its values. If the interval is invalid, an exception is thrown.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param start - The start of the interval.
 * @param end - The end of the interval.
 * @param options - The options object.
 *
 * @throws `Start date is invalid` when `start` is invalid.
 * @throws `End date is invalid` when `end` is invalid.
 * @throws `End date must be after start date` when end is before `start` and `options.assertPositive` is true.
 *
 * @returns The normalized and validated interval object.
 */
function interval(start, end, options) {
  const _start = (0, _index.toDate)(start);
  if (isNaN(+_start)) throw new TypeError("Start date is invalid");

  const _end = (0, _index.toDate)(end);
  if (isNaN(+_end)) throw new TypeError("End date is invalid");

  if (options?.assertPositive && +_start > +_end)
    throw new TypeError("End date must be after start date");

  return { start: _start, end: _end };
}


/***/ }),

/***/ "./node_modules/date-fns/intervalToDuration.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/intervalToDuration.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.intervalToDuration = intervalToDuration;
var _index = __webpack_require__(/*! ./add.js */ "./node_modules/date-fns/add.js");
var _index2 = __webpack_require__(/*! ./differenceInDays.js */ "./node_modules/date-fns/differenceInDays.js");
var _index3 = __webpack_require__(/*! ./differenceInHours.js */ "./node_modules/date-fns/differenceInHours.js");
var _index4 = __webpack_require__(/*! ./differenceInMinutes.js */ "./node_modules/date-fns/differenceInMinutes.js");
var _index5 = __webpack_require__(/*! ./differenceInMonths.js */ "./node_modules/date-fns/differenceInMonths.js");
var _index6 = __webpack_require__(/*! ./differenceInSeconds.js */ "./node_modules/date-fns/differenceInSeconds.js");
var _index7 = __webpack_require__(/*! ./differenceInYears.js */ "./node_modules/date-fns/differenceInYears.js");
var _index8 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name intervalToDuration
 * @category Common Helpers
 * @summary Convert interval to duration
 *
 * @description
 * Convert a interval object to a duration object.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval to convert to duration
 *
 * @returns The duration object
 *
 * @example
 * // Get the duration between January 15, 1929 and April 4, 1968.
 * intervalToDuration({
 *   start: new Date(1929, 0, 15, 12, 0, 0),
 *   end: new Date(1968, 3, 4, 19, 5, 0)
 * })
 * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }
 */
function intervalToDuration(interval) {
  const start = (0, _index8.toDate)(interval.start);
  const end = (0, _index8.toDate)(interval.end);

  const duration = {};

  const years = (0, _index7.differenceInYears)(end, start);
  if (years) duration.years = years;

  const remainingMonths = (0, _index.add)(start, { years: duration.years });

  const months = (0, _index5.differenceInMonths)(end, remainingMonths);
  if (months) duration.months = months;

  const remainingDays = (0, _index.add)(remainingMonths, {
    months: duration.months,
  });

  const days = (0, _index2.differenceInDays)(end, remainingDays);
  if (days) duration.days = days;

  const remainingHours = (0, _index.add)(remainingDays, {
    days: duration.days,
  });

  const hours = (0, _index3.differenceInHours)(end, remainingHours);
  if (hours) duration.hours = hours;

  const remainingMinutes = (0, _index.add)(remainingHours, {
    hours: duration.hours,
  });

  const minutes = (0, _index4.differenceInMinutes)(end, remainingMinutes);
  if (minutes) duration.minutes = minutes;

  const remainingSeconds = (0, _index.add)(remainingMinutes, {
    minutes: duration.minutes,
  });

  const seconds = (0, _index6.differenceInSeconds)(end, remainingSeconds);
  if (seconds) duration.seconds = seconds;

  return duration;
}


/***/ }),

/***/ "./node_modules/date-fns/intlFormat.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/intlFormat.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.intlFormat = intlFormat;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The locale string (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).
 */

/**
 * The format options (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#options)
 */

/**
 * The locale options.
 */

/**
 * @name intlFormat
 * @category Common Helpers
 * @summary Format the date with Intl.DateTimeFormat (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
 *
 * @description
 * Return the formatted date string in the given format.
 * The method uses [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) inside.
 * formatOptions are the same as [`Intl.DateTimeFormat` options](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options)
 *
 * > ⚠️ Please note that before Node version 13.0.0, only the locale data for en-US is available by default.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in middle-endian format:
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456))
 * //=> 10/4/2019
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in Korean.
 * // Convert the date with locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   locale: 'ko-KR',
 * })
 * //=> 2019. 10. 4.
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019.
 * // Convert the date with format's options.
 * const result = intlFormat.default(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   year: 'numeric',
 *   month: 'numeric',
 *   day: 'numeric',
 *   hour: 'numeric',
 * })
 * //=> 10/4/2019, 12 PM
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in German.
 * // Convert the date with format's options and locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   weekday: 'long',
 *   year: 'numeric',
 *   month: 'long',
 *   day: 'numeric',
 * }, {
 *   locale: 'de-DE',
 * })
 * //=> Freitag, 4. Oktober 2019
 */

function intlFormat(date, formatOrLocale, localeOptions) {
  let formatOptions;

  if (isFormatOptions(formatOrLocale)) {
    formatOptions = formatOrLocale;
  } else {
    localeOptions = formatOrLocale;
  }

  return new Intl.DateTimeFormat(localeOptions?.locale, formatOptions).format(
    (0, _index.toDate)(date),
  );
}

function isFormatOptions(opts) {
  return opts !== undefined && !("locale" in opts);
}


/***/ }),

/***/ "./node_modules/date-fns/intlFormatDistance.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/intlFormatDistance.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.intlFormatDistance = intlFormatDistance;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

var _index2 = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index3 = __webpack_require__(/*! ./differenceInCalendarMonths.js */ "./node_modules/date-fns/differenceInCalendarMonths.js");
var _index4 = __webpack_require__(/*! ./differenceInCalendarQuarters.js */ "./node_modules/date-fns/differenceInCalendarQuarters.js");
var _index5 = __webpack_require__(/*! ./differenceInCalendarWeeks.js */ "./node_modules/date-fns/differenceInCalendarWeeks.js");
var _index6 = __webpack_require__(/*! ./differenceInCalendarYears.js */ "./node_modules/date-fns/differenceInCalendarYears.js");
var _index7 = __webpack_require__(/*! ./differenceInHours.js */ "./node_modules/date-fns/differenceInHours.js");
var _index8 = __webpack_require__(/*! ./differenceInMinutes.js */ "./node_modules/date-fns/differenceInMinutes.js");
var _index9 = __webpack_require__(/*! ./differenceInSeconds.js */ "./node_modules/date-fns/differenceInSeconds.js");
var _index10 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link intlFormatDistance} function options.
 */

/**
 * The unit used to format the distance in {@link intlFormatDistance}.
 */

/**
 * @name intlFormatDistance
 * @category Common Helpers
 * @summary Formats distance between two dates in a human-readable format
 * @description
 * The function calculates the difference between two dates and formats it as a human-readable string.
 *
 * The function will pick the most appropriate unit depending on the distance between dates. For example, if the distance is a few hours, it might return `x hours`. If the distance is a few months, it might return `x months`.
 *
 * You can also specify a unit to force using it regardless of the distance to get a result like `123456 hours`.
 *
 * See the table below for the unit picking logic:
 *
 * | Distance between dates | Result (past)  | Result (future) |
 * | ---------------------- | -------------- | --------------- |
 * | 0 seconds              | now            | now             |
 * | 1-59 seconds           | X seconds ago  | in X seconds    |
 * | 1-59 minutes           | X minutes ago  | in X minutes    |
 * | 1-23 hours             | X hours ago    | in X hours      |
 * | 1 day                  | yesterday      | tomorrow        |
 * | 2-6 days               | X days ago     | in X days       |
 * | 7 days                 | last week      | next week       |
 * | 8 days-1 month         | X weeks ago    | in X weeks      |
 * | 1 month                | last month     | next month      |
 * | 2-3 months             | X months ago   | in X months     |
 * | 1 quarter              | last quarter   | next quarter    |
 * | 2-3 quarters           | X quarters ago | in X quarters   |
 * | 1 year                 | last year      | next year       |
 * | 2+ years               | X years ago    | in X years      |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with.
 * @param options - An object with options.
 * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)
 * The narrow one could be similar to the short one for some locales.
 *
 * @returns The distance in words according to language-sensitive relative time formatting.
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must not be invalid Unit
 * @throws `options.locale` must not be invalid locale
 * @throws `options.localeMatcher` must not be invalid localeMatcher
 * @throws `options.numeric` must not be invalid numeric
 * @throws `options.style` must not be invalid style
 *
 * @example
 * // What is the distance between the dates when the fist date is after the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0)
 * )
 * //=> 'in 1 hour'
 *
 * // What is the distance between the dates when the fist date is before the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0)
 * )
 * //=> '1 hour ago'
 *
 * @example
 * // Use the unit option to force the function to output the result in quarters. Without setting it, the example would return "next year"
 * intlFormatDistance(
 *   new Date(1987, 6, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { unit: 'quarter' }
 * )
 * //=> 'in 5 quarters'
 *
 * @example
 * // Use the locale option to get the result in Spanish. Without setting it, the example would return "in 1 hour".
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { locale: 'es' }
 * )
 * //=> 'dentro de 1 hora'
 *
 * @example
 * // Use the numeric option to force the function to use numeric values. Without setting it, the example would return "tomorrow".
 * intlFormatDistance(
 *   new Date(1986, 3, 5, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { numeric: 'always' }
 * )
 * //=> 'in 1 day'
 *
 * @example
 * // Use the style option to force the function to use short values. Without setting it, the example would return "in 2 years".
 * intlFormatDistance(
 *   new Date(1988, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { style: 'short' }
 * )
 * //=> 'in 2 yr'
 */
function intlFormatDistance(date, baseDate, options) {
  let value = 0;
  let unit;
  const dateLeft = (0, _index10.toDate)(date);
  const dateRight = (0, _index10.toDate)(baseDate);

  if (!options?.unit) {
    // Get the unit based on diffInSeconds calculations if no unit is specified
    const diffInSeconds = (0, _index9.differenceInSeconds)(dateLeft, dateRight); // The smallest unit

    if (Math.abs(diffInSeconds) < _index.secondsInMinute) {
      value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
      unit = "second";
    } else if (Math.abs(diffInSeconds) < _index.secondsInHour) {
      value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
      unit = "minute";
    } else if (
      Math.abs(diffInSeconds) < _index.secondsInDay &&
      Math.abs((0, _index2.differenceInCalendarDays)(dateLeft, dateRight)) < 1
    ) {
      value = (0, _index7.differenceInHours)(dateLeft, dateRight);
      unit = "hour";
    } else if (
      Math.abs(diffInSeconds) < _index.secondsInWeek &&
      (value = (0, _index2.differenceInCalendarDays)(dateLeft, dateRight)) &&
      Math.abs(value) < 7
    ) {
      unit = "day";
    } else if (Math.abs(diffInSeconds) < _index.secondsInMonth) {
      value = (0, _index5.differenceInCalendarWeeks)(dateLeft, dateRight);
      unit = "week";
    } else if (Math.abs(diffInSeconds) < _index.secondsInQuarter) {
      value = (0, _index3.differenceInCalendarMonths)(dateLeft, dateRight);
      unit = "month";
    } else if (Math.abs(diffInSeconds) < _index.secondsInYear) {
      if ((0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight) < 4) {
        // To filter out cases that are less than a year but match 4 quarters
        value = (0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight);
        unit = "quarter";
      } else {
        value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
      unit = "year";
    }
  } else {
    // Get the value if unit is specified
    unit = options?.unit;
    if (unit === "second") {
      value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
    } else if (unit === "minute") {
      value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
    } else if (unit === "hour") {
      value = (0, _index7.differenceInHours)(dateLeft, dateRight);
    } else if (unit === "day") {
      value = (0, _index2.differenceInCalendarDays)(dateLeft, dateRight);
    } else if (unit === "week") {
      value = (0, _index5.differenceInCalendarWeeks)(dateLeft, dateRight);
    } else if (unit === "month") {
      value = (0, _index3.differenceInCalendarMonths)(dateLeft, dateRight);
    } else if (unit === "quarter") {
      value = (0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight);
    } else if (unit === "year") {
      value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
    }
  }

  const rtf = new Intl.RelativeTimeFormat(options?.locale, {
    localeMatcher: options?.localeMatcher,
    numeric: options?.numeric || "auto",
    style: options?.style,
  });

  return rtf.format(value, unit);
}


/***/ }),

/***/ "./node_modules/date-fns/isAfter.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isAfter.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isAfter = isAfter;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be after the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is after the second date
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */
function isAfter(date, dateToCompare) {
  const _date = (0, _index.toDate)(date);
  const _dateToCompare = (0, _index.toDate)(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}


/***/ }),

/***/ "./node_modules/date-fns/isBefore.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isBefore.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isBefore = isBefore;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be before the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is before the second date
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore(date, dateToCompare) {
  const _date = (0, _index.toDate)(date);
  const _dateToCompare = (0, _index.toDate)(dateToCompare);
  return +_date < +_dateToCompare;
}


/***/ }),

/***/ "./node_modules/date-fns/isDate.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/isDate.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isDate = isDate; /**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param value - The value to check
 *
 * @returns True if the given value is a date
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  return (
    value instanceof Date ||
    (typeof value === "object" &&
      Object.prototype.toString.call(value) === "[object Date]")
  );
}


/***/ }),

/***/ "./node_modules/date-fns/isEqual.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isEqual.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isEqual = isEqual;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The dates are equal
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */
function isEqual(leftDate, rightDate) {
  const _dateLeft = (0, _index.toDate)(leftDate);
  const _dateRight = (0, _index.toDate)(rightDate);
  return +_dateLeft === +_dateRight;
}


/***/ }),

/***/ "./node_modules/date-fns/isExists.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isExists.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isExists = isExists; /**
 * @name isExists
 * @category Common Helpers
 * @summary Is the given date exists?
 *
 * @description
 * Checks if the given arguments convert to an existing date.
 *
 * @param year - The year of the date to check
 * @param month - The month of the date to check
 * @param day - The day of the date to check
 *
 * @returns `true` if the date exists
 *
 * @example
 * // For the valid date:
 * const result = isExists(2018, 0, 31)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isExists(2018, 1, 31)
 * //=> false
 */
function isExists(year, month, day) {
  const date = new Date(year, month, day);
  return (
    date.getFullYear() === year &&
    date.getMonth() === month &&
    date.getDate() === day
  );
}


/***/ }),

/***/ "./node_modules/date-fns/isFirstDayOfMonth.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/isFirstDayOfMonth.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isFirstDayOfMonth = isFirstDayOfMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isFirstDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the first day of a month?
 *
 * @description
 * Is the given date the first day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the first day of a month
 *
 * @example
 * // Is 1 September 2014 the first day of a month?
 * const result = isFirstDayOfMonth(new Date(2014, 8, 1))
 * //=> true
 */
function isFirstDayOfMonth(date) {
  return (0, _index.toDate)(date).getDate() === 1;
}


/***/ }),

/***/ "./node_modules/date-fns/isFriday.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isFriday.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isFriday = isFriday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isFriday
 * @category Weekday Helpers
 * @summary Is the given date Friday?
 *
 * @description
 * Is the given date Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Friday
 *
 * @example
 * // Is 26 September 2014 Friday?
 * const result = isFriday(new Date(2014, 8, 26))
 * //=> true
 */
function isFriday(date) {
  return (0, _index.toDate)(date).getDay() === 5;
}


/***/ }),

/***/ "./node_modules/date-fns/isFuture.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isFuture.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isFuture = isFuture;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isFuture
 * @category Common Helpers
 * @summary Is the given date in the future?
 * @pure false
 *
 * @description
 * Is the given date in the future?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the future
 *
 * @example
 * // If today is 6 October 2014, is 31 December 2014 in the future?
 * const result = isFuture(new Date(2014, 11, 31))
 * //=> true
 */
function isFuture(date) {
  return +(0, _index.toDate)(date) > Date.now();
}


/***/ }),

/***/ "./node_modules/date-fns/isLastDayOfMonth.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/isLastDayOfMonth.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isLastDayOfMonth = isLastDayOfMonth;
var _index = __webpack_require__(/*! ./endOfDay.js */ "./node_modules/date-fns/endOfDay.js");
var _index2 = __webpack_require__(/*! ./endOfMonth.js */ "./node_modules/date-fns/endOfMonth.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the last day of a month
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */
function isLastDayOfMonth(date) {
  const _date = (0, _index3.toDate)(date);
  return +(0, _index.endOfDay)(_date) === +(0, _index2.endOfMonth)(_date);
}


/***/ }),

/***/ "./node_modules/date-fns/isLeapYear.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isLeapYear.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isLeapYear = isLeapYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isLeapYear
 * @category Year Helpers
 * @summary Is the given date in the leap year?
 *
 * @description
 * Is the given date in the leap year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the leap year
 *
 * @example
 * // Is 1 September 2012 in the leap year?
 * const result = isLeapYear(new Date(2012, 8, 1))
 * //=> true
 */
function isLeapYear(date) {
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}


/***/ }),

/***/ "./node_modules/date-fns/isMatch.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isMatch.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isMatch = isMatch;
var _index = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index2 = __webpack_require__(/*! ./parse.js */ "./node_modules/date-fns/parse.js");

/**
 * The {@link isMatch} function options.
 */

/**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The date string to verify
 * @param format - The string of tokens
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns Is format string a match for date string?
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */
function isMatch(dateStr, formatStr, options) {
  return (0, _index.isValid)(
    (0, _index2.parse)(dateStr, formatStr, new Date(), options),
  );
}


/***/ }),

/***/ "./node_modules/date-fns/isMonday.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isMonday.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isMonday = isMonday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isMonday
 * @category Weekday Helpers
 * @summary Is the given date Monday?
 *
 * @description
 * Is the given date Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Monday
 *
 * @example
 * // Is 22 September 2014 Monday?
 * const result = isMonday(new Date(2014, 8, 22))
 * //=> true
 */
function isMonday(date) {
  return (0, _index.toDate)(date).getDay() === 1;
}


/***/ }),

/***/ "./node_modules/date-fns/isPast.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/isPast.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isPast = isPast;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isPast
 * @category Common Helpers
 * @summary Is the given date in the past?
 * @pure false
 *
 * @description
 * Is the given date in the past?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the past
 *
 * @example
 * // If today is 6 October 2014, is 2 July 2014 in the past?
 * const result = isPast(new Date(2014, 6, 2))
 * //=> true
 */
function isPast(date) {
  return +(0, _index.toDate)(date) < Date.now();
}


/***/ }),

/***/ "./node_modules/date-fns/isSameDay.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/isSameDay.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameDay = isSameDay;
var _index = __webpack_require__(/*! ./startOfDay.js */ "./node_modules/date-fns/startOfDay.js");

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same day (and year and month)
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = (0, _index.startOfDay)(dateLeft);
  const dateRightStartOfDay = (0, _index.startOfDay)(dateRight);

  return +dateLeftStartOfDay === +dateRightStartOfDay;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameHour.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isSameHour.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameHour = isSameHour;
var _index = __webpack_require__(/*! ./startOfHour.js */ "./node_modules/date-fns/startOfHour.js");

/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same hour (and same day)
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */
function isSameHour(dateLeft, dateRight) {
  const dateLeftStartOfHour = (0, _index.startOfHour)(dateLeft);
  const dateRightStartOfHour = (0, _index.startOfHour)(dateRight);

  return +dateLeftStartOfHour === +dateRightStartOfHour;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameISOWeek.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/isSameISOWeek.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameISOWeek = isSameISOWeek;
var _index = __webpack_require__(/*! ./isSameWeek.js */ "./node_modules/date-fns/isSameWeek.js");

/**
 * @name isSameISOWeek
 * @category ISO Week Helpers
 * @summary Are the given dates in the same ISO week (and year)?
 *
 * @description
 * Are the given dates in the same ISO week (and year)?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week (and year)
 *
 * @example
 * // Are 1 September 2014 and 7 September 2014 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2014, 8, 7))
 * //=> true
 *
 * @example
 * // Are 1 September 2014 and 1 September 2015 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))
 * //=> false
 */
function isSameISOWeek(dateLeft, dateRight) {
  return (0, _index.isSameWeek)(dateLeft, dateRight, { weekStartsOn: 1 });
}


/***/ }),

/***/ "./node_modules/date-fns/isSameISOWeekYear.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/isSameISOWeekYear.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameISOWeekYear = isSameISOWeekYear;
var _index = __webpack_require__(/*! ./startOfISOWeekYear.js */ "./node_modules/date-fns/startOfISOWeekYear.js");

/**
 * @name isSameISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Are the given dates in the same ISO week-numbering year?
 *
 * @description
 * Are the given dates in the same ISO week-numbering year?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week-numbering year
 *
 * @example
 * // Are 29 December 2003 and 2 January 2005 in the same ISO week-numbering year?
 * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))
 * //=> true
 */
function isSameISOWeekYear(dateLeft, dateRight) {
  const dateLeftStartOfYear = (0, _index.startOfISOWeekYear)(dateLeft);
  const dateRightStartOfYear = (0, _index.startOfISOWeekYear)(dateRight);

  return +dateLeftStartOfYear === +dateRightStartOfYear;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameMinute.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/isSameMinute.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameMinute = isSameMinute;
var _index = __webpack_require__(/*! ./startOfMinute.js */ "./node_modules/date-fns/startOfMinute.js");

/**
 * @name isSameMinute
 * @category Minute Helpers
 * @summary Are the given dates in the same minute (and hour and day)?
 *
 * @description
 * Are the given dates in the same minute (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same minute (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 4, 6, 30, 15)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 5, 6, 30)
 * )
 * //=> false
 */
function isSameMinute(dateLeft, dateRight) {
  const dateLeftStartOfMinute = (0, _index.startOfMinute)(dateLeft);
  const dateRightStartOfMinute = (0, _index.startOfMinute)(dateRight);

  return +dateLeftStartOfMinute === +dateRightStartOfMinute;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameMonth.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/isSameMonth.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameMonth = isSameMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same month (and year)
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);
  return (
    _dateLeft.getFullYear() === _dateRight.getFullYear() &&
    _dateLeft.getMonth() === _dateRight.getMonth()
  );
}


/***/ }),

/***/ "./node_modules/date-fns/isSameQuarter.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/isSameQuarter.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameQuarter = isSameQuarter;
var _index = __webpack_require__(/*! ./startOfQuarter.js */ "./node_modules/date-fns/startOfQuarter.js");

/**
 * @name isSameQuarter
 * @category Quarter Helpers
 * @summary Are the given dates in the same quarter (and year)?
 *
 * @description
 * Are the given dates in the same quarter (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same quarter (and year)
 *
 * @example
 * // Are 1 January 2014 and 8 March 2014 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
 * //=> true
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameQuarter(dateLeft, dateRight) {
  const dateLeftStartOfQuarter = (0, _index.startOfQuarter)(dateLeft);
  const dateRightStartOfQuarter = (0, _index.startOfQuarter)(dateRight);

  return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameSecond.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/isSameSecond.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameSecond = isSameSecond;
var _index = __webpack_require__(/*! ./startOfSecond.js */ "./node_modules/date-fns/startOfSecond.js");

/**
 * @name isSameSecond
 * @category Second Helpers
 * @summary Are the given dates in the same second (and hour and day)?
 *
 * @description
 * Are the given dates in the same second (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same second (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 30, 15),
 *   new Date(2014, 8, 4, 6, 30, 15, 500)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 4, 6, 1, 15)
 * )
 * //=> false
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 5, 6, 0, 15)
 * )
 * //=> false
 */
function isSameSecond(dateLeft, dateRight) {
  const dateLeftStartOfSecond = (0, _index.startOfSecond)(dateLeft);
  const dateRightStartOfSecond = (0, _index.startOfSecond)(dateRight);

  return +dateLeftStartOfSecond === +dateRightStartOfSecond;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isSameWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameWeek = isSameWeek;
var _index = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");

/**
 * The {@link isSameWeek} function options.
 */

/**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 * @param options - An object with options
 *
 * @returns The dates are in the same week (and month and year)
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameWeek(dateLeft, dateRight, options) {
  const dateLeftStartOfWeek = (0, _index.startOfWeek)(dateLeft, options);
  const dateRightStartOfWeek = (0, _index.startOfWeek)(dateRight, options);

  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}


/***/ }),

/***/ "./node_modules/date-fns/isSameYear.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isSameYear.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSameYear = isSameYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same year
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */
function isSameYear(dateLeft, dateRight) {
  const _dateLeft = (0, _index.toDate)(dateLeft);
  const _dateRight = (0, _index.toDate)(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}


/***/ }),

/***/ "./node_modules/date-fns/isSaturday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isSaturday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSaturday = isSaturday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isSaturday
 * @category Weekday Helpers
 * @summary Is the given date Saturday?
 *
 * @description
 * Is the given date Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Saturday
 *
 * @example
 * // Is 27 September 2014 Saturday?
 * const result = isSaturday(new Date(2014, 8, 27))
 * //=> true
 */
function isSaturday(date) {
  return (0, _index.toDate)(date).getDay() === 6;
}


/***/ }),

/***/ "./node_modules/date-fns/isSunday.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isSunday.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isSunday = isSunday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isSunday
 * @category Weekday Helpers
 * @summary Is the given date Sunday?
 *
 * @description
 * Is the given date Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Sunday
 *
 * @example
 * // Is 21 September 2014 Sunday?
 * const result = isSunday(new Date(2014, 8, 21))
 * //=> true
 */
function isSunday(date) {
  return (0, _index.toDate)(date).getDay() === 0;
}


/***/ }),

/***/ "./node_modules/date-fns/isThisHour.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isThisHour.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisHour = isThisHour;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameHour.js */ "./node_modules/date-fns/isSameHour.js");

/**
 * @name isThisHour
 * @category Hour Helpers
 * @summary Is the given date in the same hour as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same hour as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this hour
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:00:00 in this hour?
 * const result = isThisHour(new Date(2014, 8, 25, 18))
 * //=> true
 */
function isThisHour(date) {
  return (0, _index2.isSameHour)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisISOWeek.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/isThisISOWeek.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisISOWeek = isThisISOWeek;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameISOWeek.js */ "./node_modules/date-fns/isSameISOWeek.js");

/**
 * @name isThisISOWeek
 * @category ISO Week Helpers
 * @summary Is the given date in the same ISO week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same ISO week as the current date?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this ISO week
 *
 * @example
 * // If today is 25 September 2014, is 22 September 2014 in this ISO week?
 * const result = isThisISOWeek(new Date(2014, 8, 22))
 * //=> true
 */

function isThisISOWeek(date) {
  return (0, _index2.isSameISOWeek)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisMinute.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/isThisMinute.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisMinute = isThisMinute;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameMinute.js */ "./node_modules/date-fns/isSameMinute.js");

/**
 * @name isThisMinute
 * @category Minute Helpers
 * @summary Is the given date in the same minute as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same minute as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this minute
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:00 in this minute?
 * const result = isThisMinute(new Date(2014, 8, 25, 18, 30))
 * //=> true
 */

function isThisMinute(date) {
  return (0, _index2.isSameMinute)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisMonth.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/isThisMonth.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisMonth = isThisMonth;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameMonth.js */ "./node_modules/date-fns/isSameMonth.js");

/**
 * @name isThisMonth
 * @category Month Helpers
 * @summary Is the given date in the same month as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same month as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this month
 *
 * @example
 * // If today is 25 September 2014, is 15 September 2014 in this month?
 * const result = isThisMonth(new Date(2014, 8, 15))
 * //=> true
 */

function isThisMonth(date) {
  return (0, _index2.isSameMonth)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisQuarter.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/isThisQuarter.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisQuarter = isThisQuarter;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameQuarter.js */ "./node_modules/date-fns/isSameQuarter.js");

/**
 * @name isThisQuarter
 * @category Quarter Helpers
 * @summary Is the given date in the same quarter as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same quarter as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this quarter
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this quarter?
 * const result = isThisQuarter(new Date(2014, 6, 2))
 * //=> true
 */
function isThisQuarter(date) {
  return (0, _index2.isSameQuarter)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisSecond.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/isThisSecond.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisSecond = isThisSecond;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameSecond.js */ "./node_modules/date-fns/isSameSecond.js");

/**
 * @name isThisSecond
 * @category Second Helpers
 * @summary Is the given date in the same second as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same second as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this second
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:15.000 in this second?
 * const result = isThisSecond(new Date(2014, 8, 25, 18, 30, 15))
 * //=> true
 */
function isThisSecond(date) {
  return (0, _index2.isSameSecond)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThisWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isThisWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisWeek = isThisWeek;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameWeek.js */ "./node_modules/date-fns/isSameWeek.js");

/**
 * The {@link isThisWeek} function options.
 */

/**
 * @name isThisWeek
 * @category Week Helpers
 * @summary Is the given date in the same week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same week as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param options - The object with options
 *
 * @returns The date is in this week
 *
 * @example
 * // If today is 25 September 2014, is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21))
 * //=> true
 *
 * @example
 * // If today is 25 September 2014 and week starts with Monday
 * // is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
 * //=> false
 */
function isThisWeek(date, options) {
  return (0, _index2.isSameWeek)(date, (0, _index.constructNow)(date), options);
}


/***/ }),

/***/ "./node_modules/date-fns/isThisYear.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isThisYear.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThisYear = isThisYear;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameYear.js */ "./node_modules/date-fns/isSameYear.js");

/**
 * @name isThisYear
 * @category Year Helpers
 * @summary Is the given date in the same year as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same year as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this year
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this year?
 * const result = isThisYear(new Date(2014, 6, 2))
 * //=> true
 */
function isThisYear(date) {
  return (0, _index2.isSameYear)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isThursday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isThursday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isThursday = isThursday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isThursday
 * @category Weekday Helpers
 * @summary Is the given date Thursday?
 *
 * @description
 * Is the given date Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Thursday
 *
 * @example
 * // Is 25 September 2014 Thursday?
 * const result = isThursday(new Date(2014, 8, 25))
 * //=> true
 */
function isThursday(date) {
  return (0, _index.toDate)(date).getDay() === 4;
}


/***/ }),

/***/ "./node_modules/date-fns/isToday.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isToday.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isToday = isToday;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameDay.js */ "./node_modules/date-fns/isSameDay.js");

/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is today
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */
function isToday(date) {
  return (0, _index2.isSameDay)(date, (0, _index.constructNow)(date));
}


/***/ }),

/***/ "./node_modules/date-fns/isTomorrow.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isTomorrow.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isTomorrow = isTomorrow;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index3 = __webpack_require__(/*! ./isSameDay.js */ "./node_modules/date-fns/isSameDay.js");

/**
 * @name isTomorrow
 * @category Day Helpers
 * @summary Is the given date tomorrow?
 * @pure false
 *
 * @description
 * Is the given date tomorrow?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is tomorrow
 *
 * @example
 * // If today is 6 October 2014, is 7 October 14:00:00 tomorrow?
 * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))
 * //=> true
 */
function isTomorrow(date) {
  return (0, _index3.isSameDay)(
    date,
    (0, _index.addDays)((0, _index2.constructNow)(date), 1),
  );
}


/***/ }),

/***/ "./node_modules/date-fns/isTuesday.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/isTuesday.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isTuesday = isTuesday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isTuesday
 * @category Weekday Helpers
 * @summary Is the given date Tuesday?
 *
 * @description
 * Is the given date Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Tuesday
 *
 * @example
 * // Is 23 September 2014 Tuesday?
 * const result = isTuesday(new Date(2014, 8, 23))
 * //=> true
 */
function isTuesday(date) {
  return (0, _index.toDate)(date).getDay() === 2;
}


/***/ }),

/***/ "./node_modules/date-fns/isValid.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isValid.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isValid = isValid;
var _index = __webpack_require__(/*! ./isDate.js */ "./node_modules/date-fns/isDate.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is valid
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(date) {
  if (!(0, _index.isDate)(date) && typeof date !== "number") {
    return false;
  }
  const _date = (0, _index2.toDate)(date);
  return !isNaN(Number(_date));
}


/***/ }),

/***/ "./node_modules/date-fns/isWednesday.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/isWednesday.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isWednesday = isWednesday;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isWednesday
 * @category Weekday Helpers
 * @summary Is the given date Wednesday?
 *
 * @description
 * Is the given date Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Wednesday
 *
 * @example
 * // Is 24 September 2014 Wednesday?
 * const result = isWednesday(new Date(2014, 8, 24))
 * //=> true
 */
function isWednesday(date) {
  return (0, _index.toDate)(date).getDay() === 3;
}


/***/ }),

/***/ "./node_modules/date-fns/isWeekend.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/isWeekend.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isWeekend = isWeekend;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isWeekend
 * @category Weekday Helpers
 * @summary Does the given date fall on a weekend?
 *
 * @description
 * Does the given date fall on a weekend?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date falls on a weekend
 *
 * @example
 * // Does 5 October 2014 fall on a weekend?
 * const result = isWeekend(new Date(2014, 9, 5))
 * //=> true
 */
function isWeekend(date) {
  const day = (0, _index.toDate)(date).getDay();
  return day === 0 || day === 6;
}


/***/ }),

/***/ "./node_modules/date-fns/isWithinInterval.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/isWithinInterval.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isWithinInterval = isWithinInterval;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param interval - The interval to check
 *
 * @returns The date is within the interval
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date })
 * // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end })
 * // => true
 */
function isWithinInterval(date, interval) {
  const time = +(0, _index.toDate)(date);
  const [startTime, endTime] = [
    +(0, _index.toDate)(interval.start),
    +(0, _index.toDate)(interval.end),
  ].sort((a, b) => a - b);

  return time >= startTime && time <= endTime;
}


/***/ }),

/***/ "./node_modules/date-fns/isYesterday.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/isYesterday.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.isYesterday = isYesterday;
var _index = __webpack_require__(/*! ./constructNow.js */ "./node_modules/date-fns/constructNow.js");
var _index2 = __webpack_require__(/*! ./isSameDay.js */ "./node_modules/date-fns/isSameDay.js");
var _index3 = __webpack_require__(/*! ./subDays.js */ "./node_modules/date-fns/subDays.js");

/**
 * @name isYesterday
 * @category Day Helpers
 * @summary Is the given date yesterday?
 * @pure false
 *
 * @description
 * Is the given date yesterday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is yesterday
 *
 * @example
 * // If today is 6 October 2014, is 5 October 14:00:00 yesterday?
 * const result = isYesterday(new Date(2014, 9, 5, 14, 0))
 * //=> true
 */
function isYesterday(date) {
  return (0, _index2.isSameDay)(
    date,
    (0, _index3.subDays)((0, _index.constructNow)(date), 1),
  );
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfDecade.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfDecade.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfDecade = lastDayOfDecade;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name lastDayOfDecade
 * @category Decade Helpers
 * @summary Return the last day of a decade for the given date.
 *
 * @description
 * Return the last day of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a decade
 *
 * @example
 * // The last day of a decade for 21 December 2012 21:12:00:
 * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))
 * //=> Wed Dec 31 2019 00:00:00
 */
function lastDayOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  const decade = 9 + Math.floor(year / 10) * 10;
  _date.setFullYear(decade + 1, 0, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfISOWeek.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfISOWeek.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfISOWeek = lastDayOfISOWeek;
var _index = __webpack_require__(/*! ./lastDayOfWeek.js */ "./node_modules/date-fns/lastDayOfWeek.js");

/**
 * @name lastDayOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the last day of an ISO week for the given date.
 *
 * @description
 * Return the last day of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of an ISO week
 *
 * @example
 * // The last day of an ISO week for 2 September 2014 11:55:00:
 * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfISOWeek(date) {
  return (0, _index.lastDayOfWeek)(date, { weekStartsOn: 1 });
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfISOWeekYear.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfISOWeekYear.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfISOWeekYear = lastDayOfISOWeekYear;
var _index = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name lastDayOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the last day of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the last day of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The last day of an ISO week-numbering year for 2 July 2005:
 * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 00:00:00
 */
function lastDayOfISOWeekYear(date) {
  const year = (0, _index.getISOWeekYear)(date);
  const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(year + 1, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  const _date = (0, _index2.startOfISOWeek)(fourthOfJanuary);
  _date.setDate(_date.getDate() - 1);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfMonth.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfMonth.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfMonth = lastDayOfMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a month
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfMonth(date) {
  const _date = (0, _index.toDate)(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfQuarter.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfQuarter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfQuarter = lastDayOfQuarter;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name lastDayOfQuarter
 * @category Quarter Helpers
 * @summary Return the last day of a year quarter for the given date.
 *
 * @description
 * Return the last day of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a quarter
 *
 * @example
 * // The last day of a quarter for 2 September 2014 11:55:00:
 * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfQuarter(date) {
  const _date = (0, _index.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3) + 3;
  _date.setMonth(month, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfWeek.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfWeek.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfWeek = lastDayOfWeek;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link lastDayOfWeek} function options.
 */

/**
 * @name lastDayOfWeek
 * @category Week Helpers
 * @summary Return the last day of a week for the given date.
 *
 * @description
 * Return the last day of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The last day of a week
 *
 * @example
 * // The last day of a week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfWeek(date, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

  _date.setHours(0, 0, 0, 0);
  _date.setDate(_date.getDate() + diff);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lastDayOfYear.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/lastDayOfYear.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lastDayOfYear = lastDayOfYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name lastDayOfYear
 * @category Year Helpers
 * @summary Return the last day of a year for the given date.
 *
 * @description
 * Return the last day of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a year
 *
 * @example
 * // The last day of a year for 2 September 2014 11:55:00:
 * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 00:00:00
 */
function lastDayOfYear(date) {
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/lightFormat.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/lightFormat.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.lightFormat = lightFormat;
Object.defineProperty(exports, "lightFormatters", ({
  enumerable: true,
  get: function () {
    return _index3.lightFormatters;
  },
}));
var _index = __webpack_require__(/*! ./isValid.js */ "./node_modules/date-fns/isValid.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index3 = __webpack_require__(/*! ./_lib/format/lightFormatters.js */ "./node_modules/date-fns/_lib/format/lightFormatters.js");

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

// This RegExp consists of three parts separated by `|`:
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @private
 */

/**
 * @name lightFormat
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. Unlike `format`,
 * `lightFormat` doesn't use locales and outputs date using the most popular tokens.
 *
 * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   |
 * |---------------------------------|---------|-----------------------------------|
 * | AM, PM                          | a..aaa  | AM, PM                            |
 * |                                 | aaaa    | a.m., p.m.                        |
 * |                                 | aaaaa   | a, p                              |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 |
 * |                                 | yy      | 44, 01, 00, 17                    |
 * |                                 | yyy     | 044, 001, 000, 017                |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |
 * |                                 | MM      | 01, 02, ..., 12                   |
 * | Day of month                    | d       | 1, 2, ..., 31                     |
 * |                                 | dd      | 01, 02, ..., 31                   |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |
 * |                                 | hh      | 01, 02, ..., 11, 12               |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |
 * |                                 | HH      | 00, 01, 02, ..., 23               |
 * | Minute                          | m       | 0, 1, ..., 59                     |
 * |                                 | mm      | 00, 01, ..., 59                   |
 * | Second                          | s       | 0, 1, ..., 59                     |
 * |                                 | ss      | 00, 01, ..., 59                   |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |
 * |                                 | SS      | 00, 01, ..., 99                   |
 * |                                 | SSS     | 000, 001, ..., 999                |
 * |                                 | SSSS    | ...                               |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 *
 * @returns The formatted date string
 *
 * @throws `Invalid time value` if the date is invalid
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')
 * //=> '2014-02-11'
 */
function lightFormat(date, formatStr) {
  const _date = (0, _index2.toDate)(date);

  if (!(0, _index.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const tokens = formatStr.match(formattingTokensRegExp);

  // The only case when formattingTokensRegExp doesn't match the string is when it's empty
  if (!tokens) return "";

  const result = tokens
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }

      const formatter = _index3.lightFormatters[firstCharacter];
      if (formatter) {
        return formatter(_date, substring);
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return substring;
    })
    .join("");

  return result;
}

function cleanEscapedString(input) {
  const matches = input.match(escapedStringRegExp);

  if (!matches) {
    return input;
  }

  return matches[1].replace(doubleQuoteRegExp, "'");
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildFormatLongFn.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildFormatLongFn.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.buildFormatLongFn = buildFormatLongFn;

function buildFormatLongFn(args) {
  return (options = {}) => {
    // TODO: Remove String()
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildLocalizeFn.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildLocalizeFn.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.buildLocalizeFn = buildLocalizeFn; /* eslint-disable no-unused-vars */

/**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */

/**
 * The map of localized values for each width.
 */

/**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */

/**
 * Converts the unit value to the tuple of values.
 */

/**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */

/**
 * The tuple of localized quarter values. The first element represents Q1.
 */

/**
 * The tuple of localized day values. The first element represents Sunday.
 */

/**
 * The tuple of localized month values. The first element represents January.
 */

function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";

    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;

      valuesArray =
        args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;

    // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildMatchFn.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchFn.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.buildMatchFn = buildMatchFn;

function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;

    const matchPattern =
      (width && args.matchPatterns[width]) ||
      args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];

    const parsePatterns =
      (width && args.parsePatterns[width]) ||
      args.parsePatterns[args.defaultParseWidth];

    const key = Array.isArray(parsePatterns)
      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
      : // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString));

    let value;

    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback
      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        options.valueCallback(value)
      : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

function findKey(object, predicate) {
  for (const key in object) {
    if (
      Object.prototype.hasOwnProperty.call(object, key) &&
      predicate(object[key])
    ) {
      return key;
    }
  }
  return undefined;
}

function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildMatchPatternFn.js":
/*!******************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchPatternFn.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.buildMatchPatternFn = buildMatchPatternFn;

function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];

    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback
      ? args.valueCallback(parseResult[0])
      : parseResult[0];

    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
    value = options.valueCallback ? options.valueCallback(value) : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/locale/en-US.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.enUS = void 0;
var _index = __webpack_require__(/*! ./en-US/_lib/formatDistance.js */ "./node_modules/date-fns/locale/en-US/_lib/formatDistance.js");
var _index2 = __webpack_require__(/*! ./en-US/_lib/formatLong.js */ "./node_modules/date-fns/locale/en-US/_lib/formatLong.js");
var _index3 = __webpack_require__(/*! ./en-US/_lib/formatRelative.js */ "./node_modules/date-fns/locale/en-US/_lib/formatRelative.js");
var _index4 = __webpack_require__(/*! ./en-US/_lib/localize.js */ "./node_modules/date-fns/locale/en-US/_lib/localize.js");
var _index5 = __webpack_require__(/*! ./en-US/_lib/match.js */ "./node_modules/date-fns/locale/en-US/_lib/match.js");

/**
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */
const enUS = (exports.enUS = {
  code: "en-US",
  formatDistance: _index.formatDistance,
  formatLong: _index2.formatLong,
  formatRelative: _index3.formatRelative,
  localize: _index4.localize,
  match: _index5.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatDistance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatDistance.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.formatDistance = void 0;

const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds",
  },

  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds",
  },

  halfAMinute: "half a minute",

  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes",
  },

  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours",
  },

  xHours: {
    one: "1 hour",
    other: "{{count}} hours",
  },

  xDays: {
    one: "1 day",
    other: "{{count}} days",
  },

  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks",
  },

  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months",
  },

  xMonths: {
    one: "1 month",
    other: "{{count}} months",
  },

  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years",
  },

  xYears: {
    one: "1 year",
    other: "{{count}} years",
  },

  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years",
  },

  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years",
  },
};

const formatDistance = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }

  return result;
};
exports.formatDistance = formatDistance;


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatLong.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatLong.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.formatLong = void 0;
var _index = __webpack_require__(/*! ../../_lib/buildFormatLongFn.js */ "./node_modules/date-fns/locale/_lib/buildFormatLongFn.js");

const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

const formatLong = (exports.formatLong = {
  date: (0, _index.buildFormatLongFn)({
    formats: dateFormats,
    defaultWidth: "full",
  }),

  time: (0, _index.buildFormatLongFn)({
    formats: timeFormats,
    defaultWidth: "full",
  }),

  dateTime: (0, _index.buildFormatLongFn)({
    formats: dateTimeFormats,
    defaultWidth: "full",
  }),
});


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatRelative.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatRelative.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.formatRelative = void 0;

const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P",
};

const formatRelative = (token, _date, _baseDate, _options) =>
  formatRelativeLocale[token];
exports.formatRelative = formatRelative;


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/localize.js":
/*!*************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/localize.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.localize = void 0;
var _index = __webpack_require__(/*! ../../_lib/buildLocalizeFn.js */ "./node_modules/date-fns/locale/_lib/buildLocalizeFn.js");

const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"],
};

const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],

  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
};

const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
};

const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
};

const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
};

const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};

const localize = (exports.localize = {
  ordinalNumber,

  era: (0, _index.buildLocalizeFn)({
    values: eraValues,
    defaultWidth: "wide",
  }),

  quarter: (0, _index.buildLocalizeFn)({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index.buildLocalizeFn)({
    values: monthValues,
    defaultWidth: "wide",
  }),

  day: (0, _index.buildLocalizeFn)({
    values: dayValues,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index.buildLocalizeFn)({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide",
  }),
});


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/match.js":
/*!**********************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/match.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.match = void 0;

var _index = __webpack_require__(/*! ../../_lib/buildMatchFn.js */ "./node_modules/date-fns/locale/_lib/buildMatchFn.js");
var _index2 = __webpack_require__(/*! ../../_lib/buildMatchPatternFn.js */ "./node_modules/date-fns/locale/_lib/buildMatchPatternFn.js");

const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;

const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i,
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i,
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

const match = (exports.match = {
  ordinalNumber: (0, _index2.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index.buildMatchFn)({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index.buildMatchFn)({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index.buildMatchFn)({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any",
  }),

  day: (0, _index.buildMatchFn)({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any",
  }),
});


/***/ }),

/***/ "./node_modules/date-fns/max.js":
/*!**************************************!*\
  !*** ./node_modules/date-fns/max.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.max = max;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name max
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The latest of the dates
 *
 * @example
 * // Which of these dates is the latest?
 * const result = max([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Sun Jul 02 1995 00:00:00
 */
function max(dates) {
  let result;
  dates.forEach(function (dirtyDate) {
    const currentDate = (0, _index.toDate)(dirtyDate);

    if (
      result === undefined ||
      result < currentDate ||
      isNaN(Number(currentDate))
    ) {
      result = currentDate;
    }
  });

  return result || new Date(NaN);
}


/***/ }),

/***/ "./node_modules/date-fns/milliseconds.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/milliseconds.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.milliseconds = milliseconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name milliseconds
 * @category Millisecond Helpers
 * @summary
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * @description
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * One month is a year divided by 12.
 *
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * @returns The milliseconds
 *
 * @example
 * // 1 year in milliseconds
 * milliseconds({ years: 1 })
 * //=> 31556952000
 *
 * // 3 months in milliseconds
 * milliseconds({ months: 3 })
 * //=> 7889238000
 */
function milliseconds({ years, months, weeks, days, hours, minutes, seconds }) {
  let totalDays = 0;

  if (years) totalDays += years * _index.daysInYear;
  if (months) totalDays += months * (_index.daysInYear / 12);
  if (weeks) totalDays += weeks * 7;
  if (days) totalDays += days;

  let totalSeconds = totalDays * 24 * 60 * 60;

  if (hours) totalSeconds += hours * 60 * 60;
  if (minutes) totalSeconds += minutes * 60;
  if (seconds) totalSeconds += seconds;

  return Math.trunc(totalSeconds * 1000);
}


/***/ }),

/***/ "./node_modules/date-fns/millisecondsToHours.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/millisecondsToHours.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.millisecondsToHours = millisecondsToHours;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name millisecondsToHours
 * @category Conversion Helpers
 * @summary Convert milliseconds to hours.
 *
 * @description
 * Convert a number of milliseconds to a full number of hours.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in hours
 *
 * @example
 * // Convert 7200000 milliseconds to hours:
 * const result = millisecondsToHours(7200000)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToHours(7199999)
 * //=> 1
 */
function millisecondsToHours(milliseconds) {
  const hours = milliseconds / _index.millisecondsInHour;
  return Math.trunc(hours);
}


/***/ }),

/***/ "./node_modules/date-fns/millisecondsToMinutes.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/millisecondsToMinutes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.millisecondsToMinutes = millisecondsToMinutes;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name millisecondsToMinutes
 * @category Conversion Helpers
 * @summary Convert milliseconds to minutes.
 *
 * @description
 * Convert a number of milliseconds to a full number of minutes.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in minutes
 *
 * @example
 * // Convert 60000 milliseconds to minutes:
 * const result = millisecondsToMinutes(60000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToMinutes(119999)
 * //=> 1
 */
function millisecondsToMinutes(milliseconds) {
  const minutes = milliseconds / _index.millisecondsInMinute;
  return Math.trunc(minutes);
}


/***/ }),

/***/ "./node_modules/date-fns/millisecondsToSeconds.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/millisecondsToSeconds.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.millisecondsToSeconds = millisecondsToSeconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name millisecondsToSeconds
 * @category Conversion Helpers
 * @summary Convert milliseconds to seconds.
 *
 * @description
 * Convert a number of milliseconds to a full number of seconds.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in seconds
 *
 * @example
 * // Convert 1000 miliseconds to seconds:
 * const result = millisecondsToSeconds(1000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToSeconds(1999)
 * //=> 1
 */
function millisecondsToSeconds(milliseconds) {
  const seconds = milliseconds / _index.millisecondsInSecond;
  return Math.trunc(seconds);
}


/***/ }),

/***/ "./node_modules/date-fns/min.js":
/*!**************************************!*\
  !*** ./node_modules/date-fns/min.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.min = min;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name min
 * @category Common Helpers
 * @summary Returns the earliest of the given dates.
 *
 * @description
 * Returns the earliest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The earliest of the dates
 *
 * @example
 * // Which of these dates is the earliest?
 * const result = min([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Wed Feb 11 1987 00:00:00
 */
function min(dates) {
  let result;

  dates.forEach((dirtyDate) => {
    const date = (0, _index.toDate)(dirtyDate);
    if (!result || result > date || isNaN(+date)) {
      result = date;
    }
  });

  return result || new Date(NaN);
}


/***/ }),

/***/ "./node_modules/date-fns/minutesToHours.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/minutesToHours.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.minutesToHours = minutesToHours;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name minutesToHours
 * @category Conversion Helpers
 * @summary Convert minutes to hours.
 *
 * @description
 * Convert a number of minutes to a full number of hours.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in hours
 *
 * @example
 * // Convert 140 minutes to hours:
 * const result = minutesToHours(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = minutesToHours(179)
 * //=> 2
 */
function minutesToHours(minutes) {
  const hours = minutes / _index.minutesInHour;
  return Math.trunc(hours);
}


/***/ }),

/***/ "./node_modules/date-fns/minutesToMilliseconds.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/minutesToMilliseconds.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.minutesToMilliseconds = minutesToMilliseconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name minutesToMilliseconds
 * @category Conversion Helpers
 * @summary Convert minutes to milliseconds.
 *
 * @description
 * Convert a number of minutes to a full number of milliseconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in milliseconds
 *
 * @example
 * // Convert 2 minutes to milliseconds
 * const result = minutesToMilliseconds(2)
 * //=> 120000
 */
function minutesToMilliseconds(minutes) {
  return Math.trunc(minutes * _index.millisecondsInMinute);
}


/***/ }),

/***/ "./node_modules/date-fns/minutesToSeconds.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/minutesToSeconds.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.minutesToSeconds = minutesToSeconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name minutesToSeconds
 * @category Conversion Helpers
 * @summary Convert minutes to seconds.
 *
 * @description
 * Convert a number of minutes to a full number of seconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in seconds
 *
 * @example
 * // Convert 2 minutes to seconds
 * const result = minutesToSeconds(2)
 * //=> 120
 */
function minutesToSeconds(minutes) {
  return Math.trunc(minutes * _index.secondsInMinute);
}


/***/ }),

/***/ "./node_modules/date-fns/monthsToQuarters.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/monthsToQuarters.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.monthsToQuarters = monthsToQuarters;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name monthsToQuarters
 * @category Conversion Helpers
 * @summary Convert number of months to quarters.
 *
 * @description
 * Convert a number of months to a full number of quarters.
 *
 * @param months - The number of months to be converted.
 *
 * @returns The number of months converted in quarters
 *
 * @example
 * // Convert 6 months to quarters:
 * const result = monthsToQuarters(6)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = monthsToQuarters(7)
 * //=> 2
 */
function monthsToQuarters(months) {
  const quarters = months / _index.monthsInQuarter;
  return Math.trunc(quarters);
}


/***/ }),

/***/ "./node_modules/date-fns/monthsToYears.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/monthsToYears.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.monthsToYears = monthsToYears;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name monthsToYears
 * @category Conversion Helpers
 * @summary Convert number of months to years.
 *
 * @description
 * Convert a number of months to a full number of years.
 *
 * @param months - The number of months to be converted
 *
 * @returns The number of months converted in years
 *
 * @example
 * // Convert 36 months to years:
 * const result = monthsToYears(36)
 * //=> 3
 *
 * // It uses floor rounding:
 * const result = monthsToYears(40)
 * //=> 3
 */
function monthsToYears(months) {
  const years = months / _index.monthsInYear;
  return Math.trunc(years);
}


/***/ }),

/***/ "./node_modules/date-fns/nextDay.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/nextDay.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextDay = nextDay;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./getDay.js */ "./node_modules/date-fns/getDay.js");

/**
 * @name nextDay
 * @category Weekday Helpers
 * @summary When is the next day of the week?
 *
 * @description
 * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - day of the week
 *
 * @returns The date is the next day of week
 *
 * @example
 * // When is the next Monday after Mar, 20, 2020?
 * const result = nextDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 23 2020 00:00:00
 *
 * @example
 * // When is the next Tuesday after Mar, 21, 2020?
 * const result = nextDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextDay(date, day) {
  let delta = day - (0, _index2.getDay)(date);
  if (delta <= 0) delta += 7;

  return (0, _index.addDays)(date, delta);
}


/***/ }),

/***/ "./node_modules/date-fns/nextFriday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/nextFriday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextFriday = nextFriday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextFriday
 * @category Weekday Helpers
 * @summary When is the next Friday?
 *
 * @description
 * When is the next Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Friday
 *
 * @example
 * // When is the next Friday after Mar, 22, 2020?
 * const result = nextFriday(new Date(2020, 2, 22))
 * //=> Fri Mar 27 2020 00:00:00
 */
function nextFriday(date) {
  return (0, _index.nextDay)(date, 5);
}


/***/ }),

/***/ "./node_modules/date-fns/nextMonday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/nextMonday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextMonday = nextMonday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextMonday
 * @category Weekday Helpers
 * @summary When is the next Monday?
 *
 * @description
 * When is the next Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Monday
 *
 * @example
 * // When is the next Monday after Mar, 22, 2020?
 * const result = nextMonday(new Date(2020, 2, 22))
 * //=> Mon Mar 23 2020 00:00:00
 */
function nextMonday(date) {
  return (0, _index.nextDay)(date, 1);
}


/***/ }),

/***/ "./node_modules/date-fns/nextSaturday.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/nextSaturday.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextSaturday = nextSaturday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextSaturday
 * @category Weekday Helpers
 * @summary When is the next Saturday?
 *
 * @description
 * When is the next Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Saturday
 *
 * @example
 * // When is the next Saturday after Mar, 22, 2020?
 * const result = nextSaturday(new Date(2020, 2, 22))
 * //=> Sat Mar 28 2020 00:00:00
 */
function nextSaturday(date) {
  return (0, _index.nextDay)(date, 6);
}


/***/ }),

/***/ "./node_modules/date-fns/nextSunday.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/nextSunday.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextSunday = nextSunday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextSunday
 * @category Weekday Helpers
 * @summary When is the next Sunday?
 *
 * @description
 * When is the next Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Sunday
 *
 * @example
 * // When is the next Sunday after Mar, 22, 2020?
 * const result = nextSunday(new Date(2020, 2, 22))
 * //=> Sun Mar 29 2020 00:00:00
 */
function nextSunday(date) {
  return (0, _index.nextDay)(date, 0);
}


/***/ }),

/***/ "./node_modules/date-fns/nextThursday.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/nextThursday.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextThursday = nextThursday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextThursday
 * @category Weekday Helpers
 * @summary When is the next Thursday?
 *
 * @description
 * When is the next Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Thursday
 *
 * @example
 * // When is the next Thursday after Mar, 22, 2020?
 * const result = nextThursday(new Date(2020, 2, 22))
 * //=> Thur Mar 26 2020 00:00:00
 */
function nextThursday(date) {
  return (0, _index.nextDay)(date, 4);
}


/***/ }),

/***/ "./node_modules/date-fns/nextTuesday.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/nextTuesday.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextTuesday = nextTuesday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextTuesday
 * @category Weekday Helpers
 * @summary When is the next Tuesday?
 *
 * @description
 * When is the next Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Tuesday
 *
 * @example
 * // When is the next Tuesday after Mar, 22, 2020?
 * const result = nextTuesday(new Date(2020, 2, 22))
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextTuesday(date) {
  return (0, _index.nextDay)(date, 2);
}


/***/ }),

/***/ "./node_modules/date-fns/nextWednesday.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/nextWednesday.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.nextWednesday = nextWednesday;
var _index = __webpack_require__(/*! ./nextDay.js */ "./node_modules/date-fns/nextDay.js");

/**
 * @name nextWednesday
 * @category Weekday Helpers
 * @summary When is the next Wednesday?
 *
 * @description
 * When is the next Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Wednesday
 *
 * @example
 * // When is the next Wednesday after Mar, 22, 2020?
 * const result = nextWednesday(new Date(2020, 2, 22))
 * //=> Wed Mar 25 2020 00:00:00
 */
function nextWednesday(date) {
  return (0, _index.nextDay)(date, 3);
}


/***/ }),

/***/ "./node_modules/date-fns/parse.js":
/*!****************************************!*\
  !*** ./node_modules/date-fns/parse.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "longFormatters", ({
  enumerable: true,
  get: function () {
    return _index5.longFormatters;
  },
}));
exports.parse = parse;
Object.defineProperty(exports, "parsers", ({
  enumerable: true,
  get: function () {
    return _index7.parsers;
  },
}));
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./getDefaultOptions.js */ "./node_modules/date-fns/getDefaultOptions.js");
var _index3 = __webpack_require__(/*! ./_lib/defaultLocale.js */ "./node_modules/date-fns/_lib/defaultLocale.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index5 = __webpack_require__(/*! ./_lib/format/longFormatters.js */ "./node_modules/date-fns/_lib/format/longFormatters.js");
var _index6 = __webpack_require__(/*! ./_lib/protectedTokens.js */ "./node_modules/date-fns/_lib/protectedTokens.js");

var _index7 = __webpack_require__(/*! ./parse/_lib/parsers.js */ "./node_modules/date-fns/parse/_lib/parsers.js");

var _Setter = __webpack_require__(/*! ./parse/_lib/Setter.js */ "./node_modules/date-fns/parse/_lib/Setter.js");

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

/**
 * The {@link parse} function options.
 */

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;

const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The string to parse
 * @param formatStr - The string of tokens
 * @param referenceDate - defines values missing from the parsed dateString
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns The parsed date
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dateStr, formatStr, referenceDate, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index3.defaultLocale;

  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  if (formatStr === "") {
    if (dateStr === "") {
      return (0, _index4.toDate)(referenceDate);
    } else {
      return (0, _index.constructFrom)(referenceDate, NaN);
    }
  }

  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  // If timezone isn't specified, it will be set to the system timezone
  const setters = [new _Setter.DateToSystemTimezoneSetter()];

  const tokens = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter in _index5.longFormatters) {
        const longFormatter = _index5.longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp);

  const usedTokens = [];

  for (let token of tokens) {
    if (
      !options?.useAdditionalWeekYearTokens &&
      (0, _index6.isProtectedWeekYearToken)(token)
    ) {
      (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
    }
    if (
      !options?.useAdditionalDayOfYearTokens &&
      (0, _index6.isProtectedDayOfYearToken)(token)
    ) {
      (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
    }

    const firstCharacter = token[0];
    const parser = _index7.parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) =>
            incompatibleTokens.includes(usedToken.token) ||
            usedToken.token === firstCharacter,
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`,
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`,
        );
      }

      usedTokens.push({ token: firstCharacter, fullToken: token });

      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions,
      );

      if (!parseResult) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }

      setters.push(parseResult.setter);

      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      // Replace two single quote characters with one single quote character
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }

      // Cut token from string, or, if string doesn't match the token, return Invalid Date
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
    }
  }

  // Check if the remaining input contains something other than whitespace
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return (0, _index.constructFrom)(referenceDate, NaN);
  }

  const uniquePrioritySetters = setters
    .map((setter) => setter.priority)
    .sort((a, b) => b - a)
    .filter((priority, index, array) => array.indexOf(priority) === index)
    .map((priority) =>
      setters
        .filter((setter) => setter.priority === priority)
        .sort((a, b) => b.subPriority - a.subPriority),
    )
    .map((setterArray) => setterArray[0]);

  let date = (0, _index4.toDate)(referenceDate);

  if (isNaN(date.getTime())) {
    return (0, _index.constructFrom)(referenceDate, NaN);
  }

  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return (0, _index.constructFrom)(referenceDate, NaN);
    }

    const result = setter.set(date, flags, subFnOptions);
    // Result is tuple (date, flags)
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
      // Result is date
    } else {
      date = result;
    }
  }

  return (0, _index.constructFrom)(referenceDate, date);
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/Parser.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/Parser.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.Parser = void 0;
var _Setter = __webpack_require__(/*! ./Setter.js */ "./node_modules/date-fns/parse/_lib/Setter.js");

class Parser {
  run(dateString, token, match, options) {
    const result = this.parse(dateString, token, match, options);
    if (!result) {
      return null;
    }

    return {
      setter: new _Setter.ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority,
      ),
      rest: result.rest,
    };
  }

  validate(_utcDate, _value, _options) {
    return true;
  }
}
exports.Parser = Parser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/Setter.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/Setter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ValueSetter =
  exports.Setter =
  exports.DateToSystemTimezoneSetter =
    void 0;
var _index = __webpack_require__(/*! ../../transpose.js */ "./node_modules/date-fns/transpose.js");
var _index2 = __webpack_require__(/*! ../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

const TIMEZONE_UNIT_PRIORITY = 10;

class Setter {
  subPriority = 0;

  validate(_utcDate, _options) {
    return true;
  }
}
exports.Setter = Setter;

class ValueSetter extends Setter {
  constructor(
    value,

    validateValue,

    setValue,

    priority,
    subPriority,
  ) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }

  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }

  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}
exports.ValueSetter = ValueSetter;

class DateToSystemTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;
  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return (0, _index2.constructFrom)(date, (0, _index.transpose)(date, Date));
  }
}
exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.timezonePatterns = exports.numericPatterns = void 0;
const numericPatterns = (exports.numericPatterns = {
  month: /^(1[0-2]|0?\d)/, // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/, // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/, // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/, // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/, // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/, // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/, // 0 to 12
  minute: /^[0-5]?\d/, // 0 to 59
  second: /^[0-5]?\d/, // 0 to 59

  singleDigit: /^\d/, // 0 to 9
  twoDigits: /^\d{1,2}/, // 0 to 99
  threeDigits: /^\d{1,3}/, // 0 to 999
  fourDigits: /^\d{1,4}/, // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/, // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/, // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/, // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/, // 0 to 9999, -0 to -9999
});

const timezonePatterns = (exports.timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/,
});


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.parsers = void 0;
var _EraParser = __webpack_require__(/*! ./parsers/EraParser.js */ "./node_modules/date-fns/parse/_lib/parsers/EraParser.js");
var _YearParser = __webpack_require__(/*! ./parsers/YearParser.js */ "./node_modules/date-fns/parse/_lib/parsers/YearParser.js");
var _LocalWeekYearParser = __webpack_require__(/*! ./parsers/LocalWeekYearParser.js */ "./node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js");
var _ISOWeekYearParser = __webpack_require__(/*! ./parsers/ISOWeekYearParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js");
var _ExtendedYearParser = __webpack_require__(/*! ./parsers/ExtendedYearParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js");
var _QuarterParser = __webpack_require__(/*! ./parsers/QuarterParser.js */ "./node_modules/date-fns/parse/_lib/parsers/QuarterParser.js");
var _StandAloneQuarterParser = __webpack_require__(/*! ./parsers/StandAloneQuarterParser.js */ "./node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js");
var _MonthParser = __webpack_require__(/*! ./parsers/MonthParser.js */ "./node_modules/date-fns/parse/_lib/parsers/MonthParser.js");
var _StandAloneMonthParser = __webpack_require__(/*! ./parsers/StandAloneMonthParser.js */ "./node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js");
var _LocalWeekParser = __webpack_require__(/*! ./parsers/LocalWeekParser.js */ "./node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js");
var _ISOWeekParser = __webpack_require__(/*! ./parsers/ISOWeekParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js");
var _DateParser = __webpack_require__(/*! ./parsers/DateParser.js */ "./node_modules/date-fns/parse/_lib/parsers/DateParser.js");
var _DayOfYearParser = __webpack_require__(/*! ./parsers/DayOfYearParser.js */ "./node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js");
var _DayParser = __webpack_require__(/*! ./parsers/DayParser.js */ "./node_modules/date-fns/parse/_lib/parsers/DayParser.js");
var _LocalDayParser = __webpack_require__(/*! ./parsers/LocalDayParser.js */ "./node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js");
var _StandAloneLocalDayParser = __webpack_require__(/*! ./parsers/StandAloneLocalDayParser.js */ "./node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js");
var _ISODayParser = __webpack_require__(/*! ./parsers/ISODayParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ISODayParser.js");
var _AMPMParser = __webpack_require__(/*! ./parsers/AMPMParser.js */ "./node_modules/date-fns/parse/_lib/parsers/AMPMParser.js");
var _AMPMMidnightParser = __webpack_require__(/*! ./parsers/AMPMMidnightParser.js */ "./node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js");
var _DayPeriodParser = __webpack_require__(/*! ./parsers/DayPeriodParser.js */ "./node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js");
var _Hour1to12Parser = __webpack_require__(/*! ./parsers/Hour1to12Parser.js */ "./node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js");
var _Hour0to23Parser = __webpack_require__(/*! ./parsers/Hour0to23Parser.js */ "./node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js");
var _Hour0To11Parser = __webpack_require__(/*! ./parsers/Hour0To11Parser.js */ "./node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js");
var _Hour1To24Parser = __webpack_require__(/*! ./parsers/Hour1To24Parser.js */ "./node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js");
var _MinuteParser = __webpack_require__(/*! ./parsers/MinuteParser.js */ "./node_modules/date-fns/parse/_lib/parsers/MinuteParser.js");
var _SecondParser = __webpack_require__(/*! ./parsers/SecondParser.js */ "./node_modules/date-fns/parse/_lib/parsers/SecondParser.js");
var _FractionOfSecondParser = __webpack_require__(/*! ./parsers/FractionOfSecondParser.js */ "./node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js");
var _ISOTimezoneWithZParser = __webpack_require__(/*! ./parsers/ISOTimezoneWithZParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js");
var _ISOTimezoneParser = __webpack_require__(/*! ./parsers/ISOTimezoneParser.js */ "./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js");
var _TimestampSecondsParser = __webpack_require__(/*! ./parsers/TimestampSecondsParser.js */ "./node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js");
var _TimestampMillisecondsParser = __webpack_require__(/*! ./parsers/TimestampMillisecondsParser.js */ "./node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js");

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any -- It's ok, we want any here
const parsers = (exports.parsers = {
  G: new _EraParser.EraParser(),
  y: new _YearParser.YearParser(),
  Y: new _LocalWeekYearParser.LocalWeekYearParser(),
  R: new _ISOWeekYearParser.ISOWeekYearParser(),
  u: new _ExtendedYearParser.ExtendedYearParser(),
  Q: new _QuarterParser.QuarterParser(),
  q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
  M: new _MonthParser.MonthParser(),
  L: new _StandAloneMonthParser.StandAloneMonthParser(),
  w: new _LocalWeekParser.LocalWeekParser(),
  I: new _ISOWeekParser.ISOWeekParser(),
  d: new _DateParser.DateParser(),
  D: new _DayOfYearParser.DayOfYearParser(),
  E: new _DayParser.DayParser(),
  e: new _LocalDayParser.LocalDayParser(),
  c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
  i: new _ISODayParser.ISODayParser(),
  a: new _AMPMParser.AMPMParser(),
  b: new _AMPMMidnightParser.AMPMMidnightParser(),
  B: new _DayPeriodParser.DayPeriodParser(),
  h: new _Hour1to12Parser.Hour1to12Parser(),
  H: new _Hour0to23Parser.Hour0to23Parser(),
  K: new _Hour0To11Parser.Hour0To11Parser(),
  k: new _Hour1To24Parser.Hour1To24Parser(),
  m: new _MinuteParser.MinuteParser(),
  s: new _SecondParser.SecondParser(),
  S: new _FractionOfSecondParser.FractionOfSecondParser(),
  X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
  x: new _ISOTimezoneParser.ISOTimezoneParser(),
  t: new _TimestampSecondsParser.TimestampSecondsParser(),
  T: new _TimestampMillisecondsParser.TimestampMillisecondsParser(),
});


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.AMPMMidnightParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class AMPMMidnightParser extends _Parser.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "bbbbb":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}
exports.AMPMMidnightParser = AMPMMidnightParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/AMPMParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/AMPMParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.AMPMParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class AMPMParser extends _Parser.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "aaaaa":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}
exports.AMPMParser = AMPMParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/DateParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/DateParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.DateParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
  31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
];

// Day of the month
class DateParser extends _Parser.Parser {
  priority = 90;
  subPriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "d":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.date,
          dateString,
        );
      case "do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = (0, _utils.isLeapYearIndex)(year);
    const month = date.getMonth();
    if (isLeapYear) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }

  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.DateParser = DateParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.DayOfYearParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class DayOfYearParser extends _Parser.Parser {
  priority = 90;

  subpriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "D":
      case "DD":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.dayOfYear,
          dateString,
        );
      case "Do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = (0, _utils.isLeapYearIndex)(year);
    if (isLeapYear) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }

  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.DayOfYearParser = DayOfYearParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/DayParser.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/DayParser.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.DayParser = void 0;
var _index = __webpack_require__(/*! ../../../setDay.js */ "./node_modules/date-fns/setDay.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

// Day of week
class DayParser extends _Parser.Parser {
  priority = 90;

  parse(dateString, token, match) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "EEEEE":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "EEEE":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}
exports.DayParser = DayParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.DayPeriodParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// in the morning, in the afternoon, in the evening, at night
class DayPeriodParser extends _Parser.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "BBBBB":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "t", "T"];
}
exports.DayPeriodParser = DayPeriodParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/EraParser.js":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/EraParser.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.EraParser = void 0;

var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

class EraParser extends _Parser.Parser {
  priority = 140;

  parse(dateString, token, match) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return (
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );

      // A, B
      case "GGGGG":
        return match.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return (
          match.era(dateString, { width: "wide" }) ||
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );
    }
  }

  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["R", "u", "t", "T"];
}
exports.EraParser = EraParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ExtendedYearParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class ExtendedYearParser extends _Parser.Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "u") {
      return (0, _utils.parseNDigitsSigned)(4, dateString);
    }

    return (0, _utils.parseNDigitsSigned)(token.length, dateString);
  }

  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}
exports.ExtendedYearParser = ExtendedYearParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.FractionOfSecondParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class FractionOfSecondParser extends _Parser.Parser {
  priority = 30;

  parse(dateString, token) {
    const valueCallback = (value) =>
      Math.trunc(value * Math.pow(10, -token.length + 3));
    return (0, _utils.mapValue)(
      (0, _utils.parseNDigits)(token.length, dateString),
      valueCallback,
    );
  }

  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
exports.FractionOfSecondParser = FractionOfSecondParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.Hour0To11Parser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class Hour0To11Parser extends _Parser.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "K":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.hour11h,
          dateString,
        );
      case "Ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["h", "H", "k", "t", "T"];
}
exports.Hour0To11Parser = Hour0To11Parser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.Hour0to23Parser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class Hour0to23Parser extends _Parser.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "H":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.hour23h,
          dateString,
        );
      case "Ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 23;
  }

  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}
exports.Hour0to23Parser = Hour0to23Parser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.Hour1To24Parser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class Hour1To24Parser extends _Parser.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "k":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.hour24h,
          dateString,
        );
      case "ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 24;
  }

  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}
exports.Hour1To24Parser = Hour1To24Parser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.Hour1to12Parser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class Hour1to12Parser extends _Parser.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "h":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.hour12h,
          dateString,
        );
      case "ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 12;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["H", "K", "k", "t", "T"];
}
exports.Hour1to12Parser = Hour1to12Parser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ISODayParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ISODayParser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ISODayParser = void 0;
var _index = __webpack_require__(/*! ../../../setISODay.js */ "./node_modules/date-fns/setISODay.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// ISO day of week
class ISODayParser extends _Parser.Parser {
  priority = 90;

  parse(dateString, token, match) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };

    switch (token) {
      // 2
      case "i":
      case "ii": // 02
        return (0, _utils.parseNDigits)(token.length, dateString);
      // 2nd
      case "io":
        return match.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return (0, _utils.mapValue)(
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // T
      case "iiiii":
        return (0, _utils.mapValue)(
          match.day(dateString, {
            width: "narrow",
            context: "formatting",
          }),
          valueCallback,
        );
      // Tu
      case "iiiiii":
        return (0, _utils.mapValue)(
          match.day(dateString, {
            width: "short",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // Tuesday
      case "iiii":
      default:
        return (0, _utils.mapValue)(
          match.day(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 7;
  }

  set(date, _flags, value) {
    date = (0, _index.setISODay)(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.ISODayParser = ISODayParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ISOTimezoneParser = void 0;
var _index = __webpack_require__(/*! ../../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ../../../_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Timezone (ISO-8601)
class ISOTimezoneParser extends _Parser.Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "x":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "xx":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basic,
          dateString,
        );
      case "xxxx":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "xxxxx":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "xxx":
      default:
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.extended,
          dateString,
        );
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return (0, _index.constructFrom)(
      date,
      date.getTime() -
        (0, _index2.getTimezoneOffsetInMilliseconds)(date) -
        value,
    );
  }

  incompatibleTokens = ["t", "T", "X"];
}
exports.ISOTimezoneParser = ISOTimezoneParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ISOTimezoneWithZParser = void 0;
var _index = __webpack_require__(/*! ../../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ../../../_lib/getTimezoneOffsetInMilliseconds.js */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js");
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Timezone (ISO-8601. +00:00 is `'Z'`)
class ISOTimezoneWithZParser extends _Parser.Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "X":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "XX":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basic,
          dateString,
        );
      case "XXXX":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "XXXXX":
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "XXX":
      default:
        return (0, _utils.parseTimezonePattern)(
          _constants.timezonePatterns.extended,
          dateString,
        );
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return (0, _index.constructFrom)(
      date,
      date.getTime() -
        (0, _index2.getTimezoneOffsetInMilliseconds)(date) -
        value,
    );
  }

  incompatibleTokens = ["t", "T", "x"];
}
exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ISOWeekParser = void 0;
var _index = __webpack_require__(/*! ../../../setISOWeek.js */ "./node_modules/date-fns/setISOWeek.js");
var _index2 = __webpack_require__(/*! ../../../startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// ISO week of year
class ISOWeekParser extends _Parser.Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "I":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.week,
          dateString,
        );
      case "Io":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value) {
    return (0, _index2.startOfISOWeek)((0, _index.setISOWeek)(date, value));
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.ISOWeekParser = ISOWeekParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.ISOWeekYearParser = void 0;
var _index = __webpack_require__(/*! ../../../startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index2 = __webpack_require__(/*! ../../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// ISO week-numbering year
class ISOWeekYearParser extends _Parser.Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "R") {
      return (0, _utils.parseNDigitsSigned)(4, dateString);
    }

    return (0, _utils.parseNDigitsSigned)(token.length, dateString);
  }

  set(date, _flags, value) {
    const firstWeekOfYear = (0, _index2.constructFrom)(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return (0, _index.startOfISOWeek)(firstWeekOfYear);
  }

  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.ISOWeekYearParser = ISOWeekYearParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.LocalDayParser = void 0;
var _index = __webpack_require__(/*! ../../../setDay.js */ "./node_modules/date-fns/setDay.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Local day of week
class LocalDayParser extends _Parser.Parser {
  priority = 90;
  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "e":
      case "ee": // 03
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback,
        );
      // 3rd
      case "eo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "eee":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "eeeee":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "eeee":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T",
  ];
}
exports.LocalDayParser = LocalDayParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.LocalWeekParser = void 0;
var _index = __webpack_require__(/*! ../../../setWeek.js */ "./node_modules/date-fns/setWeek.js");
var _index2 = __webpack_require__(/*! ../../../startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Local week of year
class LocalWeekParser extends _Parser.Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "w":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.week,
          dateString,
        );
      case "wo":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value, options) {
    return (0, _index2.startOfWeek)(
      (0, _index.setWeek)(date, value, options),
      options,
    );
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}
exports.LocalWeekParser = LocalWeekParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.LocalWeekYearParser = void 0;
var _index = __webpack_require__(/*! ../../../getWeekYear.js */ "./node_modules/date-fns/getWeekYear.js");

var _index2 = __webpack_require__(/*! ../../../startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Local week-numbering year
class LocalWeekYearParser extends _Parser.Parser {
  priority = 130;

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY",
    });

    switch (token) {
      case "Y":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(4, dateString),
          valueCallback,
        );
      case "Yo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value, options) {
    const currentYear = (0, _index.getWeekYear)(date, options);

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
        value.year,
        currentYear,
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate,
      );
      date.setHours(0, 0, 0, 0);
      return (0, _index2.startOfWeek)(date, options);
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return (0, _index2.startOfWeek)(date, options);
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}
exports.LocalWeekYearParser = LocalWeekYearParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/MinuteParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/MinuteParser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.MinuteParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class MinuteParser extends _Parser.Parser {
  priority = 60;

  parse(dateString, token, match) {
    switch (token) {
      case "m":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.minute,
          dateString,
        );
      case "mo":
        return match.ordinalNumber(dateString, { unit: "minute" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
exports.MinuteParser = MinuteParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/MonthParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/MonthParser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.MonthParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class MonthParser extends _Parser.Parser {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];

  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return (0, _utils.mapValue)(
          (0, _utils.parseNumericPattern)(
            _constants.numericPatterns.month,
            dateString,
          ),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "MM":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(2, dateString),
          valueCallback,
        );
      // 1st, 2nd, ..., 12th
      case "Mo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );

      // J, F, ..., D
      case "MMMMM":
        return match.month(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return (
          match.month(dateString, { width: "wide", context: "formatting" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
exports.MonthParser = MonthParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/QuarterParser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/QuarterParser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.QuarterParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class QuarterParser extends _Parser.Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ": // 01, 02, 03, 04
        return (0, _utils.parseNDigits)(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match.quarter(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.QuarterParser = QuarterParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/SecondParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/SecondParser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.SecondParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class SecondParser extends _Parser.Parser {
  priority = 50;

  parse(dateString, token, match) {
    switch (token) {
      case "s":
        return (0, _utils.parseNumericPattern)(
          _constants.numericPatterns.second,
          dateString,
        );
      case "so":
        return match.ordinalNumber(dateString, { unit: "second" });
      default:
        return (0, _utils.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
exports.SecondParser = SecondParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.StandAloneLocalDayParser = void 0;
var _index = __webpack_require__(/*! ../../../setDay.js */ "./node_modules/date-fns/setDay.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// Stand-alone local day of week
class StandAloneLocalDayParser extends _Parser.Parser {
  priority = 90;

  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "c":
      case "cc": // 03
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback,
        );
      // 3rd
      case "co":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "ccc":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // T
      case "ccccc":
        return match.day(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return (
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // Tuesday
      case "cccc":
      default:
        return (
          match.day(dateString, { width: "wide", context: "standalone" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T",
  ];
}
exports.StandAloneLocalDayParser = StandAloneLocalDayParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.StandAloneMonthParser = void 0;
var _constants = __webpack_require__(/*! ../constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class StandAloneMonthParser extends _Parser.Parser {
  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return (0, _utils.mapValue)(
          (0, _utils.parseNumericPattern)(
            _constants.numericPatterns.month,
            dateString,
          ),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "LL":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(2, dateString),
          valueCallback,
        );
      // 1st, 2nd, ..., 12th
      case "Lo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );

      // J, F, ..., D
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return (
          match.month(dateString, { width: "wide", context: "standalone" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.StandAloneMonthParser = StandAloneMonthParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.StandAloneQuarterParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class StandAloneQuarterParser extends _Parser.Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq": // 01, 02, 03, 04
        return (0, _utils.parseNDigits)(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.StandAloneQuarterParser = StandAloneQuarterParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.TimestampMillisecondsParser = void 0;
var _index = __webpack_require__(/*! ../../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class TimestampMillisecondsParser extends _Parser.Parser {
  priority = 20;

  parse(dateString) {
    return (0, _utils.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [(0, _index.constructFrom)(date, value), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}
exports.TimestampMillisecondsParser = TimestampMillisecondsParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.TimestampSecondsParser = void 0;
var _index = __webpack_require__(/*! ../../../constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

class TimestampSecondsParser extends _Parser.Parser {
  priority = 40;

  parse(dateString) {
    return (0, _utils.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [
      (0, _index.constructFrom)(date, value * 1000),
      { timestampIsSet: true },
    ];
  }

  incompatibleTokens = "*";
}
exports.TimestampSecondsParser = TimestampSecondsParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/parsers/YearParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/parsers/YearParser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.YearParser = void 0;
var _Parser = __webpack_require__(/*! ../Parser.js */ "./node_modules/date-fns/parse/_lib/Parser.js");

var _utils = __webpack_require__(/*! ../utils.js */ "./node_modules/date-fns/parse/_lib/utils.js");

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
class YearParser extends _Parser.Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy",
    });

    switch (token) {
      case "y":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(4, dateString),
          valueCallback,
        );
      case "yo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value) {
    const currentYear = date.getFullYear();

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
        value.year,
        currentYear,
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
exports.YearParser = YearParser;


/***/ }),

/***/ "./node_modules/date-fns/parse/_lib/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/parse/_lib/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
exports.isLeapYearIndex = isLeapYearIndex;
exports.mapValue = mapValue;
exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
exports.parseNDigits = parseNDigits;
exports.parseNDigitsSigned = parseNDigitsSigned;
exports.parseNumericPattern = parseNumericPattern;
exports.parseTimezonePattern = parseTimezonePattern;
var _index = __webpack_require__(/*! ../../constants.js */ "./node_modules/date-fns/constants.js");

var _constants = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/parse/_lib/constants.js");

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest,
  };
}

function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1),
    };
  }

  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

  return {
    value:
      sign *
      (hours * _index.millisecondsInHour +
        minutes * _index.millisecondsInMinute +
        seconds * _index.millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(
    _constants.numericPatterns.anyDigitsSigned,
    dateString,
  );
}

function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants.numericPatterns.singleDigit,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants.numericPatterns.twoDigits,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants.numericPatterns.threeDigits,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants.numericPatterns.fourDigits,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}

function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants.numericPatterns.singleDigitSigned,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants.numericPatterns.twoDigitsSigned,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants.numericPatterns.threeDigitsSigned,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants.numericPatterns.fourDigitsSigned,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}

function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}


/***/ }),

/***/ "./node_modules/date-fns/parseISO.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/parseISO.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.parseISO = parseISO;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * The {@link parseISO} function options.
 */

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  const additionalDigits = options?.additionalDigits ?? 2;
  const dateStrings = splitDateString(argument);

  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }

  const timestamp = date.getTime();
  let time = 0;
  let offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time);
    // JS parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.
    const result = new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate(),
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds(),
    );
    return result;
  }

  return new Date(timestamp + time + offset);
}

const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/,
};

const dateRegex =
  /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex =
  /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length,
      );
    }
  }

  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" +
      (4 + additionalDigits) +
      "})|(\\d{2}|[+-]\\d{" +
      (2 + additionalDigits) +
      "})$)",
  );

  const captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return { year: NaN, restDateString: "" };

  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length),
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);

  const captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);

  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (
      !validateDate(year, month, day) ||
      !validateDayOfYearDate(year, dayOfYear)
    ) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return (
    hours * _index.millisecondsInHour +
    minutes * _index.millisecondsInMinute +
    seconds * 1000
  );
}

function parseTimeUnit(value) {
  return (value && parseFloat(value.replace(",", "."))) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;

  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;

  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = (captures[3] && parseInt(captures[3])) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return (
    sign *
    (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute)
  );
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

function validateDate(year, month, date) {
  return (
    month >= 0 &&
    month <= 11 &&
    date >= 1 &&
    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
  );
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return (
    seconds >= 0 &&
    seconds < 60 &&
    minutes >= 0 &&
    minutes < 60 &&
    hours >= 0 &&
    hours < 25
  );
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}


/***/ }),

/***/ "./node_modules/date-fns/parseJSON.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/parseJSON.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.parseJSON = parseJSON; /**
 * @name parseJSON
 * @category Common Helpers
 * @summary Parse a JSON date string
 *
 * @description
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 *
 * @returns The parsed date in the local time zone
 */
function parseJSON(dateStr) {
  const parts = dateStr.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
  );
  if (parts) {
    // Group 8 matches the sign
    return new Date(
      Date.UTC(
        +parts[1],
        +parts[2] - 1,
        +parts[3],
        +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
        +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
        +parts[6],
        +((parts[7] || "0") + "00").substring(0, 3),
      ),
    );
  }
  return new Date(NaN);
}


/***/ }),

/***/ "./node_modules/date-fns/previousDay.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/previousDay.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousDay = previousDay;
var _index = __webpack_require__(/*! ./getDay.js */ "./node_modules/date-fns/getDay.js");
var _index2 = __webpack_require__(/*! ./subDays.js */ "./node_modules/date-fns/subDays.js");

/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - The day of the week
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
function previousDay(date, day) {
  let delta = (0, _index.getDay)(date) - day;
  if (delta <= 0) delta += 7;

  return (0, _index2.subDays)(date, delta);
}


/***/ }),

/***/ "./node_modules/date-fns/previousFriday.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/previousFriday.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousFriday = previousFriday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
function previousFriday(date) {
  return (0, _index.previousDay)(date, 5);
}


/***/ }),

/***/ "./node_modules/date-fns/previousMonday.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/previousMonday.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousMonday = previousMonday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
function previousMonday(date) {
  return (0, _index.previousDay)(date, 1);
}


/***/ }),

/***/ "./node_modules/date-fns/previousSaturday.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/previousSaturday.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousSaturday = previousSaturday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
function previousSaturday(date) {
  return (0, _index.previousDay)(date, 6);
}


/***/ }),

/***/ "./node_modules/date-fns/previousSunday.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/previousSunday.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousSunday = previousSunday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
function previousSunday(date) {
  return (0, _index.previousDay)(date, 0);
}


/***/ }),

/***/ "./node_modules/date-fns/previousThursday.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/previousThursday.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousThursday = previousThursday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
function previousThursday(date) {
  return (0, _index.previousDay)(date, 4);
}


/***/ }),

/***/ "./node_modules/date-fns/previousTuesday.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/previousTuesday.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousTuesday = previousTuesday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
function previousTuesday(date) {
  return (0, _index.previousDay)(date, 2);
}


/***/ }),

/***/ "./node_modules/date-fns/previousWednesday.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/previousWednesday.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.previousWednesday = previousWednesday;
var _index = __webpack_require__(/*! ./previousDay.js */ "./node_modules/date-fns/previousDay.js");

/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
function previousWednesday(date) {
  return (0, _index.previousDay)(date, 3);
}


/***/ }),

/***/ "./node_modules/date-fns/quartersToMonths.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/quartersToMonths.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.quartersToMonths = quartersToMonths;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
function quartersToMonths(quarters) {
  return Math.trunc(quarters * _index.monthsInQuarter);
}


/***/ }),

/***/ "./node_modules/date-fns/quartersToYears.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/quartersToYears.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.quartersToYears = quartersToYears;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
function quartersToYears(quarters) {
  const years = quarters / _index.quartersInYear;
  return Math.trunc(years);
}


/***/ }),

/***/ "./node_modules/date-fns/roundToNearestHours.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/roundToNearestHours.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.roundToNearestHours = roundToNearestHours;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link roundToNearestHours} function options.
 */

/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00

 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00

* @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
function roundToNearestHours(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 12)
    return (0, _index2.constructFrom)(date, NaN);

  const _date = (0, _index3.toDate)(date);
  const fractionalMinutes = _date.getMinutes() / 60;
  const fractionalSeconds = _date.getSeconds() / 60 / 60;
  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60 / 60;
  const hours =
    _date.getHours() +
    fractionalMinutes +
    fractionalSeconds +
    fractionalMilliseconds;

  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index.getRoundingMethod)(method);

  // nearestTo option does not care daylight savings time
  const roundedHours = roundingMethod(hours / nearestTo) * nearestTo;

  const result = (0, _index2.constructFrom)(date, _date);
  result.setHours(roundedHours, 0, 0, 0);
  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/roundToNearestMinutes.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/roundToNearestMinutes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.roundToNearestMinutes = roundToNearestMinutes;
var _index = __webpack_require__(/*! ./_lib/getRoundingMethod.js */ "./node_modules/date-fns/_lib/getRoundingMethod.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link roundToNearestMinutes} function options.
 */

/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
function roundToNearestMinutes(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 30)
    return (0, _index2.constructFrom)(date, NaN);

  const _date = (0, _index3.toDate)(date);
  const fractionalSeconds = _date.getSeconds() / 60;
  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60;
  const minutes =
    _date.getMinutes() + fractionalSeconds + fractionalMilliseconds;

  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index.getRoundingMethod)(method);

  const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;

  const result = (0, _index2.constructFrom)(date, _date);
  result.setMinutes(roundedMinutes, 0, 0);
  return result;
}


/***/ }),

/***/ "./node_modules/date-fns/secondsToHours.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/secondsToHours.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.secondsToHours = secondsToHours;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
function secondsToHours(seconds) {
  const hours = seconds / _index.secondsInHour;
  return Math.trunc(hours);
}


/***/ }),

/***/ "./node_modules/date-fns/secondsToMilliseconds.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/secondsToMilliseconds.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.secondsToMilliseconds = secondsToMilliseconds;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
function secondsToMilliseconds(seconds) {
  return seconds * _index.millisecondsInSecond;
}


/***/ }),

/***/ "./node_modules/date-fns/secondsToMinutes.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/secondsToMinutes.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.secondsToMinutes = secondsToMinutes;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
function secondsToMinutes(seconds) {
  const minutes = seconds / _index.secondsInMinute;
  return Math.trunc(minutes);
}


/***/ }),

/***/ "./node_modules/date-fns/set.js":
/*!**************************************!*\
  !*** ./node_modules/date-fns/set.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.set = set;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./setMonth.js */ "./node_modules/date-fns/setMonth.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */

function set(date, values) {
  let _date = (0, _index3.toDate)(date);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) {
    return (0, _index.constructFrom)(date, NaN);
  }

  if (values.year != null) {
    _date.setFullYear(values.year);
  }

  if (values.month != null) {
    _date = (0, _index2.setMonth)(_date, values.month);
  }

  if (values.date != null) {
    _date.setDate(values.date);
  }

  if (values.hours != null) {
    _date.setHours(values.hours);
  }

  if (values.minutes != null) {
    _date.setMinutes(values.minutes);
  }

  if (values.seconds != null) {
    _date.setSeconds(values.seconds);
  }

  if (values.milliseconds != null) {
    _date.setMilliseconds(values.milliseconds);
  }

  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setDate.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/setDate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setDate = setDate;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
function setDate(date, dayOfMonth) {
  const _date = (0, _index.toDate)(date);
  _date.setDate(dayOfMonth);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setDay.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/setDay.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setDay = setDay;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index3 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link setDay} function options.
 */

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(date, day, options) {
  const defaultOptions = (0, _index3.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index2.toDate)(date);
  const currentDay = _date.getDay();

  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;

  const delta = 7 - weekStartsOn;
  const diff =
    day < 0 || day > 6
      ? day - ((currentDay + delta) % 7)
      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
  return (0, _index.addDays)(_date, diff);
}


/***/ }),

/***/ "./node_modules/date-fns/setDayOfYear.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/setDayOfYear.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setDayOfYear = setDayOfYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
function setDayOfYear(date, dayOfYear) {
  const _date = (0, _index.toDate)(date);
  _date.setMonth(0);
  _date.setDate(dayOfYear);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setDefaultOptions.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/setDefaultOptions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setDefaultOptions = setDefaultOptions;

var _index = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
function setDefaultOptions(options) {
  const result = {};
  const defaultOptions = (0, _index.getDefaultOptions)();

  for (const property in defaultOptions) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      result[property] = defaultOptions[property];
    }
  }

  for (const property in options) {
    if (Object.prototype.hasOwnProperty.call(options, property)) {
      if (options[property] === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        delete result[property];
      } else {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        result[property] = options[property];
      }
    }
  }

  (0, _index.setDefaultOptions)(result);
}


/***/ }),

/***/ "./node_modules/date-fns/setHours.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/setHours.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setHours = setHours;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
function setHours(date, hours) {
  const _date = (0, _index.toDate)(date);
  _date.setHours(hours);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setISODay.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/setISODay.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setISODay = setISODay;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");
var _index2 = __webpack_require__(/*! ./getISODay.js */ "./node_modules/date-fns/getISODay.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
function setISODay(date, day) {
  const _date = (0, _index3.toDate)(date);
  const currentDay = (0, _index2.getISODay)(_date);
  const diff = day - currentDay;
  return (0, _index.addDays)(_date, diff);
}


/***/ }),

/***/ "./node_modules/date-fns/setISOWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/setISOWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setISOWeek = setISOWeek;
var _index = __webpack_require__(/*! ./getISOWeek.js */ "./node_modules/date-fns/getISOWeek.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
function setISOWeek(date, week) {
  const _date = (0, _index2.toDate)(date);
  const diff = (0, _index.getISOWeek)(_date) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setISOWeekYear.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/setISOWeekYear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setISOWeekYear = setISOWeekYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index3 = __webpack_require__(/*! ./startOfISOWeekYear.js */ "./node_modules/date-fns/startOfISOWeekYear.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
function setISOWeekYear(date, weekYear) {
  let _date = (0, _index4.toDate)(date);
  const diff = (0, _index2.differenceInCalendarDays)(
    _date,
    (0, _index3.startOfISOWeekYear)(_date),
  );
  const fourthOfJanuary = (0, _index.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(weekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  _date = (0, _index3.startOfISOWeekYear)(fourthOfJanuary);
  _date.setDate(_date.getDate() + diff);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setMilliseconds.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/setMilliseconds.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setMilliseconds = setMilliseconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
function setMilliseconds(date, milliseconds) {
  const _date = (0, _index.toDate)(date);
  _date.setMilliseconds(milliseconds);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setMinutes.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/setMinutes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setMinutes = setMinutes;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
function setMinutes(date, minutes) {
  const _date = (0, _index.toDate)(date);
  _date.setMinutes(minutes);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setMonth.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/setMonth.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setMonth = setMonth;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./getDaysInMonth.js */ "./node_modules/date-fns/getDaysInMonth.js");
var _index3 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
function setMonth(date, month) {
  const _date = (0, _index3.toDate)(date);
  const year = _date.getFullYear();
  const day = _date.getDate();

  const dateWithDesiredMonth = (0, _index.constructFrom)(date, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = (0, _index2.getDaysInMonth)(dateWithDesiredMonth);
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setQuarter.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/setQuarter.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setQuarter = setQuarter;
var _index = __webpack_require__(/*! ./setMonth.js */ "./node_modules/date-fns/setMonth.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
function setQuarter(date, quarter) {
  const _date = (0, _index2.toDate)(date);
  const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
  const diff = quarter - oldQuarter;
  return (0, _index.setMonth)(_date, _date.getMonth() + diff * 3);
}


/***/ }),

/***/ "./node_modules/date-fns/setSeconds.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/setSeconds.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setSeconds = setSeconds;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
function setSeconds(date, seconds) {
  const _date = (0, _index.toDate)(date);
  _date.setSeconds(seconds);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setWeek.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/setWeek.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setWeek = setWeek;
var _index = __webpack_require__(/*! ./getWeek.js */ "./node_modules/date-fns/getWeek.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * The {@link setWeek} function options.
 */

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(date, week, options) {
  const _date = (0, _index2.toDate)(date);
  const diff = (0, _index.getWeek)(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setWeekYear.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/setWeekYear.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setWeekYear = setWeekYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./differenceInCalendarDays.js */ "./node_modules/date-fns/differenceInCalendarDays.js");
var _index3 = __webpack_require__(/*! ./startOfWeekYear.js */ "./node_modules/date-fns/startOfWeekYear.js");
var _index4 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index5 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link setWeekYear} function options.
 */

/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
function setWeekYear(date, weekYear, options) {
  const defaultOptions = (0, _index5.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  let _date = (0, _index4.toDate)(date);
  const diff = (0, _index2.differenceInCalendarDays)(
    _date,
    (0, _index3.startOfWeekYear)(_date, options),
  );
  const firstWeek = (0, _index.constructFrom)(date, 0);
  firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  _date = (0, _index3.startOfWeekYear)(firstWeek, options);
  _date.setDate(_date.getDate() + diff);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/setYear.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/setYear.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.setYear = setYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
function setYear(date, year) {
  const _date = (0, _index2.toDate)(date);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) {
    return (0, _index.constructFrom)(date, NaN);
  }

  _date.setFullYear(year);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfDay.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/startOfDay.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfDay = startOfDay;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(date) {
  const _date = (0, _index.toDate)(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfDecade.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/startOfDecade.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfDecade = startOfDecade;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
function startOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index.toDate)(date);
  const year = _date.getFullYear();
  const decade = Math.floor(year / 10) * 10;
  _date.setFullYear(decade, 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfHour.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/startOfHour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfHour = startOfHour;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
function startOfHour(date) {
  const _date = (0, _index.toDate)(date);
  _date.setMinutes(0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfISOWeek.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeek.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfISOWeek = startOfISOWeek;
var _index = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");

/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(date) {
  return (0, _index.startOfWeek)(date, { weekStartsOn: 1 });
}


/***/ }),

/***/ "./node_modules/date-fns/startOfISOWeekYear.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeekYear.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfISOWeekYear = startOfISOWeekYear;
var _index = __webpack_require__(/*! ./getISOWeekYear.js */ "./node_modules/date-fns/getISOWeekYear.js");
var _index2 = __webpack_require__(/*! ./startOfISOWeek.js */ "./node_modules/date-fns/startOfISOWeek.js");
var _index3 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(date) {
  const year = (0, _index.getISOWeekYear)(date);
  const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return (0, _index2.startOfISOWeek)(fourthOfJanuary);
}


/***/ }),

/***/ "./node_modules/date-fns/startOfMinute.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/startOfMinute.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfMinute = startOfMinute;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
function startOfMinute(date) {
  const _date = (0, _index.toDate)(date);
  _date.setSeconds(0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfMonth.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfMonth.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfMonth = startOfMonth;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth(date) {
  const _date = (0, _index.toDate)(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfQuarter.js":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/startOfQuarter.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfQuarter = startOfQuarter;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
function startOfQuarter(date) {
  const _date = (0, _index.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3);
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfSecond.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/startOfSecond.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfSecond = startOfSecond;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
function startOfSecond(date) {
  const _date = (0, _index.toDate)(date);
  _date.setMilliseconds(0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfToday.js":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfToday.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfToday = startOfToday;
var _index = __webpack_require__(/*! ./startOfDay.js */ "./node_modules/date-fns/startOfDay.js");

/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
function startOfToday() {
  return (0, _index.startOfDay)(Date.now());
}


/***/ }),

/***/ "./node_modules/date-fns/startOfTomorrow.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/startOfTomorrow.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.startOfTomorrow = startOfTomorrow; /**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @description
 * Return the start of tomorrow.
 *
 * @returns The start of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
function startOfTomorrow() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfWeek.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/startOfWeek.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfWeek = startOfWeek;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");

var _index2 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(date, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfWeekYear.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/startOfWeekYear.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfWeekYear = startOfWeekYear;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");
var _index2 = __webpack_require__(/*! ./getWeekYear.js */ "./node_modules/date-fns/getWeekYear.js");
var _index3 = __webpack_require__(/*! ./startOfWeek.js */ "./node_modules/date-fns/startOfWeek.js");

var _index4 = __webpack_require__(/*! ./_lib/defaultOptions.js */ "./node_modules/date-fns/_lib/defaultOptions.js");

/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(date, options) {
  const defaultOptions = (0, _index4.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = (0, _index2.getWeekYear)(date, options);
  const firstWeek = (0, _index.constructFrom)(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = (0, _index3.startOfWeek)(firstWeek, options);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfYear.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/startOfYear.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.startOfYear = startOfYear;
var _index = __webpack_require__(/*! ./toDate.js */ "./node_modules/date-fns/toDate.js");
var _index2 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(date) {
  const cleanDate = (0, _index.toDate)(date);
  const _date = (0, _index2.constructFrom)(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}


/***/ }),

/***/ "./node_modules/date-fns/startOfYesterday.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/startOfYesterday.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.startOfYesterday = startOfYesterday; /**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
function startOfYesterday() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}


/***/ }),

/***/ "./node_modules/date-fns/sub.js":
/*!**************************************!*\
  !*** ./node_modules/date-fns/sub.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.sub = sub;
var _index = __webpack_require__(/*! ./subDays.js */ "./node_modules/date-fns/subDays.js");
var _index2 = __webpack_require__(/*! ./subMonths.js */ "./node_modules/date-fns/subMonths.js");

var _index3 = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
function sub(date, duration) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  // Subtract years and months
  const dateWithoutMonths = (0, _index2.subMonths)(date, months + years * 12);

  // Subtract weeks and days
  const dateWithoutDays = (0, _index.subDays)(
    dateWithoutMonths,
    days + weeks * 7,
  );

  // Subtract hours, minutes and seconds
  const minutestoSub = minutes + hours * 60;
  const secondstoSub = seconds + minutestoSub * 60;
  const mstoSub = secondstoSub * 1000;
  const finalDate = (0, _index3.constructFrom)(
    date,
    dateWithoutDays.getTime() - mstoSub,
  );

  return finalDate;
}


/***/ }),

/***/ "./node_modules/date-fns/subBusinessDays.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/subBusinessDays.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subBusinessDays = subBusinessDays;
var _index = __webpack_require__(/*! ./addBusinessDays.js */ "./node_modules/date-fns/addBusinessDays.js");

/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Substract the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Substract the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Substract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
function subBusinessDays(date, amount) {
  return (0, _index.addBusinessDays)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subDays.js":
/*!******************************************!*\
  !*** ./node_modules/date-fns/subDays.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subDays = subDays;
var _index = __webpack_require__(/*! ./addDays.js */ "./node_modules/date-fns/addDays.js");

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
function subDays(date, amount) {
  return (0, _index.addDays)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subHours.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/subHours.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subHours = subHours;
var _index = __webpack_require__(/*! ./addHours.js */ "./node_modules/date-fns/addHours.js");

/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
function subHours(date, amount) {
  return (0, _index.addHours)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subISOWeekYears.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/subISOWeekYears.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subISOWeekYears = subISOWeekYears;
var _index = __webpack_require__(/*! ./addISOWeekYears.js */ "./node_modules/date-fns/addISOWeekYears.js");

/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
function subISOWeekYears(date, amount) {
  return (0, _index.addISOWeekYears)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subMilliseconds.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/subMilliseconds.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subMilliseconds = subMilliseconds;
var _index = __webpack_require__(/*! ./addMilliseconds.js */ "./node_modules/date-fns/addMilliseconds.js");

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 *
 * @returns The new date with the milliseconds subtracted
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */
function subMilliseconds(date, amount) {
  return (0, _index.addMilliseconds)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subMinutes.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/subMinutes.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subMinutes = subMinutes;
var _index = __webpack_require__(/*! ./addMinutes.js */ "./node_modules/date-fns/addMinutes.js");

/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
function subMinutes(date, amount) {
  return (0, _index.addMinutes)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subMonths.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/subMonths.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subMonths = subMonths;
var _index = __webpack_require__(/*! ./addMonths.js */ "./node_modules/date-fns/addMonths.js");

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths(date, amount) {
  return (0, _index.addMonths)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subQuarters.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/subQuarters.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subQuarters = subQuarters;
var _index = __webpack_require__(/*! ./addQuarters.js */ "./node_modules/date-fns/addQuarters.js");

/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
function subQuarters(date, amount) {
  return (0, _index.addQuarters)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subSeconds.js":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/subSeconds.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subSeconds = subSeconds;
var _index = __webpack_require__(/*! ./addSeconds.js */ "./node_modules/date-fns/addSeconds.js");

/**
 * @name subSeconds
 * @category Second Helpers
 * @summary Subtract the specified number of seconds from the given date.
 *
 * @description
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
function subSeconds(date, amount) {
  return (0, _index.addSeconds)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subWeeks.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/subWeeks.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subWeeks = subWeeks;
var _index = __webpack_require__(/*! ./addWeeks.js */ "./node_modules/date-fns/addWeeks.js");

/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
function subWeeks(date, amount) {
  return (0, _index.addWeeks)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/subYears.js":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/subYears.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.subYears = subYears;
var _index = __webpack_require__(/*! ./addYears.js */ "./node_modules/date-fns/addYears.js");

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
function subYears(date, amount) {
  return (0, _index.addYears)(date, -amount);
}


/***/ }),

/***/ "./node_modules/date-fns/toDate.js":
/*!*****************************************!*\
  !*** ./node_modules/date-fns/toDate.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.toDate = toDate;

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (
    argument instanceof Date ||
    (typeof argument === "object" && argStr === "[object Date]")
  ) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new argument.constructor(+argument);
  } else if (
    typeof argument === "number" ||
    argStr === "[object Number]" ||
    typeof argument === "string" ||
    argStr === "[object String]"
  ) {
    // TODO: Can we get rid of as?
    return new Date(argument);
  } else {
    // TODO: Can we get rid of as?
    return new Date(NaN);
  }
}


/***/ }),

/***/ "./node_modules/date-fns/transpose.js":
/*!********************************************!*\
  !*** ./node_modules/date-fns/transpose.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.transpose = transpose;
var _index = __webpack_require__(/*! ./constructFrom.js */ "./node_modules/date-fns/constructFrom.js");

/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam DateInputType - The input `Date` type derived from the passed argument.
 * @typeParam DateOutputType - The output `Date` type derived from the passed constructor.
 *
 * @param fromDate - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
function transpose(fromDate, constructor) {
  const date =
    constructor instanceof Date
      ? (0, _index.constructFrom)(constructor, 0)
      : new constructor(0);
  date.setFullYear(
    fromDate.getFullYear(),
    fromDate.getMonth(),
    fromDate.getDate(),
  );
  date.setHours(
    fromDate.getHours(),
    fromDate.getMinutes(),
    fromDate.getSeconds(),
    fromDate.getMilliseconds(),
  );
  return date;
}


/***/ }),

/***/ "./node_modules/date-fns/weeksToDays.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/weeksToDays.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.weeksToDays = weeksToDays;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
function weeksToDays(weeks) {
  return Math.trunc(weeks * _index.daysInWeek);
}


/***/ }),

/***/ "./node_modules/date-fns/yearsToDays.js":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/yearsToDays.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.yearsToDays = yearsToDays;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
function yearsToDays(years) {
  return Math.trunc(years * _index.daysInYear);
}


/***/ }),

/***/ "./node_modules/date-fns/yearsToMonths.js":
/*!************************************************!*\
  !*** ./node_modules/date-fns/yearsToMonths.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.yearsToMonths = yearsToMonths;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
function yearsToMonths(years) {
  return Math.trunc(years * _index.monthsInYear);
}


/***/ }),

/***/ "./node_modules/date-fns/yearsToQuarters.js":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/yearsToQuarters.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.yearsToQuarters = yearsToQuarters;
var _index = __webpack_require__(/*! ./constants.js */ "./node_modules/date-fns/constants.js");

/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
function yearsToQuarters(years) {
  return Math.trunc(years * _index.quartersInYear);
}


/***/ }),

/***/ "./src/style/main.css":
/*!****************************!*\
  !*** ./src/style/main.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./main.css */ "./node_modules/css-loader/dist/cjs.js!./src/style/main.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./assets/404.svg":
/*!************************!*\
  !*** ./assets/404.svg ***!
  \************************/
/***/ ((module) => {

module.exports = "<svg id=\"_0146_404_page_not_found_1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 500 500\" data-imageid=\"404-page-not-found-1-66\" imageName=\"404 Page Not Found 1\" class=\"illustrations_image\" style=\"width: 216px;\"><defs><style>.cls-1_404-page-not-found-1-66{fill:#fff;}.cls-2_404-page-not-found-1-66{opacity:.39;}.cls-2_404-page-not-found-1-66,.cls-3_404-page-not-found-1-66,.cls-4_404-page-not-found-1-66,.cls-5_404-page-not-found-1-66,.cls-6_404-page-not-found-1-66,.cls-7_404-page-not-found-1-66,.cls-8_404-page-not-found-1-66,.cls-9_404-page-not-found-1-66{fill:none;}.cls-10_404-page-not-found-1-66{fill:#f4a28c;}.cls-3_404-page-not-found-1-66{opacity:.58;}.cls-11_404-page-not-found-1-66{fill:#ce8172;}.cls-12_404-page-not-found-1-66{fill:#e6e6e6;}.cls-4_404-page-not-found-1-66{opacity:.03;}.cls-5_404-page-not-found-1-66{opacity:.73;}.cls-6_404-page-not-found-1-66{opacity:.08;}.cls-7_404-page-not-found-1-66{opacity:.31;}.cls-8_404-page-not-found-1-66{opacity:.3;}.cls-13_404-page-not-found-1-66{fill:#24285b;}.cls-14_404-page-not-found-1-66{fill:#000001;}.cls-9_404-page-not-found-1-66{opacity:.15;}.cls-15_404-page-not-found-1-66{fill:#ffd200;}.cls-16_404-page-not-found-1-66{fill:#68e1fd;}</style></defs><g id=\"bg_404-page-not-found-1-66\"><g class=\"cls-8_404-page-not-found-1-66\"><path class=\"cls-12_404-page-not-found-1-66\" d=\"m96.84,209.61c-39.29,7.63-67.06,44.93-62.48,86,2.43,21.79,12.28,41.01,37.6,46.57,67.2,14.75,320.84,70.29,370.68-25.94,38.85-75.01,15.7-126.93-20.39-159.43-36.09-32.5-110.85-25.75-172.64-3.51-46.05,16.57-80.21,42.24-152.77,56.32Z\"></path></g><g class=\"cls-4_404-page-not-found-1-66\"><ellipse class=\"cls-14_404-page-not-found-1-66\" cx=\"252.75\" cy=\"398.41\" rx=\"228.74\" ry=\"16.91\"></ellipse></g><path class=\"cls-12_404-page-not-found-1-66\" d=\"m438.94,154.97c0-5.3-4.3-9.61-9.61-9.61-.53,0-1.04.05-1.54.14-2.19-4.06-6.47-6.82-11.4-6.82-.16,0-.32.02-.47.02.3-1.19.47-2.44.47-3.73,0-8.49-6.88-15.37-15.37-15.37s-15.37,6.88-15.37,15.37c0,1.29.18,2.53.47,3.73-.16,0-.31-.02-.47-.02-7.15,0-12.95,5.8-12.95,12.95s5.8,12.95,12.95,12.95h44.94v-.09c4.71-.61,8.35-4.63,8.35-9.52Z\"></path><path class=\"cls-12_404-page-not-found-1-66\" d=\"m284.64,79.2c0-4.55-3.69-8.24-8.24-8.24-.45,0-.89.05-1.32.12-1.87-3.48-5.55-5.85-9.78-5.85-.14,0-.27.02-.41.02.26-1.02.41-2.09.41-3.19,0-7.28-5.9-13.18-13.18-13.18s-13.18,5.9-13.18,13.18c0,1.1.15,2.17.41,3.19-.14,0-.27-.02-.41-.02-6.13,0-11.1,4.97-11.1,11.1s4.97,11.1,11.1,11.1h38.54v-.08c4.04-.52,7.16-3.97,7.16-8.16Z\"></path><path class=\"cls-12_404-page-not-found-1-66\" d=\"m90.94,237.74c0-4.55-3.69-8.24-8.24-8.24-.45,0-.89.05-1.32.12-1.87-3.48-5.55-5.85-9.78-5.85-.14,0-.27.02-.41.02.26-1.02.41-2.09.41-3.19,0-7.28-5.9-13.18-13.18-13.18s-13.18,5.9-13.18,13.18c0,1.1.15,2.17.41,3.19-.14,0-.27-.02-.41-.02-6.13,0-11.1,4.97-11.1,11.1s4.97,11.1,11.1,11.1h38.54v-.08c4.04-.52,7.16-3.97,7.16-8.16Z\"></path></g><g id=\"sun_404-page-not-found-1-66\"><circle class=\"cls-15_404-page-not-found-1-66\" cx=\"132.6\" cy=\"103.97\" r=\"32.36\"></circle><g class=\"cls-9_404-page-not-found-1-66\"><circle class=\"cls-15_404-page-not-found-1-66\" cx=\"132.6\" cy=\"103.97\" r=\"61.7\"></circle></g></g><g id=\"_404_404-page-not-found-1-66\"><circle class=\"cls-13_404-page-not-found-1-66\" cx=\"249.97\" cy=\"315.23\" r=\"82.41\"></circle><circle class=\"cls-1_404-page-not-found-1-66\" cx=\"249.97\" cy=\"315.23\" r=\"51.88\"></circle><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m150.48,334.88c5.46,0,7.42,1.96,7.42,7.42v9.38c0,5.46-1.53,7.42-7.42,7.42h-15.06v28.59c0,5.46-1.96,7.42-7.42,7.42h-10.69c-5.46,0-7.42-1.96-7.42-7.42v-28.59H37.88c-5.46,0-7.42-1.96-7.42-7.42v-7.86c0-3.71.87-6.55,2.62-8.95l72.45-89.91c2.84-3.49,6.33-5.24,10.47-5.24h12c5.45,0,7.42,1.53,7.42,7.42v87.72h15.06Zm-40.59-58.48l-47.35,58.48h47.35v-58.48Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m462.13,334.88c5.46,0,7.42,1.96,7.42,7.42v9.38c0,5.46-1.53,7.42-7.42,7.42h-15.06v28.59c0,5.46-1.96,7.42-7.42,7.42h-10.69c-5.46,0-7.42-1.96-7.42-7.42v-28.59h-72.01c-5.46,0-7.42-1.96-7.42-7.42v-7.86c0-3.71.87-6.55,2.62-8.95l72.45-89.91c2.84-3.49,6.33-5.24,10.47-5.24h12c5.45,0,7.42,1.53,7.42,7.42v87.72h15.06Zm-40.59-58.48l-47.35,58.48h47.35v-58.48Z\" style=\"fill: rgb(0, 49, 83);\"></path><g class=\"cls-3_404-page-not-found-1-66\"><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m429.81,222.19s-13.71-3.75-16.7-16.51c0,0,21.25-4.29,21.85,17.64l-5.16-1.13Z\" style=\"fill: rgb(0, 49, 83);\"></path></g><g class=\"cls-5_404-page-not-found-1-66\"><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m431.49,220.83s-9.58-15.15-1.15-29.31c0,0,16.16,10.26,8.98,29.34l-7.83-.03Z\" style=\"fill: rgb(0, 49, 83);\"></path></g><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m433.96,220.84s5.06-16,20.36-19.03c0,0,2.87,10.39-9.91,19.07l-10.46-.04Z\" style=\"fill: rgb(0, 49, 83);\"></path><polygon class=\"cls-13_404-page-not-found-1-66\" points=\"424.02 220.48 426.79 239.5 444.3 239.57 446.88 220.57 424.02 220.48\"></polygon><path class=\"cls-10_404-page-not-found-1-66\" d=\"m259.94,207s2.26,10.89,1.28,18.42c-.4,3.06-3.25,5.24-6.3,4.8-3.79-.55-8.75-2.39-10.67-8.08l-4.44-9.25s-2.58-5.89,3.11-11.11c5.69-5.21,15.97-1.48,17.02,5.22Z\"></path><polygon class=\"cls-10_404-page-not-found-1-66\" points=\"240.61 214.57 239.17 250.97 259.29 250.33 252.26 224.1 240.61 214.57\"></polygon><path class=\"cls-13_404-page-not-found-1-66\" d=\"m257.26,207.79c-1.92.33-5.46.74-10.27.42,0,0,4.02,4.4,1.2,10.1-2.82,5.7-8.7,4.06-8.7,4.06l-1.5-14.2c-.57-4.13,1.15-8.24,4.51-10.7,1.37-1,2.9-2.02,4.46-2.87,3.89-2.12,10.19-.11,13.53-3.3,1.46-1.4,3.9-.71,4.43,1.24,1.15,4.24,1.18,11.12-4.37,14.17-1.02.56-2.14.88-3.28,1.07Z\"></path><path class=\"cls-10_404-page-not-found-1-66\" d=\"m249.33,217.84s-.59-4.24-3.74-3.53c-3.15.71-2.34,6.84,2.06,6.9l1.68-3.36Z\"></path><path class=\"cls-10_404-page-not-found-1-66\" d=\"m261.01,213.93l3.58,3.89c.88.96.47,2.51-.78,2.9l-4.13,1.3,1.32-8.09Z\"></path><g class=\"cls-7_404-page-not-found-1-66\"><path class=\"cls-11_404-page-not-found-1-66\" d=\"m254.04,229.78s-3.77-.31-6.92-3.09c0,0,1.07,6.58,9.11,12.25l-2.19-9.17Z\"></path></g><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m239.17,250.97l20.12-.64s31.59-5.37,42.56,20.4c10.97,25.77-3.1,62.19-3.1,62.19,0,0-11.39,38.45-59.52,34.18,0,0-40.05-2.32-44.57-57.21-.2-2.39-.59-4.77-1.1-7.11-1.86-8.59-2.93-34.64,45.61-51.81Z\" style=\"fill: rgb(0, 49, 83);\"></path><g class=\"cls-6_404-page-not-found-1-66\"><path class=\"cls-14_404-page-not-found-1-66\" d=\"m212.25,285.19s10.73,1.16,25.62,26.11c14.9,24.95,44.14,15.81,60.63-2.65l-30.66,40.48-34.27-2.74-18.64-49.62-2.69-11.58Z\"></path></g><rect class=\"cls-15_404-page-not-found-1-66\" x=\"324.94\" y=\"227.78\" width=\"5.94\" height=\"17.29\" transform=\"translate(-28.42 45.5) rotate(-7.61)\"></rect><g class=\"cls-6_404-page-not-found-1-66\"><rect class=\"cls-14_404-page-not-found-1-66\" x=\"324.94\" y=\"227.78\" width=\"5.94\" height=\"17.29\" transform=\"translate(-28.42 45.5) rotate(-7.61)\"></rect></g><rect class=\"cls-13_404-page-not-found-1-66\" x=\"325.4\" y=\"240.13\" width=\"9.14\" height=\"22.22\" transform=\"translate(-30.36 45.9) rotate(-7.61)\"></rect><path class=\"cls-15_404-page-not-found-1-66\" d=\"m321.4,191.96c-10.67,1.42-18.16,11.23-16.73,21.89,1.42,10.67,11.23,18.16,21.89,16.73,10.67-1.42,18.16-11.23,16.73-21.89-1.42-10.67-11.23-18.16-21.89-16.73Zm4.4,32.95c-7.53,1.01-14.46-4.29-15.46-11.82-1.01-7.53,4.29-14.46,11.82-15.46,7.53-1.01,14.46,4.29,15.46,11.82,1.01,7.53-4.29,14.46-11.82,15.46Z\"></path><circle class=\"cls-1_404-page-not-found-1-66\" cx=\"324.02\" cy=\"211.34\" r=\"13.84\"></circle><path class=\"cls-16_404-page-not-found-1-66 targetColor\" d=\"m194.14,287.88c2.15-8.5,13.49-10.15,18.11-2.69,5.76,9.31,13.32,23.02,19.41,39.27,11.51,30.7,67.98,10.46,88.82-61.11l11.89,7.38s-16.41,92.96-82.41,96.37c0,0-41.19,8.36-53.7-42.2,0,0-3.14-9.53-3.42-14.91l-.88-6.06s-.48-6.59,2.13-15.89c0,0,.01-.06.04-.17Z\" style=\"fill: rgb(0, 49, 83);\"></path><g class=\"cls-2_404-page-not-found-1-66\"><path class=\"cls-1_404-page-not-found-1-66\" d=\"m194.14,287.88c2.15-8.5,13.49-10.15,18.11-2.69,5.76,9.31,13.32,23.02,19.41,39.27,11.51,30.7,67.98,10.46,88.82-61.11l11.89,7.38s-16.41,92.96-82.41,96.37c0,0-41.19,8.36-53.7-42.2,0,0-3.14-9.53-3.42-14.91l-.88-6.06s-.48-6.59,2.13-15.89c0,0,.01-.06.04-.17Z\"></path></g><path class=\"cls-10_404-page-not-found-1-66\" d=\"m323.39,265.15s1.21-15.31,7.51-15.29c6.3.03,21.15,11.37-1.76,18.86l-5.75-3.57Z\"></path></g></svg>"

/***/ }),

/***/ "./assets/checklist-71.svg":
/*!*********************************!*\
  !*** ./assets/checklist-71.svg ***!
  \*********************************/
/***/ ((module) => {

module.exports = "<svg version=\"1.1\" id=\"_0020_checklist\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 500 500\" style=\"width: 213px;\" xml:space=\"preserve\" data-imageid=\"checklist-71\" imageName=\"Checklist\" class=\"illustrations_image\"><style type=\"text/css\"> .st0_checklist-71{fill:#FFFFFF;} .st1_checklist-71{fill:#231F20;} .st2_checklist-71{fill:#68E1FD;} .st3_checklist-71{fill:none;} </style><g id=\"Character_checklist-71\"><path class=\"st0_checklist-71\" d=\"M307.1,365.8c-18.2-13.4-25.2-37.7-24.9-60.2c0.1-11.4,2.2-23.5,10.1-31.7c3.8-3.9,8.7-6.6,13.8-8.8\n\t\tc16.1-7,37.6-8.1,48.9,5.4c3.3,4,5.3,8.8,7.2,13.6c6.7,16.7,12.8,33.6,18.2,50.8c5.3,16.9,11,43.5-12.9,45\n\t\tC348,381.1,323.1,377.5,307.1,365.8z\"></path><path class=\"st1_checklist-71\" d=\"M360.2,380.8c-17.5,0-39-3.7-53.5-14.4l0,0c-16.4-12-25.5-34.2-25.2-60.9c0.2-14.7,3.6-25.2,10.4-32.2\n\t\tc4.4-4.5,10.1-7.2,14-9c16.5-7.2,38.3-8.2,49.7,5.6c3.2,3.9,5.2,8.6,7.4,13.8c6.7,16.6,12.8,33.7,18.2,50.8\n\t\tc5.9,18.7,6.2,31.4,1.1,38.8c-3,4.4-8,6.8-14.7,7.2C365.2,380.8,362.7,380.8,360.2,380.8z M307.5,365.2\n\t\tc16.4,12,41.7,15.1,59.9,13.9c6.2-0.4,10.8-2.6,13.5-6.6c4.8-7,4.4-19.2-1.4-37.5c-5.3-17.1-11.4-34.1-18.1-50.7\n\t\tc-2.1-5.1-4-9.6-7.1-13.4c-10.9-13.2-32-12.2-48-5.2c-3.8,1.6-9.4,4.4-13.5,8.6c-6.5,6.7-9.8,16.9-9.9,31.2\n\t\tC282.6,331.7,291.6,353.4,307.5,365.2L307.5,365.2z\"></path><path class=\"st2_checklist-71 targetColor\" d=\"M116.7,280.5l-52.6-21.7c18.7-39.9,39.7-63.6,54.3-72.9c18.6-15.4,64.6-16.5,106.7-18.1c0,0,20-1.7,40.1,3.9\n\t\tc49.2,13.6,95,84.9,95,84.9l-59.6,8.1c0,0,7.7,72.1,14.5,159.9c0,0-77.2,17.4-197.9,10.6C117.1,435.2,117.8,293,116.7,280.5z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st0_checklist-71\" d=\"M230.6,160.7l6.6,31.7c0,0-7,21-28.3,18.8s-31.1-19.3-31.1-19.3l-7.6-58.2c0,0,14.2-10.2,5.2-42.8\n\t\tc0,0,24.4,8.3,54.6,0.3c0,0,14.2,34.7,13.8,51S230.6,160.7,230.6,160.7z\"></path><path class=\"st1_checklist-71\" d=\"M212,212c-1,0-2.1-0.1-3.1-0.2c-21.4-2.2-31.5-19.5-31.6-19.7c-0.1-0.1-0.1-0.2-0.1-0.3l-7.6-58.2\n\t\tc0-0.3,0.1-0.5,0.3-0.7c0.1-0.1,13.6-10.4,5-42c-0.1-0.3,0-0.6,0.2-0.7c0.2-0.2,0.5-0.3,0.8-0.2c0.2,0.1,24.6,8.1,54.1,0.3\n\t\tc0.4-0.1,0.8,0.1,0.9,0.4c0.6,1.4,14.2,35.1,13.9,51.3c-0.3,14.4-10.3,18.3-13.2,19.1l6.4,31c0,0.1,0,0.3,0,0.4\n\t\tC237.9,192.8,231.2,212,212,212z M178.6,191.5c0.9,1.5,10.7,16.8,30.4,18.8s26.7-15.9,27.4-18.1l-6.5-31.5c0-0.2,0-0.4,0.1-0.6\n\t\tc0.1-0.2,0.3-0.3,0.5-0.3c0.5-0.1,12.4-2.4,12.7-17.8c0.3-14.8-11.7-45.4-13.5-50.1c-17.4,4.5-35.6,4.5-53,0\n\t\tc7.6,29.2-3.3,40.1-5.5,42L178.6,191.5z\"></path><path class=\"st0_checklist-71\" d=\"M182.3,131c-1.1-2.7-3-5-5.5-6.6c-2.4-1.3-5-2.2-7.7-2.7c-1.4-0.4-3-0.5-4.4-0.2c-1,0.3-2,0.8-2.8,1.5\n\t\tc-2.1,1.4-3.6,3.5-4.3,5.9c-0.3,2-0.1,4,0.5,5.9c0.5,2.1,1.3,4.2,2.4,6.1c4.7,7.8,14.8,10.4,22.6,5.7c0.1,0,0.1-0.1,0.2-0.1\"></path><path class=\"st1_checklist-71\" d=\"M174.6,149.6c-6.1,0-11.7-3.2-14.8-8.4c-1.1-2-2-4-2.5-6.2c-0.7-2-0.9-4.2-0.5-6.3c0.7-2.6,2.3-4.8,4.6-6.3\n\t\tc0.9-0.7,1.9-1.3,3.1-1.6c1.6-0.3,3.2-0.2,4.8,0.2c2.8,0.4,5.5,1.4,8,2.8c2.7,1.6,4.7,4.1,5.9,7c0.1,0.4,0,0.8-0.4,1\n\t\tc-0.4,0.1-0.8,0-1-0.4c-1-2.6-2.9-4.8-5.2-6.2c-2.3-1.3-4.9-2.1-7.5-2.6c-1.3-0.4-2.7-0.4-4.1-0.2c-0.9,0.3-1.8,0.7-2.5,1.3\n\t\tc-1.9,1.3-3.3,3.2-4,5.4c-0.3,1.9-0.1,3.8,0.5,5.6c0.5,2.1,1.3,4,2.4,5.9c4.4,7.5,14.1,9.9,21.6,5.5c0.1,0,0.1-0.1,0.2-0.1\n\t\tc0.3-0.2,0.8-0.1,1,0.2c0.2,0.3,0.1,0.8-0.2,1C180.9,148.8,177.8,149.6,174.6,149.6z\"></path><path class=\"st1_checklist-71\" d=\"M233.2,176.5c0,0-11.8,3.5-22-4S201,159.7,201,159.7s15.7,6.1,28.9,1.5L233.2,176.5z\"></path><path class=\"st1_checklist-71\" d=\"M226.5,178.1c-5.7,0.1-11.2-1.7-15.8-5c-10.4-7.7-10.5-13.1-10.5-13.4c0-0.2,0.1-0.5,0.3-0.6\n\t\tc0.2-0.1,0.5-0.2,0.7-0.1c0.2,0.1,15.6,5.9,28.4,1.5c0.2-0.1,0.4,0,0.6,0.1c0.2,0.1,0.3,0.3,0.4,0.5l3.3,15.2\n\t\tc0.1,0.4-0.1,0.8-0.5,0.9C231.1,177.8,228.8,178.1,226.5,178.1z M202,160.9c0.6,1.9,2.6,5.8,9.6,11c8.4,6.2,18.1,4.7,20.7,4.1\n\t\tl-3-13.7C218.3,165.7,205.9,162.2,202,160.9z\"></path><path class=\"st0_checklist-71\" d=\"M211.7,113.3c0,0,13.5,14.2,11.4,17.4c-2.1,3.2-9.5,2.6-9.5,2.6\"></path><path class=\"st1_checklist-71\" d=\"M215,134.1c-0.9,0-1.4-0.1-1.5-0.1c-0.4,0-0.7-0.4-0.7-0.8s0.4-0.7,0.8-0.7c1.9,0.2,7.3,0.1,8.8-2.2\n\t\tc1.1-1.7-5-9.9-11.3-16.5c-0.3-0.3-0.3-0.8,0-1.1c0.3-0.3,0.8-0.3,1.1,0c3.3,3.4,13.7,14.9,11.5,18.3\n\t\tC222,133.7,217.4,134.1,215,134.1z\"></path><ellipse transform=\"matrix(0.9277 -0.3733 0.3733 0.9277 -29.3062 80.5707)\" class=\"st1_checklist-71\" cx=\"193.4\" cy=\"116\" rx=\"2.7\" ry=\"3.8\"></ellipse><ellipse transform=\"matrix(0.9277 -0.3733 0.3733 0.9277 -25.5794 90.684)\" class=\"st1_checklist-71\" cx=\"221.3\" cy=\"111.4\" rx=\"2.7\" ry=\"3.8\"></ellipse><path class=\"st1_checklist-71\" d=\"M213.6,152.8c-5.2,0-10-3.1-14-8.9c-2.3-3.4-4.1-7-5.4-10.9c-0.1-0.4,0.1-0.8,0.5-0.9c0.4-0.1,0.8,0.1,0.9,0.5\n\t\tc1.2,3.7,3,7.2,5.1,10.4c4.5,6.5,10,9.3,15.7,7.9c13.8-3.3,13.6-19.7,13.6-19.9c0-0.4,0.3-0.8,0.7-0.8c0,0,0,0,0,0\n\t\tc0.4,0,0.7,0.3,0.8,0.7c0,0.2,0.3,17.7-14.7,21.4C215.8,152.7,214.7,152.8,213.6,152.8z\"></path><path class=\"st0_checklist-71\" d=\"M135.4,267.7L110,328.1l56.6-48.9l36.1,12.2c0,0-8.1,53.8-57.3,99.1s-100.1,36.7-103-5.8s27-124.9,27-124.9\"></path><path class=\"st1_checklist-71\" d=\"M81.4,421.6c-5.8,0.1-11.6-1-17-3.1c-13.6-5.4-21.7-17.4-22.8-33.7c-2.9-42.2,26.8-124.4,27.1-125.2\n\t\tc0.1-0.4,0.6-0.6,1-0.5c0,0,0,0,0,0c0.4,0.1,0.6,0.6,0.5,0.9c0,0,0,0,0,0.1c-0.3,0.8-29.8,82.7-27,124.6\n\t\tc1.1,15.7,8.8,27.2,21.8,32.4c21.7,8.6,52.3-1.8,79.9-27.1c45.6-42.1,55.9-92,57-98.1l-35-11.9l-56.3,48.6\n\t\tc-0.3,0.3-0.8,0.2-1.1-0.1c-0.2-0.2-0.2-0.5-0.1-0.8l25.4-60.3c0.2-0.4,0.6-0.6,1-0.4c0,0,0,0,0,0c0.4,0.2,0.6,0.6,0.4,1\n\t\tc0,0,0,0,0,0l-24.3,57.4l54.2-46.8c0.2-0.2,0.5-0.2,0.7-0.1l36.1,12.2c0.3,0.1,0.6,0.5,0.5,0.8c-0.1,0.5-8.6,54.5-57.5,99.6\n\t\tC124.5,410.8,101.2,421.6,81.4,421.6z\"></path><polygon class=\"st1_checklist-71\" points=\"181.1,191.2 245.5,242.3 247.3,245.4 255.8,260.3 239.4,255.3 236,254.3 171.6,203.1 \t\"></polygon><path class=\"st1_checklist-71\" d=\"M255.8,261h-0.2l-19.8-6c-0.1,0-0.2-0.1-0.2-0.1l-64.4-51.2c-0.2-0.1-0.2-0.3-0.3-0.5c0-0.2,0-0.4,0.1-0.6\n\t\tl9.5-11.9c0.3-0.3,0.7-0.3,1-0.1l64.4,51.2c0.1,0.1,0.1,0.1,0.2,0.2l10.3,17.9c0.2,0.4,0.1,0.8-0.3,1C256.1,261,256,261,255.8,261\n\t\tL255.8,261z M236.4,253.6l17.8,5.4l-9.2-16.2l-63.7-50.6l-8.6,10.8L236.4,253.6z\"></path><polygon class=\"st2_checklist-71 targetColor\" points=\"247.3,245.4 255.8,260.3 239.4,255.3 \t\" style=\"fill: rgb(0, 49, 83);\"></polygon><path class=\"st1_checklist-71\" d=\"M255.8,261h-0.2l-16.4-5c-0.4-0.1-0.6-0.5-0.5-0.9c0-0.1,0.1-0.2,0.1-0.3l7.9-9.9c0.2-0.2,0.4-0.3,0.6-0.3\n\t\tc0.2,0,0.5,0.2,0.6,0.4l8.6,14.9c0.2,0.4,0.1,0.8-0.3,1C256.1,261,256,261,255.8,261z M240.7,254.9l13.6,4.1l-7.1-12.3L240.7,254.9\n\t\tz\"></path><path class=\"st1_checklist-71\" d=\"M156.1,190l8.8-11.1c0.8-1,2.2-1.2,3.2-0.4l0,0l31.8,25.2l0,0l-11.7,14.7l0,0l-31.8-25.2\n\t\tC155.5,192.5,155.3,191,156.1,190L156.1,190z\"></path><path class=\"st1_checklist-71\" d=\"M188.2,219.3c-0.2,0-0.3-0.1-0.5-0.2L156,193.9c-1.3-1-1.6-2.9-0.5-4.2c0,0,0,0,0.1-0.1l8.8-11.1\n\t\tc1.1-1.3,3-1.5,4.3-0.5l31.8,25.2c0.3,0.3,0.4,0.7,0.1,1.1c0,0,0,0,0,0L188.8,219C188.7,219.2,188.5,219.3,188.2,219.3L188.2,219.3\n\t\tz M166.7,178.8h-0.2c-0.4,0.1-0.8,0.3-1,0.6l-8.8,11.1l0,0c-0.3,0.3-0.4,0.7-0.3,1.1c0.1,0.4,0.3,0.8,0.6,1l31.2,24.8l10.7-13.4\n\t\tl-31.2-24.8C167.4,179,167.1,178.9,166.7,178.8z M156.1,190.1L156.1,190.1z\"></path><path class=\"st1_checklist-71\" d=\"M175.9,216.4c-0.2,0-0.3-0.1-0.5-0.2c-0.1-0.1-15.9-12.5-18-14.5c-2.6-2.4-1.5-7.3-1.4-7.9\n\t\tc0.1-0.4,0.5-0.6,0.9-0.6c0.4,0.1,0.6,0.5,0.5,0.9c0,0-1.1,4.5,0.9,6.4c1.9,1.7,15.9,12.8,17.9,14.4c0.3,0.3,0.4,0.7,0.1,1.1\n\t\tC176.4,216.2,176.2,216.3,175.9,216.4L175.9,216.4z\"></path><path class=\"st0_checklist-71\" d=\"M201.8,295.9c0.8-3.4,2.2-10.4,2.2-10.4s14.1,1.1,17.1-3.2s11.9-35.1,8.9-40.4s-14.3-12.5-17.8-13.9\n\t\ts-17.3,1.4-17.3,1.4l10.9-11c0,0,17.8,10.5,25.8,9.8s10.3-3.6,6.2-8.4s-34-18.2-39-17.6s-27.1,21.4-27.6,24.4s-17.5,60.6-13.9,67\"></path><path class=\"st1_checklist-71\" d=\"M201.8,296.6h-0.2c-0.4-0.1-0.6-0.5-0.5-0.9c0.8-3.3,2.2-10.3,2.2-10.4c0.1-0.4,0.4-0.6,0.8-0.6\n\t\tc3.8,0.3,14.2,0.4,16.4-2.9c1.4-2.1,4.4-10.9,6.6-19.6c2.6-10.3,3.5-17.9,2.3-20c-2.9-5.1-14.3-12.3-17.4-13.6\n\t\tc-2.6-1.1-13.1,0.6-16.9,1.4c-0.4,0.1-0.8-0.2-0.9-0.6c0-0.2,0-0.5,0.2-0.7l10.9-11c0.2-0.2,0.6-0.3,0.9-0.1\n\t\tc0.2,0.1,17.7,10.4,25.3,9.7c4.1-0.4,6.7-1.4,7.3-2.8s-0.6-3.1-1.7-4.4c-3.9-4.5-33.6-17.9-38.3-17.3s-26.5,20.9-27,23.8\n\t\tc-0.1,0.6-0.7,3-2,7.8c-4,14.8-14.7,53.9-11.9,58.7c0.2,0.4,0.1,0.8-0.3,1c-0.4,0.2-0.8,0.1-1-0.3l0,0c-2.7-4.7,4.4-32.9,11.8-59.9\n\t\tc1.1-3.9,1.9-7.1,2-7.6c0.5-3.5,23-24.3,28.2-25s35.3,12.8,39.7,17.8c1.9,2.3,2.6,4.3,1.9,5.9c-0.9,2.1-3.7,3.3-8.6,3.8\n\t\tc-7.4,0.6-22.7-7.9-25.7-9.6l-8.8,8.8c4.2-0.7,12.6-2,15.4-0.9c3.4,1.4,15.1,8.8,18.2,14.2c1.9,3.3-0.5,14.6-2.1,21.1\n\t\tc-2.2,9-5.2,17.8-6.8,20.1c-2.8,4.1-14,3.8-17.1,3.6c-0.4,1.8-1.4,7.1-2.1,9.8C202.5,296.4,202.2,296.6,201.8,296.6z\"></path><path class=\"st0_checklist-71\" d=\"M190.4,243c0,0,18.7-3.2,22.8-2s16,13.9,16,13.9\"></path><path class=\"st1_checklist-71\" d=\"M229.1,255.6c-0.2,0-0.4-0.1-0.6-0.2c-3.2-3.5-12.4-12.8-15.6-13.7s-17.3,1.2-22.5,2.1\n\t\tc-0.4,0.1-0.8-0.2-0.9-0.6c-0.1-0.4,0.2-0.8,0.6-0.9c0.8-0.1,18.9-3.2,23.1-2s15.8,13.6,16.3,14.1c0.3,0.3,0.3,0.8,0,1.1\n\t\tC229.5,255.6,229.3,255.7,229.1,255.6L229.1,255.6z\"></path><path class=\"st0_checklist-71\" d=\"M204,285.5c0,0,2.8-8.9,2.1-15.2\"></path><path class=\"st1_checklist-71\" d=\"M204,286.2c-0.1,0-0.1,0-0.2,0c-0.4-0.1-0.6-0.5-0.5-0.9c0-0.1,2.7-8.8,2.1-15c0-0.4,0.2-0.8,0.7-0.8\n\t\tc0,0,0,0,0,0c0.4,0,0.8,0.2,0.8,0.7c0.7,6.5-2,15.2-2.1,15.6C204.6,286,204.3,286.2,204,286.2z\"></path><path class=\"st0_checklist-71\" d=\"M193.8,270c0.9-0.2,16.6,0.2,17.6,0\"></path><path class=\"st1_checklist-71\" d=\"M209.1,270.8c-1.4,0-3.6,0-6.5-0.1c-3.6,0-8.1-0.1-8.6,0c-0.4,0.1-0.8-0.2-0.9-0.6c-0.1-0.4,0.2-0.8,0.5-0.9\n\t\tc0.5-0.1,3.1-0.1,9,0c3.6,0,8.1,0.1,8.6,0c0.4-0.1,0.8,0.2,0.9,0.6c0.1,0.4-0.1,0.8-0.5,0.9c0,0,0,0,0,0\n\t\tC210.7,270.8,209.9,270.8,209.1,270.8z\"></path><path class=\"st0_checklist-71\" d=\"M187.4,255.6c0,0,13.5-3,19.8-1.6s17.4,14.5,18.6,15.7\"></path><path class=\"st1_checklist-71\" d=\"M225.8,270.4c-0.2,0-0.4-0.1-0.5-0.2c-0.2-0.2-0.5-0.5-0.9-1c-3-3.3-11.9-13.3-17.3-14.4\n\t\tc-6.1-1.3-19.4,1.6-19.5,1.6c-0.4,0.1-0.8-0.1-0.9-0.5c-0.1-0.4,0.1-0.8,0.5-0.9c0,0,0.1,0,0.1,0c0.6-0.1,13.7-3,20.2-1.6\n\t\tc5.2,1.1,12.8,9,18.1,14.9c0.4,0.5,0.7,0.8,0.9,1c0.3,0.3,0.3,0.8,0,1.1C226.2,270.4,226,270.4,225.8,270.4z\"></path><line class=\"st3_checklist-71\" x1=\"110\" y1=\"328.1\" x2=\"82.3\" y2=\"349.3\"></line><path class=\"st1_checklist-71\" d=\"M82.3,350c-0.4,0-0.7-0.3-0.7-0.8c0-0.2,0.1-0.4,0.3-0.6l27.7-21.2c0.3-0.2,0.8-0.2,1,0.1\n\t\tc0.3,0.3,0.2,0.8-0.1,1c0,0,0,0,0,0l-27.6,21.2C82.6,350,82.5,350,82.3,350z\"></path><path class=\"st1_checklist-71\" d=\"M157.7,118.5c-0.3,0-0.6-0.2-0.7-0.6c-2.5-10.6-5-21.3-7.2-31.7l-0.2-1.1c-1-4.5-2.1-9.6-1.8-14.3\n\t\tc0.3-5.7,4.8-6.1,7.6-6c0.7-4.9,3.3-9.3,7.4-12.1c10.4-7.2,21.4-4,32-0.9c6.9,2,14,4.1,20.6,3.1c4.4-0.6,8.5-2.7,12.5-4.7h0.1\n\t\tc1.4-0.7,2.9-1.4,4.3-2.1c2.9-1.3,17.3-7.3,21.2,0.6c1.2,2.4,0.3,4.9-0.8,7c-1.4,2.9-3,5.7-4.8,8.4c0.9-0.5,1.9-0.9,2.9-1.3\n\t\tc3.9-1.7,8.3-1.8,12.3-0.3c1.7,0.7,3.2,1.8,4.2,3.4c2,3.2,1.2,7.4-2.4,12.4c-2,2.8-4.1,5.6-6.4,8.2c2.8-1.7,5.9-3.2,9.3-2.3\n\t\tc1.6,0.3,2.9,1.4,3.7,2.8c1.4,2.9-0.9,5.9-1.7,6.9c-6,7.9-13.7,14.4-22.4,19.2c-0.4,0.2-0.8,0.1-1-0.3s-0.1-0.8,0.3-1\n\t\tc0,0,0,0,0.1,0c8.5-4.6,16-11,21.9-18.8c0.6-0.8,2.5-3.3,1.5-5.4c-0.6-1-1.5-1.8-2.7-2c-3.4-0.9-6.5,1.1-9.5,3\n\t\tc-1,0.6-1.9,1.2-2.9,1.8c-0.4,0.2-0.8,0-1-0.3c-0.1-0.3-0.1-0.6,0.1-0.8c3.5-3.7,6.7-7.6,9.6-11.8c3.1-4.5,3.9-8.1,2.3-10.7\n\t\tc-0.8-1.3-2.1-2.2-3.5-2.8c-3.2-1.3-7.2-1.2-11.2,0.3c-1.9,0.8-3.8,1.7-5.5,2.9c-0.3,0.2-0.7,0.2-1-0.1c-0.2-0.3-0.3-0.7-0.1-0.9\n\t\tc2.4-3.5,4.6-7.2,6.5-11c0.9-1.8,1.6-3.9,0.8-5.7c-3.4-6.8-17.6-0.6-19.3,0.1c-1.4,0.6-2.9,1.3-4.2,2h-0.1c-4.1,2-8.4,4.2-13,4.8\n\t\tc-6.9,1-14.2-1.1-21.2-3.1c-10.3-3-21-6.1-30.8,0.7c-3.9,2.7-6.4,7-6.8,11.7c-0.1,0.4-0.4,0.7-0.8,0.7c-3.4-0.1-6.4,0.2-6.7,4.6\n\t\ts0.9,9.6,1.9,14l0.2,1.1c2.3,10.5,4.7,21.1,7.2,31.7c0.1,0.4-0.1,0.8-0.5,0.9c0,0,0,0,0,0C157.8,118.5,157.8,118.5,157.7,118.5z\"></path><path class=\"st0_checklist-71\" d=\"M163.2,197.4c-0.4,0-0.8-0.4-0.7-0.8c0-0.2,0.1-0.3,0.2-0.5l10.1-12.2c0.3-0.3,0.8-0.4,1.1-0.1\n\t\ts0.4,0.8,0.1,1.1l0,0l-10.1,12.2C163.7,197.3,163.5,197.4,163.2,197.4z\"></path><line class=\"st3_checklist-71\" x1=\"255.4\" y1=\"259.8\" x2=\"257.5\" y2=\"261.5\"></line><path class=\"st1_checklist-71\" d=\"M257.5,262.2c-0.2,0-0.3-0.1-0.5-0.2l-2.1-1.6c-0.3-0.2-0.4-0.7-0.2-1c0.2-0.3,0.7-0.4,1-0.2\n\t\tc0,0,0.1,0,0.1,0.1l2.1,1.6c0.3,0.3,0.4,0.7,0.1,1.1C258,262.1,257.8,262.2,257.5,262.2L257.5,262.2z\"></path></g><g id=\"Checklist_checklist-71\"><path class=\"st1_checklist-71\" d=\"M270.9,110.3h175.3c2.9,0,5.2,2.3,5.2,5.2v229.9c0,2.9-2.3,5.2-5.2,5.2H270.9c-2.9,0-5.2-2.3-5.2-5.2V115.5\n\t\tC265.7,112.6,268.1,110.3,270.9,110.3z\"></path><rect x=\"277.1\" y=\"125\" class=\"st0_checklist-71\" width=\"162.9\" height=\"210.8\"></rect><path class=\"st1_checklist-71\" d=\"M440.1,336.6H277.1c-0.4,0-0.8-0.3-0.8-0.8V125c0-0.4,0.3-0.7,0.7-0.8c0,0,0,0,0,0h162.9\n\t\tc0.4,0,0.7,0.3,0.8,0.7c0,0,0,0,0,0v210.9C440.8,336.3,440.5,336.6,440.1,336.6z M277.9,335.1h161.4V125.8H277.9V335.1z\"></path><path class=\"st2_checklist-71 targetColor\" d=\"M401.2,101.8h-23.4c-2.1-10.6-12.3-17.5-22.9-15.4c-7.8,1.5-13.9,7.6-15.4,15.4H316c-3.1,0-5.6,2.5-5.6,5.6\n\t\tc0,0,0,0,0,0V127c0,3.1,2.5,5.6,5.6,5.6h85.2c3.1,0,5.6-2.5,5.6-5.6v-19.6C406.8,104.3,404.3,101.8,401.2,101.8z M358.6,104.4\n\t\tc-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5C363.6,102.1,361.4,104.4,358.6,104.4L358.6,104.4z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st1_checklist-71\" d=\"M339.9,193.4h-39.4c-0.8,0-1.5-0.7-1.5-1.5v-42.1c0-0.8,0.7-1.5,1.5-1.5h39.4c0.8,0,1.5,0.7,1.5,1.5v42.1\n\t\tC341.4,192.7,340.7,193.4,339.9,193.4z M300.5,149.8v42.1h39.4v-42L300.5,149.8z\"></path><path class=\"st2_checklist-71 targetColor\" d=\"M349.1,160.1c-0.2,0.4-0.4,0.7-0.7,1c-8.5,8.5-16.9,16.9-25.4,25.4c-0.4,0.7-1.3,0.9-2,0.5\n\t\tc-0.2-0.1-0.3-0.3-0.5-0.5l-14.3-14.8c-0.6-0.5-0.7-1.4-0.3-2c0.1-0.1,0.2-0.2,0.3-0.3l3.6-3.2c0.5-0.6,1.3-0.7,1.9-0.2\n\t\tc0.1,0.1,0.2,0.1,0.2,0.2l8.5,8.6c0.9,0.9,1.5,0.9,2.4,0l19.8-19.7c0.4-0.7,1.3-0.8,2-0.4c0.2,0.1,0.3,0.2,0.4,0.4\n\t\tc1.1,1.1,2.2,2.2,3.3,3.4c0.2,0.3,0.5,0.6,0.7,0.9L349.1,160.1z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st1_checklist-71\" d=\"M339.9,250.8h-39.4c-0.8,0-1.5-0.7-1.5-1.5c0,0,0,0,0,0v-42.1c0-0.8,0.7-1.5,1.5-1.5h39.4\n\t\tc0.8,0,1.5,0.7,1.5,1.5v42.1C341.4,250.1,340.7,250.8,339.9,250.8z M300.5,207.2v42.1h39.4v-42.1L300.5,207.2z\"></path><path class=\"st2_checklist-71 targetColor\" d=\"M349.1,217.5c-0.2,0.4-0.4,0.7-0.7,1c-8.5,8.5-16.9,16.9-25.4,25.4c-0.4,0.7-1.3,0.9-2,0.5\n\t\tc-0.2-0.1-0.3-0.3-0.5-0.5l-14.3-14.8c-0.6-0.5-0.7-1.4-0.3-2c0.1-0.1,0.2-0.2,0.3-0.3l3.6-3.2c0.5-0.6,1.3-0.7,1.9-0.2\n\t\tc0.1,0.1,0.2,0.1,0.2,0.2l8.5,8.6c0.9,0.9,1.5,0.9,2.4,0l19.8-19.7c0.4-0.7,1.3-0.8,2-0.4c0.2,0.1,0.3,0.2,0.4,0.4\n\t\tc1.1,1.1,2.2,2.2,3.3,3.4c0.2,0.3,0.5,0.6,0.7,0.9L349.1,217.5z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st1_checklist-71\" d=\"M339.9,308.2h-39.4c-0.8,0-1.5-0.7-1.5-1.5v-42c0-0.8,0.7-1.5,1.5-1.5h39.4c0.8,0,1.5,0.7,1.5,1.5v42\n\t\tC341.4,307.6,340.7,308.2,339.9,308.2z M300.5,264.7v42.1h39.4v-42L300.5,264.7z\"></path><path class=\"st1_checklist-71\" d=\"M420.4,165h-58c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h58c0.4,0,0.8,0.3,0.8,0.8S420.8,165,420.4,165z\"></path><path class=\"st1_checklist-71\" d=\"M405.3,178.2h-43c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h43c0.4,0,0.8,0.3,0.8,0.8S405.7,178.2,405.3,178.2z\"></path><path class=\"st1_checklist-71\" d=\"M420.4,222.3h-58c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h58c0.4,0,0.8,0.3,0.8,0.8S420.8,222.3,420.4,222.3z\"></path><path class=\"st1_checklist-71\" d=\"M405.3,235.5h-43c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h43c0.4,0,0.8,0.3,0.8,0.8S405.7,235.5,405.3,235.5z\"></path><path class=\"st1_checklist-71\" d=\"M420.4,279.8h-58c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h58c0.4,0,0.8,0.3,0.8,0.8S420.8,279.8,420.4,279.8z\"></path><path class=\"st1_checklist-71\" d=\"M405.3,293h-43c-0.4,0-0.8-0.3-0.8-0.8s0.3-0.8,0.8-0.8h43c0.4,0,0.8,0.3,0.8,0.8S405.7,293,405.3,293z\"></path></g><path id=\"Character_hand_checklist-71\" class=\"st0_checklist-71\" d=\"M415.6,350c0.4-2.6,0.6-5.3,0.8-7.9c0.4-5.3-0.9-11.2-2.5-16.1c-0.7-2.2-1.7-4.5-3.6-6\n\ts-5-1.5-6.3,0.5c-1.2,1.7-0.7,4-0.2,6c1.2,5.5,1.5,11.1,0.8,16.7c-0.9-7.5-1.9-15.3-6-21.7c-0.9-1.5-2.1-2.7-3.5-3.6\n\tc-1.5-0.9-3.4-0.8-4.8,0.1c-2.1,1.5-1.9,4.6-1.7,7.2c0.7,6.6,0.6,13.3-0.3,19.9c0.5-5.8,0.1-11.6-1.2-17.3c-0.9-3.7-2.5-7.8-6.1-9\n\tc-0.8-0.3-1.6-0.3-2.5-0.2c-1.7,0.6-2.9,2-3.2,3.7c-0.3,1.7-0.3,3.4,0,5.1c0.7,6.7,0.5,13.4-0.6,20c0.8-5.8,0.6-11.7-0.6-17.4\n\tc-0.3-2.3-1.2-4.5-2.6-6.3c-1.5-1.7-4.1-2.8-6.2-1.8c-1.6,0.9-2.7,2.4-3,4.2c-0.3,1.8-0.3,3.6-0.2,5.3c0.2,6.7-1.1,13.4-3.7,19.7\n\tc-2.1,5.2-4.9,10.9-4.4,16.7c0.5,6,5.3,11.2,10.9,13.4s12,2,17.9,0.9c19.5-3.9,35.7-13.2,42.6-31.9\"></path><path id=\"hand_checklist-71\" class=\"st1_checklist-71\" d=\"M374.4,383.8c-3.4,0.1-6.8-0.5-10-1.8c-6.3-2.5-10.9-8.1-11.4-14c-0.5-5.4,1.8-10.7,3.8-15.4l0.7-1.7\n\tc2.5-6.1,3.8-12.7,3.6-19.4v-0.8c-0.1-1.6,0-3.1,0.2-4.7c0.3-2,1.6-3.8,3.4-4.7c2.5-1.1,5.5,0.1,7.1,2c1.5,1.9,2.4,4.1,2.8,6.5\n\tc-0.1-0.7-0.1-1.5-0.2-2.2v-0.4c-0.3-1.6-0.3-3.3,0-4.9c0.3-2,1.8-3.7,3.7-4.3c0.9-0.2,1.9-0.2,2.9,0.2c3.2,1,5.4,4.2,6.6,9.5\n\tc0.1,0.6,0.3,1.3,0.4,1.9c-0.1-1.4-0.2-2.8-0.3-4.2c-0.3-2.9-0.4-6.2,2-7.9c1.7-1.1,3.9-1.2,5.6-0.1c1.6,0.9,2.9,2.3,3.8,3.9\n\tc2.5,4.1,4.1,8.7,4.8,13.5c-0.1-2.7-0.5-5.4-1.1-8c-0.5-2.1-1-4.7,0.4-6.6c0.7-0.9,1.8-1.6,2.9-1.7c1.6-0.2,3.2,0.1,4.5,1.1\n\tc2.1,1.5,3.1,4.1,3.9,6.3c2.1,6.3,2.9,11.8,2.6,16.4c-0.1,0.8-0.1,1.5-0.1,2.2c-0.1,1.9-0.3,3.9-0.6,5.8c-0.1,0.4-0.5,0.7-0.9,0.6\n\tc-0.4-0.1-0.7-0.5-0.6-0.9c0,0,0,0,0,0c0.3-1.9,0.5-3.7,0.6-5.6c0-0.7,0.1-1.4,0.1-2.2c0.3-4.4-0.5-9.7-2.5-15.9\n\tc-0.7-2-1.6-4.3-3.3-5.6c-1-0.7-2.2-1-3.4-0.8c-0.8,0.1-1.5,0.5-1.9,1.1c-1,1.4-0.5,3.5-0.1,5.4c1.3,5.6,1.5,11.3,0.8,17\n\tc0,0.4-0.4,0.7-0.8,0.7l0,0c-0.4,0-0.7-0.3-0.7-0.7c-0.8-7-1.8-15-5.9-21.3c-0.8-1.4-1.9-2.5-3.3-3.4c-1.3-0.7-2.8-0.7-4,0\n\tc-1.7,1.3-1.6,4-1.4,6.5c0.7,6.7,0.6,13.4-0.3,20.1c-0.1,0.4-0.4,0.7-0.9,0.6c-0.4-0.1-0.7-0.4-0.6-0.8c0.5-5.7,0-11.4-1.3-17\n\tc-1.1-4.7-3-7.6-5.6-8.4c-0.6-0.2-1.3-0.3-2-0.1c-1.4,0.5-2.4,1.7-2.6,3.2c-0.2,1.5-0.2,3,0,4.5v0.4c0.7,6.7,0.5,13.5-0.6,20.2\n\tc-0.1,0.4-0.5,0.7-0.9,0.6c-0.4-0.1-0.6-0.4-0.6-0.8c0.8-5.7,0.6-11.5-0.6-17.1c-0.3-2.2-1.2-4.2-2.5-6c-1.2-1.4-3.5-2.4-5.3-1.6\n\tc-1.4,0.7-2.3,2.1-2.6,3.7c-0.2,1.4-0.3,2.9-0.2,4.3v0.8c0.2,6.9-1.1,13.7-3.7,20c-0.2,0.5-0.5,1.1-0.7,1.7c-2,4.8-4.1,9.7-3.6,14.7\n\tc0.5,5.3,4.6,10.5,10.4,12.8c4.8,1.9,10.6,2.2,17.5,0.8c21.8-4.3,36-14.9,42.1-31.4c0.1-0.4,0.5-0.6,0.9-0.5\n\tc0.4,0.1,0.6,0.5,0.5,0.9c0,0,0,0.1,0,0.1c-6.3,17-20.8,27.9-43.2,32.4C380,383.5,377.2,383.8,374.4,383.8z\"></path></svg>"

/***/ }),

/***/ "./assets/construction-site-59.svg":
/*!*****************************************!*\
  !*** ./assets/construction-site-59.svg ***!
  \*****************************************/
/***/ ((module) => {

module.exports = "<svg id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 500 500\" data-imageid=\"construction-site-59\" imageName=\"Construction Site\" class=\"illustrations_image\" style=\"width: 213px;\"><defs><style>.cls-1_construction-site-59{fill:url(#linear-gradient);}.cls-1_construction-site-59,.cls-2_construction-site-59,.cls-3_construction-site-59,.cls-4_construction-site-59,.cls-5_construction-site-59,.cls-6_construction-site-59,.cls-7_construction-site-59,.cls-8_construction-site-59,.cls-9_construction-site-59,.cls-10_construction-site-59,.cls-11_construction-site-59,.cls-12_construction-site-59,.cls-13_construction-site-59,.cls-14_construction-site-59,.cls-15_construction-site-59,.cls-16_construction-site-59,.cls-17_construction-site-59,.cls-18_construction-site-59,.cls-19_construction-site-59,.cls-20_construction-site-59,.cls-21_construction-site-59,.cls-22_construction-site-59,.cls-23_construction-site-59,.cls-24_construction-site-59,.cls-25_construction-site-59,.cls-26_construction-site-59,.cls-27_construction-site-59,.cls-28_construction-site-59,.cls-29_construction-site-59,.cls-30_construction-site-59,.cls-31_construction-site-59,.cls-32_construction-site-59,.cls-33_construction-site-59,.cls-34_construction-site-59,.cls-35_construction-site-59,.cls-36_construction-site-59,.cls-37_construction-site-59,.cls-38_construction-site-59,.cls-39_construction-site-59,.cls-40_construction-site-59,.cls-41_construction-site-59,.cls-42_construction-site-59,.cls-43_construction-site-59,.cls-44_construction-site-59,.cls-45_construction-site-59{stroke-width:0px;}.cls-2_construction-site-59{fill:url(#linear-gradient-38-construction-site-59);}.cls-3_construction-site-59{fill:url(#linear-gradient-33-construction-site-59);}.cls-4_construction-site-59{fill:url(#linear-gradient-29-construction-site-59);}.cls-5_construction-site-59{fill:url(#linear-gradient-32-construction-site-59);}.cls-6_construction-site-59{fill:url(#linear-gradient-30-construction-site-59);}.cls-7_construction-site-59{fill:url(#linear-gradient-31-construction-site-59);}.cls-8_construction-site-59{fill:url(#linear-gradient-36-construction-site-59);}.cls-9_construction-site-59{fill:url(#linear-gradient-39-construction-site-59);}.cls-10_construction-site-59{fill:url(#linear-gradient-34-construction-site-59);}.cls-11_construction-site-59{fill:url(#linear-gradient-37-construction-site-59);}.cls-12_construction-site-59{fill:url(#linear-gradient-35-construction-site-59);}.cls-13_construction-site-59{fill:url(#linear-gradient-28-construction-site-59);}.cls-14_construction-site-59{fill:url(#linear-gradient-25-construction-site-59);}.cls-15_construction-site-59{fill:url(#linear-gradient-11-construction-site-59);}.cls-16_construction-site-59{fill:url(#linear-gradient-12-construction-site-59);}.cls-17_construction-site-59{fill:url(#linear-gradient-13-construction-site-59);}.cls-18_construction-site-59{fill:url(#linear-gradient-10-construction-site-59);}.cls-19_construction-site-59{fill:url(#linear-gradient-17-construction-site-59);}.cls-20_construction-site-59{fill:url(#linear-gradient-16-construction-site-59);}.cls-21_construction-site-59{fill:url(#linear-gradient-19-construction-site-59);}.cls-22_construction-site-59{fill:url(#linear-gradient-15-construction-site-59);}.cls-23_construction-site-59{fill:url(#linear-gradient-23-construction-site-59);}.cls-24_construction-site-59{fill:url(#linear-gradient-21-construction-site-59);}.cls-25_construction-site-59{fill:url(#linear-gradient-18-construction-site-59);}.cls-26_construction-site-59{fill:url(#linear-gradient-14-construction-site-59);}.cls-27_construction-site-59{fill:url(#linear-gradient-22-construction-site-59);}.cls-28_construction-site-59{fill:url(#linear-gradient-20-construction-site-59);}.cls-29_construction-site-59{fill:url(#linear-gradient-27-construction-site-59);}.cls-30_construction-site-59{fill:url(#linear-gradient-24-construction-site-59);}.cls-31_construction-site-59{fill:url(#linear-gradient-26-construction-site-59);}.cls-32_construction-site-59{fill:url(#linear-gradient-40-construction-site-59);}.cls-33_construction-site-59{fill:url(#linear-gradient-41-construction-site-59);}.cls-46_construction-site-59{opacity:.24;}.cls-34_construction-site-59{fill:url(#linear-gradient-4-construction-site-59);}.cls-35_construction-site-59{fill:url(#linear-gradient-2-construction-site-59);}.cls-36_construction-site-59{fill:url(#linear-gradient-3-construction-site-59);}.cls-37_construction-site-59{fill:url(#linear-gradient-8-construction-site-59);}.cls-38_construction-site-59{fill:url(#linear-gradient-9-construction-site-59);}.cls-39_construction-site-59{fill:url(#linear-gradient-7-construction-site-59);}.cls-40_construction-site-59{fill:url(#linear-gradient-5-construction-site-59);}.cls-41_construction-site-59{fill:url(#linear-gradient-6-construction-site-59);}.cls-42_construction-site-59{fill:#231f20;}.cls-43_construction-site-59{fill:#ffb4a3;}.cls-44_construction-site-59,.cls-45_construction-site-59{fill:#68e1fd;}.cls-45_construction-site-59{isolation:isolate;opacity:.25;}</style><linearGradient id=\"linear-gradient-construction-site-59\" x1=\"-3398.95\" y1=\"-6314.66\" x2=\"-3522.29\" y2=\"-6310.54\" gradientTransform=\"translate(3823.04 6580.54)\" gradientUnits=\"userSpaceOnUse\"><stop offset=\"0\" stop-color=\"#231f20\" stop-opacity=\"0\"></stop><stop offset=\"1\" stop-color=\"#231f20\"></stop></linearGradient><linearGradient id=\"linear-gradient-2-construction-site-59\" x1=\"-3386.88\" y1=\"-6316.06\" x2=\"-3391.6\" y2=\"-6232.3\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-3-construction-site-59\" x1=\"-3370.66\" y1=\"-6313.83\" x2=\"-3444.51\" y2=\"-6230.39\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-4-construction-site-59\" x1=\"-3353.93\" y1=\"-6291.98\" x2=\"-3395.28\" y2=\"-6290.46\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-5-construction-site-59\" x1=\"-3421.21\" y1=\"-6285.21\" x2=\"-3363.95\" y2=\"-6285.21\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-6-construction-site-59\" x1=\"-3575.73\" y1=\"-6316.55\" x2=\"-3616.94\" y2=\"-6315.03\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-7-construction-site-59\" x1=\"-3498.83\" y1=\"-6283.49\" x2=\"-3533.6\" y2=\"-6351.38\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-8-construction-site-59\" x1=\"-3503.35\" y1=\"-6310.08\" x2=\"-3504.43\" y2=\"-6296.54\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-9-construction-site-59\" x1=\"-3505.79\" y1=\"-6387.99\" x2=\"-3505.79\" y2=\"-6342.44\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-10-construction-site-59\" x1=\"-3505.79\" y1=\"-6387.54\" x2=\"-3505.79\" y2=\"-6335.66\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-11-construction-site-59\" x1=\"-3552.14\" y1=\"-6370.47\" x2=\"-3556.81\" y2=\"-6342.66\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-12-construction-site-59\" x1=\"-3587.12\" y1=\"-6316.24\" x2=\"-3562.36\" y2=\"-6316.52\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-13-construction-site-59\" x1=\"-3440.57\" y1=\"-6287.56\" x2=\"-3439.95\" y2=\"-6232.67\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-14-construction-site-59\" x1=\"-3550.15\" y1=\"-6304.74\" x2=\"-3554.71\" y2=\"-6248.01\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-15-construction-site-59\" x1=\"-3550.26\" y1=\"-6302.43\" x2=\"-3554.52\" y2=\"-6249.31\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-16-construction-site-59\" x1=\"-3439.94\" y1=\"-6364.65\" x2=\"-3441.85\" y2=\"-6296.73\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-17-construction-site-59\" x1=\"-3439.88\" y1=\"-6361.63\" x2=\"-3442.02\" y2=\"-6285.63\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-18-construction-site-59\" x1=\"-3557.12\" y1=\"-6304.32\" x2=\"-3559.05\" y2=\"-6280.24\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-19-construction-site-59\" x1=\"-3514.09\" y1=\"-6292.19\" x2=\"-3555.44\" y2=\"-6290.67\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-20-construction-site-59\" x1=\"-3554.57\" y1=\"-6368.94\" x2=\"-3561.77\" y2=\"-6317.8\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-21-construction-site-59\" x1=\"-3398.95\" y1=\"-6414.04\" x2=\"-3522.29\" y2=\"-6409.93\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-22-construction-site-59\" x1=\"-3386.88\" y1=\"-6415.45\" x2=\"-3391.6\" y2=\"-6331.69\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-23-construction-site-59\" x1=\"-3370.64\" y1=\"-6413.21\" x2=\"-3444.5\" y2=\"-6329.76\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-24-construction-site-59\" x1=\"-3353.93\" y1=\"-6391.36\" x2=\"-3395.28\" y2=\"-6389.84\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-25-construction-site-59\" x1=\"-3575.73\" y1=\"-6415.93\" x2=\"-3616.94\" y2=\"-6414.41\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-26-construction-site-59\" x1=\"-3505.79\" y1=\"-6487.37\" x2=\"-3505.79\" y2=\"-6441.83\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-27-construction-site-59\" x1=\"-3505.79\" y1=\"-6486.92\" x2=\"-3505.79\" y2=\"-6435.05\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-28-construction-site-59\" x1=\"-3552.14\" y1=\"-6469.85\" x2=\"-3556.81\" y2=\"-6442.04\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-29-construction-site-59\" x1=\"-3587.12\" y1=\"-6415.62\" x2=\"-3562.36\" y2=\"-6415.9\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-30-construction-site-59\" x1=\"-3439.94\" y1=\"-6464.04\" x2=\"-3441.85\" y2=\"-6396.11\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-31-construction-site-59\" x1=\"-3439.88\" y1=\"-6461.02\" x2=\"-3442.02\" y2=\"-6385.02\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-32-construction-site-59\" x1=\"-3514.09\" y1=\"-6391.57\" x2=\"-3555.44\" y2=\"-6390.05\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-33-construction-site-59\" x1=\"-3554.57\" y1=\"-6468.33\" x2=\"-3561.77\" y2=\"-6417.18\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-34-construction-site-59\" x1=\"-3697.24\" y1=\"-6367.09\" x2=\"-3693.75\" y2=\"-6361.58\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-35-construction-site-59\" x1=\"-3704.77\" y1=\"-6316.4\" x2=\"-3704.07\" y2=\"-6273.03\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-36-construction-site-59\" x1=\"-3709.11\" y1=\"-6301.13\" x2=\"-3708.71\" y2=\"-6276.65\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-37-construction-site-59\" x1=\"-3697.13\" y1=\"-6221.71\" x2=\"-3784.84\" y2=\"-6208.64\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-38-construction-site-59\" x1=\"-3706.94\" y1=\"-6264.92\" x2=\"-3696.7\" y2=\"-6218.32\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-39-construction-site-59\" x1=\"-3709.71\" y1=\"-6274.39\" x2=\"-3706.83\" y2=\"-6244.62\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-40-construction-site-59\" x1=\"-3709.71\" y1=\"-6268.55\" x2=\"-3706.82\" y2=\"-6238.79\" gradientTransform=\"translate(3823.04 6514.83)\" xlink:href=\"#linear-gradient-construction-site-59\"></linearGradient><linearGradient id=\"linear-gradient-41-construction-site-59\" x1=\"-3670.97\" y1=\"-6258.1\" x2=\"-3667.26\" y2=\"-6183.06\" gradientTransform=\"translate(3823.04 6514.83)\" gradientUnits=\"userSpaceOnUse\"><stop offset=\"0\" stop-color=\"#000\" stop-opacity=\"0\"></stop><stop offset=\".49\" stop-color=\"#000\" stop-opacity=\".49\"></stop><stop offset=\".97\" stop-color=\"#000\"></stop></linearGradient></defs><path id=\"background_construction-site-59\" class=\"cls-45_construction-site-59 targetColor\" d=\"M113.34,189.22c-33.24,6.49-104.82,22.34-80.51,101.43,3.39,11.05,25.28,48.81,27.71,60.11,2.7,12.62-2.91,25.93-.17,38.55,4.94,22.68,32.38,31.11,55.33,34.63,26.54,4.07,53.9,7.14,80.02,1.06,14.41-3.35,28.06-9.39,42.4-13.04,58.85-14.83,122.93,12.12,180.76-6.2,17.12-5.41,34.23-16.2,39.63-33.33,3.48-11.15,1.5-23.19,1.44-34.89-.17-29.72,3.68-69.24,13.11-97.42s52.88-139.1-38.25-157.27c-132.4-26.4-90.54,61.29-321.46,106.37h-.01Z\" style=\"fill: rgb(0, 49, 83);\"></path><path id=\"floor_construction-site-59\" class=\"cls-45_construction-site-59 targetColor\" d=\"M111.68,389.44c-21.29,4.6-43.8,10.68-58.25,26.95-2.98,3.35-5.66,7.36-5.73,11.84-.18,10.66,12.99,15.65,23.56,17.08,32.64,4.35,65.72,2.98,98.62,1.63,20.81-.87,41.68-1.74,62.27-4.79,40.46-6.09,80.59-20.78,121.31-16.34,13.41,1.46,26.52,4.99,39.94,6.34,21.57,2.13,43.32-1.41,63.1-10.26,6.95-3.13,14.3-7.72,16.13-15.14,1.83-7.42-2.66-15.01-8.83-19.31-6.17-4.3-13.77-5.95-21.13-7.5-17.73-3.73-33.04-10.35-51.2-11.5-22.97-1.44-45.99-2.11-69.04-2-45.64.23-91.22,3.51-136.43,9.82-24.93,3.48-49.7,7.87-74.31,13.18h-.01Z\" style=\"fill: rgb(0, 49, 83);\"></path><g id=\"shadow_construction-site-59\" class=\"cls-46_construction-site-59\"><path class=\"cls-42_construction-site-59\" d=\"M93.43,439.31c12.75,1.16,25.56,1.66,38.36,1.74,11.08.05,22.51-.29,32.58-4.89,5.52-2.52,10.5-6.28,16.3-8.07,5.46-1.69,11.3-1.54,16.94-2.3,5.64-.76,11.61-2.74,14.92-7.39l-21.63-7.19c-2.74-1-5.56-1.76-8.43-2.26-3.67-.4-7.37-.36-11.03.11-13.88,1.34-27.66,3.56-41.25,6.64-7.62,1.74-11.57,6.26-18.18,9.16-5.32,2.34-8.51.5-13.91.35-12.56-.34-21.53,12.54-4.67,14.08v.02Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M212.24,382.74c-3.18.05-7.46,1.04-7.42,4.23,11.48,3.56,23.83-.37,35.84.05,16.15.57,30.86,8.96,44.82,17.13-5.5-.13-10.65,2.71-13.46,7.44,31.46,3.32,62.98-4.7,94.6-5.22,33.1-.5,66.27,7.27,99.11,3.19-.57-2.67-3.79-3.69-6.49-4.09-13.81-2.09-27.89-1.14-41.82-2.03-13.94-.9-28.37-3.92-39.23-12.69,11.28-2.68,22.18-6.77,32.44-12.17-6.52-3.07-14.13-2.13-21.28-1.27-47.48,5.74-95.52,5.09-142.83-1.91-1.63,3.26,3.35,5.69,6.95,5.97l79.28,6.29c9.08.72,18.91,1.74,25.59,7.95-35.06,6.73-83.24-.23-116.27-13.86-5.42-2.24,3.39-8.56-2.46-7.95-6.79.71-19.23,8.79-27.39,8.94h.02Z\"></path></g><g id=\"construction_construction-site-59\"><rect class=\"cls-44_construction-site-59 targetColor\" x=\"391.75\" y=\"155.83\" width=\"15.41\" height=\"221.52\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-1_construction-site-59\" x=\"398.29\" y=\"155.83\" width=\"8.87\" height=\"221.52\"></rect><path class=\"cls-44_construction-site-59 targetColor\" d=\"M407.16,202.99c0-.49,55.4,18.93,55.4,18.93l1.32,19.03-57.94-20.97-.15-17h1.37Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-35_construction-site-59\" d=\"M405.78,204.62c0-.49,56.78,19.95,56.78,19.95l1.32,15.57-57.94-20.97-.16-14.55h0Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M402.82,206.78c0-.49,55.39,18.93,55.39,18.93l1.32,17.81-57.94-20.97-.17-15.81,1.41.04h0Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-36_construction-site-59\" d=\"M401.44,207.99c0-.49,56.77,19.95,56.77,19.95l1.32,15.57-57.94-20.97-.15-14.55Z\"></path><rect class=\"cls-44_construction-site-59 targetColor\" x=\"453.08\" y=\"174.67\" width=\"15.41\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-34_construction-site-59\" x=\"454.84\" y=\"174.67\" width=\"15.41\" height=\"228.27\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"459.23\" y=\"174.67\" width=\"2.17\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"459.35 295.1 459.35 297.96 459.09 310.66 401.83 291.47 401.73 291.43 402.47 276.46 459.35 295.1\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-40_construction-site-59\" points=\"459.09 297.31 459.09 312.02 401.83 291.47 402.47 278.64 459.09 297.31\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"231.31\" y=\"151.12\" width=\"15.41\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-41_construction-site-59\" x=\"233.07\" y=\"151.12\" width=\"15.41\" height=\"226.23\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"240.78\" y=\"276.24\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-39_construction-site-59\" x=\"240.78\" y=\"276.24\" width=\"152.93\" height=\"14.41\"></rect><rect class=\"cls-37_construction-site-59\" x=\"246.57\" y=\"276.24\" width=\"145.17\" height=\"1.97\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"240.78\" y=\"202.21\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-38_construction-site-59\" x=\"240.78\" y=\"202.21\" width=\"152.93\" height=\"14.41\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"242.78\" y=\"206.01\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-18_construction-site-59\" x=\"240.78\" y=\"204.01\" width=\"152.93\" height=\"16.41\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"292.93 223.22 246.72 206.01 246.72 209.77 292.93 226.96 292.93 223.22\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-15_construction-site-59\" points=\"292.93 223.22 246.72 206.01 246.72 209.77 292.93 226.96 292.93 223.22\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"246.72\" y=\"206.01\" width=\"145.03\" height=\"1.5\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"246.72\" y=\"201.2\" width=\"145.03\" height=\"1.5\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"237.46\" y=\"151.12\" width=\"9.26\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-16_construction-site-59\" x=\"237.46\" y=\"151.12\" width=\"9.26\" height=\"226.23\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"306.16\" y=\"298.94\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-17_construction-site-59\" x=\"306.16\" y=\"300.93\" width=\"152.93\" height=\"12.41\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"237.46 294.09 305.11 314.8 305.06 297.55 237.46 276.79 237.46 294.09\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-26_construction-site-59\" points=\"305.11 314.8 305.1 314.8 237.46 294.09 237.46 276.79 305.06 297.55 305.11 314.8\"></polygon><polygon class=\"cls-22_construction-site-59\" points=\"305.1 314.8 237.46 294.09 237.46 278.86 305.06 299.62 305.1 314.8\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"306.16\" y=\"224.91\" width=\"152.93\" height=\"13.96\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-20_construction-site-59\" x=\"306.16\" y=\"226.96\" width=\"152.93\" height=\"11.91\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"306.16\" y=\"229\" width=\"152.93\" height=\"15.96\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-19_construction-site-59\" x=\"306.16\" y=\"231.05\" width=\"152.93\" height=\"13.84\"></rect><polygon class=\"cls-25_construction-site-59\" points=\"237.46 276.79 252.88 276.79 292.93 287.7 292.93 293.83 237.46 276.79\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"237.46\" y=\"151.12\" width=\"2.17\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"292.93\" y=\"174.46\" width=\"15.41\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-21_construction-site-59\" x=\"294.69\" y=\"174.46\" width=\"15.41\" height=\"228.27\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"299.08\" y=\"174.46\" width=\"2.17\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"239.63 207.12 292.93 226.96 292.93 244.89 239.63 221.75 239.63 207.12\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-28_construction-site-59\" points=\"239.63 209.42 292.93 229.27 292.93 244.89 239.63 221.75 239.63 209.42\"></polygon><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"246.72 206.01 292.93 223.22 292.93 225.27 246.72 208.12 246.72 206.01\" style=\"fill: rgb(0, 49, 83);\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"391.75\" y=\"56.45\" width=\"15.41\" height=\"135.46\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-24_construction-site-59\" x=\"398.29\" y=\"56.45\" width=\"8.87\" height=\"221.52\"></rect><path class=\"cls-44_construction-site-59 targetColor\" d=\"M407.16,103.59c0-.48,55.4,18.93,55.4,18.93l1.32,19-57.94-20.97-.15-17,1.37.03h0Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-27_construction-site-59\" d=\"M405.78,105.23c0-.48,56.78,20,56.78,20l1.32,15.54-57.97-20.96-.13-14.57h0Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M402.82,107.39c0-.49,55.39,18.93,55.39,18.93l1.32,17.82-57.94-20.97-.15-15.78h1.38Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-23_construction-site-59\" d=\"M401.44,108.61c0-.49,56.77,20,56.77,20l1.32,15.54-57.94-20.97-.15-14.56h0Z\"></path><rect class=\"cls-44_construction-site-59 targetColor\" x=\"453.08\" y=\"75.29\" width=\"15.41\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-30_construction-site-59\" x=\"454.84\" y=\"75.29\" width=\"15.41\" height=\"228.27\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"459.23\" y=\"75.29\" width=\"2.17\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"231.31\" y=\"51.74\" width=\"15.41\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-14_construction-site-59\" x=\"233.07\" y=\"51.74\" width=\"15.41\" height=\"226.23\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"240.78\" y=\"102.83\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-31_construction-site-59\" x=\"240.78\" y=\"102.83\" width=\"152.93\" height=\"14.41\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"242.78\" y=\"106.63\" width=\"152.93\" height=\"14.41\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-29_construction-site-59\" x=\"240.78\" y=\"104.63\" width=\"152.93\" height=\"16.41\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"292.93 123.83 246.72 106.63 246.72 110.37 292.93 127.58 292.93 123.83\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-13_construction-site-59\" points=\"292.93 123.83 246.72 106.63 246.72 110.37 292.93 127.58 292.93 123.83\"></polygon><rect class=\"cls-44_construction-site-59 targetColor\" x=\"246.72\" y=\"106.63\" width=\"145.03\" height=\"1.5\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"246.72\" y=\"101.82\" width=\"145.03\" height=\"1.5\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"237.46\" y=\"51.74\" width=\"9.26\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-4_construction-site-59\" x=\"237.46\" y=\"51.74\" width=\"9.26\" height=\"226.23\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"306.16\" y=\"125.53\" width=\"152.93\" height=\"13.96\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-6_construction-site-59\" x=\"306.16\" y=\"127.58\" width=\"152.93\" height=\"11.91\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"306.16\" y=\"129.61\" width=\"152.93\" height=\"15.96\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-7_construction-site-59\" x=\"306.16\" y=\"131.66\" width=\"152.93\" height=\"13.84\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"237.46\" y=\"51.74\" width=\"2.17\" height=\"226.23\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"292.93\" y=\"75.08\" width=\"15.41\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><rect class=\"cls-5_construction-site-59\" x=\"294.69\" y=\"75.08\" width=\"15.41\" height=\"228.27\"></rect><rect class=\"cls-44_construction-site-59 targetColor\" x=\"299.08\" y=\"75.08\" width=\"2.17\" height=\"228.27\" style=\"fill: rgb(0, 49, 83);\"></rect><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"239.63 107.74 292.93 127.58 292.93 145.5 239.63 122.36 239.63 107.74\" style=\"fill: rgb(0, 49, 83);\"></polygon><polygon class=\"cls-3_construction-site-59\" points=\"239.63 110.04 292.93 129.88 292.93 145.5 239.63 122.36 239.63 110.04\"></polygon><polygon class=\"cls-44_construction-site-59 targetColor\" points=\"246.72 106.63 292.93 123.83 292.93 125.87 246.72 108.72 246.72 106.63\" style=\"fill: rgb(0, 49, 83);\"></polygon></g><g id=\"character_construction-site-59\"><path class=\"cls-43_construction-site-59\" d=\"M130.55,216.16c1.13,1.43,1.66,3.24,1.48,5.05-.09.79-.3,1.57-.34,2.36-.08.8.17,1.6.7,2.21.47.45,1.21.74,1.32,1.37.17.87-.91,1.38-1.55,2.01-.56.7-.95,1.52-1.13,2.4-.39,1.28-.93,2.52-1.6,3.69-.58,1.23-1.58,2.21-2.82,2.76-.87.31-1.93.23-2.76.71-1.95,1.12-1.49,4.35-3.29,5.73-.52.35-1.12.56-1.74.63-1.43.22-2.89.02-4.21-.57-.59-.23-1.11-.63-1.48-1.15-.35-.7-.47-1.49-.36-2.27.15-2.61.5-5.27.42-7.9-.04-1.41-.21-2.82-.19-4.23.04-4.23,1.95-8.22,5.22-10.91,3.34-2.64,7.82-3.35,11.81-1.88l-.77-.87\"></path><path class=\"cls-42_construction-site-59\" d=\"M116.62,223.33c-1.22.32-1.98,1.53-1.74,2.76.31,1.2,1.37,2.05,2.61,2.1l-2.77,5.33c-.23.45-.63.99-1.12.87s-.62-.8-.71-1.33c-.3-1.68-1.62-2.96-2.36-4.49-1.1-2.23-.87-4.86-.68-7.34.2-2.21.43-4.52,1.63-6.39.7-1.01,1.57-1.89,2.56-2.61,1.66-1.41,3.66-2.34,5.8-2.7,1.81-.13,3.62.1,5.34.66,1.73.37,3.35,1.12,4.75,2.2,1.4,1.12,2.03,2.96,1.6,4.7-2.61.35-7.68,0-9.72,1.9-1.74,1.64-.56,5.22-2.81,6.34-.09-1.5-1.11-1.82-2.36-2.01h-.02Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M138.89,214c-.8-.48-4.35-1.96-5.16-2.44-.16-2.82-3.19-6.49-7.35-8.05-3.11-1.12-9.51-1.12-14.59,2.69-5.76,4.35-4.96,11.63-5.02,13.54-.03,1.34,1.02,2.45,2.36,2.49.35,0,.7-.06,1.03-.2,1.54-.7,3.12-1.3,4.73-1.81l6.95-1.74c4.91-1.3,12.11-3.2,17.04-4.47h.01Z\" style=\"fill: rgb(0, 49, 83);\"></path><polygon class=\"cls-10_construction-site-59\" points=\"137.82 213.54 117.26 218.86 124.05 215.25 125.91 214.27 129.05 213.18 132.59 211.96 133.73 211.56 137.82 213.54\"></polygon><polygon class=\"cls-42_construction-site-59\" points=\"117.26 219.55 111.12 230.85 109.71 227.41 111.65 224.01 109.41 222.39 111.79 221.31 113.34 222.55 113.97 220.5 117.26 219.55\"></polygon><path class=\"cls-44_construction-site-59 targetColor\" d=\"M107.63,221.63s.97.25,3.48-.87c2.01-.81,4.08-1.46,6.19-1.93l8.64-4.59s-10.99-5.53-17.47.74c-.03.02-2.56,3.49-.83,6.65h-.01Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-12_construction-site-59\" d=\"M107.5,212.52s4.7-8.08,12.24-8.05c3.56.03,6.98,1.32,9.68,3.64,0,0-12.95-8.15-21.92,4.41Z\"></path><path class=\"cls-8_construction-site-59\" d=\"M107.33,220.95s.09,1.24,2.16.43c2.08-.81,8.34-2.61,8.34-2.61l2.89-1.74s-12.25,4.7-13.4,3.91h.01Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M110.67,415.67c14.19-27.18,22.71-56.96,25.03-87.53.21-2.78.32-5.77-1.15-8.15-2.81-4.56-9.42-4.29-14.7-3.48-2.4.38-5.11.98-6.31,3.09-.87,1.56-10.02,7.19-9.19,8.77,6.09,11.48,8.55,26.21,5.51,41.52-2.99,15.07-8.36,26.2-10.52,41.24,1.23.1,10.86,5.42,11.33,4.53h0Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M170.14,261.17c-.87,5.89-3.29,11.74-7.75,15.65s-11.12,5.65-16.61,3.33c-5.75-2.43-9.02-8.4-11.86-13.91-.06,13.97,5.55,27.82,3.6,41.62-.14,2.02-.87,3.95-2.08,5.57-1.5,1.74-3.81,2.46-6.01,3.07-7.68,2.09-15.54,3.48-23.47,4.15-.77.06-1.52.13-2.29.17-.92-4.56-1.3-10.49-1.37-17.73v-2.19c0-5.81.14-12.38.36-19.66v-2.11c0-.41,0-1.04.05-1.74v-4.23c.15-4.52.3-9.28.43-14.27,0-.64,0-1.28.04-1.93.02-1.77.23-3.54.63-5.27.62-2.88,2.33-5.4,4.77-7.04h0c1.83-1.2,3.8-2.15,5.88-2.83,8.31-2.91,18.2-1.17,24.14,5.09,1.02,1.09,1.94,2.27,2.74,3.54,1.32,2.02,2.42,4.17,3.56,6.31,1.15,2.28,2.49,4.45,4.01,6.49,1.37,1.74,3.37,3.4,5.54,3.02,3.11-.56,3.96-4.56,4-7.69.06-5.2-.23-10.41-.87-15.57,3.98-.36,7.98-.22,11.92.43.49,3.19.82,6.4.98,9.62.13,2.71.02,5.43-.34,8.13v-.02Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-11_construction-site-59\" d=\"M120.32,286.43c-2.33,3.8-5.5,7.01-8.69,10.08-1.5,1.43-.63,18.73-2.18,20.13-.57.5-1.95,2.21-3.48,4-.77.06-1.52.13-2.29.17-.92-4.56-1.3-10.49-1.37-17.73v-2.19c0-5.81.14-12.38.36-19.66v-2.11c0-.41,0-1.04.05-1.74v-4.23c1.09-.95,1.88,3.03,2.08,3.55.07.17.16.33.29.47.18.14.4.21.63.18,1.03-.17,1.97-.72,2.61-1.55,1.7-1.7,3.32-3.48,4.86-5.34l10.28,3.27c.67,4.42-.79,8.89-3.13,12.69h-.02Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M122.22,273.46c-3.02,12.38-12,24.34-19.92,27.44-3.24,1.26-6.3,1.04-8.69-1.24-4.35-3.89-5.22-18.26-3.89-34.36.15-1.99.55-3.95,1.2-5.83.92-2.57,2.33-4.95,4.13-7.01,3.71-4,8.5-6.84,13.79-8.19l-.08.35-1.41,6.85-1.49,7.2-2.98,14.47-1.74,8.34c0,.95.58.7,1.47-.24,2.48-2.61,7.42-10.58,9.5-12.24.06-.05.12-.1.17-.16l9.93,4.62h.01Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-2_construction-site-59\" d=\"M144.9,256.75c-.29.06-.59.1-.87.14-6.38.76-12.82.5-19.24.64s-12.62.66-18.93,1.13l-2.55.2c-4.12.28-8.26.52-12.4.6.92-2.57,2.33-4.95,4.13-7.01.61-.14,1.23-.23,1.85-.28,2.36-.19,4.72-.37,7.09-.51,1.12-.08,2.24-.14,3.36-.2,7.51-.43,15.01-.7,22.52-.97,3.83-.13,7.65-.26,11.47-.05h0c1.33,2.02,2.43,4.17,3.57,6.31h0Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M127.64,363.46c9.41,12.28,18.3,26.08,19.13,41.49.16,2.77.47,6.22,3.06,7.22,1.24.34,2.56.32,3.79-.06l9.56-1.97-5.96-26.66c-1.5-6.73-3.02-13.52-5.85-19.8-1.99-4.41-4.6-8.51-6.75-12.86-5.42-10.97-7.73-23.17-9.99-35.2-11.19.73-36.6-4.25-30.27,12.81,5.02,13.61,16.12,22.86,23.27,35.04h.01Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M153.13,415.8c.17.62.47,1.19.87,1.7.84.81,2.03,1.14,3.16.87,1.11-.27,2.17-.74,3.13-1.36.54-.25,1-.64,1.33-1.13.32-.85.29-1.78-.09-2.61l-1.57-4.98c-.05-.3-.23-.57-.49-.73-.34-.07-.7.03-.96.27-1.74,1.16-4.35,1.3-5.95,2.45s-.06,3.8.56,5.53h.01Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M100.01,418.16c1.56,1.03,3.29,1.78,5.1,2.23.28.09.59.09.87,0,.42-.15.61-.62.75-1.03l2.25-6.45c-.27.78-4.82-3.16-5.9-2.76-2.01.79-2.68,6.21-3.07,8.02h0Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M159.54,413.55c.97-.35,1.99-.56,3.03-.63,2.89-.07,5.66,2.06,8.48,1.4.73-.25,1.47-.47,2.23-.63,1.85-.07,3.48,1.23,3.82,3.05.27,1.8-.31,3.62-1.57,4.92-1.26,1.27-2.76,2.29-4.41,3-3.39,1.66-7.02,2.78-10.75,3.3-.94.19-1.91.13-2.83-.16-.75-.34-1.4-.85-1.9-1.5-1.81-2.07-3.86-5.7-3.54-8.59.34-3.05,5.03-3.42,7.46-4.16h-.02Z\"></path><path class=\"cls-42_construction-site-59\" d=\"M107.86,419.04c.41.12.79.31,1.13.57.38.42.65.93.8,1.48.98,2.6,2.68,4.87,4.89,6.55.92.57,1.73,1.3,2.38,2.16.65.91.52,2.16-.31,2.9-.5.28-1.07.4-1.64.35-1.89-.05-3.76-.24-5.62-.55-5.05-.73-10.43-1.61-14.22-5.02-1.04-.81-1.74-1.97-1.96-3.27-.16-1.65.87-2.96,1.74-4.24.63-.94,1.43-3.03,2.42-3.65,2.22-1.36,8.15,1.95,10.41,2.73h-.02Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M218.91,234.28s-.06.95-.14,2.4c-.26,4.54-.81,13.96-.87,14.13s-208.48,9.23-208.48,9.23l-.87-12.17-.22-2.36,12.17-.11,198.4-11.12h0Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-9_construction-site-59\" d=\"M218.77,236.68c-.26,4.54-.81,13.96-.87,14.13s-208.48,9.23-208.48,9.23l-.87-12.17,11.95-.1,198.26-11.09h0Z\"></path><path class=\"cls-44_construction-site-59 targetColor\" d=\"M218.91,240.12s-.06.95-.14,2.4c-.26,4.55-.81,13.97-.87,14.13s-208.48,9.21-208.48,9.21l-.87-12.17-.22-2.33,12.17-.11,198.4-11.12h0Z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"cls-32_construction-site-59\" d=\"M218.77,242.52c-.26,4.55-.81,13.97-.87,14.13s-208.48,9.21-208.48,9.21l-.87-12.17,11.95-.06,198.26-11.1h0Z\"></path><path class=\"cls-43_construction-site-59\" d=\"M119.95,271.93c2.2-2.66,3.06-5.33,4.08-8.63.3-.99-.66-1.03-1.8,1.68.29-1.92.87-5.02.87-5.76-1.02-.94-1.24.77-1.53,1.47-.45.92-.85,1.86-1.21,2.83.17-1.65.16-2.43.33-4.08,0-.3,0-.72-.3-.79-1.56.31-.95,3.96-2.34,5.35.23-1.52.46-5.12,0-4.89-.87,0-1.29,1.11-1.44,1.99l-.87,4.93c-.49-.15-.58-.77-.7-1.27s-.65-1.04-1.06-.74c-.13.12-.22.28-.24.45-.04.62,0,1.25.14,1.86.11,1.2-.31,2.4-1.15,3.27,2.3,1.08,4.73,1.87,7.23,2.34h-.01Z\"></path><path class=\"cls-43_construction-site-59\" d=\"M160.41,235.81c-.46.56-.81,1.2-1.03,1.89-.25.53-.38,1.1-.37,1.69,0,.6.39,1.12.96,1.32.15.05.31.04.44-.04.09-.07.16-.17.21-.28.47-.89.87-1.82,1.2-2.77-.72.9-.87,2.14-.37,3.19.17.36.51.7.87.62s.5-.47.59-.81c.23-.8.41-1.61.56-2.42-.12.52-.2,1.05-.23,1.58-.03.27,0,.55.1.81.11.26.37.43.65.41.23-.07.43-.22.56-.43.62-.8,1.13-1.68,1.52-2.61-.19.86-.15,1.76.1,2.61.04.13.11.25.22.33.36.27.87-.13,1.08-.51.46-.72.8-1.52,1.01-2.35.14-.44.17-.9.09-1.36-.09-.47-.42-.85-.87-1-.46-.12-.92.15-1.05.61.08-.58-.57-1.05-1.16-.99-.58.12-1.09.46-1.42.95-.05-.56-.49-1-1.05-1.04-1.02-.1-1.76-.32-2.59.61h-.02Z\"></path><path class=\"cls-33_construction-site-59\" d=\"M170.14,261.17c-.87,5.89-3.29,11.74-7.75,15.65s-11.12,5.65-16.61,3.33c-5.75-2.43-9.02-8.4-11.86-13.91,0,0,.34-4.93,3.91-1.99s8.87,20.75,19.81,10.35c10.95-10.41,10.99-21.51,10.99-21.51l1.87-.08c.13,2.73,0,5.46-.36,8.16Z\"></path></g></svg>"

/***/ }),

/***/ "./assets/resting-49.svg":
/*!*******************************!*\
  !*** ./assets/resting-49.svg ***!
  \*******************************/
/***/ ((module) => {

module.exports = "<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 500 500\" style=\"width: 144px;\" xml:space=\"preserve\" data-imageid=\"resting-49\" imageName=\"Resting\" class=\"illustrations_image\"><style type=\"text/css\"> .st0_resting-49{fill:#FFD5B8;} .st1_resting-49{fill:url(#SVGID_1_);} .st2_resting-49{fill:url(#SVGID_00000031205202326426783520000015103624356007395511_);} .st3_resting-49{fill:url(#SVGID_00000016064646538642280390000006874074321927623571_);} .st4_resting-49{fill:#EF8A3F;} .st5_resting-49{opacity:0.3;fill:#091114;enable-background:new ;} .st6_resting-49{fill:#FF9A55;} .st7_resting-49{fill:#091114;} .st8_resting-49{fill:#68E1FD;} .st9_resting-49{opacity:0.46;fill:#091114;enable-background:new ;} .st10_resting-49{opacity:0.22;fill:#091114;enable-background:new ;} .st11_resting-49{fill:#981E61;} .st12_resting-49{opacity:0.5;fill:#091114;enable-background:new ;} .st13_resting-49{fill:#9BC634;} .st14_resting-49{fill:#85AA1D;} .st15_resting-49{fill:#935542;} </style><path id=\"Base_resting-49\" class=\"st0_resting-49\" d=\"M32.6,283.4L205,183.2c2.5-1.5,5.6-1.5,8.1,0l257.8,147.5c3.9,2.2,5.2,7.2,3,11.1\n\tc-0.7,1.2-1.8,2.3-3,3L306.1,440c-8.2,4.8-18.4,4.8-26.6,0L32.6,297.5c-3.9-2.2-5.2-7.2-3-11.1C30.4,285.2,31.4,284.1,32.6,283.4z\"></path><g id=\"Shadow_resting-49\"><linearGradient id=\"SVGID_1_-resting-49\" gradientUnits=\"userSpaceOnUse\" x1=\"104.6152\" y1=\"774.4592\" x2=\"69.8252\" y2=\"822.2092\" gradientTransform=\"matrix(1 0 0 1 0 -498)\"><stop offset=\"0\" style=\"stop-color:#935542\"></stop><stop offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"></stop></linearGradient><path class=\"st1_resting-49\" d=\"M84.5,328.3c9.7-8.3,16.8-16.1,26.8-24L76,300.7l-22.5,8.9C63.7,316.1,74.1,322.2,84.5,328.3z\"></path><linearGradient id=\"SVGID_00000119079739588633089820000003627765237290165920_-resting-49\" gradientUnits=\"userSpaceOnUse\" x1=\"282.7687\" y1=\"774.1445\" x2=\"246.2186\" y2=\"824.3245\" gradientTransform=\"matrix(1 0 0 1 0 -498)\"><stop offset=\"0\" style=\"stop-color:#935542\"></stop><stop offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"></stop></linearGradient><path style=\"fill:url(#SVGID_00000119079739588633089820000003627765237290165920_);\" d=\"M300.8,391.4l66.5-43.1L204.8,247.6\n\t\tL131,296.3C140,302.5,291.9,385,300.8,391.4z\"></path><linearGradient id=\"SVGID_00000167357464996013437550000015196528290398506418_-resting-49\" gradientUnits=\"userSpaceOnUse\" x1=\"199.7601\" y1=\"860.7735\" x2=\"184.5201\" y2=\"883.7935\" gradientTransform=\"matrix(1 0 0 1 0 -498)\"><stop offset=\"0\" style=\"stop-color:#935542\"></stop><stop offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"></stop></linearGradient><path style=\"fill:url(#SVGID_00000167357464996013437550000015196528290398506418_);\" d=\"M232.7,413.4l42.6-23.8L143,325.4\n\t\tl-25.7,21C122.9,350.2,227.1,409.4,232.7,413.4z\"></path></g><g id=\"Desk_resting-49\"><polygon class=\"st4_resting-49\" points=\"244.1,406.7 275.3,389.6 275.3,354.5 238.1,370.2 \t\"></polygon><polygon class=\"st5_resting-49\" points=\"244.1,406.7 275.3,389.6 275.3,354.5 238.1,370.2 \t\"></polygon><polygon class=\"st4_resting-49\" points=\"126.2,303.5 126.2,338.7 244.1,406.7 244.9,372 \t\"></polygon><polygon class=\"st6_resting-49\" points=\"126.2,303.5 157.6,285.5 275.3,354.5 244.9,372 \t\"></polygon></g><g id=\"TV_resting-49\"><path class=\"st7_resting-49\" d=\"M160.6,249.4l94.1,54.3c0.9,0.5,1.4,1.5,1.4,2.5v40.9c0,1.6-1.3,2.9-2.9,2.9c-0.5,0-1-0.1-1.4-0.4l-94.1-54.3\n\t\tc-0.9-0.5-1.4-1.5-1.4-2.5v-40.9c0-1.6,1.3-2.9,2.9-2.9C159.7,249.1,160.2,249.2,160.6,249.4z\"></path><polyline class=\"st7_resting-49\" points=\"192.6,313.1 191,327 210.5,337.8 208.4,322.2 \t\"></polyline><ellipse transform=\"matrix(0.4346 -0.9006 0.9006 0.4346 -183.8286 367.5092)\" class=\"st7_resting-49\" cx=\"200.8\" cy=\"330.2\" rx=\"3.7\" ry=\"20.1\"></ellipse></g><g id=\"Lamp_resting-49\"><path class=\"st4_resting-49\" d=\"M79.5,285.3c-0.6,0-1.3-0.1-1.8-0.4l-0.3,1.9l29.9,0.8v-2.2L79.5,285.3z\"></path><path class=\"st4_resting-49\" d=\"M77.7,285l-0.3,1.8l16.5,9.5V294C88.3,291.3,83,288.2,77.7,285z\"></path><path class=\"st4_resting-49\" d=\"M94.3,156.2c-1,0.2-2,0-2.9-0.4l-18.9,146c1.2,0.7,2.3,1.3,3.5,2l19.1-147.7C94.9,156.1,94.6,156.2,94.3,156.2\n\t\tz\"></path><path class=\"st4_resting-49\" d=\"M98.7,156c-0.7,0.1-1.4,0.1-2.1,0c-0.6,0-1.1,0-1.7,0.1l12.8,149.8c1-0.5,2-0.9,3-1.3l0.5-0.2h0.1L98.7,156z\"></path><path class=\"st4_resting-49\" d=\"M96.6,156.1c-0.8,0-1.5,0-2.3,0.1c-0.3,0-0.6,0.1-0.9,0.1l-1.2,158.3l0,0c0.6-0.2,1.3-0.3,2-0.2h1.1l0.6-0.1\n\t\tl1.2-158.2L96.6,156.1z\"></path><path class=\"st8_resting-49 targetColor\" d=\"M75.9,158.6v32.7c0,0,37.6,1.1,37.6,0v-32.7\" style=\"fill: rgb(0, 49, 83);\"></path><ellipse class=\"st8_resting-49 targetColor\" cx=\"94.8\" cy=\"158.5\" rx=\"18.8\" ry=\"8.7\" style=\"fill: rgb(0, 49, 83);\"></ellipse><ellipse class=\"st9_resting-49\" cx=\"94.8\" cy=\"158.5\" rx=\"18.8\" ry=\"8.7\"></ellipse><ellipse class=\"st8_resting-49 targetColor\" cx=\"94.8\" cy=\"191.8\" rx=\"18.8\" ry=\"8.7\" style=\"fill: rgb(0, 49, 83);\"></ellipse></g><g id=\"Sofa_resting-49\"><path class=\"st8_resting-49 targetColor\" d=\"M354.5,354.4c0,0,6-0.7,12.9-6s-12.9-4.5-12.9-4.5V354.4z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st10_resting-49\" d=\"M354.5,354.4c0,0,6-0.7,12.9-6s-12.9-4.5-12.9-4.5V354.4z\"></path><path class=\"st7_resting-49\" d=\"M209.5,256.4v17.7c0,0,0.9,2.5,5,2.2s4.7-2.8,4.7-2.8v-21.2L209.5,256.4z\"></path><path class=\"st7_resting-49\" d=\"M339,335.7v17.7c0,0,0.9,2.5,5,2.2s4.7-2.8,4.7-2.8v-21.2L339,335.7z\"></path><path class=\"st8_resting-49 targetColor\" d=\"M367.6,260.1c8.8-5.8,17.9-11.2,26.7-17.1l-142.9-81.7c-5.7-3.3-12.8-3.2-18.5,0.1l-39.5,23.2\n\t\tc-6.5,3.8-5.5,9.6-5.5,9.6s-1.8,54.2,0,57.8s7.2,6,7.2,6l159.4,96.3C367.5,344.4,356.9,267.2,367.6,260.1z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st9_resting-49\" d=\"M367.6,260.1c8.8-5.8,17.9-11.2,26.7-17.1l-142.9-81.7c-5.7-3.3-12.8-3.2-18.5,0.1l-39.5,23.2\n\t\tc-6.5,3.8-5.5,9.6-5.5,9.6s-1.8,54.2,0,57.8s7.2,6,7.2,6l159.4,96.3C367.5,344.4,356.9,267.2,367.6,260.1z\"></path><path class=\"st8_resting-49 targetColor\" d=\"M375,272.6c0,0-132.9-76.2-132.6-77s0-28.6,0-28.6l156.8,90.3L375,272.6z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st8_resting-49 targetColor\" d=\"M412.4,255.2l-1.8-0.2c-2.8,2.1-5.8,3.8-9,5.1c-13.2,9.9-28,18.2-42.8,25.7v63.8c1.9,0.4,3.8,0.5,5.8,0.3\n\t\tl40.9-24.2c5.3-3.2,8.6-8.9,8.6-15.1v-53.7C413.5,256.3,412.9,255.8,412.4,255.2z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st10_resting-49\" d=\"M375,272.6c0,0-132.9-76.2-132.6-77s0-28.6,0-28.6l156.8,90.3L375,272.6z\"></path><path class=\"st8_resting-49 targetColor\" d=\"M202.6,217.9l40.1-22.4l151.8,87.1l-45.6,24.9c-2.2,1.2-4.8,1.2-6.9,0l-139.4-78.3c-3.1-1.8-4.3-5.7-2.5-8.9\n\t\tC200.7,219.3,201.5,218.5,202.6,217.9z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st10_resting-49\" d=\"M412.4,255.2l-1.8-0.2c-2.8,2.1-5.8,3.8-9,5.1c-13.2,9.9-28,18.2-42.8,25.7v63.8c1.9,0.4,3.8,0.5,5.8,0.3\n\t\tl40.9-24.2c5.3-3.2,8.6-8.9,8.6-15.1v-53.7C413.5,256.3,412.9,255.8,412.4,255.2z\"></path><path class=\"st8_resting-49 targetColor\" d=\"M189.2,186.4c0,0-3.9,1.3,0,6.1s18-5.3,18-5.3l35.1-20.2l156.8,90.3l-40.9,23.3c0,0-3.2,2.5-0.8,5.3\n\t\ts5.7,1.5,12.4-1.8s43-23.9,43-23.9s3.6-2.5-1.9-7.1s-161.2-92.3-161.2-92.3s-5.8-5.3-12.9-1.7S189.2,186.4,189.2,186.4z\" style=\"fill: rgb(0, 49, 83);\"></path></g><g id=\"Wall_Photo_resting-49\"><path class=\"st6_resting-49\" d=\"M373.1,121.6l-1.1,62.5c0,2.2-1.8,3.9-4,3.9c-0.6,0-1.2-0.2-1.7-0.4l-53.1-26.5c-1.8-0.9-2.9-2.7-2.9-4.8\n\t\tl1.1-62.6c0.1-2.4,2-4.2,4.4-4.2c0.6,0,1.3,0.2,1.8,0.5l52.7,26.8C372.1,117.8,373.2,119.6,373.1,121.6z\"></path><path class=\"st11_resting-49\" d=\"M340.3,152.6c-3.8-6.6-7.3-13.4-10.6-20.2c-2.1-4.3-8.5-0.5-6.4,3.8c3.3,6.9,6.9,13.6,10.6,20.2\n\t\tC336.2,160.5,342.6,156.8,340.3,152.6z\"></path><path class=\"st11_resting-49\" d=\"M355.6,151.1c-7.7-11.9-14.7-24.2-21-36.9c-2.1-4.3-8.6-0.5-6.4,3.8c6.3,12.7,13.3,25,21,36.9\n\t\tC351.8,158.9,358.2,155.1,355.6,151.1z\"></path><path class=\"st11_resting-49\" d=\"M353.2,124.1c-4.8,0-4.8,7.5,0,7.5S358,124.1,353.2,124.1z\"></path></g><g id=\"Character_resting-49\"><polygon class=\"st11_resting-49\" points=\"374.2,280.7 365.4,277.2 368.1,263.1 376.4,261.3 \t\"></polygon><path class=\"st11_resting-49\" d=\"M374.2,280.7c0,0-0.8-6.7-1.3-9.8s-2.5-20.2,5.4-19.7s2.9,17.3,3.1,19.1s1,7.1-0.1,8.7\n\t\tS376.8,282.5,374.2,280.7z\"></path><path class=\"st12_resting-49\" d=\"M378.3,251.3c-4.6-0.3-5.9,5.5-6,10.9l-4.2,0.9l-2.7,14.2l8.9,3.5c2.5,1.7,5.9,0,7.1-1.6s0.4-6.8,0.1-8.7\n\t\tS386.2,251.9,378.3,251.3z\"></path><path class=\"st4_resting-49\" d=\"M243.9,151.4c0,0-4.7,1.6-5.2,1.6s-8.8-0.1-8.3,4.7s13.5,3.6,13.5,3.6l6-6.2\"></path><path class=\"st4_resting-49\" d=\"M227.2,157.2l6.6-2.2c0,0,8.1-1.7,8.9,0s-1.5,7.4-2.2,7.6l-6.1,1.4l-6,0.7\"></path><path class=\"st6_resting-49\" d=\"M279.7,221.1c0,0,41.2,26.7,45.2,27.1s44.7,16,44.7,16s-2,10.1-0.9,14.8c0,0-74.3-18.5-83.6-21.6\n\t\ts-30.8-24.2-25.4-29.8C265.1,222,279.7,221.1,279.7,221.1z\"></path><path class=\"st5_resting-49\" d=\"M279.7,221.1c0,0,41.2,26.7,45.2,27.1s44.7,16,44.7,16s-2,10.1-0.9,14.8c0,0-74.3-18.5-83.6-21.6\n\t\ts-30.8-24.2-25.4-29.8C265.1,222,279.7,221.1,279.7,221.1z\"></path><path class=\"st13_resting-49\" d=\"M255.8,178.9c3.4-3.1,9-17.2,7.6-20.5s-10.5,2.1-10.5,2.1l-9.1-9.2c0,0,12.7-10.3,18.7-11.9\n\t\ts10.7,0.3,12.7,7.4s-4.4,32.4-3.6,37.8s8,36.3,8,36.3c-5.8,9.8-29.4,14.9-32.7,14.1s-20.1-37.9-20.1-37.9s-31.4-20.2-27.2-29.6\n\t\ts22.3-12.1,26-12.5s6.5,11.4,6.5,11.4s-11.9,3.3-13,4.8s4.1,5.4,14,7.5s12.1,0.9,12.1,0.9\"></path><path class=\"st11_resting-49\" d=\"M384.2,267.4c0,0,2.9,1.9,4.8-0.4s3-20.9,4.5-24.6s1.6-10.3-3-10.8s-5.2,1.8-6.2,4.8s-4.7,12.3-8.1,13.4\n\t\tc-2.9,0.9-5.8,1.6-8.8,2.2l0.8,11L384.2,267.4z\"></path><path class=\"st7_resting-49\" d=\"M252.4,183.9c0,0,8.1,36.2,8.4,37.1s7.7,5.2,7.7,5.2l1.6-6.5l-15.5-36.5L252.4,183.9z\"></path><path class=\"st14_resting-49\" d=\"M241.7,180.2c0,0,10.6,9,10.1,8.4s2.3-4.2,2.3-4.2l4.7,1.4l-5.4-9.4\"></path><path class=\"st4_resting-49\" d=\"M258.5,163.4c0,0,4,14.6-2.6,17.8s-11.2-1.6-13.2-5.9s-1.2-14.6,7.3-15.6C257.4,158.7,258.5,163.4,258.5,163.4\n\t\tz\"></path><path class=\"st15_resting-49\" d=\"M259.8,160.6c0.7-1.8,1-5-1.1-6c-1.6-0.6-3.4-0.3-4.7,0.9c-0.7-0.6-1.6-1-2.5-1.2c-3.4-1-7-0.2-9.7,2.1\n\t\tc-0.1,0.1-0.3,0.2-0.4,0.3c-0.2,0.1-0.4,0.1-0.6,0.1c-5.2,0.1-6.3,6-5.4,10c0.9,4.2,3.1,7.9,6.3,10.8c1.4,1.1,3,1.9,4.7,2.4\n\t\tc0.2,0.1,0.4-0.1,0.5-0.3v-0.1c0.2-0.1,0.3-0.4,0.2-0.7l0,0c-0.4-0.9-0.6-1.9-0.4-2.8c0-0.1,0-0.3-0.1-0.4c0.2-0.2,0.2-0.5,0-0.7\n\t\tc-0.1-0.1-0.2-0.1-0.3-0.1c-1.1,0.1-2.2-0.3-3-1.1c-0.5-0.5-0.9-1.5,0.1-1.7c0.4-0.1,0.7,0,1,0.3c0.1,0.2,0.3,0.5,0.5,0.7\n\t\tc0.1,0.1,0.2,0.1,0.3,0.1c0.4,0.1,0.8-0.2,0.6-0.6c-0.2-0.3-0.4-0.5-0.6-0.8c-0.7-1.1-0.4-2.5,0.5-3.4c1.2-1.1,2.3-0.5,3.7-0.4\n\t\tc0.9,0.1,1.8-0.4,2-1.3c0-0.6-0.1-1.2-0.2-1.7c0-0.9,0.5-1.7,1.3-2c1.5-0.6,2.4,0.7,3.5,1.4c0.9,0.7,2.1,0.9,3.2,0.6\n\t\tc1.4-0.4,2.3-1.8,1.9-3.2c-0.1-0.4-0.3-0.7-0.5-1C260.2,160.6,260,160.5,259.8,160.6z M250.8,162.7c0.2-0.3,0.4-0.5,0.7-0.6\n\t\tc0.1,0,0.2-0.1,0.3-0.2h0.1l0.1,0.1C251.5,162.1,251.1,162.4,250.8,162.7L250.8,162.7z M259.1,159.6L259.1,159.6\n\t\tc0-0.2,0.1-0.3,0.1-0.5C259.2,159.2,259.2,159.4,259.1,159.6L259.1,159.6z\"></path><path class=\"st6_resting-49\" d=\"M247,235.2c0,0,6.8,21,20.4,25.4c13.6,4.3,24.5-4,30.8-2.1s58,8.2,71.5,5.8c0,0,2.3-14.4-0.9-17.5\n\t\ts-59.7-14.4-65.3-15.2s-30.2-4.5-30.2-4.5\"></path></g></svg>"

/***/ }),

/***/ "./assets/scrum-board-27.svg":
/*!***********************************!*\
  !*** ./assets/scrum-board-27.svg ***!
  \***********************************/
/***/ ((module) => {

module.exports = "<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 500 500\" style=\"width: 213px;\" xml:space=\"preserve\" data-imageid=\"scrum-board-27\" imageName=\"Scrum Board\" class=\"illustrations_image\"><style type=\"text/css\"> .st0_scrum-board-27{fill:#FFE922;} .st1_scrum-board-27{opacity:0.32;fill:url(#SVGID_1_);enable-background:new ;} .st2_scrum-board-27{fill:url(#SVGID_00000070839622645231592330000006216104606246164134_);} .st3_scrum-board-27{opacity:0.32;fill:url(#SVGID_00000079461928213063612320000005995035490293984951_);enable-background:new ;} .st4_scrum-board-27{fill:#FFC65A;} .st5_scrum-board-27{fill:#68E1FD;} .st6_scrum-board-27{opacity:0.52;fill:#091114;enable-background:new ;} .st7_scrum-board-27{fill:#AA6800;} .st8_scrum-board-27{fill:#091114;} .st9_scrum-board-27{fill:#F15A24;} .st10_scrum-board-27{fill:#AD3C04;} .st11_scrum-board-27{fill:#E28133;} .st12_scrum-board-27{opacity:0.46;fill:#091114;enable-background:new ;} .st13_scrum-board-27{fill:#FFAC99;} </style><path id=\"Base_scrum-board-27\" class=\"st0_scrum-board-27\" d=\"M54,309.8l245.1,136.7c4.7,2.6,10.6,2.4,15.1-0.6l124.2-83.2c6.6-4.4,8.4-13.4,4-20\n\tc-1.3-1.9-3-3.5-5-4.6L204.2,209.5c-4.3-2.4-9.6-2.4-13.9,0L54,284.5c-7,3.9-9.5,12.7-5.6,19.7C49.7,306.6,51.6,308.5,54,309.8z\"></path><g id=\"Shadow_scrum-board-27\"><linearGradient id=\"SVGID_1_-scrum-board-27\" gradientUnits=\"userSpaceOnUse\" x1=\"268.6005\" y1=\"75.5794\" x2=\"286.1605\" y2=\"89.4094\" gradientTransform=\"matrix(1 0 0 -1 0 502)\"><stop offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0\"></stop><stop offset=\"0.98\" style=\"stop-color:#AA6800\"></stop></linearGradient><path class=\"st1_scrum-board-27\" d=\"M334.6,369.2l-82.3,48.3l19.2,10.6l81.3-46.2C341.7,374.5,344.1,378.4,334.6,369.2z\"></path><linearGradient id=\"SVGID_00000145757200576483870920000017669064205776380083_-scrum-board-27\" gradientUnits=\"userSpaceOnUse\" x1=\"113.3894\" y1=\"232.3604\" x2=\"78.7594\" y2=\"184.8304\" gradientTransform=\"matrix(1 0 0 -1 0 502)\"><stop offset=\"0\" style=\"stop-color:#F15A24\"></stop><stop offset=\"1\" style=\"stop-color:#FFFFFF\"></stop></linearGradient><path style=\"fill:url(#SVGID_00000145757200576483870920000017669064205776380083_);\" d=\"M93.4,321.3c9.7-8.3,16.7-16,26.7-23.9\n\t\tl-35.2-3.6l-22.4,8.8C72.6,309.1,83,315.2,93.4,321.3z\"></path><linearGradient id=\"SVGID_00000062899500111323453690000014843590903433435838_-scrum-board-27\" gradientUnits=\"userSpaceOnUse\" x1=\"140.4908\" y1=\"113.1388\" x2=\"222.4408\" y2=\"166.8588\" gradientTransform=\"matrix(1 0 0 -1 0 502)\"><stop offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0\"></stop><stop offset=\"0.98\" style=\"stop-color:#AA6800\"></stop></linearGradient><path style=\"opacity:0.32;fill:url(#SVGID_00000062899500111323453690000014843590903433435838_);enable-background:new ;\" d=\"\n\t\tM212.2,323.1l-105.7,59.3l38.7,23.1l103.4-58.7C234.6,337.3,224.3,334.8,212.2,323.1z\"></path></g><g id=\"Pencil_scrum-board-27\"><polyline class=\"st4_scrum-board-27\" points=\"385,341.5 411.5,337.4 388.4,361 \t\"></polyline><ellipse class=\"st5_scrum-board-27 targetColor\" cx=\"385\" cy=\"351.8\" rx=\"7.9\" ry=\"10.2\" style=\"fill: rgb(0, 49, 83);\"></ellipse><polygon class=\"st5_scrum-board-27 targetColor\" points=\"294.6,414.9 388.4,361 382,342.3 287.9,396.4 \t\" style=\"fill: rgb(0, 49, 83);\"></polygon><ellipse class=\"st5_scrum-board-27 targetColor\" cx=\"291.6\" cy=\"405.5\" rx=\"7.9\" ry=\"10.2\" style=\"fill: rgb(0, 49, 83);\"></ellipse><ellipse class=\"st6_scrum-board-27\" cx=\"291.6\" cy=\"405.5\" rx=\"7.9\" ry=\"10.2\"></ellipse><path class=\"st7_scrum-board-27\" d=\"M411.5,337.4l-10,1.6c0,0,3.8,1.3,2.7,5.9L411.5,337.4z\"></path></g><g id=\"Board_scrum-board-27\"><path class=\"st8_scrum-board-27\" d=\"M348.5,248.1c0-6.8-10.6-6.8-10.6,0c0.2,29.3,1.4,58.5,3.5,87.7c0.5,6.8,11.1,6.8,10.6,0\n\t\tC349.9,306.6,348.7,277.4,348.5,248.1z\"></path><path class=\"st8_scrum-board-27\" d=\"M282.7,223.7L245,275.4c-4,5.5,5.2,10.8,9.2,5.4l37.7-51.7C295.9,223.6,286.7,218.3,282.7,223.7z\"></path><path class=\"st9_scrum-board-27\" d=\"M428.8,163.2L230.5,49.1c-2.9-1.6-6.6-0.6-8.2,2.3c-0.4,0.8-0.7,1.6-0.8,2.4L208.7,212c-0.2,2.3,1,4.6,3,5.8\n\t\tl194,109.9c2.9,1.6,6.6,0.6,8.3-2.3c0.4-0.7,0.7-1.5,0.7-2.3l17-153.9C432,166.8,430.9,164.4,428.8,163.2z\"></path><polygon class=\"st5_scrum-board-27 targetColor\" points=\"408.9,201.3 324.9,154.3 313.2,252.5 397.5,299.8 \t\" style=\"fill: rgb(0, 49, 83);\"></polygon><path class=\"st5_scrum-board-27 targetColor\" d=\"M249.9,97c0,0,0.1,34.4-6.1,41.3l26.1,15.2c2.7-3.5,4.5-7.5,5.3-11.9c0.6-3.9,2.5-29.5,2.5-29.5L249.9,97z\" style=\"fill: rgb(0, 49, 83);\"></path><path class=\"st5_scrum-board-27 targetColor\" d=\"M281.7,115.4c0,0,0.1,34.4-6.1,41.3l26.1,15.2c2.7-3.5,4.5-7.5,5.3-11.9c0.6-3.9,2.5-29.5,2.5-29.5\n\t\tL281.7,115.4z\" style=\"fill: rgb(0, 49, 83);\"></path><polygon class=\"st8_scrum-board-27\" points=\"347.8,160.9 345,171.9 392.2,197.6 395.5,188 \t\"></polygon><circle class=\"st10_scrum-board-27\" cx=\"296.2\" cy=\"122.7\" r=\"4.4\"></circle><polygon class=\"st10_scrum-board-27\" points=\"291.5,242.6 299.5,181.1 245.9,148.9 \t\"></polygon><polygon class=\"st4_scrum-board-27\" points=\"244.4,149.8 291.5,177.3 291.5,242.6 244.4,214.3 \t\"></polygon><circle class=\"st10_scrum-board-27\" cx=\"266.4\" cy=\"104\" r=\"4.3\"></circle></g><g id=\"Lamp_scrum-board-27\"><path class=\"st11_scrum-board-27\" d=\"M88.4,278.5c-0.6,0-1.3-0.1-1.8-0.4l-0.3,1.9l29.7,0.8v-2.2H88.4z\"></path><path class=\"st11_scrum-board-27\" d=\"M86.5,278.1l-0.3,1.8l16.4,9.5v-2.3C97.2,284.4,91.8,281.3,86.5,278.1z\"></path><path class=\"st11_scrum-board-27\" d=\"M103.1,149.9c-1,0.2-2,0-2.8-0.4L81.4,294.9c1.1,0.7,2.3,1.3,3.5,2l19.1-147\n\t\tC103.7,149.9,103.4,149.9,103.1,149.9z\"></path><path class=\"st11_scrum-board-27\" d=\"M107.4,149.8c-0.7,0.1-1.4,0.1-2.1,0c-0.6,0-1.1,0-1.7,0.1l12.7,149.1c1-0.5,2-0.9,3-1.3l0.5-0.3h0.1\n\t\tL107.4,149.8z\"></path><path class=\"st11_scrum-board-27\" d=\"M105.4,149.8c-0.8,0-1.5,0.1-2.3,0.2c-0.3,0-0.6,0.1-0.9,0.1L101,307.5l0,0c0.6-0.2,1.3-0.3,2-0.2h1.1\n\t\tl0.6-0.1l1.2-157.5L105.4,149.8z\"></path><path class=\"st5_scrum-board-27 targetColor\" d=\"M84.8,152.3v32.6c0,0,37.5,1.1,37.5,0v-32.6\" style=\"fill: rgb(0, 49, 83);\"></path><ellipse class=\"st5_scrum-board-27 targetColor\" cx=\"103.6\" cy=\"152.2\" rx=\"18.7\" ry=\"8.7\" style=\"fill: rgb(0, 49, 83);\"></ellipse><ellipse class=\"st12_scrum-board-27\" cx=\"103.6\" cy=\"152.2\" rx=\"18.7\" ry=\"8.7\"></ellipse><ellipse class=\"st5_scrum-board-27 targetColor\" cx=\"103.6\" cy=\"185.3\" rx=\"18.7\" ry=\"8.7\" style=\"fill: rgb(0, 49, 83);\"></ellipse></g><g id=\"Character_scrum-board-27\"><path class=\"st13_scrum-board-27\" d=\"M244.5,165.7c0,0-0.9-5.9,0-8.1s1.4-8.6,1.4-8.6c1.2-0.3,2.3,0.4,2.8,1.5c0.8,2-0.9,6.8-0.9,6.8\n\t\ts4.9,10.1,0,14.7S244.5,165.7,244.5,165.7z\"></path><path class=\"st8_scrum-board-27\" d=\"M212.1,197.2l32.4-31.6c0,0,7.3,15.9,0,23.2l-29.7,29.5\"></path><path class=\"st10_scrum-board-27\" d=\"M206.1,327.8c0,0-4.5,6.2-4.1,9.8s6.1,9.7,7.4,12.3s1.6,3.7,0,5.6s-15.6-10.2-15.9-12.2s1.9-9.4,1.9-9.4\n\t\tl-6.2,7.8l-4.5-2.6l9.6-16.1\"></path><path class=\"st8_scrum-board-27\" d=\"M207.9,355.8c-0.4-0.4-11.4-4.2-11.4-4.2s-5.2-5.4-5-7.5s2-10.2,4-10.1s2.1,10.9,2.1,10.9L207.9,355.8z\"></path><path class=\"st10_scrum-board-27\" d=\"M221,338.1l1.4,16.5c0,0,3.6,2.6,4.4,2.4s3.5-0.9,3.5-1.3s-1.3-11.7-0.9-12s5.8,8.6,7.6,8.8\n\t\ts14.8-7.4,13.5-10.3s-7.6-1.4-10.7-1.4s-7.4-1.8-9.8-7.2\"></path><path class=\"st4_scrum-board-27\" d=\"M229.3,293.4l8,42.3c0,0-4.6,6-21.1,5.3l-12.3-30\"></path><path class=\"st4_scrum-board-27\" d=\"M232.8,227c0,0,12.3,18,8.5,47.1c-3.4,25.8-29.1,56.2-29.1,56.2s-7.7,3.4-23.7-11.8l17.7-28.1\n\t\tc0,0-17.2-40,3.1-65.3\"></path><path class=\"st13_scrum-board-27\" d=\"M267.5,192.5c0-2.3,3.5-2.3,3.6,0c0,1.2,0,2.4,0,3.6c0.1-0.3,0.3-0.5,0.4-0.8c1.4-3.3,2.5-6.8,3.2-10.4\n\t\tc0.4-2.3,3.8-1.3,3.5,1c-0.2,1.7-0.6,3.5-1.1,5.2l0.4-0.1c1.2-0.4,2.6,0.3,3,1.6c0,0,0,0.1,0,0.1c0.2,0.5,0.2,1.1,0.1,1.7h0.3\n\t\tc1,0.3,1.8,1.2,1.8,2.3c0,0.6-0.1,1.2-0.5,1.7c0.4,0.4,0.7,0.8,0.9,1.4c0.1,1.3-0.4,2.6-1.5,3.3c-1.2,1-2.6,2.4-3.7,3.5\n\t\tc-1.5,1.4-3.2,2.9-4.5,4s-3.7-2.7-3.7-3.9c-0.9,0.3-1.8-0.2-2.1-1c-0.1-0.2-0.1-0.4-0.1-0.6C267.5,200.8,267.6,196.7,267.5,192.5z\"></path><path class=\"st10_scrum-board-27\" d=\"M274.7,196.3c0.9-1.8,1.6-3.6,2.4-5.4c0.1-0.4,0.8-0.2,0.6,0.2c-0.7,1.9-1.5,3.7-2.4,5.6\n\t\tC275.1,197.1,274.5,196.7,274.7,196.3z\"></path><path class=\"st8_scrum-board-27\" d=\"M231,187.3c0,0,6,5.4,8.3,9.2s11.6,14,15.5,10.9c3.8-3.1,10.6-9,10.6-9s9.7,6.7,8.7,13.6c0,0-8.6,17.6-22,13.7\n\t\ts-16.8-9-16.8-9l-2,11.4c0,0-16.7,5.2-24.4-2.5c0,0-5.1-32.9-1.3-37.8\"></path><path class=\"st13_scrum-board-27\" d=\"M232.8,167.4c0.1,0.4,0.4,12.3-3.6,13.4s-11-1.7-12.8-5.5s0.8-15.8,7.2-16.5S231.7,163.9,232.8,167.4z\"></path><path class=\"st11_scrum-board-27\" d=\"M227.9,169.6c-2.7,1.8-1,5.2,0.1,7.4c0.8,1.7,1.2,3.6,1.2,5.4c0,1.8,0.6,3.5,1.7,4.8c0.9,1.1,1.7,2.3,2.3,3.6\n\t\tc-5.8,1.3-12,0.9-17.9,0.2c-4.9-0.4-9.8-1-14.6-1.9c0.1-1,0.3-2,0.7-3c1.1-2.6,3-4,2.6-7.1c-0.4-2.4-1-4.7-0.1-7.1s2.9-3.6,4.9-5\n\t\tc0.6-0.4,1.1-0.9,1.6-1.4l0.4-0.7c1.2-2,2-4.4,3.6-6.1c1.6-1.6,3.6-2.6,5.8-3c4.6-0.8,9.4,0.2,13.2,3c0,0,3.5,3.4,2.4,6.9\n\t\tS230.3,168,227.9,169.6z\"></path><path class=\"st10_scrum-board-27\" d=\"M230.9,302.1c0,0-14.1,24.4-18.7,28.1l3.9,10.8C216.2,341,232.5,318,230.9,302.1z\"></path><path class=\"st10_scrum-board-27\" d=\"M206.5,289c4.5-9.5,7-19.8,7.4-30.3c0-0.4,0.4-0.6,0.7-0.6c0.3,0,0.5,0.3,0.6,0.6c-0.4,10.7-2.9,21.3-7.5,31\n\t\tC207.2,290.5,206.1,289.8,206.5,289z\"></path></g></svg>"

/***/ }),

/***/ "./src/components/card.js":
/*!********************************!*\
  !*** ./src/components/card.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Card: () => (/* binding */ Card)
/* harmony export */ });
/* harmony import */ var _modules_gui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/gui */ "./src/modules/gui.js");
/* harmony import */ var _modules_logic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/logic */ "./src/modules/logic.js");
/* harmony import */ var _modules_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/storage */ "./src/modules/storage.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/utils */ "./src/modules/utils.js");
/* harmony import */ var _todoform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./todoform */ "./src/components/todoform.js");
/* harmony import */ var _sidebar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sidebar */ "./src/components/sidebar.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/format.mjs");








/**
 * Interface collecting functions that are called from within
 * or should hae effect on a Card displaying information
 * about a Todo. Also handles interactive elements such as
 * buttons to edit or delete todos.
 */
class Card {
    constructor() {}

    //#region Implementing singleton pattern
    static getInstance() {
        if (!Card.instance) {
            Card.instance = new Card();
        }
        return Card.instance;
    }
    //#endregion

    /**
     * Changes the status of a Todo and its appearance to reflect the change.
     * @param {*} todo
     * @param {*} todoUI
     */
    static checkTodo(todo, todoUI) {
        todo.toggleStatus();
        todoUI.classList.toggle("done");

        // Ternary operator in case we are in the "General" view or in a filtered one.
        _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(
            _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.getCurrentProject().getUid() === todo.project
                ? _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.getCurrentProject()
                : _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(todo.project)
        );
    }

    /**
     * Edits the UI Card to reflect changes to the Todo item.
     * @param {*} element
     * @param {*} todoUI
     */
    static editTodoUI(element, todoUI) {
        const elementToEdit = todoUI.querySelector(`[prop=${element[0]}]`);
        let newValue = element[1];

        if (element[0] === "dueDate") {
            newValue = (0,date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(newValue, "d MMM yyyy");
        }

        if (elementToEdit) elementToEdit.textContent = newValue;
    }

    /**
     * Deletes a todo from the in-memory list and from the UI view.
     * @param {*} todo
     * @param {*} todoUI
     */
    static deleteTodo(todo, todoUI) {
        let project =
            _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.getCurrentProject().getUid() === todo.project
                ? _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.getCurrentProject()
                : _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(todo.project);

        document.querySelector("#todoView").removeChild(todoUI);

        _modules_logic__WEBPACK_IMPORTED_MODULE_1__.Logic.deleteTodo(project, todo);
        _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(project);

        _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.update()
        _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.checkIfFiltered()
    }

    /**
     * Creates a new UI todo from the supplied Todo instance. Builds
     * from the todo template inside the main html file and loads event
     * listeneres for buttons inside tha card. Also check at creation time
     * if the todo is already done or not and applies style accordingly.
     * @param {*} todo
     * @returns
     */
    static createCard(todo) {
        // Clones the todo to display from the template. Cleans its properties.
        const template = document.querySelector(".todoTemplate");
        const newCard = template.cloneNode(true);
        newCard.classList.remove("todoTemplate");
        newCard.classList.add("todo");
        newCard.setAttribute("uid", todo.getUid());

        // Checkbox activation and card styling according to todo status.
        const checkbox = newCard.querySelector(".doneCheck");
        if (todo.getStatus()) {
            newCard.classList.add("done");
            checkbox.checked = true;
        }
        checkbox.onchange = () => this.checkTodo(todo, newCard);

        // Populates the Todo card with data from the passed Todo  instance.
        newCard.querySelector(".todoTitle").textContent = todo.title;
        newCard.querySelector(".todoDesc").textContent = todo.description;
        newCard.querySelector(".todoProject").textContent = _modules_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.toTitleCase(
            _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(todo.project).name
        );
        newCard.querySelector("time").datetime = todo.dueDate;
        newCard.querySelector("time").textContent = todo.dueDate;

        // Activates buttons functionality
        const editButton = newCard.querySelector(".editButton");
        editButton.onclick = () => _todoform__WEBPACK_IMPORTED_MODULE_4__.TodoForm.openForm("edit", todo);

        const deleteButton = newCard.querySelector(".deleteButton");
        deleteButton.onclick = () => this.deleteTodo(todo, newCard);

        _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.update()

        return newCard;
    }
}


/***/ }),

/***/ "./src/components/projectform.js":
/*!***************************************!*\
  !*** ./src/components/projectform.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProjectForm: () => (/* binding */ ProjectForm)
/* harmony export */ });
/* harmony import */ var _modules_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/storage */ "./src/modules/storage.js");
/* harmony import */ var _sidebar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sidebar */ "./src/components/sidebar.js");
/* harmony import */ var _modules_logic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/logic */ "./src/modules/logic.js");
/* harmony import */ var _modules_gui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/gui */ "./src/modules/gui.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/utils */ "./src/modules/utils.js");

 




/**
 * Contains functionalities for the dialog and inner form
 * deployed to create and edit projects inside the app.
 */
const ProjectForm = (() => {
    
    const dialog = {
        modal:         document.querySelector("#projectForm"),
        closebtn:      document.querySelector("#closeProjectForm"),
        savebtn:       document.querySelector("#saveProject"),
        name:          document.querySelector("#projectFormName"),
        description:   document.querySelector("#projectDesc"),
        uicolor:       document.querySelector("#projectColor"),
        circle:        document.querySelector("#colorCircle")
    };
    
    /**
     * Initializes the project creation dialog by grabbin refereces to
     * inputs and activates buttons and menus.
     */
    function init() {
        dialog.closebtn.onclick = () => closeForm();
        dialog.uicolor.onchange = () => updateColorCircle(dialog.uicolor.value)
        dialog.savebtn.disabled = true;
        dialog.name.oninput = () => preventEmptyProject();
    }
    
    /**
     * Opens the form checking the mode: editing or creation.
     * @param {} mode 
     * @param {*} project 
     */
    function openForm(mode="create", project=null) {
        dialog.modal.show();
        _modules_gui__WEBPACK_IMPORTED_MODULE_3__.Gui.toggleOverlay();
        (mode === "edit") ? openForEditing(project) : openForCreation();
    }
    
    /**
     * Opens the Project form in creation mode.
     */
    function openForCreation() {
        dialog.savebtn.onclick = () => saveNewProject();
    }

    /**
     * Opens the Project form in editing mode.
     * @param {*} project 
     */
    function openForEditing(project) {

        const propertiesToUpdate = ["name", "description", "uicolor" ]
        .forEach((property) => dialog[property].value = project[property])
        updateColorCircle(project.uicolor)

        dialog.savebtn.textContent = "Save changes";

        dialog.savebtn.onclick = (e) => {
            saveProjectChanges(project);
            closeForm();
        };

        dialog.modal.show()
    }

    /**
     * Closes the project modal and resets field values.
     */
    function closeForm() {
        dialog.modal.close();
        _modules_gui__WEBPACK_IMPORTED_MODULE_3__.Gui.toggleOverlay();
        resetForm();
    }

    /**
     * Reset field values.
     */
    function resetForm() {        
        [dialog.name, dialog.description, dialog.uicolor].forEach(
            (field) => field.value = "")
    }

    /**
     * Saves new project with data provided in the input form.
     */
    function saveNewProject() {

        const newProject = _modules_logic__WEBPACK_IMPORTED_MODULE_2__.Logic.createProject(
            dialog.name.value,
            dialog.description.value,
            dialog.uicolor.value
        );

        closeForm();
        
        _modules_storage__WEBPACK_IMPORTED_MODULE_0__.Store.saveProject(newProject);
        _sidebar__WEBPACK_IMPORTED_MODULE_1__.Sidebar.showProjects();
    }

    function saveProjectChanges(project) {
        const propertiesToWatch = [
            "name", 
            "description", 
            "uicolor", 
        ]
        for (const property of propertiesToWatch) {
            
            const newValue = dialog[property].value;
            const oldValue = project[property];

            if (newValue !== oldValue) {
                _modules_logic__WEBPACK_IMPORTED_MODULE_2__.Logic.editProject(project, property, newValue)
            }
        }
        
        _modules_storage__WEBPACK_IMPORTED_MODULE_0__.Store.saveProject(project);
        _sidebar__WEBPACK_IMPORTED_MODULE_1__.Sidebar.showProjects();
        
        if (project === _modules_gui__WEBPACK_IMPORTED_MODULE_3__.Gui.getCurrentProject()) _modules_gui__WEBPACK_IMPORTED_MODULE_3__.Gui.switchProject(project)

    }

    /**
     * Changes the color of the circle next to color picker to
     * give user a preview.
     * @param {*} color 
     */
    function updateColorCircle(color) {
        dialog.circle.style.backgroundColor = color;
    }

    /**
     * Prevents creation of unnamed projects by disabling the save button if
     * the user does not provide the name. The rest of values are set by
     * validation functions.
     */
        function preventEmptyProject() {
            _modules_utils__WEBPACK_IMPORTED_MODULE_4__.Utils.isValidString("name", dialog.name.value) 
            ? dialog.savebtn.removeAttribute("disabled")  
            : dialog.savebtn.setAttribute("disabled", true) 
        }

    return { init, openForm }
})();


/***/ }),

/***/ "./src/components/sidebar.js":
/*!***********************************!*\
  !*** ./src/components/sidebar.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sidebar: () => (/* binding */ Sidebar)
/* harmony export */ });
/* harmony import */ var _modules_gui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/gui */ "./src/modules/gui.js");
/* harmony import */ var _modules_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/storage */ "./src/modules/storage.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/utils */ "./src/modules/utils.js");
/* harmony import */ var _todoform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./todoform */ "./src/components/todoform.js");
/* harmony import */ var _projectform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./projectform */ "./src/components/projectform.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/format.mjs");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/isToday.mjs");
/* harmony import */ var _modules_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modules/filter */ "./src/modules/filter.js");








const Sidebar = (function() {

    const sidebar = {
        self:               document.querySelector("#sidebar"),
        addTodoButton:      document.querySelector("#addTodoButton"),
        addProjectButton:   document.querySelector("#addProject"),
        inboxTab:           document.querySelector("#inbox"),
        todayTab:           document.querySelector("#today"),
        todayNumber:        document.querySelector("#todoNumber"),
        projectList:        document.querySelector("#projectList"),
        foldButton:         document.querySelector(".foldButton"),
        unfoldButton:       document.querySelector(".foldButton.content")  
    }

    /**
     * Initalizes the Sidebar, gives the first update to dynamic sidebar
     * elements and activates buttons,
     */
    function init() {
        toggleTabSelection()
        updateTodayTodos();
        setTimeout(() => sidebar.self.classList.add("foldable"),500);

        [sidebar.foldButton, sidebar.unfoldButton]
        .forEach((btn) => btn.onclick = () => foldSidebar())
        sidebar.unfoldButton.style.display = "none";
        sidebar.addTodoButton.onclick = () => _todoform__WEBPACK_IMPORTED_MODULE_3__.TodoForm.openForm();
        sidebar.addProjectButton.onclick = () => _projectform__WEBPACK_IMPORTED_MODULE_4__.ProjectForm.openForm();

        sidebar.inboxTab.classList.toggle("current")
        sidebar.inboxTab.onclick = () => 
            _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.switchProject(_modules_storage__WEBPACK_IMPORTED_MODULE_1__.Store.loadProject("aaa000"));

        sidebar.todayTab.onclick = () => 
            _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.renderFiltered("dueDate", (0,date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(new Date(), "d MMM yyyy"));
    }

        /**
     * Closes the sidebar and lets the content area to expand.
     */
    function foldSidebar() {
        sidebar.self.classList.toggle("folded");
        sidebar.unfoldButton.style.display = (
            sidebar.unfoldButton.style.display === 'none') 
            ? 'block' 
            : 'none';
    }

    /**
     * Updates the number of today todos displayed in the Sidebar.
     */
    function updateTodayTodos() {
        const todayNumber = document.querySelector("#todoNumber");
        const todayTodos = _modules_storage__WEBPACK_IMPORTED_MODULE_1__.Store.loadAllTodos().filter((todo) =>
            (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isToday)(todo.dueDate)
        );
        todayNumber.textContent = todayTodos.length;
    }

    /**
     * Clears the Project list in the sidebar panel by wiping
     * todo child elements.
     */
    function clearProjects() {
        while (sidebar.projectList.firstChild) {
            sidebar.projectList.removeChild(projectList.firstChild);
        }
    }

    /**
     * Loads clickable projects tab under the porject list in the sidebar.
     * Uses the template from the hidden 'templates' html element.
     */
    function showProjects() {
        const template = document.querySelector("#projectTabTemplate");
        
        clearProjects();

        for (const project of Object.keys(localStorage)) {
            if (project === "aaa000") {
                continue;
            }

            const loaded = _modules_storage__WEBPACK_IMPORTED_MODULE_1__.Store.loadProject(project)
            const tab = template.cloneNode(true);
            
            tab.id = project.toLowerCase();
            tab.querySelector(".projectName").textContent =
                _modules_utils__WEBPACK_IMPORTED_MODULE_2__.Utils.toTitleCase(loaded.name);
            tab.querySelector("span").style.color =
                loaded.uicolor;
            tab.onclick = () => {
                _modules_gui__WEBPACK_IMPORTED_MODULE_0__.Gui.switchProject(_modules_storage__WEBPACK_IMPORTED_MODULE_1__.Store.loadProject(project));
            }
            sidebar.projectList.appendChild(tab);
        }
        toggleTabSelection()
    }

    /**
     * Enables graphical feedback for tab selection.
     */
    function toggleTabSelection() {
        const allSidebarTabs = document.querySelectorAll(".tab")
        allSidebarTabs.forEach((tab) => {
            tab.addEventListener("click", () => {
                allSidebarTabs.forEach(t => t.classList.remove("current"))
                tab.classList.toggle("current")
                if (tab.id !== "filters") _modules_filter__WEBPACK_IMPORTED_MODULE_5__.Filter.hideFilterPanel()
            }) 
        })
    }

    /**
     * Dispatches a click event to the Inbox Tab when needed.
     */
    function showInbox() {
        sidebar.inboxTab.click()
    }

    return { init, foldSidebar, updateTodayTodos, showProjects, showInbox }
})();


/***/ }),

/***/ "./src/components/todoform.js":
/*!************************************!*\
  !*** ./src/components/todoform.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TodoForm: () => (/* binding */ TodoForm)
/* harmony export */ });
/* harmony import */ var _modules_logic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logic */ "./src/modules/logic.js");
/* harmony import */ var _modules_gui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/gui */ "./src/modules/gui.js");
/* harmony import */ var _modules_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/storage */ "./src/modules/storage.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/utils */ "./src/modules/utils.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/format.mjs");
/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./card */ "./src/components/card.js");







/**
 * Interface for getting and manipulation data about a todo.
 * Handles static and interactive elements of the Todo dialog.
 */
const TodoForm = ( () => {
    
    const dialog = {
        modal:          document.querySelector("dialog"),
        form:           document.querySelector("#todoForm"),
        title:          document.querySelector("#formTitle"),
        description:    document.querySelector("#formDesc"),
        dueDate:        document.querySelector("#formDate"),
        priority:       document.querySelector("#formPriority"),
        project:        document.querySelector("#formProject"),
        closebtn:       document.querySelector("#closeForm"),
        savebtn:        document.querySelector("#saveTodo"),
    }

    /**
     * Initializes the form getting necessary references and adding
     * event listeners conncect for creation, saving and deletion of
     * todos in memory and UI.
     */
    function init() {
        dialog.form.onsubmit = (e) => e.preventDefault()
        dialog.closebtn.onclick = () => closeForm();
        dialog.title.oninput = () => preventEmptyTodo();
    }

    /**
     * Opens the form checking the mode: editing or creation.
     * @param {*} mode 
     * @param {*} todo 
     */
    function openForm(mode="create", todo=null) {
        updateProjectSelection();
        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.toggleOverlay();
        (mode === "edit") ? openForEditing(todo) : openForCreation();
    }

    /**
     * Closes the Todo form.
     */
    function closeForm() {
        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.toggleOverlay();
        dialog.modal.close();
        clearForm();
    }

    /**
     * Opens todo form in creation mode.
     */
    function openForCreation() {
        preventEmptyTodo();

        dialog.project.value = 
            !_modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject().filtered 
            ? _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject().getUid() 
            : "aaa000"

        dialog.savebtn.onclick = (e) => {
            saveNewTodo();
            closeForm();
        };
        
        dialog.modal.show()
    }

    /**
     * Opens todo form in editing mode.
     */
    function openForEditing(todo) {
        const propertiesToUpdate = ["title", "description", "priority", "project" ]
        .forEach((property) => dialog[property].value = todo[property])

        dialog.dueDate.value = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__.format)(todo.dueDate, "yyyy-MM-dd");
        dialog.savebtn.textContent = "Save changes";

        dialog.savebtn.onclick = (e) => {
            saveTodoChanges(todo);
            closeForm();
        };

        dialog.modal.show()
    }

    /**
     * Visual command to signal the Logic component to create a new todo
     * in memory and the Store to save it in storage.
     */
    function saveNewTodo() {   
        const todoProperties = {
            title:          dialog.title.value,
            description:    dialog.description.value,
            dueDate:        validateDate(dialog.dueDate.value),
            priority:       validatePriority(dialog.priority.value),
            projectID:      validateProject(dialog.project.value),
        }
        /**
         * If the project to update is the currently displayed one it will
         * just save it instead of reloading all todos. This check has been
         * added to handle when the user creates a todo from the general view.
         */
        const projectToUpdate =
            _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject().getUid() === todoProperties.projectID
            ? _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject()
            : _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(todoProperties.projectID);

        _modules_logic__WEBPACK_IMPORTED_MODULE_0__.Logic.createTodo(todoProperties, projectToUpdate);

        _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(projectToUpdate);

        if (projectToUpdate === _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject()) {
            _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.renderProject(_modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject());
        }

        console.log(_modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject(), todoProperties)

        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.update()
        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.checkIfFiltered()
    }

    /**
     * Edits the todo according the modified fields of the Todo form.
     * Will overwrite only the effective changes both in memory and UI.
     * @param {*} todo
     */
    function saveTodoChanges(todo) {
        const todoView = document.querySelector("#todoView");
        const todoUI = document.querySelector(`[uid="${todo.getUid()}"]`);

        const projectToUpdate =
            _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject().getUid() === todo.project
            ? _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.getCurrentProject()
            : _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(todo.project);

        let hasProjectChanged;

        const propertiesToWatch = [
            "title", 
            "description", 
            "dueDate", 
            "priority", 
            "project" 
        ]
        /**
         * If a property has changed with user input it will get
         * updated. This includes swapping todos between projects.
         */
        for (const property of propertiesToWatch) {
            
            const newValue = dialog[property].value;
            const oldValue = todo[property];

            if (newValue !== oldValue) {
                todo = _modules_logic__WEBPACK_IMPORTED_MODULE_0__.Logic.editTodo(
                    projectToUpdate,
                    todo,
                    property,
                    dialog[property].value
                );
                _card__WEBPACK_IMPORTED_MODULE_4__.Card.editTodoUI([property, newValue], todoUI);

                if (property === "project") {
                    
                    _modules_logic__WEBPACK_IMPORTED_MODULE_0__.Logic.moveTodo(oldValue, newValue, todo);
                    hasProjectChanged = true;
                    todoView.removeChild(todoUI);

                }
            }
        }

        // Check to avoid saving two times and provoke a cloning behaviour.
        if (!hasProjectChanged) _modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(projectToUpdate);

        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.update()
        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.checkIfFiltered()
    }

    /**
     * Resets form values to default since the editing mode
     * overwrites them.
     */
    function clearForm() {

        [ 
            dialog.title, 
            dialog.description, 
            dialog.dueDate, 
            dialog.priority, 
            dialog.project
        ].forEach( (input) => input.value = "" )

        dialog.savebtn.textContent = "Add todo";

    }

    /**
     * Updates thew dropdown menu to reflect the created projects.
     */
    function updateProjectSelection() {
         const selection = dialog.project;

        for (const project of Object.keys(localStorage)) {

            const newOption = document.createElement("option");
            newOption.value = project;
            newOption.textContent = _modules_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.toTitleCase(_modules_storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(project).name);

            if (!selection.contains
                (
                    document.querySelector(`option[value="${newOption.value}"]`)
                )
            ) {
                selection.appendChild(newOption);
            }
        }
    }

    /**
     * Defaults the date to today if user does not provide an input.
     * @param {*} dateToValidate
     * @returns A valid date
     */
    function validateDate(dateToValidate) {
        let date;

        try {
            date = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__.format)(dateToValidate, "d MMM yyyy");
        } catch (Error) {
            date = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__.format)(new Date(), "d MMM yyyy");
        }
        return date;
    }

    /**
     * Defaults the project to the "general" one if the user does not provide an input.
     * @param {*} project
     * @returns
     */
    function validateProject(project) {
        return !project ? "aaa000" : project;
    }

    /**
     * Defaults the priority to the lowest (4) if the user does not provide an input.
     * @param {*} priority
     */
    function validatePriority(priority) {
        return !priority ? "4" : priority;
    }

    /**
     * Prevents creation of untitled todos by disabling the save button if
     * the user does not provide the title. The rest of values are set by
     * validation functions.
     */
    function preventEmptyTodo() {
        _modules_utils__WEBPACK_IMPORTED_MODULE_3__.Utils.isValidString("title", dialog.title.value) 
        ? dialog.savebtn.removeAttribute("disabled")  
        : dialog.savebtn.setAttribute("disabled", true) 
    }

    return {  init, openForm  }
})();

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_logic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/logic */ "./src/modules/logic.js");
/* harmony import */ var _modules_gui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/gui */ "./src/modules/gui.js");
/* harmony import */ var _components_sidebar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/sidebar */ "./src/components/sidebar.js");
/* harmony import */ var _components_todoform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/todoform */ "./src/components/todoform.js");
/* harmony import */ var _components_projectform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/projectform */ "./src/components/projectform.js");
/* harmony import */ var _style_main_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style/main.css */ "./src/style/main.css");
/* harmony import */ var _modules_filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/filter */ "./src/modules/filter.js");








/**
 * Handles startup of the Todo app by loading event listeners
 * and calling initialization functions.
 */
const Startup = (function () {
    let general;

    document.addEventListener("DOMContentLoaded", () => {
        general = _modules_logic__WEBPACK_IMPORTED_MODULE_0__.Logic.initDefaultProject();
        _modules_gui__WEBPACK_IMPORTED_MODULE_1__.Gui.switchProject(general)
    });

    document.addEventListener("DOMContentLoaded", ()=>{
        _components_sidebar__WEBPACK_IMPORTED_MODULE_2__.Sidebar.init();
        _components_sidebar__WEBPACK_IMPORTED_MODULE_2__.Sidebar.showProjects();
    })

    document.addEventListener("DOMContentLoaded", () => {
        _components_todoform__WEBPACK_IMPORTED_MODULE_3__.TodoForm.init();
        _components_projectform__WEBPACK_IMPORTED_MODULE_4__.ProjectForm.init();
    })

    document.addEventListener("DOMContentLoaded", () => {
        _modules_filter__WEBPACK_IMPORTED_MODULE_6__.Filter.init()
    })

    return { general };
})();







/***/ }),

/***/ "./src/modules/filter.js":
/*!*******************************!*\
  !*** ./src/modules/filter.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Filter: () => (/* binding */ Filter)
/* harmony export */ });
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/format.mjs");
/* harmony import */ var _gui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gui */ "./src/modules/gui.js");



const Filter = (function() {

    /**
     * A collection of GUI elements that interact with searchinf and filtering
     * functions.
     */
    const filter = {
        filterTab:      document.querySelector("#filters"),
        panel:          document.querySelector("#filterSelectionPanel"),
        selector:       document.querySelector("#prop"),
        value:          document.querySelector("#value"),
        projectName:    document.querySelector("#projectName"),
        projectDesc:    document.querySelector("#projectDescription"),
    }

    /**
     * Initializes filtering functionalities and loads event listeners.
     */
    function init() {
        filter.filterTab.onclick = () => showFilterPanel()

        filter.selector.onchange = () => {
            let inputType;
            switch (filter.selector.value) {
                case "dueDate":
                    filter.value.setAttribute("type", "date")
                    break;
                case "priority":
                    filter.value.setAttribute("type", "number")
                    filter.value.setAttribute("max", 4)
                    break
                case "title":
                    filter.value.setAttribute("type", "text")
                    break
                default:
                    filter.value.setAttribute("disabled", "true")
                    break;
            }
            _gui__WEBPACK_IMPORTED_MODULE_0__.Gui.clearTodoView()
            filter.value.value = ""
        }
        filter.value.oninput = () => lookup()
    }

    /**
     * Shows the filtering options in the GUI once the search panel is
     * clicked by the user.
     */
    function showFilterPanel() {
        filter.panel.style.display = "flex";
        _gui__WEBPACK_IMPORTED_MODULE_0__.Gui.renderFiltered("title", undefined)
        filter.selector.value = "";
        filter.projectName.textContent = "Search & Filters";
        filter.projectDesc.textContent = "Filter Todos by desired value.";
    }
    
    /**
     * Hides the filtersd panel once the user clicks on another view.
     */
    function hideFilterPanel() {
        filter.panel.style.display = "none"
    }

    /**
     * Performs input validation and calls the GUI function to render filtered
     * results. Makes sure that the GUI does not get overwritten when inside
     * the filter view.
     */
    function lookup() {
        let property = filter.selector.value;
        let value = filter.value.value;
        const type = filter.value.getAttribute("type");
        
        if (type === "date") { value = (0,date_fns__WEBPACK_IMPORTED_MODULE_1__.format)(value, "d MMM yyyy"); }
        else if (type === "text") { value = value.trim() }
        
        _gui__WEBPACK_IMPORTED_MODULE_0__.Gui.renderFiltered(property, value);
        checkIfEmpty();
    }
    
    /**
     * Perfoms emptyness cheking for showing the Empty Project graphics and avoid
     * html element persisting in the filtered view when search value is empty.
     */
    function checkIfEmpty() {
        if (filter.value.value === "") _gui__WEBPACK_IMPORTED_MODULE_0__.Gui.clearTodoView()
        _gui__WEBPACK_IMPORTED_MODULE_0__.Gui.checkForEmptyProject()
    }
    
    return { init, hideFilterPanel }
})();

/***/ }),

/***/ "./src/modules/gui.js":
/*!****************************!*\
  !*** ./src/modules/gui.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gui: () => (/* binding */ Gui)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/modules/utils.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage */ "./src/modules/storage.js");
/* harmony import */ var _components_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/card */ "./src/components/card.js");
/* harmony import */ var _components_sidebar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/sidebar */ "./src/components/sidebar.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./project */ "./src/modules/project.js");
/* harmony import */ var _assets_checklist_71_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/checklist-71.svg */ "./assets/checklist-71.svg");
/* harmony import */ var _assets_checklist_71_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_assets_checklist_71_svg__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _assets_scrum_board_27_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/scrum-board-27.svg */ "./assets/scrum-board-27.svg");
/* harmony import */ var _assets_scrum_board_27_svg__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_assets_scrum_board_27_svg__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _assets_construction_site_59_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../assets/construction-site-59.svg */ "./assets/construction-site-59.svg");
/* harmony import */ var _assets_construction_site_59_svg__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_assets_construction_site_59_svg__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _assets_404_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../assets/404.svg */ "./assets/404.svg");
/* harmony import */ var _assets_404_svg__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_assets_404_svg__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _assets_resting_49_svg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../assets/resting-49.svg */ "./assets/resting-49.svg");
/* harmony import */ var _assets_resting_49_svg__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_assets_resting_49_svg__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _components_projectform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/projectform */ "./src/components/projectform.js");
/* harmony import */ var _logic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./logic */ "./src/modules/logic.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/format.mjs");














/**
 * Object that collects references and functions related to the Content Area
 * and the general behaviour of the GUI. Leaves autonomy to methods from
 * smaller components like Todo cards and the Sidebar, in separate entities.
 */
const Gui = (function() {
    /**
     * Collection of references to UI elements not included
     * in smaller components.
     */
    const ui = {
        todoView:               document.querySelector("#todoView"),
        projectName:            document.querySelector("#projectName"),
        projectDesc:            document.querySelector("#projectDescription"),
        emptyPanel:             document.querySelector("#emptyProjectScreen"),
        emptyPaneltext:         document.querySelector("#emptyProjectText"),
        editProjectButton:      document.querySelector(".edit"),
        deleteProjectButton:    document.querySelector(".delete"),
        overlay:                document.querySelector("#dialogOverlay")
    }

    /**
     * Collection of SVG imports to be displayed in the content panel
     * with the message to create a new project.
     */
    const svgs = [(_assets_checklist_71_svg__WEBPACK_IMPORTED_MODULE_5___default()), (_assets_scrum_board_27_svg__WEBPACK_IMPORTED_MODULE_6___default()), (_assets_construction_site_59_svg__WEBPACK_IMPORTED_MODULE_7___default()), (_assets_404_svg__WEBPACK_IMPORTED_MODULE_8___default()), (_assets_resting_49_svg__WEBPACK_IMPORTED_MODULE_9___default())]

    /**
     * The current project shown in the content area.
     * Gets updated on project switching.
     */
    let currentProject;

    function setCurrentProject(value) {
        currentProject = value
    }

    function getCurrentProject() {
        return currentProject
    }

    /**
     * Clears the Todo view in the content panel by wiping
     * todo child elements.
     */
    function clearTodoView() {
        while (ui.todoView.firstChild) {
            todoView.removeChild(todoView.firstChild);
        }
    };

    /**
     * Visual command from GUI to delete a project. Updates all displayed
     * data that may have changed.
     * @param {*} project 
     */
    function deleteProject(project) {
        _logic__WEBPACK_IMPORTED_MODULE_11__.Logic.deleteProject(project.getUid());
        Gui.update();
        _components_sidebar__WEBPACK_IMPORTED_MODULE_3__.Sidebar.showInbox();
    }

    /**
     * Loads the clicked project in the GUI by calling the Storage component
     * to acquire the project data and by calling the rendering method onto
     * the collection of todos.
     * @param {*} project
     */
    function renderProject(project) {
        clearTodoView();
        ui.projectName.textContent = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.toTitleCase(project.name);
        ui.projectDesc.textContent = project.description

        for (const todo of project.getTodosList()) {
            todoView.appendChild(_components_card__WEBPACK_IMPORTED_MODULE_2__.Card.createCard(todo));
        }

        if (project.getUid() === "aaa000" || project.filtered) {
            ui.editProjectButton.style.display = "none"
            ui.deleteProjectButton.style.display = "none"

        } else {
            ui.editProjectButton.style.display = "flex"
            ui.deleteProjectButton.style.display = "flex"
            ui.editProjectButton.onclick = () => _components_projectform__WEBPACK_IMPORTED_MODULE_10__.ProjectForm.openForm("edit", project)
            ui.deleteProjectButton.onclick = () => deleteProject(project)
        }
    };

    /**
     * Switches the content view between projects, from current
     * to target one.
     * @param {*} target
     */
    function switchProject(target) {
        currentProject = target;
        renderProject(target);
        checkForEmptyProject();
    };

    /**
     * Creates a temporary project to store filtered todos and render them
     * in the dedicated tab. Checks for property and value.
     * @param {*} property 
     * @param {*} value 
     */
    function renderFiltered(property, value) {
        const filterName = value === (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.format)(new Date(), "d MMM yyyy") 
        ? "Today" 
        : "Search & Filters";

        const filterDesc = value === (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.format)(new Date(), "d MMM yyyy") 
        ? "A list of Today's tasks." 
        : "Filter Todos by desired value."

        const filteredTodos = _storage__WEBPACK_IMPORTED_MODULE_1__.Store.loadAllTodos().filter(
            (todo) => 
                todo[property] === value || new RegExp(`(?=...)${value}`, "i").test(todo[property])
        );

        const tempProject = new _project__WEBPACK_IMPORTED_MODULE_4__["default"](
            filterName,
            filterDesc,
            "black",
            [property, value]
        );

        filteredTodos.forEach((todo) => tempProject.add(todo));
        switchProject(tempProject);
    };

    /**
     * Checks if the currently displayed project is empty and shows
     * call to action graphics if this is the case.
     */
    function checkForEmptyProject() {
        ui.emptyPanel.removeChild(ui.emptyPanel.firstChild)

        if(!currentProject.filtered) {
            const svg = insertSvg(svgs[_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.randMax(0, 2)])
            ui.emptyPanel.insertBefore(svg, ui.emptyPanel.firstChild) 
            ui.emptyPaneltext.textContent = "Looks like this project is empty, \n let's start something new!"


        } else if (currentProject.filtered && currentProject.name === "today") {
            const restSvg = insertSvg(svgs[4])
            ui.emptyPanel.insertBefore(restSvg, ui.emptyPanel.firstChild) 
            ui.emptyPaneltext.textContent = "Nothing to do for today. Enjoy some rest!"

        } else {
            const searchSvg = insertSvg(svgs[3])
            ui.emptyPanel.insertBefore(searchSvg, ui.emptyPanel.firstChild) 
            ui.emptyPaneltext.textContent = "Couldn't find anything with given parameters!"

        }
        ui.emptyPanel.style.display = ui.todoView.firstChild ? "none" : "flex"
    };

    /**
     * Displays an SVG graphic in the Content Area if the project is empty
     * by getting the imported <svg> element and parsing it into a new HTML
     * element to be later appended to the DOM.
     * @param {*} svg 
     * @returns 
     */
    function insertSvg(svg) {
        const svgImg = (new DOMParser()).parseFromString(svg, "image/svg+xml")
        const svgElement = svgImg.documentElement
        svgElement.id = "emptyImage"
        svgElement.style = false; // Resets style because the original has a style attr
        return svgElement
    }

    /**
     * Checks if the current viewed project is a temporary "filter"
     * project and in that case filters again to update displayed values.
     */
    function checkIfFiltered() {
        const project = currentProject;
        
        if (Array.isArray(project.filtered)) {
            renderFiltered(project.filtered.at(0), project.filtered[1]);
        }
    };

    /**
     * Updates dynamic UI elements like counters and panle that should be
     * hidden or visibile based on Todo state.
     */
    function update() {
        _components_sidebar__WEBPACK_IMPORTED_MODULE_3__.Sidebar.updateTodayTodos();
        _components_sidebar__WEBPACK_IMPORTED_MODULE_3__.Sidebar.showProjects();
        checkForEmptyProject();
    };

    /**
     * Opens an overlay to prevent the user from clicking anything while forms
     * are open.
     */
    function toggleOverlay() {
        ui.overlay.style.display = ui.overlay.style.display === "block" ? "none" : "block"
    }

    return {
        setCurrentProject,
        getCurrentProject,
        renderProject,
        switchProject,
        renderFiltered,
        checkForEmptyProject,
        checkIfFiltered,
        clearTodoView,
        toggleOverlay,   
        update
    }
})();


/***/ }),

/***/ "./src/modules/logic.js":
/*!******************************!*\
  !*** ./src/modules/logic.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Logic: () => (/* binding */ Logic)
/* harmony export */ });
/* harmony import */ var _todo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./todo */ "./src/modules/todo.js");
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./project */ "./src/modules/project.js");
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage */ "./src/modules/storage.js");




class Logic {
    constructor() {}

    // Implementing singleton pattern
    static getInstance() {
        if (!Logic.instance) {
            Logic.instance = new Logic();
        }
        return Logic.instance;
    }

    /**
     * Creates a new Todo item with the data extracted from the
     * UI fields passed as an object. It also calls the Todo
     * constructor and checks if the Todo belongs to an existing
     * project, in that case it pushes it in its collection.
     *
     * @param {*} properties {title, description, dueDate, priority}
     * @param {*} project Defaults to 'general' for non categorized Todos.
     */
    static createTodo(todoProperties, project) {
        const newTodo = new _todo__WEBPACK_IMPORTED_MODULE_0__["default"](
            todoProperties.title,
            todoProperties.description,
            todoProperties.dueDate,
            todoProperties.priority,
            todoProperties.projectID
        );

        project.add(newTodo);
        console.info(
            `Created todo '${newTodo.title}'. Added to project '${project.name}'.`
        );

        return newTodo;
    }

    /**
     * Deletes the provided Todo element from the Project array.
     * Checks for Todo existence inside Project.
     * @param {*} project
     * @param {*} todo
     */
    static deleteTodo(project, todo) {
        if (!project.hasTodo(todo)) {
            return;
        }
        const indexToDelete = project.todos.findIndex(
            (t) => t.getUid() === todo.getUid()
        );
        project.todos.splice(indexToDelete, 1);
        console.info(
            `Deleted todo '${todo.title}' from project '${project.name}'.`
        );
    }

    /**
     * Edits the passed property replacing its value with the given one.
     * Checks if the todo belongs to the project and if the property is
     * one of the Todo type.
     * @param {*} project
     * @param {*} todo
     * @param {*} property
     * @param {*} value
     * @returns The edited todo
     */
    static editTodo(project, todo, property, value) {
        if (!project.hasTodo(todo)) {
            console.log("check if project has todo")
            return;
        }
        const target = project.todos.find(
            (item) => item.getUid() === todo.getUid()
        );
        const oldValue = target[property];
        if (property in todo) target[property] = value;
        console.info(
            `Edited todo '${todo.title}' inside project '${project.name}.' ('${property}: old: ${oldValue} new:${value}')`
        );

        return target
    }

    /**
     * Moves a Todo object from source project to target project.
     * @param {*} source
     * @param {*} target
     * @param {*} todo
     */
    static moveTodo(source, target, todo) {
        const from = _storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(source);
        const to = _storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject(target);

        this.deleteTodo(from, todo);
        _storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(from);

        to.add(todo);
        _storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(to);

        console.info(
            `Moved todo ${todo.title} from '${from.name} to '${to.name}'`
        );
    }

    /**
     * Creates and returns a new instance of a Project. Checks
     * if the project already exists in the storage.
     * @param {*} name
     * @param {*} description
     * @returns An instance of the new Project
     */
    static createProject(name, description, color) {
        const newProject = new _project__WEBPACK_IMPORTED_MODULE_1__["default"](name, description, color);
        console.info(`Created project '${name}'.`);
        return newProject;
    }

    /**
     * Deletes the given project from storage. Delegates to
     * the Store component the effective removing from localStorage.
     * @param {*} name
     * @returns
     */
    static deleteProject(uid) {
        if (!_storage__WEBPACK_IMPORTED_MODULE_2__.Store.doProjectExistById(uid)) {
            return;
        }
        _storage__WEBPACK_IMPORTED_MODULE_2__.Store.removeProject(uid);
        console.info(`Deleted project '${uid}'.`);
    }

    /**
     * Changes details about the given project by accessing its properties
     * and calling the right setters. Checks if the property exists inside
     * the given project.
     * @param {*} project
     * @param {*} property
     * @param {*} value
     * @returns
     */
    static editProject(project, property, value) {
        if (_storage__WEBPACK_IMPORTED_MODULE_2__.Store.doProjectExistById(project.getUid())) {
            if (property !== "todos" && property in project) {
                const oldValue = project[property];
                project[property] = value;

                console.info(
                    `Edited project '${project.name}.' ('${property}: old: ${oldValue} new:${value}')`
                );
            } else {
                console.error(
                    `Cannot access property '${property}' of project '${project.name}'.`
                );
            }
        } else {
            console.error(
                `Project '${project.name}' does not exist in storage.`
            );
            return;
        }
    }

    /**
     * Loads the 'general' project at startup to contain and serve
     * todos that do not belong to a named project. Creats the default
     * project if it does not exist.
     */
    static initDefaultProject() {
        let general = _storage__WEBPACK_IMPORTED_MODULE_2__.Store.loadProject("aaa000");

        if (!general) {
            general = this.createProject(
                "general",
                "Container project for uncategorized todos."
            );
            _storage__WEBPACK_IMPORTED_MODULE_2__.Store.saveProject(general);
        }
        return general;
    }
}


/***/ }),

/***/ "./src/modules/project.js":
/*!********************************!*\
  !*** ./src/modules/project.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Project)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/modules/utils.js");
/* harmony import */ var _todo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo.js */ "./src/modules/todo.js");



/**
 *
 * A Project is a collection of todos that share a common
 * end goal. It provides functionality for grouping and
 * tracking multiple todos at once.
 * It comes with methods for serializing and parsing itself from JSON.
 *
 * @param name
 * @param description
 */
class Project {
    constructor(name, description, uicolor = "black", filtered = null) {
        this.name = name.toLowerCase();
        this.description = description;
        this.uicolor = uicolor;
        this.filtered = filtered;
        this.#uid = (name === "general") ? "aaa000"  : _utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.generateHexId()
    }

    /** Project class fields */
    /**
     * The collection of todos that is associated with this
     * instance of the project.
     */
    todos = [];

    #uid;

    /** UNUSED?
     * Flag to check whether the project is pending or complete.
     */
    complete = false;

    //#region Getters and Setters
    get name() {
        return this._name;
    }

    set name(value) {
        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isValidString("name", value)) this._name = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = value;
    }

    get uicolor() {
        return this._uicolor;
    }

    set uicolor(value) {
        this._uicolor = value;
    }

    getUid() {
        return this.#uid
    }
    //#endregion

    //#region Project methods

    /**
     * Flips the 'complete' project flag.
     */
    toggleStatus() {
        this.complete = this.complete === true ? false : true;
    }

    hasTodo(todo) {
        if (!this.todos.find((item) => item.getUid() === todo.getUid())) {
            console.error(`Todo is not inside project '${this.name}'.`);
            return false;
        }
        return true;
    }

    /**
     * Takes control of serialization process and makes sure that the saved
     * projects can be reinstantiated smoothly while preserving getter and
     * setter architecture and private variables.
     * @returns
     */
    toJSON() {
        return {
            name: this._name,
            description: this._description,
            todos: this.todos,
            complete: this.complete,
            uicolor: this._uicolor,
            uid: this.#uid
        };
    }

    /** Static method to create a Project instance from JSON once loaded from
     * storage. Also re-instantiates the Todos inside of the todos array.
     */
    static fromJSON(json) {
        const obj = JSON.parse(json);
        const project = new Project(obj.name, obj.description, obj.uicolor);

        if (obj.complete) project.toggleStatus();

        obj.todos.forEach((todo) => {
            project.todos.push(_todo_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromJSON(JSON.stringify(todo)));
        });

        project.#uid = obj.uid
        
        return project;
    }

    //#endregion

    //#region Multiple todos functions

    /**
     * Getter method for the list of todos.
     * @returns
     */
    getTodosList() {
        return this.todos;
    }

    /**
     * Adds the desired Todo item to the project colletion.
     * Checks if the object passed as argument is an instance
     * of a Todo.
     * @param {*} todo
     */
    add(todo) {
        if (todo instanceof _todo_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            this.todos.push(todo);
            console.info(`Added todo ${todo.title} to project ${this.name}`);
        } else {
            console.error(
                `The item ${todo.title} is not a valid Todo instance.`
            );
            return;
        }
    }

    //#endregion
}


/***/ }),

/***/ "./src/modules/storage.js":
/*!********************************!*\
  !*** ./src/modules/storage.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Store: () => (/* binding */ Store)
/* harmony export */ });
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project */ "./src/modules/project.js");


class Store {
    constructor() {}

    //#region Implementing singleton pattern
    static getInstance() {
        if (!Storage.instance) {
            Storage.instance = new Store();
        }
        return Storage.instance;
    }
    //#endregion

    /**
     * Saves a project in localStorage using the localStorage API.
     * @param {*} project
     */
    static saveProject(project) {
        if (project instanceof _project__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            localStorage.setItem(project.getUid(), JSON.stringify(project));
            console.info(`Saved project ${project.name} in storage.`);
        }
    }

    /**
     * Loads a project by name from localStorage and parses its
     * data to return an instance of Project class with the stored
     * properties and values.
     * @param {*} projectName
     * @returns a Project instance
     */
    static loadProject(uid) {
        if (!this.doProjectExistById(uid)) {
            return;
        }

        const project = _project__WEBPACK_IMPORTED_MODULE_0__["default"].fromJSON(localStorage.getItem(uid));
        console.info(`Loaded project ${project.name} from storage.`);

        return project;
    }

    /**
     * Loads all todos from every project present in memory to let
     * the user interact with collection of all tasks without having
     * to traverse all projects.
     */
    static loadAllTodos() {
        let allTodos = [];
        for (const project of Object.keys(localStorage)) {
            const loadedProject = this.loadProject(project);
            allTodos.push(...loadedProject.getTodosList());
        }

        return allTodos;
    }

    /**
     * Uses localStorage API to remove a project.
     * @param {*} uid
     */
    static removeProject(uid) {
        localStorage.removeItem(uid);
    }

    /**
     * Look up function to check if a project already exists in storage.
     * @param {*} projectName
     * @returns
     */
    static doProjectExistById(uid) {
        const check = localStorage.getItem(uid);
        if (!check) console.info(`Project does not exist.`);
        return check;
    }
}


/***/ }),

/***/ "./src/modules/todo.js":
/*!*****************************!*\
  !*** ./src/modules/todo.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Todo)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/modules/utils.js");
/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ "./src/modules/storage.js");
const { isDate, format } = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/index.js");



/**
 * A class representing a Todo item: stores all data related to the
 * todo including uniquie ID, tile, description, due date and priority.
 * Has a private status field that control wheter the task is done.
 * It comes with methods for serializing and parsing itself from JSON.
 * @param title
 * @param description
 * @param dueDate
 * @param priority
 * @param project
 */
class Todo {
    constructor(
        title,
        description,
        dueDate = new Date(),
        priority = "4",
        projectID = "aaa000"
    ) {
        this.title = title;
        this.description = description;
        this.dueDate = format(new Date(dueDate), "d MMM yyyy");
        this.priority = priority;
        this.project = projectID;
    }

    #uid = _utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.generateHexId();

    /** Checks wheter the task is done. */
    #done = false;

    //#region Getters and Setters
    get title() {
        return this._title;
    }

    set title(value) {
        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isValidString("title", value)) this._title = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = String(value);
    }

    get dueDate() {
        return this._dueDate;
    }

    set dueDate(value) {
        this._dueDate = value;
    }

    get priority() {
        return this._priority;
    }

    set priority(value) {
        this._priority = value;
    }

    get project() {
        return this._project;
    }

    set project(value) {
        this._project = _storage_js__WEBPACK_IMPORTED_MODULE_1__.Store.doProjectExistById(value) ? value : this._project;
    }

    getUid() {
        return this.#uid;
    }

    getStatus() {
        return this.#done;
    }
    //#endregion

    //#region Instance Methods
    toggleStatus() {
        this.#done = this.#done === true ? false : true;
    }

    /**
     * Takes control of serialization process and makes sure that the saved
     * todo can be reinstantiated smoothly while preserving the getter and
     * setter architcture and private variables.
     * @returns
     */
    toJSON() {
        return {
            uid: this.#uid,
            title: this._title,
            description: this._description,
            dueDate: this._dueDate,
            priority: this._priority,
            project: this._project,
            done: this.#done,
        };
    }

    /** Static method to create a Todo instance from JSON once loaded from
     * storage.
     */
    static fromJSON(json) {
        const obj = JSON.parse(json);
        const todo = new Todo(
            obj.title,
            obj.description,
            obj.dueDate,
            obj.priority,
            obj.project
        );
        todo.#done = obj.done;
        todo.#uid = obj.uid;
        return todo;
    }
    //#endregion
}


/***/ }),

/***/ "./src/modules/utils.js":
/*!******************************!*\
  !*** ./src/modules/utils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utils: () => (/* binding */ Utils)
/* harmony export */ });
/**
 * A collection of useful method that are shared between different
 * components of the App but do not belong to a single component.
 */
class Utils {
    constructor() {}

    // Implementing singleton pattern
    static getUtilsInstance() {
        if (!Utility.instance) {
            Utility.instance = new Utility();
        }
        return Utility.instance;
    }

    /**
     * Mthod to check if the provided string value is a
     * valid input for the property the user is editing.
     * @param {*} field
     * @param {*} value
     */
    static isValidString(fieldName, value) {
        if (/\S/.test(value) && typeof value === "string") {
            return true;
        } else {
            console.warn(
                `Value "${value}" is not a valid input for field "${fieldName}".`
            );
            return false
        }
    }

    /**
     * Generate a random hexadecimal identifier.
     */
    static generateHexId(proj) {
        let hex = "";
        for (let i = 0; i < 6; i++) {
            const randN = Math.floor(Math.random() * 16);
            hex += randN.toString(16);
        }
        return hex;
    }

    /**
     * Sets the input text to Title Case.
     * @param {*} text
     * @returns
     */
    static toTitleCase(text) {
        return text
            .toLowerCase()
            .split(/\s+/)
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ");
    }

    static randMax(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/addLeadingZeros.mjs":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/_lib/addLeadingZeros.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addLeadingZeros: () => (/* binding */ addLeadingZeros)
/* harmony export */ });
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/defaultOptions.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/_lib/defaultOptions.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultOptions: () => (/* binding */ getDefaultOptions),
/* harmony export */   setDefaultOptions: () => (/* binding */ setDefaultOptions)
/* harmony export */ });
let defaultOptions = {};

function getDefaultOptions() {
  return defaultOptions;
}

function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/formatters.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/formatters.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatters: () => (/* binding */ formatters)
/* harmony export */ });
/* harmony import */ var _getDayOfYear_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../getDayOfYear.mjs */ "./node_modules/date-fns/getDayOfYear.mjs");
/* harmony import */ var _getISOWeek_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../getISOWeek.mjs */ "./node_modules/date-fns/getISOWeek.mjs");
/* harmony import */ var _getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../getISOWeekYear.mjs */ "./node_modules/date-fns/getISOWeekYear.mjs");
/* harmony import */ var _getWeek_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../getWeek.mjs */ "./node_modules/date-fns/getWeek.mjs");
/* harmony import */ var _getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../getWeekYear.mjs */ "./node_modules/date-fns/getWeekYear.mjs");
/* harmony import */ var _addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addLeadingZeros.mjs */ "./node_modules/date-fns/_lib/addLeadingZeros.mjs");
/* harmony import */ var _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lightFormatters.mjs */ "./node_modules/date-fns/_lib/format/lightFormatters.mjs");








const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night",
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

const formatters = {
  // Era
  G: function (date, token, localize) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize.era(era, { width: "wide" });
    }
  },

  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === "yo") {
      const signedYear = date.getFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, { unit: "year" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.y(date, token);
  },

  // Local week-numbering year
  Y: function (date, token, localize, options) {
    const signedWeekYear = (0,_getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__.getWeekYear)(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, { unit: "year" });
    }

    // Padding
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(weekYear, token.length);
  },

  // ISO week-numbering year
  R: function (date, token) {
    const isoWeekYear = (0,_getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_3__.getISOWeekYear)(date);

    // Padding
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoWeekYear, token.length);
  },

  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    const year = date.getFullYear();
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(year, token.length);
  },

  // Quarter
  Q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone quarter
  q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // Month
  M: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting",
        });
      // J, F, ..., D
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize.month(month, { width: "wide", context: "formatting" });
    }
  },

  // Stand-alone month
  L: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone",
        });
      // J, F, ..., D
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize.month(month, { width: "wide", context: "standalone" });
    }
  },

  // Local week of year
  w: function (date, token, localize, options) {
    const week = (0,_getWeek_mjs__WEBPACK_IMPORTED_MODULE_4__.getWeek)(date, options);

    if (token === "wo") {
      return localize.ordinalNumber(week, { unit: "week" });
    }

    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(week, token.length);
  },

  // ISO week of year
  I: function (date, token, localize) {
    const isoWeek = (0,_getISOWeek_mjs__WEBPACK_IMPORTED_MODULE_5__.getISOWeek)(date);

    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, { unit: "week" });
    }

    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoWeek, token.length);
  },

  // Day of the month
  d: function (date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getDate(), { unit: "date" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.d(date, token);
  },

  // Day of year
  D: function (date, token, localize) {
    const dayOfYear = (0,_getDayOfYear_mjs__WEBPACK_IMPORTED_MODULE_6__.getDayOfYear)(date);

    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }

    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(dayOfYear, token.length);
  },

  // Day of week
  E: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Local day of week
  e: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone",
        });
      // T
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone",
        });
      // Tuesday
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // ISO day of week
  i: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM or PM
  a: function (date, token, localize) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "aaa":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }

    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "bbb":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.h(date, token);
  },

  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.H(date, token);
  },

  // Hour [0-11]
  K: function (date, token, localize) {
    const hours = date.getHours() % 12;

    if (token === "Ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(hours, token.length);
  },

  // Hour [1-24]
  k: function (date, token, localize) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;

    if (token === "ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(hours, token.length);
  },

  // Minute
  m: function (date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.m(date, token);
  },

  // Second
  s: function (date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
    }

    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.s(date, token);
  },

  // Fraction of second
  S: function (date, token) {
    return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.S(date, token);
  },

  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return "Z";
    }

    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (GMT)
  O: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (specific non-location)
  z: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Seconds timestamp
  t: function (date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1000);
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(timestamp, token.length);
  },

  // Milliseconds timestamp
  T: function (date, token, _localize) {
    const timestamp = date.getTime();
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(timestamp, token.length);
  },
};

function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}

function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(Math.trunc(absOffset / 60), 2);
  const minutes = (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/lightFormatters.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/lightFormatters.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lightFormatters: () => (/* binding */ lightFormatters)
/* harmony export */ });
/* harmony import */ var _addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../addLeadingZeros.mjs */ "./node_modules/date-fns/_lib/addLeadingZeros.mjs");


/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

const lightFormatters = {
  // Year
  y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    const signedYear = date.getFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(token === "yy" ? year % 100 : year, token.length);
  },

  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(month + 1, 2);
  },

  // Day of the month
  d(date, token) {
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getDate(), token.length);
  },

  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },

  // Hour [1-12]
  h(date, token) {
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getHours() % 12 || 12, token.length);
  },

  // Hour [0-23]
  H(date, token) {
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getHours(), token.length);
  },

  // Minute
  m(date, token) {
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getMinutes(), token.length);
  },

  // Second
  s(date, token) {
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getSeconds(), token.length);
  },

  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3),
    );
    return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(fractionalSeconds, token.length);
  },
};


/***/ }),

/***/ "./node_modules/date-fns/_lib/format/longFormatters.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/longFormatters.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   longFormatters: () => (/* binding */ longFormatters)
/* harmony export */ });
const dateLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong.date({ width: "full" });
  }
};

const timeLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    case "pppp":
    default:
      return formatLong.time({ width: "full" });
  }
};

const dateTimeLongFormatter = (pattern, formatLong) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  let dateTimeFormat;

  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
      break;
  }

  return dateTimeFormat
    .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
    .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};

const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter,
};


/***/ }),

/***/ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTimezoneOffsetInMilliseconds: () => (/* binding */ getTimezoneOffsetInMilliseconds)
/* harmony export */ });
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../toDate.mjs */ "./node_modules/date-fns/toDate.mjs");


/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds(),
    ),
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}


/***/ }),

/***/ "./node_modules/date-fns/_lib/protectedTokens.mjs":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/_lib/protectedTokens.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isProtectedDayOfYearToken: () => (/* binding */ isProtectedDayOfYearToken),
/* harmony export */   isProtectedWeekYearToken: () => (/* binding */ isProtectedWeekYearToken),
/* harmony export */   warnOrThrowProtectedError: () => (/* binding */ warnOrThrowProtectedError)
/* harmony export */ });
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;

const throwTokens = ["D", "DD", "YY", "YYYY"];

function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}

function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}

function warnOrThrowProtectedError(token, format, input) {
  const _message = message(token, format, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}

function message(token, format, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}


/***/ }),

/***/ "./node_modules/date-fns/constants.mjs":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/constants.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   daysInWeek: () => (/* binding */ daysInWeek),
/* harmony export */   daysInYear: () => (/* binding */ daysInYear),
/* harmony export */   maxTime: () => (/* binding */ maxTime),
/* harmony export */   millisecondsInDay: () => (/* binding */ millisecondsInDay),
/* harmony export */   millisecondsInHour: () => (/* binding */ millisecondsInHour),
/* harmony export */   millisecondsInMinute: () => (/* binding */ millisecondsInMinute),
/* harmony export */   millisecondsInSecond: () => (/* binding */ millisecondsInSecond),
/* harmony export */   millisecondsInWeek: () => (/* binding */ millisecondsInWeek),
/* harmony export */   minTime: () => (/* binding */ minTime),
/* harmony export */   minutesInDay: () => (/* binding */ minutesInDay),
/* harmony export */   minutesInHour: () => (/* binding */ minutesInHour),
/* harmony export */   minutesInMonth: () => (/* binding */ minutesInMonth),
/* harmony export */   minutesInYear: () => (/* binding */ minutesInYear),
/* harmony export */   monthsInQuarter: () => (/* binding */ monthsInQuarter),
/* harmony export */   monthsInYear: () => (/* binding */ monthsInYear),
/* harmony export */   quartersInYear: () => (/* binding */ quartersInYear),
/* harmony export */   secondsInDay: () => (/* binding */ secondsInDay),
/* harmony export */   secondsInHour: () => (/* binding */ secondsInHour),
/* harmony export */   secondsInMinute: () => (/* binding */ secondsInMinute),
/* harmony export */   secondsInMonth: () => (/* binding */ secondsInMonth),
/* harmony export */   secondsInQuarter: () => (/* binding */ secondsInQuarter),
/* harmony export */   secondsInWeek: () => (/* binding */ secondsInWeek),
/* harmony export */   secondsInYear: () => (/* binding */ secondsInYear)
/* harmony export */ });
/**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "./constants/date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */

/**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */
const daysInWeek = 7;

/**
 * @constant
 * @name daysInYear
 * @summary Days in 1 year.
 *
 * @description
 * How many days in a year.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 */
const daysInYear = 365.2425;

/**
 * @constant
 * @name maxTime
 * @summary Maximum allowed time.
 *
 * @example
 * import { maxTime } from "./constants/date-fns/constants";
 *
 * const isValid = 8640000000000001 <= maxTime;
 * //=> false
 *
 * new Date(8640000000000001);
 * //=> Invalid Date
 */
const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;

/**
 * @constant
 * @name minTime
 * @summary Minimum allowed time.
 *
 * @example
 * import { minTime } from "./constants/date-fns/constants";
 *
 * const isValid = -8640000000000001 >= minTime;
 * //=> false
 *
 * new Date(-8640000000000001)
 * //=> Invalid Date
 */
const minTime = -maxTime;

/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */
const millisecondsInWeek = 604800000;

/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */
const millisecondsInDay = 86400000;

/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */
const millisecondsInMinute = 60000;

/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */
const millisecondsInHour = 3600000;

/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */
const millisecondsInSecond = 1000;

/**
 * @constant
 * @name minutesInYear
 * @summary Minutes in 1 year.
 */
const minutesInYear = 525600;

/**
 * @constant
 * @name minutesInMonth
 * @summary Minutes in 1 month.
 */
const minutesInMonth = 43200;

/**
 * @constant
 * @name minutesInDay
 * @summary Minutes in 1 day.
 */
const minutesInDay = 1440;

/**
 * @constant
 * @name minutesInHour
 * @summary Minutes in 1 hour.
 */
const minutesInHour = 60;

/**
 * @constant
 * @name monthsInQuarter
 * @summary Months in 1 quarter.
 */
const monthsInQuarter = 3;

/**
 * @constant
 * @name monthsInYear
 * @summary Months in 1 year.
 */
const monthsInYear = 12;

/**
 * @constant
 * @name quartersInYear
 * @summary Quarters in 1 year
 */
const quartersInYear = 4;

/**
 * @constant
 * @name secondsInHour
 * @summary Seconds in 1 hour.
 */
const secondsInHour = 3600;

/**
 * @constant
 * @name secondsInMinute
 * @summary Seconds in 1 minute.
 */
const secondsInMinute = 60;

/**
 * @constant
 * @name secondsInDay
 * @summary Seconds in 1 day.
 */
const secondsInDay = secondsInHour * 24;

/**
 * @constant
 * @name secondsInWeek
 * @summary Seconds in 1 week.
 */
const secondsInWeek = secondsInDay * 7;

/**
 * @constant
 * @name secondsInYear
 * @summary Seconds in 1 year.
 */
const secondsInYear = secondsInDay * daysInYear;

/**
 * @constant
 * @name secondsInMonth
 * @summary Seconds in 1 month
 */
const secondsInMonth = secondsInYear / 12;

/**
 * @constant
 * @name secondsInQuarter
 * @summary Seconds in 1 quarter.
 */
const secondsInQuarter = secondsInMonth * 3;


/***/ }),

/***/ "./node_modules/date-fns/constructFrom.mjs":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/constructFrom.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   constructFrom: () => (/* binding */ constructFrom),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from 'date-fns'
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use contrustor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   )
 * }
 */
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constructFrom);


/***/ }),

/***/ "./node_modules/date-fns/constructNow.mjs":
/*!************************************************!*\
  !*** ./node_modules/date-fns/constructNow.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   constructNow: () => (/* binding */ constructNow),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");


/**
 * @name constructNow
 * @category Generic Helpers
 * @summary Constructs a new current date using the passed value constructor.
 * @pure false
 *
 * @description
 * The function constructs a new current date using the constructor from
 * the reference date. It helps to build generic functions that accept date
 * extensions and use the current date.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 *
 * @returns Current date initialized using the given date constructor
 *
 * @example
 * import { constructNow, isSameDay } from 'date-fns'
 *
 * function isToday<DateType extends Date>(
 *   date: DateType | number | string,
 * ): boolean {
 *   // If we were to use `new Date()` directly, the function would  behave
 *   // differently in different timezones and return false for the same date.
 *   return isSameDay(date, constructNow(date));
 * }
 */
function constructNow(date) {
  return (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_0__.constructFrom)(date, Date.now());
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constructNow);


/***/ }),

/***/ "./node_modules/date-fns/differenceInCalendarDays.mjs":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarDays.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   differenceInCalendarDays: () => (/* binding */ differenceInCalendarDays)
/* harmony export */ });
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/date-fns/constants.mjs");
/* harmony import */ var _startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startOfDay.mjs */ "./node_modules/date-fns/startOfDay.mjs");
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.mjs */ "./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs");




/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateLeft);
  const startOfDayRight = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateRight);

  const timestampLeft =
    +startOfDayLeft - (0,_lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
  const timestampRight =
    +startOfDayRight - (0,_lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__.getTimezoneOffsetInMilliseconds)(startOfDayRight);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a day is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round((timestampLeft - timestampRight) / _constants_mjs__WEBPACK_IMPORTED_MODULE_2__.millisecondsInDay);
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (differenceInCalendarDays);


/***/ }),

/***/ "./node_modules/date-fns/format.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/format.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatDate: () => (/* binding */ format),
/* harmony export */   formatters: () => (/* reexport safe */ _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters),
/* harmony export */   longFormatters: () => (/* reexport safe */ _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__.longFormatters)
/* harmony export */ });
/* harmony import */ var _lib_defaultLocale_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/defaultLocale.mjs */ "./node_modules/date-fns/locale/en-US.mjs");
/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ "./node_modules/date-fns/_lib/defaultOptions.mjs");
/* harmony import */ var _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/format/formatters.mjs */ "./node_modules/date-fns/_lib/format/formatters.mjs");
/* harmony import */ var _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/format/longFormatters.mjs */ "./node_modules/date-fns/_lib/format/longFormatters.mjs");
/* harmony import */ var _lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_lib/protectedTokens.mjs */ "./node_modules/date-fns/_lib/protectedTokens.mjs");
/* harmony import */ var _isValid_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isValid.mjs */ "./node_modules/date-fns/isValid.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");








// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874


// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;



/**
 * The {@link format} function options.
 */

/**
 * @name format
 * @alias formatDate
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 * @param options - An object with options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */
function format(date, formatStr, options) {
  const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_2__.getDefaultOptions)();
  const locale = options?.locale ?? defaultOptions.locale ?? _lib_defaultLocale_mjs__WEBPACK_IMPORTED_MODULE_3__.enUS;

  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const originalDate = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_4__.toDate)(date);

  if (!(0,_isValid_mjs__WEBPACK_IMPORTED_MODULE_5__.isValid)(originalDate)) {
    throw new RangeError("Invalid time value");
  }

  let parts = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__.longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp)
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }

      if (_lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return { isToken: false, value: substring };
    });

  // invoke localize preprocessor (only for french locales at the moment)
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }

  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  return parts
    .map((part) => {
      if (!part.isToken) return part.value;

      const token = part.value;

      if (
        (!options?.useAdditionalWeekYearTokens &&
          (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.isProtectedWeekYearToken)(token)) ||
        (!options?.useAdditionalDayOfYearTokens &&
          (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.isProtectedDayOfYearToken)(token))
      ) {
        (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.warnOrThrowProtectedError)(token, formatStr, String(date));
      }

      const formatter = _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    })
    .join("");
}

function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (format);


/***/ }),

/***/ "./node_modules/date-fns/getDayOfYear.mjs":
/*!************************************************!*\
  !*** ./node_modules/date-fns/getDayOfYear.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getDayOfYear: () => (/* binding */ getDayOfYear)
/* harmony export */ });
/* harmony import */ var _differenceInCalendarDays_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./differenceInCalendarDays.mjs */ "./node_modules/date-fns/differenceInCalendarDays.mjs");
/* harmony import */ var _startOfYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfYear.mjs */ "./node_modules/date-fns/startOfYear.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");




/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(date) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const diff = (0,_differenceInCalendarDays_mjs__WEBPACK_IMPORTED_MODULE_1__.differenceInCalendarDays)(_date, (0,_startOfYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfYear)(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getDayOfYear);


/***/ }),

/***/ "./node_modules/date-fns/getISOWeek.mjs":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/getISOWeek.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getISOWeek: () => (/* binding */ getISOWeek)
/* harmony export */ });
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/date-fns/constants.mjs");
/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ "./node_modules/date-fns/startOfISOWeek.mjs");
/* harmony import */ var _startOfISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeekYear.mjs */ "./node_modules/date-fns/startOfISOWeekYear.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");





/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(date) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const diff = +(0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_1__.startOfISOWeek)(_date) - +(0,_startOfISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeekYear)(_date);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _constants_mjs__WEBPACK_IMPORTED_MODULE_3__.millisecondsInWeek) + 1;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getISOWeek);


/***/ }),

/***/ "./node_modules/date-fns/getISOWeekYear.mjs":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/getISOWeekYear.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getISOWeekYear: () => (/* binding */ getISOWeekYear)
/* harmony export */ });
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");
/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ "./node_modules/date-fns/startOfISOWeek.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");




/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOWeekYear(date) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const year = _date.getFullYear();

  const fourthOfJanuaryOfNextYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuaryOfNextYear);

  const fourthOfJanuaryOfThisYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuaryOfThisYear);

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getISOWeekYear);


/***/ }),

/***/ "./node_modules/date-fns/getWeek.mjs":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/getWeek.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getWeek: () => (/* binding */ getWeek)
/* harmony export */ });
/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.mjs */ "./node_modules/date-fns/constants.mjs");
/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./startOfWeek.mjs */ "./node_modules/date-fns/startOfWeek.mjs");
/* harmony import */ var _startOfWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfWeekYear.mjs */ "./node_modules/date-fns/startOfWeekYear.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");





/**
 * The {@link getWeek} function options.
 */

/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The week
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(date, options) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const diff = +(0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_1__.startOfWeek)(_date, options) - +(0,_startOfWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfWeekYear)(_date, options);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _constants_mjs__WEBPACK_IMPORTED_MODULE_3__.millisecondsInWeek) + 1;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getWeek);


/***/ }),

/***/ "./node_modules/date-fns/getWeekYear.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/getWeekYear.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getWeekYear: () => (/* binding */ getWeekYear)
/* harmony export */ });
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");
/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./startOfWeek.mjs */ "./node_modules/date-fns/startOfWeek.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");
/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ "./node_modules/date-fns/_lib/defaultOptions.mjs");





/**
 * The {@link getWeekYear} function options.
 */

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The local week-numbering year
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(date, options) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const year = _date.getFullYear();

  const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const firstWeekOfNextYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeekOfNextYear, options);

  const firstWeekOfThisYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeekOfThisYear, options);

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getWeekYear);


/***/ }),

/***/ "./node_modules/date-fns/isDate.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isDate.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isDate: () => (/* binding */ isDate)
/* harmony export */ });
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param value - The value to check
 *
 * @returns True if the given value is a date
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  return (
    value instanceof Date ||
    (typeof value === "object" &&
      Object.prototype.toString.call(value) === "[object Date]")
  );
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isDate);


/***/ }),

/***/ "./node_modules/date-fns/isSameDay.mjs":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/isSameDay.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isSameDay: () => (/* binding */ isSameDay)
/* harmony export */ });
/* harmony import */ var _startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startOfDay.mjs */ "./node_modules/date-fns/startOfDay.mjs");


/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same day (and year and month)
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateLeft);
  const dateRightStartOfDay = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateRight);

  return +dateLeftStartOfDay === +dateRightStartOfDay;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSameDay);


/***/ }),

/***/ "./node_modules/date-fns/isToday.mjs":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isToday.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isToday: () => (/* binding */ isToday)
/* harmony export */ });
/* harmony import */ var _constructNow_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructNow.mjs */ "./node_modules/date-fns/constructNow.mjs");
/* harmony import */ var _isSameDay_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSameDay.mjs */ "./node_modules/date-fns/isSameDay.mjs");



/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is today
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */
function isToday(date) {
  return (0,_isSameDay_mjs__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(date, (0,_constructNow_mjs__WEBPACK_IMPORTED_MODULE_1__.constructNow)(date));
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isToday);


/***/ }),

/***/ "./node_modules/date-fns/isValid.mjs":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isValid.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isValid: () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _isDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDate.mjs */ "./node_modules/date-fns/isDate.mjs");
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is valid
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(date) {
  if (!(0,_isDate_mjs__WEBPACK_IMPORTED_MODULE_0__.isDate)(date) && typeof date !== "number") {
    return false;
  }
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_1__.toDate)(date);
  return !isNaN(Number(_date));
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isValid);


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildFormatLongFn: () => (/* binding */ buildFormatLongFn)
/* harmony export */ });
function buildFormatLongFn(args) {
  return (options = {}) => {
    // TODO: Remove String()
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildLocalizeFn: () => (/* binding */ buildLocalizeFn)
/* harmony export */ });
/* eslint-disable no-unused-vars */

/**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */

/**
 * The map of localized values for each width.
 */

/**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */

/**
 * Converts the unit value to the tuple of values.
 */

/**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */

/**
 * The tuple of localized quarter values. The first element represents Q1.
 */

/**
 * The tuple of localized day values. The first element represents Sunday.
 */

/**
 * The tuple of localized month values. The first element represents January.
 */

function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";

    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;

      valuesArray =
        args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;

    // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildMatchFn.mjs":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchFn.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildMatchFn: () => (/* binding */ buildMatchFn)
/* harmony export */ });
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;

    const matchPattern =
      (width && args.matchPatterns[width]) ||
      args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];

    const parsePatterns =
      (width && args.parsePatterns[width]) ||
      args.parsePatterns[args.defaultParseWidth];

    const key = Array.isArray(parsePatterns)
      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
      : // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString));

    let value;

    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback
      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        options.valueCallback(value)
      : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

function findKey(object, predicate) {
  for (const key in object) {
    if (
      Object.prototype.hasOwnProperty.call(object, key) &&
      predicate(object[key])
    ) {
      return key;
    }
  }
  return undefined;
}

function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}


/***/ }),

/***/ "./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildMatchPatternFn: () => (/* binding */ buildMatchPatternFn)
/* harmony export */ });
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];

    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback
      ? args.valueCallback(parseResult[0])
      : parseResult[0];

    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
    value = options.valueCallback ? options.valueCallback(value) : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US.mjs":
/*!************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   enUS: () => (/* binding */ enUS)
/* harmony export */ });
/* harmony import */ var _en_US_lib_formatDistance_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./en-US/_lib/formatDistance.mjs */ "./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs");
/* harmony import */ var _en_US_lib_formatLong_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./en-US/_lib/formatLong.mjs */ "./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs");
/* harmony import */ var _en_US_lib_formatRelative_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./en-US/_lib/formatRelative.mjs */ "./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs");
/* harmony import */ var _en_US_lib_localize_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./en-US/_lib/localize.mjs */ "./node_modules/date-fns/locale/en-US/_lib/localize.mjs");
/* harmony import */ var _en_US_lib_match_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./en-US/_lib/match.mjs */ "./node_modules/date-fns/locale/en-US/_lib/match.mjs");






/**
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */
const enUS = {
  code: "en-US",
  formatDistance: _en_US_lib_formatDistance_mjs__WEBPACK_IMPORTED_MODULE_0__.formatDistance,
  formatLong: _en_US_lib_formatLong_mjs__WEBPACK_IMPORTED_MODULE_1__.formatLong,
  formatRelative: _en_US_lib_formatRelative_mjs__WEBPACK_IMPORTED_MODULE_2__.formatRelative,
  localize: _en_US_lib_localize_mjs__WEBPACK_IMPORTED_MODULE_3__.localize,
  match: _en_US_lib_match_mjs__WEBPACK_IMPORTED_MODULE_4__.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
};

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (enUS);


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatDistance: () => (/* binding */ formatDistance)
/* harmony export */ });
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds",
  },

  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds",
  },

  halfAMinute: "half a minute",

  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes",
  },

  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours",
  },

  xHours: {
    one: "1 hour",
    other: "{{count}} hours",
  },

  xDays: {
    one: "1 day",
    other: "{{count}} days",
  },

  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks",
  },

  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months",
  },

  xMonths: {
    one: "1 month",
    other: "{{count}} months",
  },

  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years",
  },

  xYears: {
    one: "1 year",
    other: "{{count}} years",
  },

  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years",
  },

  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years",
  },
};

const formatDistance = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }

  return result;
};


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatLong: () => (/* binding */ formatLong)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildFormatLongFn.mjs */ "./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs");


const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

const formatLong = {
  date: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({
    formats: dateFormats,
    defaultWidth: "full",
  }),

  time: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({
    formats: timeFormats,
    defaultWidth: "full",
  }),

  dateTime: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({
    formats: dateTimeFormats,
    defaultWidth: "full",
  }),
};


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatRelative: () => (/* binding */ formatRelative)
/* harmony export */ });
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P",
};

const formatRelative = (token, _date, _baseDate, _options) =>
  formatRelativeLocale[token];


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/localize.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/localize.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localize: () => (/* binding */ localize)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildLocalizeFn.mjs */ "./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs");


const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"],
};

const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],

  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
};

const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
};

const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
};

const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
};

const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};

const localize = {
  ordinalNumber,

  era: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({
    values: eraValues,
    defaultWidth: "wide",
  }),

  quarter: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({
    values: monthValues,
    defaultWidth: "wide",
  }),

  day: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({
    values: dayValues,
    defaultWidth: "wide",
  }),

  dayPeriod: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide",
  }),
};


/***/ }),

/***/ "./node_modules/date-fns/locale/en-US/_lib/match.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/match.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   match: () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_lib/buildMatchFn.mjs */ "./node_modules/date-fns/locale/_lib/buildMatchFn.mjs");
/* harmony import */ var _lib_buildMatchPatternFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildMatchPatternFn.mjs */ "./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs");



const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;

const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i,
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i,
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

const match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any",
  }),

  quarter: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any",
  }),

  day: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any",
  }),
};


/***/ }),

/***/ "./node_modules/date-fns/startOfDay.mjs":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/startOfDay.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfDay: () => (/* binding */ startOfDay)
/* harmony export */ });
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(date) {
  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfDay);


/***/ }),

/***/ "./node_modules/date-fns/startOfISOWeek.mjs":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeek.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfISOWeek: () => (/* binding */ startOfISOWeek)
/* harmony export */ });
/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startOfWeek.mjs */ "./node_modules/date-fns/startOfWeek.mjs");


/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(date) {
  return (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfWeek)(date, { weekStartsOn: 1 });
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfISOWeek);


/***/ }),

/***/ "./node_modules/date-fns/startOfISOWeekYear.mjs":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeekYear.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfISOWeekYear: () => (/* binding */ startOfISOWeekYear)
/* harmony export */ });
/* harmony import */ var _getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getISOWeekYear.mjs */ "./node_modules/date-fns/getISOWeekYear.mjs");
/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ "./node_modules/date-fns/startOfISOWeek.mjs");
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");




/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(date) {
  const year = (0,_getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_0__.getISOWeekYear)(date);
  const fourthOfJanuary = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuary);
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfISOWeekYear);


/***/ }),

/***/ "./node_modules/date-fns/startOfWeek.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfWeek.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfWeek: () => (/* binding */ startOfWeek)
/* harmony export */ });
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");
/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ "./node_modules/date-fns/_lib/defaultOptions.mjs");



/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(date, options) {
  const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_1__.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfWeek);


/***/ }),

/***/ "./node_modules/date-fns/startOfWeekYear.mjs":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/startOfWeekYear.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfWeekYear: () => (/* binding */ startOfWeekYear)
/* harmony export */ });
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");
/* harmony import */ var _getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWeekYear.mjs */ "./node_modules/date-fns/getWeekYear.mjs");
/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./startOfWeek.mjs */ "./node_modules/date-fns/startOfWeek.mjs");
/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ "./node_modules/date-fns/_lib/defaultOptions.mjs");





/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(date, options) {
  const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = (0,_getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__.getWeekYear)(date, options);
  const firstWeek = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeek, options);
  return _date;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfWeekYear);


/***/ }),

/***/ "./node_modules/date-fns/startOfYear.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfYear.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startOfYear: () => (/* binding */ startOfYear)
/* harmony export */ });
/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ "./node_modules/date-fns/toDate.mjs");
/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ "./node_modules/date-fns/constructFrom.mjs");



/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(date) {
  const cleanDate = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);
  const _date = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startOfYear);


/***/ }),

/***/ "./node_modules/date-fns/toDate.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/toDate.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toDate: () => (/* binding */ toDate)
/* harmony export */ });
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (
    argument instanceof Date ||
    (typeof argument === "object" && argStr === "[object Date]")
  ) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new argument.constructor(+argument);
  } else if (
    typeof argument === "number" ||
    argStr === "[object Number]" ||
    typeof argument === "string" ||
    argStr === "[object String]"
  ) {
    // TODO: Can we get rid of as?
    return new Date(argument);
  } else {
    // TODO: Can we get rid of as?
    return new Date(NaN);
  }
}

// Fallback for modularized imports:
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toDate);


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/main.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyx3RkFBd0YsWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLGFBQWEsWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFVBQVUsTUFBTSxNQUFNLFVBQVUsWUFBWSxZQUFZLE9BQU8sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLE9BQU8sVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFlBQVksYUFBYSxjQUFjLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZ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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSCxnSEFBZ0g7QUFDaEgsMEhBQTBIO0FBQzFILDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDREQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDBFQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDBFQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLGtGQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDBFQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFH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QkFBZ0IsbUJBQU8sQ0FBQywwRUFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBcUI7QUFDN0M7QUFDQTtB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REFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDhEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLDhFQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BILGdIQUFnSDtBQUNoSCwwSEFBMEg7QUFDMUgsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBZSxhQUFhLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDdUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsaUVBQWE7QUFDdEI7O0FBRUE7QUFDQSxpRUFBZSxZQUFZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckN3QjtBQUNOO0FBQytDOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUIsMkRBQVU7QUFDbkMsMEJBQTBCLDJEQUFVOztBQUVwQztBQUNBLHNCQUFzQix5R0FBK0I7QUFDckQ7QUFDQSx1QkFBdUIseUdBQStCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkRBQWlCO0FBQ3hFOztBQUVBO0FBQ0EsaUVBQWUsd0JBQXdCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEaUI7QUFDSztBQUNKO0FBQ1E7QUFLOUI7QUFDSTtBQUNGOztBQUV0QztBQUNBO0FBQ3NDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnQzs7QUFFaEM7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLElBQUk7QUFDSjtBQUNBO0FBQ087QUFDUCx5QkFBeUIsMEVBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDZEQUFXO0FBQzFCLG9CQUFvQixpRUFBYTtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFXO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxpRUFBZSxlQUFlLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRE87QUFDYzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLG1EQUFNO0FBQzFCLGdCQUFnQixpRUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFlLFdBQVcsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWUsTUFBTSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9zdHlsZS9jb250ZW50LmNzcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL3N0eWxlL21haW4uY3NzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9zcmMvc3R5bGUvbW9iaWxlLmNzcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL3N0eWxlL3Byb2plY3Rmb3JtLmNzcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL3N0eWxlL3NpZGViYXIuY3NzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9zcmMvc3R5bGUvdG9kby5jc3MiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9zdHlsZS90b2RvZm9ybS5jc3MiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9hZGRMZWFkaW5nWmVyb3MuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2RlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9mb3JtYXQvZm9ybWF0dGVycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZm9ybWF0L2xpZ2h0Rm9ybWF0dGVycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZm9ybWF0L2xvbmdGb3JtYXR0ZXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9nZXRSb3VuZGluZ01ldGhvZC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvcHJvdGVjdGVkVG9rZW5zLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkQnVzaW5lc3NEYXlzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkRGF5cy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2FkZEhvdXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkSVNPV2Vla1llYXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkTWlsbGlzZWNvbmRzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkTWludXRlcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2FkZE1vbnRocy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2FkZFF1YXJ0ZXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkU2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2FkZFdlZWtzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvYWRkWWVhcnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9hcmVJbnRlcnZhbHNPdmVybGFwcGluZy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2NsYW1wLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY2xvc2VzdEluZGV4VG8uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jbG9zZXN0VG8uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb21wYXJlQXNjLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29tcGFyZURlc2MuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb25zdHJ1Y3RGcm9tLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29uc3RydWN0Tm93LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZGF5c1RvV2Vla3MuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5CdXNpbmVzc0RheXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbkNhbGVuZGFySVNPV2Vla3MuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbkRheXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5Ib3Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbklTT1dlZWtZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbk1pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5Nb250aHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5RdWFydGVycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJblNlY29uZHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5XZWVrcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJblllYXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZWFjaERheU9mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoSG91ck9mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoTWludXRlT2ZJbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VhY2hNb250aE9mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoUXVhcnRlck9mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoV2Vla09mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoV2Vla2VuZE9mSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoV2Vla2VuZE9mTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lYWNoV2Vla2VuZE9mWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VhY2hZZWFyT2ZJbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VuZE9mRGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZW5kT2ZEZWNhZGUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lbmRPZkhvdXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lbmRPZklTT1dlZWsuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lbmRPZklTT1dlZWtZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZW5kT2ZNaW51dGUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lbmRPZk1vbnRoLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZW5kT2ZRdWFydGVyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZW5kT2ZTZWNvbmQuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lbmRPZlRvZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZW5kT2ZUb21vcnJvdy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VuZE9mV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VuZE9mWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VuZE9mWWVzdGVyZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0RGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXREaXN0YW5jZVN0cmljdC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2Zvcm1hdERpc3RhbmNlVG9Ob3cuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXREaXN0YW5jZVRvTm93U3RyaWN0LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0RHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXRJU08uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXRJU085MDc1LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0SVNPRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXRSRkMzMzM5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0UkZDNzIzMS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2Zvcm1hdFJlbGF0aXZlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZnJvbVVuaXhUaW1lLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0RGF0ZS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldERheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldERheU9mWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldERheXNJbk1vbnRoLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0RGF5c0luWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldERlY2FkZS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldERlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0SG91cnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09EYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09XZWVrLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0SVNPV2Vla1llYXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09XZWVrc0luWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldE1pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldE1pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRNb250aC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldE92ZXJsYXBwaW5nRGF5c0luSW50ZXJ2YWxzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0UXVhcnRlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldFNlY29uZHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRUaW1lLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0VW5peFRpbWUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0V2Vla09mTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldFdlZWtzSW5Nb250aC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldFllYXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9ob3Vyc1RvTWlsbGlzZWNvbmRzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaG91cnNUb01pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9ob3Vyc1RvU2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2luZGV4LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pbnRlcnZhbFRvRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pbnRsRm9ybWF0LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaW50bEZvcm1hdERpc3RhbmNlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNBZnRlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzQmVmb3JlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNEYXRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNFcXVhbC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzRXhpc3RzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNGaXJzdERheU9mTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc0ZyaWRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzRnV0dXJlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNMYXN0RGF5T2ZNb250aC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzTGVhcFllYXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc01hdGNoLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNNb25kYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1Bhc3QuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1NhbWVEYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1NhbWVIb3VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lSVNPV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzU2FtZUlTT1dlZWtZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lTWludXRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1NhbWVRdWFydGVyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lU2Vjb25kLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzU2FtZVllYXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1NhdHVyZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTdW5kYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1RoaXNIb3VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNUaGlzSVNPV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVGhpc01pbnV0ZS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVGhpc01vbnRoLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNUaGlzUXVhcnRlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVGhpc1NlY29uZC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVGhpc1dlZWsuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1RoaXNZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNUaHVyc2RheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVG9kYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1RvbW9ycm93LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNUdWVzZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNWYWxpZC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzV2VkbmVzZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNXZWVrZW5kLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNXaXRoaW5JbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzWWVzdGVyZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbGFzdERheU9mRGVjYWRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbGFzdERheU9mSVNPV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xhc3REYXlPZklTT1dlZWtZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbGFzdERheU9mTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sYXN0RGF5T2ZRdWFydGVyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbGFzdERheU9mV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xhc3REYXlPZlllYXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9saWdodEZvcm1hdC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL19saWIvYnVpbGRMb2NhbGl6ZUZuLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL19saWIvYnVpbGRNYXRjaEZuLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL19saWIvYnVpbGRNYXRjaFBhdHRlcm5Gbi5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9lbi1VUy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdERpc3RhbmNlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0TG9uZy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdFJlbGF0aXZlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvbG9jYWxpemUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL21heC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL21pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL21pbGxpc2Vjb25kc1RvSG91cnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9taWxsaXNlY29uZHNUb01pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9taWxsaXNlY29uZHNUb1NlY29uZHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9taW4uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9taW51dGVzVG9Ib3Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL21pbnV0ZXNUb01pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL21pbnV0ZXNUb1NlY29uZHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9tb250aHNUb1F1YXJ0ZXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbW9udGhzVG9ZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL25leHREYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9uZXh0RnJpZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbmV4dE1vbmRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL25leHRTYXR1cmRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL25leHRTdW5kYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9uZXh0VGh1cnNkYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9uZXh0VHVlc2RheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL25leHRXZWRuZXNkYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9TZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9BTVBNTWlkbmlnaHRQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvQU1QTVBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9EYXRlUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL0RheU9mWWVhclBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9EYXlQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvRGF5UGVyaW9kUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL0VyYVBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9FeHRlbmRlZFllYXJQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvRnJhY3Rpb25PZlNlY29uZFBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9Ib3VyMFRvMTFQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvSG91cjB0bzIzUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL0hvdXIxVG8yNFBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9Ib3VyMXRvMTJQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvSVNPRGF5UGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL0lTT1RpbWV6b25lUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL0lTT1RpbWV6b25lV2l0aFpQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvSVNPV2Vla1BhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9JU09XZWVrWWVhclBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9Mb2NhbERheVBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9Mb2NhbFdlZWtQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvTG9jYWxXZWVrWWVhclBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9NaW51dGVQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvTW9udGhQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvUXVhcnRlclBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9TZWNvbmRQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi9wYXJzZXJzL1N0YW5kQWxvbmVNb250aFBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9TdGFuZEFsb25lUXVhcnRlclBhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9UaW1lc3RhbXBNaWxsaXNlY29uZHNQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wYXJzZS9fbGliL3BhcnNlcnMvVGltZXN0YW1wU2Vjb25kc1BhcnNlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlL19saWIvcGFyc2Vycy9ZZWFyUGFyc2VyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2UvX2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3BhcnNlSVNPLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcGFyc2VKU09OLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcHJldmlvdXNEYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9wcmV2aW91c0ZyaWRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3ByZXZpb3VzTW9uZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcHJldmlvdXNTYXR1cmRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3ByZXZpb3VzU3VuZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcHJldmlvdXNUaHVyc2RheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3ByZXZpb3VzVHVlc2RheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3ByZXZpb3VzV2VkbmVzZGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvcXVhcnRlcnNUb01vbnRocy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3F1YXJ0ZXJzVG9ZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3JvdW5kVG9OZWFyZXN0SG91cnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9yb3VuZFRvTmVhcmVzdE1pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZWNvbmRzVG9Ib3Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NlY29uZHNUb01pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NlY29uZHNUb01pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXQuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXREYXRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc2V0RGF5LmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc2V0RGF5T2ZZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc2V0RGVmYXVsdE9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXRIb3Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldElTT0RheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldElTT1dlZWsuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXRJU09XZWVrWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldE1pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldE1pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXRNb250aC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldFF1YXJ0ZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zZXRTZWNvbmRzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc2V0V2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3NldFdlZWtZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc2V0WWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZEYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mRGVjYWRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZkhvdXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZJU09XZWVrWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZNaW51dGUuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mTW9udGguanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mUXVhcnRlci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZTZWNvbmQuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mVG9kYXkuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mVG9tb3Jyb3cuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mV2Vlay5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZXZWVrWWVhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZZZWFyLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZlllc3RlcmRheS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1Yi5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1YkJ1c2luZXNzRGF5cy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1YkRheXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdWJIb3Vycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1YklTT1dlZWtZZWFycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1Yk1pbGxpc2Vjb25kcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1Yk1pbnV0ZXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdWJNb250aHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdWJRdWFydGVycy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1YlNlY29uZHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdWJXZWVrcy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N1YlllYXJzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvdG9EYXRlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvdHJhbnNwb3NlLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvd2Vla3NUb0RheXMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy95ZWFyc1RvRGF5cy5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3llYXJzVG9Nb250aHMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy95ZWFyc1RvUXVhcnRlcnMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9zdHlsZS9tYWluLmNzcz84MzMxIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL2Fzc2V0cy80MDQuc3ZnIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9hc3NldHMvY2hlY2tsaXN0LTcxLnN2ZyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vYXNzZXRzL2NvbnN0cnVjdGlvbi1zaXRlLTU5LnN2ZyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vYXNzZXRzL3Jlc3RpbmctNDkuc3ZnIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9hc3NldHMvc2NydW0tYm9hcmQtMjcuc3ZnIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9zcmMvY29tcG9uZW50cy9jYXJkLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9zcmMvY29tcG9uZW50cy9wcm9qZWN0Zm9ybS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL2NvbXBvbmVudHMvc2lkZWJhci5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL2NvbXBvbmVudHMvdG9kb2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tYWluLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9zcmMvbW9kdWxlcy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tb2R1bGVzL2d1aS5qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vc3JjL21vZHVsZXMvbG9naWMuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tb2R1bGVzL3Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tb2R1bGVzL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tb2R1bGVzL3RvZG8uanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL3NyYy9tb2R1bGVzL3V0aWxzLmpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9hZGRMZWFkaW5nWmVyb3MubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9kZWZhdWx0T3B0aW9ucy5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZm9ybWF0L2xpZ2h0Rm9ybWF0dGVycy5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9sb25nRm9ybWF0dGVycy5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9wcm90ZWN0ZWRUb2tlbnMubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29uc3RhbnRzLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2NvbnN0cnVjdEZyb20ubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29uc3RydWN0Tm93Lm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cy5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXQubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0RGF5T2ZZZWFyLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldElTT1dlZWsubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0SVNPV2Vla1llYXIubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZ2V0V2Vlay5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrWWVhci5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc0RhdGUubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNTYW1lRGF5Lm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2lzVG9kYXkubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvaXNWYWxpZC5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZEZvcm1hdExvbmdGbi5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZExvY2FsaXplRm4ubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL19saWIvYnVpbGRNYXRjaEZuLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4ubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdERpc3RhbmNlLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9lbi1VUy9fbGliL2Zvcm1hdExvbmcubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0UmVsYXRpdmUubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvbG9jYWxpemUubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvbWF0Y2gubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZkRheS5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vlay5tanMiLCJ3ZWJwYWNrOi8vdG9kby1jbG9uZS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vla1llYXIubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZldlZWsubWpzIiwid2VicGFjazovL3RvZG8tY2xvbmUvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZldlZWtZZWFyLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZZZWFyLm1qcyIsIndlYnBhY2s6Ly90b2RvLWNsb25lLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3RvRGF0ZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCNjb250ZW50IHtcbiAgICBmbGV4OiAxO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogMC41cmVtO1xuICAgIHBhZGRpbmc6IDJyZW07XG59XG5cbiNjb250ZW50LXZpZXcge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICB3aWR0aDogY2xhbXAoMzYwcHgsIDY4MHB4LCA4MDBweCk7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG59XG5cbiN1cHBlckNvbnRlbnRQYW5lbCxcbiNwcm9qZWN0RGVzY3JpcHRpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBhZGRpbmc6IDByZW0gMnJlbTtcbn1cblxuI3Byb2plY3RCdXR0b25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogLjRyZW07XG59XG5cbi5wcm9qZWN0QnV0dG9uIHtcbiAgICB3aWR0aDogMS41cmVtO1xuICAgIGhlaWdodDogMS41cmVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBwYWRkaW5nOiAxcmVtO1xufVxuXG4ucHJvamVjdEJ1dHRvbjpob3ZlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMC4wNDApO1xuICAgIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcbiAgICB0cmFuc2l0aW9uOiBlYXNlIDAuMXM7XG59XG5cbi5wcm9qZWN0QnV0dG9uLmRlbGV0ZSB7XG4gICAgY29sb3I6IHJnYmEoMTk1LCA0MCwgMTMsIDAuNzQ1KTtcbn1cblxuI3Byb2plY3ROYW1lIHtcbiAgICBmb250LXNpemU6IDJyZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcbn1cblxuI2luc2lkZVByb2plY3RBZGRCdXR0b24ge1xuICAgIHBhZGRpbmc6IDAuNXJlbTtcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogMC41cmVtO1xuXG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgY29sb3I6IHJlZDtcbiAgICBmb250LXdlaWdodDogNzAwO1xufVxuXG4jZW1wdHlQcm9qZWN0U2NyZWVuIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBnYXA6IDFyZW07XG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xuICAgIG1hcmdpbi10b3A6IDI1JTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbiNmaWx0ZXJTZWxlY3Rpb25QYW5lbFtzdHlsZSo9XCJkaXNwbGF5OiBmbGV4XCJdIH4gI2VtcHR5UHJvamVjdFNjcmVlbiB7XG4gICAgbWFyZ2luLXRvcDogNSU7XG59XG5cblxuI2VtcHR5SW1hZ2Uge1xuICAgIHdpZHRoOiAzMDBweDtcbiAgICBoZWlnaHQ6IDMwMHB4O1xufVxuXG4uZm9sZEJ1dHRvbi5jb250ZW50IHtcbiAgICB0cmFuc2l0aW9uOiAycyBlYXNlOyBcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgtMSk7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMC43NXJlbTtcbiAgICBsZWZ0OiAwLjc1cmVtO1xufVxuXG4jZmlsdGVyU2VsZWN0aW9uUGFuZWwge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgcGFkZGluZzogMnJlbTtcbiAgICBnYXA6IC41cmVtXG59XG5cbiNmaWx0ZXJTZWxlY3Rpb25QYW5lbCAjcHJvcCxcbiNmaWx0ZXJTZWxlY3Rpb25QYW5lbCAjdmFsdWUge1xuICAgIGJvcmRlci1yYWRpdXM6IDAuNHJlbTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xuICAgIHBhZGRpbmc6IDAuMjVyZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMCk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41MCk7XG59XG5cbiNkaWFsb2dPdmVybGF5IHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogNTtcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlL2NvbnRlbnQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksT0FBTztJQUNQLGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsbUJBQW1CO0lBQ25CLHVCQUF1QjtJQUN2QixXQUFXO0lBQ1gsYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsdUJBQXVCO0lBQ3ZCLGlDQUFpQztJQUNqQyxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLHFCQUFxQjtBQUN6Qjs7QUFFQTs7SUFFSSxhQUFhO0lBQ2IsOEJBQThCO0lBQzlCLHFCQUFxQjs7SUFFckIsV0FBVztJQUNYLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGFBQWE7SUFDYixVQUFVO0FBQ2Q7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsY0FBYztJQUNkLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGdCQUFnQjtJQUNoQixZQUFZO0lBQ1osYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixtQ0FBbUM7SUFDbkMscUJBQXFCO0lBQ3JCLHFCQUFxQjtBQUN6Qjs7QUFFQTtJQUNJLCtCQUErQjtBQUNuQzs7QUFFQTtJQUNJLGVBQWU7SUFDZixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsZUFBZTtJQUNmLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsV0FBVzs7SUFFWCxZQUFZO0lBQ1osZ0JBQWdCO0lBQ2hCLFVBQVU7SUFDVixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIsU0FBUztJQUNULGtCQUFrQjtJQUNsQixlQUFlO0lBQ2Ysa0JBQWtCO0FBQ3RCOztBQUVBO0lBQ0ksY0FBYztBQUNsQjs7O0FBR0E7SUFDSSxZQUFZO0lBQ1osYUFBYTtBQUNqQjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQixxQkFBcUI7SUFDckIsa0JBQWtCO0lBQ2xCLFlBQVk7SUFDWixhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLGFBQWE7SUFDYjtBQUNKOztBQUVBOztJQUVJLHFCQUFxQjtJQUNyQixxQ0FBcUM7SUFDckMsZ0JBQWdCO0lBQ2hCLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsb0NBQW9DO0lBQ3BDLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0lBQ1osYUFBYTtJQUNiLGtCQUFrQjtJQUNsQixVQUFVO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiI2NvbnRlbnQge1xcbiAgICBmbGV4OiAxO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZ2FwOiAwLjVyZW07XFxuICAgIHBhZGRpbmc6IDJyZW07XFxufVxcblxcbiNjb250ZW50LXZpZXcge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gICAgd2lkdGg6IGNsYW1wKDM2MHB4LCA2ODBweCwgODAwcHgpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcXG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xcbn1cXG5cXG4jdXBwZXJDb250ZW50UGFuZWwsXFxuI3Byb2plY3REZXNjcmlwdGlvbiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcblxcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogMHJlbSAycmVtO1xcbn1cXG5cXG4jcHJvamVjdEJ1dHRvbnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBnYXA6IC40cmVtO1xcbn1cXG5cXG4ucHJvamVjdEJ1dHRvbiB7XFxuICAgIHdpZHRoOiAxLjVyZW07XFxuICAgIGhlaWdodDogMS41cmVtO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbn1cXG5cXG4ucHJvamVjdEJ1dHRvbjpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjA0MCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcXG4gICAgdHJhbnNpdGlvbjogZWFzZSAwLjFzO1xcbn1cXG5cXG4ucHJvamVjdEJ1dHRvbi5kZWxldGUge1xcbiAgICBjb2xvcjogcmdiYSgxOTUsIDQwLCAxMywgMC43NDUpO1xcbn1cXG5cXG4jcHJvamVjdE5hbWUge1xcbiAgICBmb250LXNpemU6IDJyZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxufVxcblxcbiNpbnNpZGVQcm9qZWN0QWRkQnV0dG9uIHtcXG4gICAgcGFkZGluZzogMC41cmVtO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDogMC41cmVtO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGNvbG9yOiByZWQ7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbiNlbXB0eVByb2plY3RTY3JlZW4ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgZ2FwOiAxcmVtO1xcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgIG1hcmdpbi10b3A6IDI1JTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4jZmlsdGVyU2VsZWN0aW9uUGFuZWxbc3R5bGUqPVxcXCJkaXNwbGF5OiBmbGV4XFxcIl0gfiAjZW1wdHlQcm9qZWN0U2NyZWVuIHtcXG4gICAgbWFyZ2luLXRvcDogNSU7XFxufVxcblxcblxcbiNlbXB0eUltYWdlIHtcXG4gICAgd2lkdGg6IDMwMHB4O1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbn1cXG5cXG4uZm9sZEJ1dHRvbi5jb250ZW50IHtcXG4gICAgdHJhbnNpdGlvbjogMnMgZWFzZTsgXFxuICAgIHRyYW5zZm9ybTogc2NhbGVYKC0xKTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDAuNzVyZW07XFxuICAgIGxlZnQ6IDAuNzVyZW07XFxufVxcblxcbiNmaWx0ZXJTZWxlY3Rpb25QYW5lbCB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDJyZW07XFxuICAgIGdhcDogLjVyZW1cXG59XFxuXFxuI2ZpbHRlclNlbGVjdGlvblBhbmVsICNwcm9wLFxcbiNmaWx0ZXJTZWxlY3Rpb25QYW5lbCAjdmFsdWUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjRyZW07XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIHBhZGRpbmc6IDAuMjVyZW07XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMCk7XFxuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNTApO1xcbn1cXG5cXG4jZGlhbG9nT3ZlcmxheSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogNTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NpZGViYXIuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vY29udGVudC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi90b2RvLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3RvZG9mb3JtLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNF9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Byb2plY3Rmb3JtLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNV9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21vYmlsZS5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PVJvYm90bytNb25vOml0YWwsd2dodEAwLDEwMC4uNzAwOzEsMTAwLi43MDAmZGlzcGxheT1zd2FwKTtcIl0pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzFfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzNfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAvKiNyZWdpb24gQ1NTIFJlc2V0ICovXG46cm9vdCB7XG4gICAgZm9udC1mYW1pbHk6IFwiUm9ib3RvIE1vbm9cIiwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgZm9udC1zaXplOiAxNnB4O1xufVxuXG4qIHtcbiAgICBwYWRkaW5nOiAwO1xuICAgIG1hcmdpbjogMDtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICBmb250LWZhbWlseTogaW5oZXJpdDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xufVxuLyojZW5kcmVnaW9uKi9cblxuLyojcmVnaW9uIFBhZ2UgTGF5b3V0ICovXG5cbmJvZHkge1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbn1cblxuLmFwcCB7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi8qI2VuZHJlZ2lvbiAqL1xuXG5cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlL21haW4uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQVFBLHFCQUFxQjtBQUNyQjtJQUNJLDZDQUE2QztJQUM3QyxlQUFlO0FBQ25COztBQUVBO0lBQ0ksVUFBVTtJQUNWLFNBQVM7SUFDVCxnQkFBZ0I7SUFDaEIsa0JBQWtCO0lBQ2xCLG9CQUFvQjtJQUNwQixzQkFBc0I7QUFDMUI7QUFDQSxhQUFhOztBQUViLHVCQUF1Qjs7QUFFdkI7SUFDSSxhQUFhO0lBQ2Isa0NBQWtDO0FBQ3RDOztBQUVBO0lBQ0ksYUFBYTtJQUNiLGFBQWE7SUFDYixnQkFBZ0I7QUFDcEI7O0FBRUEsY0FBY1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Sb2JvdG8rTW9ubzppdGFsLHdnaHRAMCwxMDAuLjcwMDsxLDEwMC4uNzAwJmRpc3BsYXk9c3dhcCcpO1xcbkBpbXBvcnQgXFxcInNpZGViYXIuY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCJjb250ZW50LmNzc1xcXCI7XFxuQGltcG9ydCBcXFwidG9kby5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcInRvZG9mb3JtLmNzc1xcXCI7XFxuQGltcG9ydCBcXFwicHJvamVjdGZvcm0uY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCJtb2JpbGUuY3NzXFxcIjtcXG5cXG4vKiNyZWdpb24gQ1NTIFJlc2V0ICovXFxuOnJvb3Qge1xcbiAgICBmb250LWZhbWlseTogXFxcIlJvYm90byBNb25vXFxcIiwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG59XFxuXFxuKiB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLyojZW5kcmVnaW9uKi9cXG5cXG4vKiNyZWdpb24gUGFnZSBMYXlvdXQgKi9cXG5cXG5ib2R5IHtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuXFxuLmFwcCB7XFxuICAgIGhlaWdodDogMTAwdmg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi8qI2VuZHJlZ2lvbiAqL1xcblxcblxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCNwcm9qZWN0RGV0YWlscyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGdhcDogMC41cmVtO1xuICAgIHdpZHRoOiA0ODBweDtcbn1cblxuI3Byb2plY3REZXRhaWxzIGlucHV0LCB0ZXh0YXJlYSB7XG4gICAgcGFkZGluZzogMC4ycmVtO1xuICAgIGJvcmRlcjogbm9uZTtcbn1cblxuI3Byb2plY3REZXRhaWxzIHRleHRhcmVhIHtcbiAgICByZXNpemU6IG5vbmU7XG59XG5cbiNwcm9qZWN0RGV0YWlscyBpbnB1dCwgdGV4dGFyZWE6Zm9jdXMge1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG59XG5cbiNwcm9qZWN0Rm9ybU5hbWUge1xuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xuICAgIGZvbnQtd2VpZ2h0OiA3MDA7O1xufVxuXG4jY29sb3JTZWN0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiAwLjVyZW07XG59XG5cbiNjb2xvclNlY3Rpb24gc2VsZWN0IHtcbiAgICBmbGV4OiAxO1xufVxuI2NvbG9yU2VjdGlvbiBzZWxlY3Q6Zm9jdXMge1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG5cbiNjb2xvckNpcmNsZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIHdpZHRoOiAxcmVtO1xuICAgIGhlaWdodDogMXJlbTtcbn1cblxuI2J1dHRvbnNUYWIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBnYXA6IDAuNXJlbTtcbn1cblxuI2J1dHRvbnNUYWIgYnV0dG9uIHtcbiAgICBwYWRkaW5nOiAwLjI1cmVtIDAuNnJlbTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjRyZW07XG4gICAgYm9yZGVyOiBub25lO1xufVxuXG4jc2F2ZVByb2plY3Qge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgNDksIDgzLCAwLjUwKTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcbn1cblxuI3NhdmVQcm9qZWN0Ym9keSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuMjUpO1xufVxuXG4jc2F2ZVByb2plY3Q6ZGlzYWJsZWQ6aG92ZXIge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG59XG5cbiNjbG9zZVByb2plY3RGb3JtIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NSwgNDAsIDEzLCAwLjc0NSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG59XG5cbiNzYXZlUHJvamVjdDpub3QoW2Rpc2FibGVkXSk6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43NSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG59XG5cbiNjbG9zZVByb2plY3RGb3JtOmhvdmVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTUsIDQwLCAxMywgMC45NSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG59YCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGUvcHJvamVjdGZvcm0uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtJQUN0QixXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixZQUFZO0lBQ1osZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksaUJBQWlCO0lBQ2pCLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsV0FBVztBQUNmOztBQUVBO0lBQ0ksT0FBTztBQUNYO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksdUJBQXVCO0lBQ3ZCLGtCQUFrQjtJQUNsQixXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGFBQWE7SUFDYix5QkFBeUI7SUFDekIsV0FBVztBQUNmOztBQUVBO0lBQ0ksdUJBQXVCO0lBQ3ZCLHFCQUFxQjtJQUNyQixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksdUNBQXVDO0lBQ3ZDLGdDQUFnQztBQUNwQzs7QUFFQTtJQUNJLHVDQUF1QztBQUMzQzs7QUFFQTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLDBDQUEwQztJQUMxQyxnQ0FBZ0M7QUFDcEM7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsdUNBQXVDO0lBQ3ZDLGdDQUFnQztBQUNwQzs7QUFFQTtJQUNJLGVBQWU7SUFDZix5Q0FBeUM7SUFDekMsZ0NBQWdDO0FBQ3BDXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIiNwcm9qZWN0RGV0YWlscyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGdhcDogMC41cmVtO1xcbiAgICB3aWR0aDogNDgwcHg7XFxufVxcblxcbiNwcm9qZWN0RGV0YWlscyBpbnB1dCwgdGV4dGFyZWEge1xcbiAgICBwYWRkaW5nOiAwLjJyZW07XFxuICAgIGJvcmRlcjogbm9uZTtcXG59XFxuXFxuI3Byb2plY3REZXRhaWxzIHRleHRhcmVhIHtcXG4gICAgcmVzaXplOiBub25lO1xcbn1cXG5cXG4jcHJvamVjdERldGFpbHMgaW5wdXQsIHRleHRhcmVhOmZvY3VzIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbn1cXG5cXG4jcHJvamVjdEZvcm1OYW1lIHtcXG4gICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7O1xcbn1cXG5cXG4jY29sb3JTZWN0aW9uIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZ2FwOiAwLjVyZW07XFxufVxcblxcbiNjb2xvclNlY3Rpb24gc2VsZWN0IHtcXG4gICAgZmxleDogMTtcXG59XFxuI2NvbG9yU2VjdGlvbiBzZWxlY3Q6Zm9jdXMge1xcbiAgICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4jY29sb3JDaXJjbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICB3aWR0aDogMXJlbTtcXG4gICAgaGVpZ2h0OiAxcmVtO1xcbn1cXG5cXG4jYnV0dG9uc1RhYiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgIGdhcDogMC41cmVtO1xcbn1cXG5cXG4jYnV0dG9uc1RhYiBidXR0b24ge1xcbiAgICBwYWRkaW5nOiAwLjI1cmVtIDAuNnJlbTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC40cmVtO1xcbiAgICBib3JkZXI6IG5vbmU7XFxufVxcblxcbiNzYXZlUHJvamVjdCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgNDksIDgzLCAwLjUwKTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XFxufVxcblxcbiNzYXZlUHJvamVjdGJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC4yNSk7XFxufVxcblxcbiNzYXZlUHJvamVjdDpkaXNhYmxlZDpob3ZlciB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcblxcbiNjbG9zZVByb2plY3RGb3JtIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTUsIDQwLCAxMywgMC43NDUpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcXG59XFxuXFxuI3NhdmVQcm9qZWN0Om5vdChbZGlzYWJsZWRdKTpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNzUpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcXG59XFxuXFxuI2Nsb3NlUHJvamVjdEZvcm06aG92ZXIge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk1LCA0MCwgMTMsIDAuOTUpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAjc2lkZWJhciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDQ5LDgzLDAuMDI1KTtcbiAgICBtaW4td2lkdGg6IDI0MHB4O1xuICAgIHBhZGRpbmc6IDAuNXJlbTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICBmbGV4LWJhc2lzOiAwcHg7XG5cbn1cblxuI3NpZGViYXIuZm9sZGFibGUge1xuICAgIHRyYW5zaXRpb246IDAuNzVzIGVhc2U7XG59XG5cbiNzaWRlYmFyLmZvbGRlZCB7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIG1pbi13aWR0aDogMHB4O1xuICAgIHdpZHRoOiAwcHg7XG59XG5cbiNzaWRlYmFyLFxuLnNpZGViYXJQYW5lbCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGdhcDogMC4yNXJlbTtcbiAgICBcbn1cblxuI3NpZGViYXIge1xuICAgIGdhcDogMXJlbTtcbn1cblxuI3NpZGViYXIgcCB7XG4gICAgY29sb3I6IHJnYmEoMCwwLDAsMC43NSk7XG59XG5cbiN1c2VySW5mbzpob3Zlcixcbi5mb2xkQnV0dG9uOmhvdmVyLFxuI2FkZFRvZG9CdXR0b246aG92ZXIsXG4jYWRkUHJvamVjdDpob3Zlcixcbi50YWI6aG92ZXIsXG4ub3B0aW9uczpob3ZlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMC4wNDApO1xuICAgIHRyYW5zaXRpb246IGVhc2UgMC4xcztcbn1cblxuLyojcmVnaW9uIFVzZXIgUGFuZWwgKi9cblxuI3VzZXJQYW5lbCB7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuI3VzZXJQYW5lbCA+ICoge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuI3VzZXJJbmZvIHtcbiAgICBwYWRkaW5nOiAwLjVyZW07XG4gICAgZ2FwOiAwLjVyZW07XG59XG5cbi5jaXJjbGUgI3VzZXJDaXJjbGUge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXdlaWdodDogNzAwO1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuXG4gICAgcGFkZGluZzogMC4zcmVtO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbn1cblxuLmZvbGRCdXR0b24ge1xuICAgIHBhZGRpbmc6IDAuNXJlbTtcbiAgICBhcHBlYXJhbmNlOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xufVxuXG4vKiNlbmRyZWdpb24gKi9cblxuLyojcmVnaW9uIE1haW4gUGFuZWwgKi9cblxuLnRhYiB7XG4gICAgcGFkZGluZzogMC41cmVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xuICAgIGdhcDogMC41cmVtO1xufVxuXG4udGFiICN0b2RvTnVtYmVyIHtcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBjb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuOSk7XG59XG5cbiNhZGRUb2RvQnV0dG9uIHtcbiAgICBwYWRkaW5nOiAwLjVyZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogMC41cmVtO1xuXG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xufVxuXG4uY2lyY2xlIHtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43NSk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4jYWRkVG9kb0J1dHRvbiBzcGFuIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IG5vbmU7XG59XG5cbiNhZGRUb2RvQnV0dG9uIHAge1xuICAgIGNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43NSk7XG59XG5cbi8qI2VuZHJlZ2lvbiAqL1xuXG4vKiNyZWdpb24gUHJvamVjdHMgUGFuZWwgKi9cblxuI3Byb2plY3RIZWFkIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4jcHJvamVjdEhlYWQ6aG92ZXIge1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbn1cblxuI3Byb2plY3RIZWFkID4gcCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwLjVyZW07XG4gICAgY29sb3I6IHJnYmEoMCwwLDAsMC41KVxufVxuXG4jYWRkUHJvamVjdCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDAuNXJlbTtcblxuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJvcmRlci1yYWRpdXM6IDAuMzVyZW07XG5cbn1cblxuLm9wdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogMS41cmVtO1xuICAgIGhlaWdodDogMS41cmVtO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG59XG5cbi5wcm9qZWN0TmFtZSB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xufVxuXG5cbi8qI2VuZHJlZ2lvbiAqL1xuXG4vKiNyZWdpb24gU2hhcmVkICovXG5cbi5jdXJyZW50IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsNDksODMsMC4yNSk7XG5cbn1cblxuI3NpZGViYXIgLmN1cnJlbnQgLnBhbmVsVGV4dCxcbiNzaWRlYmFyIC5jdXJyZW50IC5wcm9qZWN0TmFtZSAge1xuICAgIGNvbG9yOiByZ2JhKDAsNDksODMsMSk7XG59XG5cbi5jdXJyZW50OmhvdmVye1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw0OSw4MywwLjI1KTtcbn1cblxuLyojZW5kcmVnaW9uICovXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS9zaWRlYmFyLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLHFDQUFxQztJQUNyQyxnQkFBZ0I7SUFDaEIsZUFBZTtJQUNmLFlBQVk7SUFDWixnQkFBZ0I7SUFDaEIsdUJBQXVCO0lBQ3ZCLGVBQWU7O0FBRW5COztBQUVBO0lBQ0ksc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksWUFBWTtJQUNaLGNBQWM7SUFDZCxVQUFVO0FBQ2Q7O0FBRUE7O0lBRUksYUFBYTtJQUNiLHNCQUFzQjtJQUN0QixZQUFZOztBQUVoQjs7QUFFQTtJQUNJLFNBQVM7QUFDYjs7QUFFQTtJQUNJLHVCQUF1QjtBQUMzQjs7QUFFQTs7Ozs7O0lBTUksZUFBZTtJQUNmLG1DQUFtQztJQUNuQyxxQkFBcUI7QUFDekI7O0FBRUEsc0JBQXNCOztBQUV0QjtJQUNJLG1CQUFtQjtJQUNuQiw4QkFBOEI7SUFDOUIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGVBQWU7SUFDZixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsZ0JBQWdCO0lBQ2hCLGdDQUFnQzs7SUFFaEMsZUFBZTtJQUNmLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGVBQWU7SUFDZixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWixlQUFlO0lBQ2Ysc0JBQXNCO0FBQzFCOztBQUVBLGNBQWM7O0FBRWQsc0JBQXNCOztBQUV0QjtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHNCQUFzQjtJQUN0QixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxpQkFBaUI7SUFDakIsb0JBQW9CO0lBQ3BCLDJCQUEyQjtBQUMvQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLFdBQVc7O0lBRVgsWUFBWTtJQUNaLGdCQUFnQjtJQUNoQixnQkFBZ0I7SUFDaEIsc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksZ0NBQWdDO0lBQ2hDLHVDQUF1QztJQUN2QyxrQkFBa0I7O0lBRWxCLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksa0JBQWtCO0lBQ2xCLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLDRCQUE0QjtBQUNoQzs7QUFFQSxjQUFjOztBQUVkLDBCQUEwQjs7QUFFMUI7SUFDSSxhQUFhO0lBQ2IsOEJBQThCO0lBQzlCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxvQkFBb0I7SUFDcEI7QUFDSjs7QUFFQTtJQUNJLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGVBQWU7O0lBRWYsZ0JBQWdCO0lBQ2hCLFlBQVk7SUFDWixzQkFBc0I7O0FBRTFCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixtQkFBbUI7SUFDbkIsYUFBYTtJQUNiLGNBQWM7SUFDZCxnQkFBZ0I7SUFDaEIsWUFBWTs7SUFFWixpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxnQkFBZ0I7SUFDaEIsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtBQUN2Qjs7O0FBR0EsY0FBYzs7QUFFZCxrQkFBa0I7O0FBRWxCO0lBQ0ksb0NBQW9DOztBQUV4Qzs7QUFFQTs7SUFFSSxzQkFBc0I7QUFDMUI7O0FBRUE7SUFDSSxvQ0FBb0M7QUFDeEM7O0FBRUEsY0FBY1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjc2lkZWJhciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw0OSw4MywwLjAyNSk7XFxuICAgIG1pbi13aWR0aDogMjQwcHg7XFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgZmxleC1iYXNpczogMHB4O1xcblxcbn1cXG5cXG4jc2lkZWJhci5mb2xkYWJsZSB7XFxuICAgIHRyYW5zaXRpb246IDAuNzVzIGVhc2U7XFxufVxcblxcbiNzaWRlYmFyLmZvbGRlZCB7XFxuICAgIHBhZGRpbmc6IDBweDtcXG4gICAgbWluLXdpZHRoOiAwcHg7XFxuICAgIHdpZHRoOiAwcHg7XFxufVxcblxcbiNzaWRlYmFyLFxcbi5zaWRlYmFyUGFuZWwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBnYXA6IDAuMjVyZW07XFxuICAgIFxcbn1cXG5cXG4jc2lkZWJhciB7XFxuICAgIGdhcDogMXJlbTtcXG59XFxuXFxuI3NpZGViYXIgcCB7XFxuICAgIGNvbG9yOiByZ2JhKDAsMCwwLDAuNzUpO1xcbn1cXG5cXG4jdXNlckluZm86aG92ZXIsXFxuLmZvbGRCdXR0b246aG92ZXIsXFxuI2FkZFRvZG9CdXR0b246aG92ZXIsXFxuI2FkZFByb2plY3Q6aG92ZXIsXFxuLnRhYjpob3ZlcixcXG4ub3B0aW9uczpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjA0MCk7XFxuICAgIHRyYW5zaXRpb246IGVhc2UgMC4xcztcXG59XFxuXFxuLyojcmVnaW9uIFVzZXIgUGFuZWwgKi9cXG5cXG4jdXNlclBhbmVsIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4jdXNlclBhbmVsID4gKiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiN1c2VySW5mbyB7XFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXG4gICAgZ2FwOiAwLjVyZW07XFxufVxcblxcbi5jaXJjbGUgI3VzZXJDaXJjbGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xcblxcbiAgICBwYWRkaW5nOiAwLjNyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuXFxuLmZvbGRCdXR0b24ge1xcbiAgICBwYWRkaW5nOiAwLjVyZW07XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xcbn1cXG5cXG4vKiNlbmRyZWdpb24gKi9cXG5cXG4vKiNyZWdpb24gTWFpbiBQYW5lbCAqL1xcblxcbi50YWIge1xcbiAgICBwYWRkaW5nOiAwLjVyZW07XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuMzVyZW07XFxuICAgIGdhcDogMC41cmVtO1xcbn1cXG5cXG4udGFiICN0b2RvTnVtYmVyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbiAgICBjb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuOSk7XFxufVxcblxcbiNhZGRUb2RvQnV0dG9uIHtcXG4gICAgcGFkZGluZzogMC41cmVtO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6IDAuNXJlbTtcXG5cXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xcbn1cXG5cXG4uY2lyY2xlIHtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgNDksIDgzLCAwLjc1KTtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuI2FkZFRvZG9CdXR0b24gc3BhbiB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC13ZWlnaHQ6IG5vbmU7XFxufVxcblxcbiNhZGRUb2RvQnV0dG9uIHAge1xcbiAgICBjb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNzUpO1xcbn1cXG5cXG4vKiNlbmRyZWdpb24gKi9cXG5cXG4vKiNyZWdpb24gUHJvamVjdHMgUGFuZWwgKi9cXG5cXG4jcHJvamVjdEhlYWQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbiNwcm9qZWN0SGVhZDpob3ZlciB7XFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuI3Byb2plY3RIZWFkID4gcCB7XFxuICAgIHBhZGRpbmctbGVmdDogMC41cmVtO1xcbiAgICBjb2xvcjogcmdiYSgwLDAsMCwwLjUpXFxufVxcblxcbiNhZGRQcm9qZWN0IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXG5cXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjM1cmVtO1xcblxcbn1cXG5cXG4ub3B0aW9ucyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB3aWR0aDogMS41cmVtO1xcbiAgICBoZWlnaHQ6IDEuNXJlbTtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcblxcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG59XFxuXFxuLnByb2plY3ROYW1lIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcblxcbi8qI2VuZHJlZ2lvbiAqL1xcblxcbi8qI3JlZ2lvbiBTaGFyZWQgKi9cXG5cXG4uY3VycmVudCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw0OSw4MywwLjI1KTtcXG5cXG59XFxuXFxuI3NpZGViYXIgLmN1cnJlbnQgLnBhbmVsVGV4dCxcXG4jc2lkZWJhciAuY3VycmVudCAucHJvamVjdE5hbWUgIHtcXG4gICAgY29sb3I6IHJnYmEoMCw0OSw4MywxKTtcXG59XFxuXFxuLmN1cnJlbnQ6aG92ZXJ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw0OSw4MywwLjI1KTtcXG59XFxuXFxuLyojZW5kcmVnaW9uICovXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAjdG9kb1ZpZXcge1xuICAgIHdpZHRoOiAxMDAlO1xufVxuXG4udG9kbyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4OiAxO1xuICAgIGdhcDogMXJlbTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIFxuICAgIHBhZGRpbmc6IDFyZW07XG4gICAgd2lkdGg6IDkwJTtcbn1cblxuLmRvbmVDaGVjayB7XG4gICAgYXBwZWFyYW5jZTogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgd2lkdGg6IDEuMjVyZW07XG4gICAgaGVpZ2h0OiAxLjI1cmVtO1xuICAgIG91dGxpbmU6IDFweCBzb2xpZCByZ2JhKDAsMCwwLDAuNDApO1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgcGxhY2UtY29udGVudDogY2VudGVyO1xufVxuXG4uZG9uZUNoZWNrOmNoZWNrZWR7XG4gICAgcGFkZGluZzogMC41cmVtO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgNDksIDgzLCAwLjUwKTtcbn1cblxuLmRvbmVDaGVjazo6YmVmb3Jle1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcbiAgICB3aWR0aDogMC42NWVtO1xuICAgIGhlaWdodDogMC42NWVtO1xuICAgIHRyYW5zaXRpb246IDEyMG1zIHRyYW5zZm9ybSBlYXNlLWluLW91dDtcbiAgICBib3gtc2hhZG93OiBpbnNldCAxZW0gMWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG4gICAgY2xpcC1wYXRoOiBwb2x5Z29uKDE0JSA0NCUsIDAgNjUlLCA1MCUgMTAwJSwgMTAwJSAxNiUsIDgwJSAwJSwgNDMlIDYyJSk7XG59XG5cbi5kb25lQ2hlY2s6Y2hlY2tlZDo6YmVmb3JlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xufVxuXG4udG9kb0luZm9UYWIge1xuICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4udG9kb0Rlc2Mge1xuICAgIG1hcmdpbi10b3A6IGF1dG87XG4gICAgd2lkdGg6IDI0MHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbn1cblxuLnJpZ2h0VGFiIHtcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbn1cblxuLnRvZG9EYXRlUHJvamVjdFRhYiB7XG4gICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogMC41cmVtO1xufVxuXG4udG9kb0RhdGVQcm9qZWN0VGFiIHNwYW4sIHRpbWUge1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBjb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNzUpO1xufVxuXG4udG9kb0RhdGVQcm9qZWN0VGFiIC5wcm9qZWN0U3ltYm9sIHtcbiAgICBjb2xvcjogaW5pdGlhbDtcbn1cblxuLmJ1dHRvbnNUYWIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGVuZDtcbiAgICBnYXA6IDAuNXJlbTtcbn1cblxuLnRvZG9CdXR0b24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogMS41cmVtO1xuICAgIGhlaWdodDogMS41cmVtO1xuXG4gICAgcGFkZGluZzogMXJlbTtcbiAgICBhcHBlYXJhbmNlOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLnRvZG9CdXR0b246aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLDAuMDQwKTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjVyZW07XG4gICAgdHJhbnNpdGlvbjogZWFzZSAwLjFzO1xufVxuXG4uZG9uZSAudG9kb1RpdGxlLFxuLmRvbmUgLnRvZG9EZXNjIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaFxufVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGUvdG9kby5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsT0FBTztJQUNQLFNBQVM7SUFDVCxtQkFBbUI7O0lBRW5CLGFBQWE7SUFDYixVQUFVO0FBQ2Q7O0FBRUE7SUFDSSxnQkFBZ0I7SUFDaEIsa0JBQWtCO0lBQ2xCLGNBQWM7SUFDZCxlQUFlO0lBQ2YsbUNBQW1DO0lBQ25DLGFBQWE7SUFDYixxQkFBcUI7QUFDekI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsdUNBQXVDO0FBQzNDOztBQUVBO0lBQ0ksV0FBVztJQUNYLG1CQUFtQjtJQUNuQixhQUFhO0lBQ2IsY0FBYztJQUNkLHVDQUF1QztJQUN2QyxtREFBbUQ7SUFDbkQsdUVBQXVFO0FBQzNFOztBQUVBO0lBQ0ksbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksc0JBQXNCO0lBQ3RCLGFBQWE7SUFDYixzQkFBc0I7QUFDMUI7O0FBRUE7SUFDSSxnQkFBZ0I7SUFDaEIsWUFBWTtJQUNaLGdCQUFnQjtJQUNoQix1QkFBdUI7SUFDdkIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksb0JBQW9CO0lBQ3BCLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsdUJBQXVCO0lBQ3ZCLFdBQVc7QUFDZjs7QUFFQTtJQUNJLGVBQWU7SUFDZiw0QkFBNEI7QUFDaEM7O0FBRUE7SUFDSSxjQUFjO0FBQ2xCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtJQUNuQixvQkFBb0I7SUFDcEIsV0FBVztBQUNmOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixtQkFBbUI7SUFDbkIsYUFBYTtJQUNiLGNBQWM7O0lBRWQsYUFBYTtJQUNiLGdCQUFnQjtJQUNoQixnQkFBZ0I7SUFDaEIsWUFBWTtJQUNaLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsbUNBQW1DO0lBQ25DLHFCQUFxQjtJQUNyQixxQkFBcUI7QUFDekI7O0FBRUE7O0lBRUk7QUFDSlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjdG9kb1ZpZXcge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnRvZG8ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4OiAxO1xcbiAgICBnYXA6IDFyZW07XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIFxcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICB3aWR0aDogOTAlO1xcbn1cXG5cXG4uZG9uZUNoZWNrIHtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICB3aWR0aDogMS4yNXJlbTtcXG4gICAgaGVpZ2h0OiAxLjI1cmVtO1xcbiAgICBvdXRsaW5lOiAxcHggc29saWQgcmdiYSgwLDAsMCwwLjQwKTtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgcGxhY2UtY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uZG9uZUNoZWNrOmNoZWNrZWR7XFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNTApO1xcbn1cXG5cXG4uZG9uZUNoZWNrOjpiZWZvcmV7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICB3aWR0aDogMC42NWVtO1xcbiAgICBoZWlnaHQ6IDAuNjVlbTtcXG4gICAgdHJhbnNpdGlvbjogMTIwbXMgdHJhbnNmb3JtIGVhc2UtaW4tb3V0O1xcbiAgICBib3gtc2hhZG93OiBpbnNldCAxZW0gMWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XFxuICAgIGNsaXAtcGF0aDogcG9seWdvbigxNCUgNDQlLCAwIDY1JSwgNTAlIDEwMCUsIDEwMCUgMTYlLCA4MCUgMCUsIDQzJSA2MiUpO1xcbn1cXG5cXG4uZG9uZUNoZWNrOmNoZWNrZWQ6OmJlZm9yZSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxufVxcblxcbi50b2RvSW5mb1RhYiB7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi50b2RvRGVzYyB7XFxuICAgIG1hcmdpbi10b3A6IGF1dG87XFxuICAgIHdpZHRoOiAyNDBweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi5yaWdodFRhYiB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG5cXG4udG9kb0RhdGVQcm9qZWN0VGFiIHtcXG4gICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBnYXA6IDAuNXJlbTtcXG59XFxuXFxuLnRvZG9EYXRlUHJvamVjdFRhYiBzcGFuLCB0aW1lIHtcXG4gICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICBjb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNzUpO1xcbn1cXG5cXG4udG9kb0RhdGVQcm9qZWN0VGFiIC5wcm9qZWN0U3ltYm9sIHtcXG4gICAgY29sb3I6IGluaXRpYWw7XFxufVxcblxcbi5idXR0b25zVGFiIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBlbmQ7XFxuICAgIGdhcDogMC41cmVtO1xcbn1cXG5cXG4udG9kb0J1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB3aWR0aDogMS41cmVtO1xcbiAgICBoZWlnaHQ6IDEuNXJlbTtcXG5cXG4gICAgcGFkZGluZzogMXJlbTtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi50b2RvQnV0dG9uOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLDAuMDQwKTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xcbiAgICB0cmFuc2l0aW9uOiBlYXNlIDAuMXM7XFxufVxcblxcbi5kb25lIC50b2RvVGl0bGUsXFxuLmRvbmUgLnRvZG9EZXNjIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2hcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBkaWFsb2d7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2l0aW9uOiAuMjVzIGVhc2U7XG5cdHRyYW5zZm9ybTogc2NhbGUoMCk7XG4gICAgdG9wOiAyMCU7XG4gICAganVzdGlmeS1zZWxmOiBjZW50ZXI7XG4gICAgei1pbmRleDogMTA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBnYXA6IDFyZW07XG4gICAgcGFkZGluZzogMS41cmVtOyBcbn1cblxuXG5kaWFsb2dbb3Blbl0ge1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjZyZW07XG4gICAgYm94LXNoYWRvdzogMCAwIDJyZW0gM3B4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgICBvcGFjaXR5OiAxO1xuXHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xufVxuXG5kaWFsb2dbb3Blbl06OmJhY2tkcm9wIHtcbiAgICB6LWluZGV4OiA1O1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBhcXVhO1xufVxuXG4jdG9kb0Zvcm0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB3aWR0aDogNDgwcHg7XG4gICAgZ2FwOiAwLjVyZW07XG59XG5cbiN1cHBlclBhbmVsIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG5cbiN1cHBlclBhbmVsIGlucHV0IHtcbiAgICBwYWRkaW5nOiAwLjJyZW07XG4gICAgYm9yZGVyOiBub25lXG59XG5cbiN1cHBlclBhbmVsIGlucHV0OmZvY3VzIHtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3gtc2hhZG93OiBub25lO1xufVxuXG4jZm9ybVRpdGxlIHtcbiAgICBmb250LXNpemU6IDEuNXJlbTtcbiAgICBmb250LXdlaWdodDogNzAwO1xufVxuXG4jZm9ybURlc2Mge1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIHJlc2l6ZTogdmVydGljYWw7XG59XG5cbiNmb3JtRGVzYzphY3RpdmUsXG4jZm9ybURlc2M6Zm9jdXMge1xuICBvdmVyZmxvdy15OiB2aXNpYmxlOyBcbn1cblxuI2Zvcm1PcHRpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1pdGVtczogZmxleC1zdGFydDtcbiAgICBnYXA6IDAuNXJlbTtcbn1cblxuI2Zvcm1PcHRpb25zIGlucHV0LCBzZWxlY3R7XG4gICAgYm9yZGVyLXJhZGl1czogMC40cmVtO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgcGFkZGluZzogMC4yNXJlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wKTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUwKTtcbn1cblxuI3RvZG9Gb3JtIGhyIHtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgbWFyZ2luLXRvcDogMC40cmVtO1xuICAgIG1hcmdpbi1ib3R0b206IDAuNHJlbTtcbiAgICBib3JkZXItYm90dG9tOiAwLjVweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xufVxuXG4jbG93ZXJQYW5lbCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGdhcDogMC41cmVtO1xufVxuXG4jbG93ZXJQYW5lbCBidXR0b24ge1xuICAgIHBhZGRpbmc6IDAuMjVyZW0gMC42cmVtO1xuICAgIGJvcmRlci1yYWRpdXM6IDAuNHJlbTtcbiAgICBib3JkZXI6IG5vbmU7XG59XG5cbiNzYXZlVG9kbyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCA0OSwgODMsIDAuNzApO1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODUpO1xufVxuXG4jc2F2ZVRvZG86ZGlzYWJsZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgNDksIDgzLCAwLjI1KTtcbn1cblxuI3NhdmVUb2RvOmRpc2FibGVkOmhvdmVyIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xufVxuXG4jY2xvc2VGb3JtIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NSwgNDAsIDEzLCAwLjc0NSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG59XG5cbiNzYXZlVG9kbzpub3QoW2Rpc2FibGVkXSk6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43NSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG59XG5cbiNjbG9zZUZvcm06aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NSwgNDAsIDEzLCAwLjk1KTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcbn1cblxuXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS90b2RvZm9ybS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxVQUFVO0lBQ1YscUJBQXFCO0NBQ3hCLG1CQUFtQjtJQUNoQixRQUFRO0lBQ1Isb0JBQW9CO0lBQ3BCLFdBQVc7SUFDWCxhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCLHFCQUFxQjtJQUNyQix1QkFBdUI7SUFDdkIsU0FBUztJQUNULGVBQWU7QUFDbkI7OztBQUdBO0lBQ0ksWUFBWTtJQUNaLHFCQUFxQjtJQUNyQiw0Q0FBNEM7O0lBRTVDLG1CQUFtQjtJQUNuQixVQUFVO0NBQ2IsbUJBQW1CO0FBQ3BCOztBQUVBO0lBQ0ksVUFBVTtJQUNWLDJCQUEyQjtJQUMzQixzQkFBc0I7QUFDMUI7O0FBRUE7SUFDSSxhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCLFlBQVk7SUFDWixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxhQUFhO0lBQ2Isc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksZUFBZTtJQUNmO0FBQ0o7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsWUFBWTtJQUNaLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGlCQUFpQjtJQUNqQixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsZ0JBQWdCO0lBQ2hCLGdCQUFnQjtBQUNwQjs7QUFFQTs7RUFFRSxtQkFBbUI7QUFDckI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHlCQUF5QjtJQUN6QixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxxQkFBcUI7SUFDckIscUNBQXFDO0lBQ3JDLGdCQUFnQjtJQUNoQixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG9DQUFvQztJQUNwQywwQkFBMEI7QUFDOUI7O0FBRUE7SUFDSSxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLHFCQUFxQjtJQUNyQiw4Q0FBOEM7QUFDbEQ7O0FBRUE7SUFDSSxhQUFhO0lBQ2IseUJBQXlCO0lBQ3pCLFdBQVc7QUFDZjs7QUFFQTtJQUNJLHVCQUF1QjtJQUN2QixxQkFBcUI7SUFDckIsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLHVDQUF1QztJQUN2QyxnQ0FBZ0M7QUFDcEM7O0FBRUE7SUFDSSx1Q0FBdUM7QUFDM0M7O0FBRUE7SUFDSSxtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSwwQ0FBMEM7SUFDMUMsZ0NBQWdDO0FBQ3BDOztBQUVBO0lBQ0ksZUFBZTtJQUNmLHVDQUF1QztJQUN2QyxnQ0FBZ0M7QUFDcEM7O0FBRUE7SUFDSSxlQUFlO0lBQ2YseUNBQXlDO0lBQ3pDLGdDQUFnQztBQUNwQ1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJkaWFsb2d7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zaXRpb246IC4yNXMgZWFzZTtcXG5cXHR0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICB0b3A6IDIwJTtcXG4gICAganVzdGlmeS1zZWxmOiBjZW50ZXI7XFxuICAgIHotaW5kZXg6IDEwO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBnYXA6IDFyZW07XFxuICAgIHBhZGRpbmc6IDEuNXJlbTsgXFxufVxcblxcblxcbmRpYWxvZ1tvcGVuXSB7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC42cmVtO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMnJlbSAzcHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgIG9wYWNpdHk6IDE7XFxuXFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcXG59XFxuXFxuZGlhbG9nW29wZW5dOjpiYWNrZHJvcCB7XFxuICAgIHotaW5kZXg6IDU7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogYXF1YTtcXG59XFxuXFxuI3RvZG9Gb3JtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDQ4MHB4O1xcbiAgICBnYXA6IDAuNXJlbTtcXG59XFxuXFxuI3VwcGVyUGFuZWwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4jdXBwZXJQYW5lbCBpbnB1dCB7XFxuICAgIHBhZGRpbmc6IDAuMnJlbTtcXG4gICAgYm9yZGVyOiBub25lXFxufVxcblxcbiN1cHBlclBhbmVsIGlucHV0OmZvY3VzIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbn1cXG5cXG4jZm9ybVRpdGxlIHtcXG4gICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbiNmb3JtRGVzYyB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG59XFxuXFxuI2Zvcm1EZXNjOmFjdGl2ZSxcXG4jZm9ybURlc2M6Zm9jdXMge1xcbiAgb3ZlcmZsb3cteTogdmlzaWJsZTsgXFxufVxcblxcbiNmb3JtT3B0aW9ucyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktaXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIGdhcDogMC41cmVtO1xcbn1cXG5cXG4jZm9ybU9wdGlvbnMgaW5wdXQsIHNlbGVjdHtcXG4gICAgYm9yZGVyLXJhZGl1czogMC40cmVtO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBwYWRkaW5nOiAwLjI1cmVtO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjApO1xcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUwKTtcXG59XFxuXFxuI3RvZG9Gb3JtIGhyIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBtYXJnaW4tdG9wOiAwLjRyZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNHJlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC41cHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG59XFxuXFxuI2xvd2VyUGFuZWwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgICBnYXA6IDAuNXJlbTtcXG59XFxuXFxuI2xvd2VyUGFuZWwgYnV0dG9uIHtcXG4gICAgcGFkZGluZzogMC4yNXJlbSAwLjZyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuNHJlbTtcXG4gICAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4jc2F2ZVRvZG8ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43MCk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODUpO1xcbn1cXG5cXG4jc2F2ZVRvZG86ZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC4yNSk7XFxufVxcblxcbiNzYXZlVG9kbzpkaXNhYmxlZDpob3ZlciB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcblxcbiNjbG9zZUZvcm0ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NSwgNDAsIDEzLCAwLjc0NSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODUpO1xcbn1cXG5cXG4jc2F2ZVRvZG86bm90KFtkaXNhYmxlZF0pOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDQ5LCA4MywgMC43NSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODUpO1xcbn1cXG5cXG4jY2xvc2VGb3JtOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NSwgNDAsIDEzLCAwLjk1KTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XFxufVxcblxcblxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFkZExlYWRpbmdaZXJvcyA9IGFkZExlYWRpbmdaZXJvcztcbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyhudW1iZXIsIHRhcmdldExlbmd0aCkge1xuICBjb25zdCBzaWduID0gbnVtYmVyIDwgMCA/IFwiLVwiIDogXCJcIjtcbiAgY29uc3Qgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpLnBhZFN0YXJ0KHRhcmdldExlbmd0aCwgXCIwXCIpO1xuICByZXR1cm4gc2lnbiArIG91dHB1dDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdExvY2FsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZW5VUztcbiAgfSxcbn0pO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9sb2NhbGUvZW4tVVMuanNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0RGVmYXVsdE9wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucztcbmV4cG9ydHMuc2V0RGVmYXVsdE9wdGlvbnMgPSBzZXREZWZhdWx0T3B0aW9ucztcblxubGV0IGRlZmF1bHRPcHRpb25zID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgZGVmYXVsdE9wdGlvbnMgPSBuZXdPcHRpb25zO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdHRlcnMgPSB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL2dldERheU9mWWVhci5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uL2dldElTT1dlZWsuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuLi8uLi9nZXRJU09XZWVrWWVhci5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4uLy4uL2dldFdlZWsuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuLi8uLi9nZXRXZWVrWWVhci5qc1wiKTtcblxudmFyIF9pbmRleDYgPSByZXF1aXJlKFwiLi4vYWRkTGVhZGluZ1plcm9zLmpzXCIpO1xudmFyIF9pbmRleDcgPSByZXF1aXJlKFwiLi9saWdodEZvcm1hdHRlcnMuanNcIik7XG5cbmNvbnN0IGRheVBlcmlvZEVudW0gPSB7XG4gIGFtOiBcImFtXCIsXG4gIHBtOiBcInBtXCIsXG4gIG1pZG5pZ2h0OiBcIm1pZG5pZ2h0XCIsXG4gIG5vb246IFwibm9vblwiLFxuICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgYWZ0ZXJub29uOiBcImFmdGVybm9vblwiLFxuICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgbmlnaHQ6IFwibmlnaHRcIixcbn07XG5cbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8IE1pbGxpc2Vjb25kcyBpbiBkYXkgICAgICAgICAgICB8XG4gKiB8ICBiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICB8ICBCICB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICB8XG4gKiB8ICBjICB8IFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrICB8ICBDKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBlICB8IExvY2FsIGRheSBvZiB3ZWVrICAgICAgICAgICAgICB8ICBFICB8IERheSBvZiB3ZWVrICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBmICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBGKiB8IERheSBvZiB3ZWVrIGluIG1vbnRoICAgICAgICAgICB8XG4gKiB8ICBnKiB8IE1vZGlmaWVkIEp1bGlhbiBkYXkgICAgICAgICAgICB8ICBHICB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBpISB8IElTTyBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgICB8ICBJISB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICB8XG4gKiB8ICBqKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8ICBKKiB8IExvY2FsaXplZCBob3VyIHcvbyBkYXkgcGVyaW9kICB8XG4gKiB8ICBrICB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICB8ICBLICB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBsKiB8IChkZXByZWNhdGVkKSAgICAgICAgICAgICAgICAgICB8ICBMICB8IFN0YW5kLWFsb25lIG1vbnRoICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBuICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBOICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBvISB8IE9yZGluYWwgbnVtYmVyIG1vZGlmaWVyICAgICAgICB8ICBPICB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICB8XG4gKiB8ICBwISB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICB8ICBQISB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICB8XG4gKiB8ICBxICB8IFN0YW5kLWFsb25lIHF1YXJ0ZXIgICAgICAgICAgICB8ICBRICB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICByKiB8IFJlbGF0ZWQgR3JlZ29yaWFuIHllYXIgICAgICAgICB8ICBSISB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB0ISB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICB8ICBUISB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICB8XG4gKiB8ICB1ICB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICB8ICBVKiB8IEN5Y2xpYyB5ZWFyICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICB2KiB8IFRpbWV6b25lIChnZW5lcmljIG5vbi1sb2NhdC4pICB8ICBWKiB8IFRpbWV6b25lIChsb2NhdGlvbikgICAgICAgICAgICB8XG4gKiB8ICB3ICB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICB8ICBXKiB8IFdlZWsgb2YgbW9udGggICAgICAgICAgICAgICAgICB8XG4gKiB8ICB4ICB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICB8ICBYICB8IFRpbWV6b25lIChJU08tODYwMSkgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICB8XG4gKiB8ICB6ICB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSB8ICBaKiB8IFRpbWV6b25lIChhbGlhc2VzKSAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICEgYXJlIG5vbi1zdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IGRhdGUtZm5zOlxuICogLSBgb2AgbW9kaWZpZXMgdGhlIHByZXZpb3VzIHRva2VuIHRvIHR1cm4gaXQgaW50byBhbiBvcmRpbmFsIChzZWUgYGZvcm1hdGAgZG9jcylcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcbiAqICAgaS5lLiA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSwgZXRjLlxuICogLSBgSWAgaXMgSVNPIHdlZWsgb2YgeWVhciwgYXMgb3Bwb3NlZCB0byBgd2Agd2hpY2ggaXMgbG9jYWwgd2VlayBvZiB5ZWFyLlxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXG4gKiAgIGBSYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYElgIGFuZCBgaWBcbiAqICAgZm9yIHVuaXZlcnNhbCBJU08gd2Vlay1udW1iZXJpbmcgZGF0ZSwgd2hlcmVhc1xuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXG4gKiAgIGZvciB3ZWVrLW51bWJlcmluZyBkYXRlIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUuXG4gKiAtIGBQYCBpcyBsb25nIGxvY2FsaXplZCBkYXRlIGZvcm1hdFxuICogLSBgcGAgaXMgbG9uZyBsb2NhbGl6ZWQgdGltZSBmb3JtYXRcbiAqL1xuXG5jb25zdCBmb3JtYXR0ZXJzID0gKGV4cG9ydHMuZm9ybWF0dGVycyA9IHtcbiAgLy8gRXJhXG4gIEc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBlcmEgPSBkYXRlLmdldEZ1bGxZZWFyKCkgPiAwID8gMSA6IDA7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gQUQsIEJDXG4gICAgICBjYXNlIFwiR1wiOlxuICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICBjYXNlIFwiR0dHXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7IHdpZHRoOiBcImFiYnJldmlhdGVkXCIgfSk7XG4gICAgICAvLyBBLCBCXG4gICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHsgd2lkdGg6IFwibmFycm93XCIgfSk7XG4gICAgICAvLyBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdFxuICAgICAgY2FzZSBcIkdHR0dcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7IHdpZHRoOiBcIndpZGVcIiB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gWWVhclxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgLy8gT3JkaW5hbCBudW1iZXJcbiAgICBpZiAodG9rZW4gPT09IFwieW9cIikge1xuICAgICAgY29uc3Qgc2lnbmVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG4gICAgICBjb25zdCB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih5ZWFyLCB7IHVuaXQ6IFwieWVhclwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfaW5kZXg3LmxpZ2h0Rm9ybWF0dGVycy55KGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaWduZWRXZWVrWWVhciA9ICgwLCBfaW5kZXg1LmdldFdlZWtZZWFyKShkYXRlLCBvcHRpb25zKTtcbiAgICAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuICAgIGNvbnN0IHdlZWtZZWFyID0gc2lnbmVkV2Vla1llYXIgPiAwID8gc2lnbmVkV2Vla1llYXIgOiAxIC0gc2lnbmVkV2Vla1llYXI7XG5cbiAgICAvLyBUd28gZGlnaXQgeWVhclxuICAgIGlmICh0b2tlbiA9PT0gXCJZWVwiKSB7XG4gICAgICBjb25zdCB0d29EaWdpdFllYXIgPSB3ZWVrWWVhciAlIDEwMDtcbiAgICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHR3b0RpZ2l0WWVhciwgMik7XG4gICAgfVxuXG4gICAgLy8gT3JkaW5hbCBudW1iZXJcbiAgICBpZiAodG9rZW4gPT09IFwiWW9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIod2Vla1llYXIsIHsgdW5pdDogXCJ5ZWFyXCIgfSk7XG4gICAgfVxuXG4gICAgLy8gUGFkZGluZ1xuICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IGlzb1dlZWtZZWFyID0gKDAsIF9pbmRleDMuZ2V0SVNPV2Vla1llYXIpKGRhdGUpO1xuXG4gICAgLy8gUGFkZGluZ1xuICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKGlzb1dlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIEV4dGVuZGVkIHllYXIuIFRoaXMgaXMgYSBzaW5nbGUgbnVtYmVyIGRlc2lnbmF0aW5nIHRoZSB5ZWFyIG9mIHRoaXMgY2FsZW5kYXIgc3lzdGVtLlxuICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgbG9jYWxpemVycyBhcmUgQi5DLiB5ZWFyczpcbiAgLy8gfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAgLy8gfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAgLy8gfCBBQyAxIHwgICAxIHwgICAxIHxcbiAgLy8gfCBCQyAxIHwgICAxIHwgICAwIHxcbiAgLy8gfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAgLy8gQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICAvLyB3aGlsZSBgdXVgIHBhZHMgc2luZ2xlIGRpZ2l0IHllYXJzIHRvIDIgY2hhcmFjdGVycyBhbmQgcmV0dXJucyBvdGhlciB5ZWFycyB1bmNoYW5nZWQuXG4gIHU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgcmV0dXJuICgwLCBfaW5kZXg2LmFkZExlYWRpbmdaZXJvcykoeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBRdWFydGVyXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDMpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgY2FzZSBcIlFRXCI6XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG4gICAgICBjYXNlIFwiUW9cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwgeyB1bml0OiBcInF1YXJ0ZXJcIiB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG4gICAgICBjYXNlIFwiUVFRXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuICAgICAgY2FzZSBcIlFRUVFRXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuICAgICAgY2FzZSBcIlFRUVFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXG4gIHE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDMpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHF1YXJ0ZXIsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXG4gICAgICBjYXNlIFwicW9cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwgeyB1bml0OiBcInF1YXJ0ZXJcIiB9KTtcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XG4gICAgICBjYXNlIFwicXFxXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuICAgICAgY2FzZSBcInFxcXFxXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuICAgICAgY2FzZSBcInFxcXFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBNb250aFxuICBNOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICByZXR1cm4gX2luZGV4Ny5saWdodEZvcm1hdHRlcnMuTShkYXRlLCB0b2tlbik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG4gICAgICBjYXNlIFwiTW9cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobW9udGggKyAxLCB7IHVuaXQ6IFwibW9udGhcIiB9KTtcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xuICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIEosIEYsIC4uLiwgRFxuICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7IHdpZHRoOiBcIndpZGVcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YW5kLWFsb25lIG1vbnRoXG4gIEw6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKG1vbnRoICsgMSk7XG4gICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICByZXR1cm4gKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShtb250aCArIDEsIDIpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxuICAgICAgY2FzZSBcIkxvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwgeyB1bml0OiBcIm1vbnRoXCIgfSk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcbiAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBKLCBGLCAuLi4sIERcbiAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwgeyB3aWR0aDogXCJ3aWRlXCIsIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcbiAgdzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHdlZWsgPSAoMCwgX2luZGV4NC5nZXRXZWVrKShkYXRlLCBvcHRpb25zKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJ3b1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7IHVuaXQ6IFwid2Vla1wiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHdlZWssIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gSVNPIHdlZWsgb2YgeWVhclxuICBJOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaXNvV2VlayA9ICgwLCBfaW5kZXgyLmdldElTT1dlZWspKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSBcIklvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb1dlZWssIHsgdW5pdDogXCJ3ZWVrXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaW5kZXg2LmFkZExlYWRpbmdaZXJvcykoaXNvV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwiZG9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXREYXRlKCksIHsgdW5pdDogXCJkYXRlXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pbmRleDcubGlnaHRGb3JtYXR0ZXJzLmQoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIERheSBvZiB5ZWFyXG4gIEQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZlllYXIgPSAoMCwgX2luZGV4LmdldERheU9mWWVhcikoZGF0ZSk7XG5cbiAgICBpZiAodG9rZW4gPT09IFwiRG9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF5T2ZZZWFyLCB7IHVuaXQ6IFwiZGF5T2ZZZWFyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaW5kZXg2LmFkZExlYWRpbmdaZXJvcykoZGF5T2ZZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJFRVwiOlxuICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJFRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcbiAgICAgIGNhc2UgXCJlZVwiOlxuICAgICAgICByZXR1cm4gKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShsb2NhbERheU9mV2VlaywgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcbiAgICAgIGNhc2UgXCJlb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2VlaywgeyB1bml0OiBcImRheVwiIH0pO1xuICAgICAgY2FzZSBcImVlZVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuICAgICAgY2FzZSBcImVlZWVlXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJlZWVlZWVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJlZWVlXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrXG4gIGM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChzYW1lIGFzIGluIGBlYClcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcobG9jYWxEYXlPZldlZWspO1xuICAgICAgLy8gUGFkZGVkIG51bWVyaWNhbCB2YWx1ZVxuICAgICAgY2FzZSBcImNjXCI6XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKGxvY2FsRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgN3RoXG4gICAgICBjYXNlIFwiY29cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobG9jYWxEYXlPZldlZWssIHsgdW5pdDogXCJkYXlcIiB9KTtcbiAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFRcbiAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG4gICAgICBjYXNlIFwiY2NjY2NjXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwic2hvcnRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdWVzZGF5XG4gICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBJU08gZGF5IG9mIHdlZWtcbiAgaTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgY29uc3QgaXNvRGF5T2ZXZWVrID0gZGF5T2ZXZWVrID09PSAwID8gNyA6IGRheU9mV2VlaztcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAyXG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGlzb0RheU9mV2Vlayk7XG4gICAgICAvLyAwMlxuICAgICAgY2FzZSBcImlpXCI6XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKGlzb0RheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDJuZFxuICAgICAgY2FzZSBcImlvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb0RheU9mV2VlaywgeyB1bml0OiBcImRheVwiIH0pO1xuICAgICAgLy8gVHVlXG4gICAgICBjYXNlIFwiaWlpXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiaWlpaWlcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImlpaWlpaVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGNvbnN0IGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/IFwicG1cIiA6IFwiYW1cIjtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJhYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImFhYWFhXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImFhYWFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5taWRuaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJiXCI6XG4gICAgICBjYXNlIFwiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImJiYmJiXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImJiYmJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPj0gMTcpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmFmdGVybm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubW9ybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiQlwiOlxuICAgICAgY2FzZSBcIkJCXCI6XG4gICAgICBjYXNlIFwiQkJCXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQkJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQlwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSBcImhvXCIpIHtcbiAgICAgIGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuICAgICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDEyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pbmRleDcubGlnaHRGb3JtYXR0ZXJzLmgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwiSG9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRIb3VycygpLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfaW5kZXg3LmxpZ2h0Rm9ybWF0dGVycy5IKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBIb3VyIFswLTExXVxuICBLOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCkgJSAxMjtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJLb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3VycywgeyB1bml0OiBcImhvdXJcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBIb3VyIFsxLTI0XVxuICBrOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgbGV0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGlmIChob3VycyA9PT0gMCkgaG91cnMgPSAyNDtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJrb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3VycywgeyB1bml0OiBcImhvdXJcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gXCJtb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldE1pbnV0ZXMoKSwgeyB1bml0OiBcIm1pbnV0ZVwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfaW5kZXg3LmxpZ2h0Rm9ybWF0dGVycy5tKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBTZWNvbmRcbiAgczogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gXCJzb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFNlY29uZHMoKSwgeyB1bml0OiBcInNlY29uZFwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfaW5kZXg3LmxpZ2h0Rm9ybWF0dGVycy5zKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcbiAgUzogZnVuY3Rpb24gKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIF9pbmRleDcubGlnaHRGb3JtYXR0ZXJzLlMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAodGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlpcIjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuICAgICAgY2FzZSBcIlhYWFhcIjpcbiAgICAgIGNhc2UgXCJYWFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxuICAgICAgY2FzZSBcIlhYWFhYXCI6XG4gICAgICBjYXNlIFwiWFhYXCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuICAgICAgY2FzZSBcInh4eHhcIjpcbiAgICAgIGNhc2UgXCJ4eFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxuICAgICAgY2FzZSBcInh4eHh4XCI6XG4gICAgICBjYXNlIFwieHh4XCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcIk9cIjpcbiAgICAgIGNhc2UgXCJPT1wiOlxuICAgICAgY2FzZSBcIk9PT1wiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJPT09PXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXRpb24pXG4gIHo6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcInpcIjpcbiAgICAgIGNhc2UgXCJ6elwiOlxuICAgICAgY2FzZSBcInp6elwiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJ6enp6XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHJldHVybiAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIFQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuICgwLCBfaW5kZXg2LmFkZExlYWRpbmdaZXJvcykodGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lU2hvcnQob2Zmc2V0LCBkZWxpbWl0ZXIgPSBcIlwiKSB7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQgPiAwID8gXCItXCIgOiBcIitcIjtcbiAgY29uc3QgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKTtcbiAgY29uc3QgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHNpZ24gKyBTdHJpbmcoaG91cnMpICsgZGVsaW1pdGVyICsgKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShtaW51dGVzLCAyKVxuICApO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXMob2Zmc2V0LCBkZWxpbWl0ZXIpIHtcbiAgaWYgKG9mZnNldCAlIDYwID09PSAwKSB7XG4gICAgY29uc3Qgc2lnbiA9IG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xuICAgIHJldHVybiBzaWduICsgKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShNYXRoLmFicyhvZmZzZXQpIC8gNjAsIDIpO1xuICB9XG4gIHJldHVybiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRlbGltaXRlcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lKG9mZnNldCwgZGVsaW1pdGVyID0gXCJcIikge1xuICBjb25zdCBzaWduID0gb2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gIGNvbnN0IGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gIGNvbnN0IGhvdXJzID0gKDAsIF9pbmRleDYuYWRkTGVhZGluZ1plcm9zKShNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKSwgMik7XG4gIGNvbnN0IG1pbnV0ZXMgPSAoMCwgX2luZGV4Ni5hZGRMZWFkaW5nWmVyb3MpKGFic09mZnNldCAlIDYwLCAyKTtcbiAgcmV0dXJuIHNpZ24gKyBob3VycyArIGRlbGltaXRlciArIG1pbnV0ZXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubGlnaHRGb3JtYXR0ZXJzID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9hZGRMZWFkaW5nWmVyb3MuanNcIik7XG5cbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICovXG5cbmNvbnN0IGxpZ2h0Rm9ybWF0dGVycyA9IChleHBvcnRzLmxpZ2h0Rm9ybWF0dGVycyA9IHtcbiAgLy8gWWVhclxuICB5KGRhdGUsIHRva2VuKSB7XG4gICAgLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF90b2tlbnNcbiAgICAvLyB8IFllYXIgICAgIHwgICAgIHkgfCB5eSB8ICAgeXl5IHwgIHl5eXkgfCB5eXl5eSB8XG4gICAgLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuICAgIC8vIHwgQUQgMSAgICAgfCAgICAgMSB8IDAxIHwgICAwMDEgfCAgMDAwMSB8IDAwMDAxIHxcbiAgICAvLyB8IEFEIDEyICAgIHwgICAgMTIgfCAxMiB8ICAgMDEyIHwgIDAwMTIgfCAwMDAxMiB8XG4gICAgLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxuICAgIC8vIHwgQUQgMTIzNCAgfCAgMTIzNCB8IDM0IHwgIDEyMzQgfCAgMTIzNCB8IDAxMjM0IHxcbiAgICAvLyB8IEFEIDEyMzQ1IHwgMTIzNDUgfCA0NSB8IDEyMzQ1IHwgMTIzNDUgfCAxMjM0NSB8XG5cbiAgICBjb25zdCBzaWduZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG4gICAgY29uc3QgeWVhciA9IHNpZ25lZFllYXIgPiAwID8gc2lnbmVkWWVhciA6IDEgLSBzaWduZWRZZWFyO1xuICAgIHJldHVybiAoMCwgX2luZGV4LmFkZExlYWRpbmdaZXJvcykoXG4gICAgICB0b2tlbiA9PT0gXCJ5eVwiID8geWVhciAlIDEwMCA6IHllYXIsXG4gICAgICB0b2tlbi5sZW5ndGgsXG4gICAgKTtcbiAgfSxcblxuICAvLyBNb250aFxuICBNKGRhdGUsIHRva2VuKSB7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgcmV0dXJuIHRva2VuID09PSBcIk1cIlxuICAgICAgPyBTdHJpbmcobW9udGggKyAxKVxuICAgICAgOiAoMCwgX2luZGV4LmFkZExlYWRpbmdaZXJvcykobW9udGggKyAxLCAyKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5hZGRMZWFkaW5nWmVyb3MpKGRhdGUuZ2V0RGF0ZSgpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIEFNIG9yIFBNXG4gIGEoZGF0ZSwgdG9rZW4pIHtcbiAgICBjb25zdCBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXRlLmdldEhvdXJzKCkgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcImFcIjpcbiAgICAgIGNhc2UgXCJhYVwiOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjYXNlIFwiYWFhXCI6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWU7XG4gICAgICBjYXNlIFwiYWFhYWFcIjpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZVswXTtcbiAgICAgIGNhc2UgXCJhYWFhXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlID09PSBcImFtXCIgPyBcImEubS5cIiA6IFwicC5tLlwiO1xuICAgIH1cbiAgfSxcblxuICAvLyBIb3VyIFsxLTEyXVxuICBoKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguYWRkTGVhZGluZ1plcm9zKShcbiAgICAgIGRhdGUuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLFxuICAgICAgdG9rZW4ubGVuZ3RoLFxuICAgICk7XG4gIH0sXG5cbiAgLy8gSG91ciBbMC0yM11cbiAgSChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmFkZExlYWRpbmdaZXJvcykoZGF0ZS5nZXRIb3VycygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIE1pbnV0ZVxuICBtKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguYWRkTGVhZGluZ1plcm9zKShkYXRlLmdldE1pbnV0ZXMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBTZWNvbmRcbiAgcyhkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmFkZExlYWRpbmdaZXJvcykoZGF0ZS5nZXRTZWNvbmRzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFMoZGF0ZSwgdG9rZW4pIHtcbiAgICBjb25zdCBudW1iZXJPZkRpZ2l0cyA9IHRva2VuLmxlbmd0aDtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIGNvbnN0IGZyYWN0aW9uYWxTZWNvbmRzID0gTWF0aC50cnVuYyhcbiAgICAgIG1pbGxpc2Vjb25kcyAqIE1hdGgucG93KDEwLCBudW1iZXJPZkRpZ2l0cyAtIDMpLFxuICAgICk7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguYWRkTGVhZGluZ1plcm9zKShmcmFjdGlvbmFsU2Vjb25kcywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmxvbmdGb3JtYXR0ZXJzID0gdm9pZCAwO1xuXG5jb25zdCBkYXRlTG9uZ0Zvcm1hdHRlciA9IChwYXR0ZXJuLCBmb3JtYXRMb25nKSA9PiB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgXCJQXCI6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHsgd2lkdGg6IFwic2hvcnRcIiB9KTtcbiAgICBjYXNlIFwiUFBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJtZWRpdW1cIiB9KTtcbiAgICBjYXNlIFwiUFBQXCI6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHsgd2lkdGg6IFwibG9uZ1wiIH0pO1xuICAgIGNhc2UgXCJQUFBQXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJmdWxsXCIgfSk7XG4gIH1cbn07XG5cbmNvbnN0IHRpbWVMb25nRm9ybWF0dGVyID0gKHBhdHRlcm4sIGZvcm1hdExvbmcpID0+IHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSBcInBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoeyB3aWR0aDogXCJzaG9ydFwiIH0pO1xuICAgIGNhc2UgXCJwcFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcIm1lZGl1bVwiIH0pO1xuICAgIGNhc2UgXCJwcHBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgY2FzZSBcInBwcHBcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcImZ1bGxcIiB9KTtcbiAgfVxufTtcblxuY29uc3QgZGF0ZVRpbWVMb25nRm9ybWF0dGVyID0gKHBhdHRlcm4sIGZvcm1hdExvbmcpID0+IHtcbiAgY29uc3QgbWF0Y2hSZXN1bHQgPSBwYXR0ZXJuLm1hdGNoKC8oUCspKHArKT8vKSB8fCBbXTtcbiAgY29uc3QgZGF0ZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsxXTtcbiAgY29uc3QgdGltZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsyXTtcblxuICBpZiAoIXRpbWVQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpO1xuICB9XG5cbiAgbGV0IGRhdGVUaW1lRm9ybWF0O1xuXG4gIHN3aXRjaCAoZGF0ZVBhdHRlcm4pIHtcbiAgICBjYXNlIFwiUFwiOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHsgd2lkdGg6IFwic2hvcnRcIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFwiOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHsgd2lkdGg6IFwibWVkaXVtXCIgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUFBQXCI6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUFBQUFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJmdWxsXCIgfSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBkYXRlVGltZUZvcm1hdFxuICAgIC5yZXBsYWNlKFwie3tkYXRlfX1cIiwgZGF0ZUxvbmdGb3JtYXR0ZXIoZGF0ZVBhdHRlcm4sIGZvcm1hdExvbmcpKVxuICAgIC5yZXBsYWNlKFwie3t0aW1lfX1cIiwgdGltZUxvbmdGb3JtYXR0ZXIodGltZVBhdHRlcm4sIGZvcm1hdExvbmcpKTtcbn07XG5cbmNvbnN0IGxvbmdGb3JtYXR0ZXJzID0gKGV4cG9ydHMubG9uZ0Zvcm1hdHRlcnMgPSB7XG4gIHA6IHRpbWVMb25nRm9ybWF0dGVyLFxuICBQOiBkYXRlVGltZUxvbmdGb3JtYXR0ZXIsXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXRSb3VuZGluZ01ldGhvZCA9IGdldFJvdW5kaW5nTWV0aG9kO1xuXG5mdW5jdGlvbiBnZXRSb3VuZGluZ01ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIChudW1iZXIpID0+IHtcbiAgICBjb25zdCByb3VuZCA9IG1ldGhvZCA/IE1hdGhbbWV0aG9kXSA6IE1hdGgudHJ1bmM7XG4gICAgY29uc3QgcmVzdWx0ID0gcm91bmQobnVtYmVyKTtcbiAgICAvLyBQcmV2ZW50IG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gMCA6IHJlc3VsdDtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEdvb2dsZSBDaHJvbWUgYXMgb2YgNjcuMC4zMzk2Ljg3IGludHJvZHVjZWQgdGltZXpvbmVzIHdpdGggb2Zmc2V0IHRoYXQgaW5jbHVkZXMgc2Vjb25kcy5cbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxuICogYW5kIEdNVCswMTowMDowMCBhZnRlciB0aGF0IGRhdGUpXG4gKlxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcbiAqIHdoaWNoIHdvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXG4gKi9cbmZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgdXRjRGF0ZSA9IG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgX2RhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIF9kYXRlLmdldE1vbnRoKCksXG4gICAgICBfZGF0ZS5nZXREYXRlKCksXG4gICAgICBfZGF0ZS5nZXRIb3VycygpLFxuICAgICAgX2RhdGUuZ2V0TWludXRlcygpLFxuICAgICAgX2RhdGUuZ2V0U2Vjb25kcygpLFxuICAgICAgX2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgKSxcbiAgKTtcbiAgdXRjRGF0ZS5zZXRVVENGdWxsWWVhcihfZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgcmV0dXJuICtkYXRlIC0gK3V0Y0RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbiA9IGlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW47XG5leHBvcnRzLmlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbiA9IGlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbjtcbmV4cG9ydHMud2Fybk9yVGhyb3dQcm90ZWN0ZWRFcnJvciA9IHdhcm5PclRocm93UHJvdGVjdGVkRXJyb3I7XG5jb25zdCBkYXlPZlllYXJUb2tlblJFID0gL15EKyQvO1xuY29uc3Qgd2Vla1llYXJUb2tlblJFID0gL15ZKyQvO1xuXG5jb25zdCB0aHJvd1Rva2VucyA9IFtcIkRcIiwgXCJERFwiLCBcIllZXCIsIFwiWVlZWVwiXTtcblxuZnVuY3Rpb24gaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbih0b2tlbikge1xuICByZXR1cm4gZGF5T2ZZZWFyVG9rZW5SRS50ZXN0KHRva2VuKTtcbn1cblxuZnVuY3Rpb24gaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiB3ZWVrWWVhclRva2VuUkUudGVzdCh0b2tlbik7XG59XG5cbmZ1bmN0aW9uIHdhcm5PclRocm93UHJvdGVjdGVkRXJyb3IodG9rZW4sIGZvcm1hdCwgaW5wdXQpIHtcbiAgY29uc3QgX21lc3NhZ2UgPSBtZXNzYWdlKHRva2VuLCBmb3JtYXQsIGlucHV0KTtcbiAgY29uc29sZS53YXJuKF9tZXNzYWdlKTtcbiAgaWYgKHRocm93VG9rZW5zLmluY2x1ZGVzKHRva2VuKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoX21lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBtZXNzYWdlKHRva2VuLCBmb3JtYXQsIGlucHV0KSB7XG4gIGNvbnN0IHN1YmplY3QgPSB0b2tlblswXSA9PT0gXCJZXCIgPyBcInllYXJzXCIgOiBcImRheXMgb2YgdGhlIG1vbnRoXCI7XG4gIHJldHVybiBgVXNlIFxcYCR7dG9rZW4udG9Mb3dlckNhc2UoKX1cXGAgaW5zdGVhZCBvZiBcXGAke3Rva2VufVxcYCAoaW4gXFxgJHtmb3JtYXR9XFxgKSBmb3IgZm9ybWF0dGluZyAke3N1YmplY3R9IHRvIHRoZSBpbnB1dCBcXGAke2lucHV0fVxcYDsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kYDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkRGF5cy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vYWRkTW9udGhzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgYWRkXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcyBhbmQgc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIHllYXJzLCBtb250aHMsIHdlZWtzLCBkYXlzLCBob3VycywgbWludXRlcyBhbmQgc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBvYmplY3Qgd2l0aCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgdG8gYmUgYWRkZWQuXG4gKlxuICogfCBLZXkgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCB5ZWFycyAgICAgICAgICB8IEFtb3VudCBvZiB5ZWFycyB0byBiZSBhZGRlZCAgICAgICAgfFxuICogfCBtb250aHMgICAgICAgICB8IEFtb3VudCBvZiBtb250aHMgdG8gYmUgYWRkZWQgICAgICAgfFxuICogfCB3ZWVrcyAgICAgICAgICB8IEFtb3VudCBvZiB3ZWVrcyB0byBiZSBhZGRlZCAgICAgICAgfFxuICogfCBkYXlzICAgICAgICAgICB8IEFtb3VudCBvZiBkYXlzIHRvIGJlIGFkZGVkICAgICAgICAgfFxuICogfCBob3VycyAgICAgICAgICB8IEFtb3VudCBvZiBob3VycyB0byBiZSBhZGRlZCAgICAgICAgfFxuICogfCBtaW51dGVzICAgICAgICB8IEFtb3VudCBvZiBtaW51dGVzIHRvIGJlIGFkZGVkICAgICAgfFxuICogfCBzZWNvbmRzICAgICAgICB8IEFtb3VudCBvZiBzZWNvbmRzIHRvIGJlIGFkZGVkICAgICAgfFxuICpcbiAqIEFsbCB2YWx1ZXMgZGVmYXVsdCB0byAwXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIHNlY29uZHMgYWRkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIHRoZSBmb2xsb3dpbmcgZHVyYXRpb24gdG8gMSBTZXB0ZW1iZXIgMjAxNCwgMTA6MTk6NTBcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZChuZXcgRGF0ZSgyMDE0LCA4LCAxLCAxMCwgMTksIDUwKSwge1xuICogICB5ZWFyczogMixcbiAqICAgbW9udGhzOiA5LFxuICogICB3ZWVrczogMSxcbiAqICAgZGF5czogNyxcbiAqICAgaG91cnM6IDUsXFxcXC03XG4gKiAgIG1pbnV0ZXM6IDksXG4gKiAgIHNlY29uZHM6IDMwLFxuICogfSlcbiAqIC8vPT4gVGh1IEp1biAxNSAyMDE3IDE1OjI5OjIwXG4gKi9cbmZ1bmN0aW9uIGFkZChkYXRlLCBkdXJhdGlvbikge1xuICBjb25zdCB7XG4gICAgeWVhcnMgPSAwLFxuICAgIG1vbnRocyA9IDAsXG4gICAgd2Vla3MgPSAwLFxuICAgIGRheXMgPSAwLFxuICAgIGhvdXJzID0gMCxcbiAgICBtaW51dGVzID0gMCxcbiAgICBzZWNvbmRzID0gMCxcbiAgfSA9IGR1cmF0aW9uO1xuXG4gIC8vIEFkZCB5ZWFycyBhbmQgbW9udGhzXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDQudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgZGF0ZVdpdGhNb250aHMgPVxuICAgIG1vbnRocyB8fCB5ZWFyc1xuICAgICAgPyAoMCwgX2luZGV4Mi5hZGRNb250aHMpKF9kYXRlLCBtb250aHMgKyB5ZWFycyAqIDEyKVxuICAgICAgOiBfZGF0ZTtcblxuICAvLyBBZGQgd2Vla3MgYW5kIGRheXNcbiAgY29uc3QgZGF0ZVdpdGhEYXlzID1cbiAgICBkYXlzIHx8IHdlZWtzXG4gICAgICA/ICgwLCBfaW5kZXguYWRkRGF5cykoZGF0ZVdpdGhNb250aHMsIGRheXMgKyB3ZWVrcyAqIDcpXG4gICAgICA6IGRhdGVXaXRoTW9udGhzO1xuXG4gIC8vIEFkZCBkYXlzLCBob3VycywgbWludXRlcyBhbmQgc2Vjb25kc1xuICBjb25zdCBtaW51dGVzVG9BZGQgPSBtaW51dGVzICsgaG91cnMgKiA2MDtcbiAgY29uc3Qgc2Vjb25kc1RvQWRkID0gc2Vjb25kcyArIG1pbnV0ZXNUb0FkZCAqIDYwO1xuICBjb25zdCBtc1RvQWRkID0gc2Vjb25kc1RvQWRkICogMTAwMDtcbiAgY29uc3QgZmluYWxEYXRlID0gKDAsIF9pbmRleDMuY29uc3RydWN0RnJvbSkoXG4gICAgZGF0ZSxcbiAgICBkYXRlV2l0aERheXMuZ2V0VGltZSgpICsgbXNUb0FkZCxcbiAgKTtcblxuICByZXR1cm4gZmluYWxEYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFkZEJ1c2luZXNzRGF5cyA9IGFkZEJ1c2luZXNzRGF5cztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9pc1NhdHVyZGF5LmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9pc1N1bmRheS5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vaXNXZWVrZW5kLmpzXCIpO1xudmFyIF9pbmRleDUgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgYWRkQnVzaW5lc3NEYXlzXG4gKiBAY2F0ZWdvcnkgRGF0ZSBFeHRlbnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ1c2luZXNzIGRheXMgKG1vbiAtIGZyaSkgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnVzaW5lc3MgZGF5cyAobW9uIC0gZnJpKSB0byB0aGUgZ2l2ZW4gZGF0ZSwgaWdub3Jpbmcgd2Vla2VuZHMuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBidXNpbmVzcyBkYXlzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBidXNpbmVzcyBkYXlzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAxMCBidXNpbmVzcyBkYXlzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBhZGRCdXNpbmVzc0RheXMobmV3IERhdGUoMjAxNCwgOCwgMSksIDEwKVxuICogLy89PiBNb24gU2VwIDE1IDIwMTQgMDA6MDA6MDAgKHNraXBwZWQgd2Vla2VuZCBkYXlzKVxuICovXG5mdW5jdGlvbiBhZGRCdXNpbmVzc0RheXMoZGF0ZSwgYW1vdW50KSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDUudG9EYXRlKShkYXRlKTtcbiAgY29uc3Qgc3RhcnRlZE9uV2Vla2VuZCA9ICgwLCBfaW5kZXg0LmlzV2Vla2VuZCkoX2RhdGUpO1xuXG4gIGlmIChpc05hTihhbW91bnQpKSByZXR1cm4gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCBOYU4pO1xuXG4gIGNvbnN0IGhvdXJzID0gX2RhdGUuZ2V0SG91cnMoKTtcbiAgY29uc3Qgc2lnbiA9IGFtb3VudCA8IDAgPyAtMSA6IDE7XG4gIGNvbnN0IGZ1bGxXZWVrcyA9IE1hdGgudHJ1bmMoYW1vdW50IC8gNSk7XG5cbiAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgKyBmdWxsV2Vla3MgKiA3KTtcblxuICAvLyBHZXQgcmVtYWluaW5nIGRheXMgbm90IHBhcnQgb2YgYSBmdWxsIHdlZWtcbiAgbGV0IHJlc3REYXlzID0gTWF0aC5hYnMoYW1vdW50ICUgNSk7XG5cbiAgLy8gTG9vcHMgb3ZlciByZW1haW5pbmcgZGF5c1xuICB3aGlsZSAocmVzdERheXMgPiAwKSB7XG4gICAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgKyBzaWduKTtcbiAgICBpZiAoISgwLCBfaW5kZXg0LmlzV2Vla2VuZCkoX2RhdGUpKSByZXN0RGF5cyAtPSAxO1xuICB9XG5cbiAgLy8gSWYgdGhlIGRhdGUgaXMgYSB3ZWVrZW5kIGRheSBhbmQgd2UgcmVkdWNlIGEgZGl2aWRhYmxlIG9mXG4gIC8vIDUgZnJvbSBpdCwgd2UgbGFuZCBvbiBhIHdlZWtlbmQgZGF0ZS5cbiAgLy8gVG8gY291bnRlciB0aGlzLCB3ZSBhZGQgZGF5cyBhY2NvcmRpbmdseSB0byBsYW5kIG9uIHRoZSBuZXh0IGJ1c2luZXNzIGRheVxuICBpZiAoc3RhcnRlZE9uV2Vla2VuZCAmJiAoMCwgX2luZGV4NC5pc1dlZWtlbmQpKF9kYXRlKSAmJiBhbW91bnQgIT09IDApIHtcbiAgICAvLyBJZiB3ZSdyZSByZWR1Y2luZyBkYXlzLCB3ZSB3YW50IHRvIGFkZCBkYXlzIHVudGlsIHdlIGxhbmQgb24gYSB3ZWVrZGF5XG4gICAgLy8gSWYgd2UncmUgYWRkaW5nIGRheXMgd2Ugd2FudCB0byByZWR1Y2UgZGF5cyB1bnRpbCB3ZSBsYW5kIG9uIGEgd2Vla2RheVxuICAgIGlmICgoMCwgX2luZGV4Mi5pc1NhdHVyZGF5KShfZGF0ZSkpXG4gICAgICBfZGF0ZS5zZXREYXRlKF9kYXRlLmdldERhdGUoKSArIChzaWduIDwgMCA/IDIgOiAtMSkpO1xuICAgIGlmICgoMCwgX2luZGV4My5pc1N1bmRheSkoX2RhdGUpKVxuICAgICAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgKyAoc2lnbiA8IDAgPyAxIDogLTIpKTtcbiAgfVxuXG4gIC8vIFJlc3RvcmUgaG91cnMgdG8gYXZvaWQgRFNUIGxhZ1xuICBfZGF0ZS5zZXRIb3Vycyhob3Vycyk7XG5cbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFkZERheXMgPSBhZGREYXlzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBhZGREYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBkYXlzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBkYXlzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAxMCBkYXlzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBhZGREYXlzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCAxMClcbiAqIC8vPT4gVGh1IFNlcCAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgYW1vdW50KSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBpZiAoaXNOYU4oYW1vdW50KSkgcmV0dXJuICgwLCBfaW5kZXgyLmNvbnN0cnVjdEZyb20pKGRhdGUsIE5hTik7XG4gIGlmICghYW1vdW50KSB7XG4gICAgLy8gSWYgMCBkYXlzLCBuby1vcCB0byBhdm9pZCBjaGFuZ2luZyB0aW1lcyBpbiB0aGUgaG91ciBiZWZvcmUgZW5kIG9mIERTVFxuICAgIHJldHVybiBfZGF0ZTtcbiAgfVxuICBfZGF0ZS5zZXREYXRlKF9kYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGRIb3VycyA9IGFkZEhvdXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZE1pbGxpc2Vjb25kcy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZEhvdXJzXG4gKiBAY2F0ZWdvcnkgSG91ciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaG91cnMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaG91cnMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBob3VycyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgaG91cnMgYWRkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDIgaG91cnMgdG8gMTAgSnVseSAyMDE0IDIzOjAwOjAwOlxuICogY29uc3QgcmVzdWx0ID0gYWRkSG91cnMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDIzLCAwKSwgMilcbiAqIC8vPT4gRnJpIEp1bCAxMSAyMDE0IDAxOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGFkZEhvdXJzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGRNaWxsaXNlY29uZHMpKGRhdGUsIGFtb3VudCAqIF9pbmRleDIubWlsbGlzZWNvbmRzSW5Ib3VyKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGRJU09XZWVrWWVhcnMgPSBhZGRJU09XZWVrWWVhcnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2V0SVNPV2Vla1llYXIuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3NldElTT1dlZWtZZWFyLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZElTT1dlZWtZZWFyc1xuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA1IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyB0byAyIEp1bHkgMjAxMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZElTT1dlZWtZZWFycyhuZXcgRGF0ZSgyMDEwLCA2LCAyKSwgNSlcbiAqIC8vPT4gRnJpIEpuIDI2IDIwMTUgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gYWRkSVNPV2Vla1llYXJzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleDIuc2V0SVNPV2Vla1llYXIpKFxuICAgIGRhdGUsXG4gICAgKDAsIF9pbmRleC5nZXRJU09XZWVrWWVhcikoZGF0ZSkgKyBhbW91bnQsXG4gICk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuYWRkTWlsbGlzZWNvbmRzID0gYWRkTWlsbGlzZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiBjb25zdCByZXN1bHQgPSBhZGRNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcbiAqL1xuZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzKGRhdGUsIGFtb3VudCkge1xuICBjb25zdCB0aW1lc3RhbXAgPSArKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICByZXR1cm4gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgdGltZXN0YW1wICsgYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGRNaW51dGVzID0gYWRkTWludXRlcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRNaWxsaXNlY29uZHMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBhZGRNaW51dGVzXG4gKiBAY2F0ZWdvcnkgTWludXRlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbnV0ZXMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBtaW51dGVzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaW51dGVzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAzMCBtaW51dGVzIHRvIDEwIEp1bHkgMjAxNCAxMjowMDowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZE1pbnV0ZXMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCAwKSwgMzApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjozMDowMFxuICovXG5mdW5jdGlvbiBhZGRNaW51dGVzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGRNaWxsaXNlY29uZHMpKFxuICAgIGRhdGUsXG4gICAgYW1vdW50ICogX2luZGV4Mi5taWxsaXNlY29uZHNJbk1pbnV0ZSxcbiAgKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGRNb250aHMgPSBhZGRNb250aHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZE1vbnRoc1xuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbW9udGhzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgbW9udGhzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtb250aHMgYWRkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDUgbW9udGhzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBhZGRNb250aHMobmV3IERhdGUoMjAxNCwgOCwgMSksIDUpXG4gKiAvLz0+IFN1biBGZWIgMDEgMjAxNSAwMDowMDowMFxuICpcbiAqIC8vIEFkZCBvbmUgbW9udGggdG8gMzAgSmFudWFyeSAyMDIzOlxuICogY29uc3QgcmVzdWx0ID0gYWRkTW9udGhzKG5ldyBEYXRlKDIwMjMsIDAsIDMwKSwgMSlcbiAqIC8vPT4gVHVlIEZlYiAyOCAyMDIzIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGFkZE1vbnRocyhkYXRlLCBhbW91bnQpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGlmIChpc05hTihhbW91bnQpKSByZXR1cm4gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgTmFOKTtcbiAgaWYgKCFhbW91bnQpIHtcbiAgICAvLyBJZiAwIG1vbnRocywgbm8tb3AgdG8gYXZvaWQgY2hhbmdpbmcgdGltZXMgaW4gdGhlIGhvdXIgYmVmb3JlIGVuZCBvZiBEU1RcbiAgICByZXR1cm4gX2RhdGU7XG4gIH1cbiAgY29uc3QgZGF5T2ZNb250aCA9IF9kYXRlLmdldERhdGUoKTtcblxuICAvLyBUaGUgSlMgRGF0ZSBvYmplY3Qgc3VwcG9ydHMgZGF0ZSBtYXRoIGJ5IGFjY2VwdGluZyBvdXQtb2YtYm91bmRzIHZhbHVlcyBmb3JcbiAgLy8gbW9udGgsIGRheSwgZXRjLiBGb3IgZXhhbXBsZSwgbmV3IERhdGUoMjAyMCwgMCwgMCkgcmV0dXJucyAzMSBEZWMgMjAxOSBhbmRcbiAgLy8gbmV3IERhdGUoMjAyMCwgMTMsIDEpIHJldHVybnMgMSBGZWIgMjAyMS4gIFRoaXMgaXMgKmFsbW9zdCogdGhlIGJlaGF2aW9yIHdlXG4gIC8vIHdhbnQgZXhjZXB0IHRoYXQgZGF0ZXMgd2lsbCB3cmFwIGFyb3VuZCB0aGUgZW5kIG9mIGEgbW9udGgsIG1lYW5pbmcgdGhhdFxuICAvLyBuZXcgRGF0ZSgyMDIwLCAxMywgMzEpIHdpbGwgcmV0dXJuIDMgTWFyIDIwMjEgbm90IDI4IEZlYiAyMDIxIGFzIGRlc2lyZWQuIFNvXG4gIC8vIHdlJ2xsIGRlZmF1bHQgdG8gdGhlIGVuZCBvZiB0aGUgZGVzaXJlZCBtb250aCBieSBhZGRpbmcgMSB0byB0aGUgZGVzaXJlZFxuICAvLyBtb250aCBhbmQgdXNpbmcgYSBkYXRlIG9mIDAgdG8gYmFjayB1cCBvbmUgZGF5IHRvIHRoZSBlbmQgb2YgdGhlIGRlc2lyZWRcbiAgLy8gbW9udGguXG4gIGNvbnN0IGVuZE9mRGVzaXJlZE1vbnRoID0gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgX2RhdGUuZ2V0VGltZSgpKTtcbiAgZW5kT2ZEZXNpcmVkTW9udGguc2V0TW9udGgoX2RhdGUuZ2V0TW9udGgoKSArIGFtb3VudCArIDEsIDApO1xuICBjb25zdCBkYXlzSW5Nb250aCA9IGVuZE9mRGVzaXJlZE1vbnRoLmdldERhdGUoKTtcbiAgaWYgKGRheU9mTW9udGggPj0gZGF5c0luTW9udGgpIHtcbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGF0IHRoZSBlbmQgb2YgdGhlIG1vbnRoLCB0aGVuIHRoaXMgaXMgdGhlIGNvcnJlY3QgZGF0ZVxuICAgIC8vIGFuZCB3ZSdyZSBkb25lLlxuICAgIHJldHVybiBlbmRPZkRlc2lyZWRNb250aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHdlIG5vdyBrbm93IHRoYXQgc2V0dGluZyB0aGUgb3JpZ2luYWwgZGF5LW9mLW1vbnRoIHZhbHVlIHdvbid0XG4gICAgLy8gY2F1c2UgYW4gb3ZlcmZsb3csIHNvIHNldCB0aGUgZGVzaXJlZCBkYXktb2YtbW9udGguIE5vdGUgdGhhdCB3ZSBjYW4ndFxuICAgIC8vIGp1c3Qgc2V0IHRoZSBkYXRlIG9mIGBlbmRPZkRlc2lyZWRNb250aGAgYmVjYXVzZSB0aGF0IG9iamVjdCBtYXkgaGF2ZSBoYWRcbiAgICAvLyBpdHMgdGltZSBjaGFuZ2VkIGluIHRoZSB1bnVzdWFsIGNhc2Ugd2hlcmUgd2hlcmUgYSBEU1QgdHJhbnNpdGlvbiB3YXMgb25cbiAgICAvLyB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoIGFuZCBpdHMgbG9jYWwgdGltZSB3YXMgaW4gdGhlIGhvdXIgc2tpcHBlZCBvclxuICAgIC8vIHJlcGVhdGVkIG5leHQgdG8gYSBEU1QgdHJhbnNpdGlvbi4gIFNvIHdlIHVzZSBgZGF0ZWAgaW5zdGVhZCB3aGljaCBpc1xuICAgIC8vIGd1YXJhbnRlZWQgdG8gc3RpbGwgaGF2ZSB0aGUgb3JpZ2luYWwgdGltZS5cbiAgICBfZGF0ZS5zZXRGdWxsWWVhcihcbiAgICAgIGVuZE9mRGVzaXJlZE1vbnRoLmdldEZ1bGxZZWFyKCksXG4gICAgICBlbmRPZkRlc2lyZWRNb250aC5nZXRNb250aCgpLFxuICAgICAgZGF5T2ZNb250aCxcbiAgICApO1xuICAgIHJldHVybiBfZGF0ZTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFkZFF1YXJ0ZXJzID0gYWRkUXVhcnRlcnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkTW9udGhzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZFF1YXJ0ZXJzXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhciBxdWFydGVycyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB5ZWFyIHF1YXJ0ZXJzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgcXVhcnRlcnMgdG8gYmUgYWRkZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIHF1YXJ0ZXJzIGFkZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCAxIHF1YXJ0ZXIgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZFF1YXJ0ZXJzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCAxKVxuICogLy89PiBNb24gRGVjIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gYWRkUXVhcnRlcnMoZGF0ZSwgYW1vdW50KSB7XG4gIGNvbnN0IG1vbnRocyA9IGFtb3VudCAqIDM7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZE1vbnRocykoZGF0ZSwgbW9udGhzKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5hZGRTZWNvbmRzID0gYWRkU2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRNaWxsaXNlY29uZHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgYWRkU2Vjb25kc1xuICogQGNhdGVnb3J5IFNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2Ygc2Vjb25kcyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgc2Vjb25kcyBhZGRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgMzAgc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBhZGRTZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDApLCAzMClcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwXG4gKi9cbmZ1bmN0aW9uIGFkZFNlY29uZHMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZE1pbGxpc2Vjb25kcykoZGF0ZSwgYW1vdW50ICogMTAwMCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuYWRkV2Vla3MgPSBhZGRXZWVrcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGREYXlzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZFdlZWtzXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygd2Vla3MgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygd2VlayB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHdlZWtzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSB3ZWVrcyBhZGRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNCB3ZWVrcyB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gYWRkV2Vla3MobmV3IERhdGUoMjAxNCwgOCwgMSksIDQpXG4gKiAvLz0+IE1vbiBTZXAgMjkgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgY29uc3QgZGF5cyA9IGFtb3VudCAqIDc7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZERheXMpKGRhdGUsIGRheXMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFkZFllYXJzID0gYWRkWWVhcnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkTW9udGhzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGFkZFllYXJzXG4gKiBAY2F0ZWdvcnkgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhcnMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhcnMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB5ZWFycyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgeWVhcnMgYWRkZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDUgeWVhcnMgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGFkZFllYXJzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCA1KVxuICogLy89PiBTdW4gU2VwIDAxIDIwMTkgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gYWRkWWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZE1vbnRocykoZGF0ZSwgYW1vdW50ICogMTIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmFyZUludGVydmFsc092ZXJsYXBwaW5nID0gYXJlSW50ZXJ2YWxzT3ZlcmxhcHBpbmc7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgYXJlSW50ZXJ2YWxzT3ZlcmxhcHBpbmd9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBhcmVJbnRlcnZhbHNPdmVybGFwcGluZ1xuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiB0aW1lIGludGVydmFsIG92ZXJsYXBwaW5nIHdpdGggYW5vdGhlciB0aW1lIGludGVydmFsP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIHRpbWUgaW50ZXJ2YWwgb3ZlcmxhcHBpbmcgd2l0aCBhbm90aGVyIHRpbWUgaW50ZXJ2YWw/IEFkamFjZW50IGludGVydmFscyBkbyBub3QgY291bnQgYXMgb3ZlcmxhcHBpbmcgdW5sZXNzIGBpbmNsdXNpdmVgIGlzIHNldCB0byBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIGludGVydmFsTGVmdCAtIFRoZSBmaXJzdCBpbnRlcnZhbCB0byBjb21wYXJlLlxuICogQHBhcmFtIGludGVydmFsUmlnaHQgLSBUaGUgc2Vjb25kIGludGVydmFsIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdGltZSBpbnRlcnZhbHMgYXJlIG92ZXJsYXBwaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBvdmVybGFwcGluZyB0aW1lIGludGVydmFsczpcbiAqIGFyZUludGVydmFsc092ZXJsYXBwaW5nKFxuICogICB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAxMCksIGVuZDogbmV3IERhdGUoMjAxNCwgMCwgMjApIH0sXG4gKiAgIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDE3KSwgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCAyMSkgfVxuICogKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBub24tb3ZlcmxhcHBpbmcgdGltZSBpbnRlcnZhbHM6XG4gKiBhcmVJbnRlcnZhbHNPdmVybGFwcGluZyhcbiAqICAgeyBzdGFydDogbmV3IERhdGUoMjAxNCwgMCwgMTApLCBlbmQ6IG5ldyBEYXRlKDIwMTQsIDAsIDIwKSB9LFxuICogICB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAyMSksIGVuZDogbmV3IERhdGUoMjAxNCwgMCwgMjIpIH1cbiAqIClcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGFkamFjZW50IHRpbWUgaW50ZXJ2YWxzOlxuICogYXJlSW50ZXJ2YWxzT3ZlcmxhcHBpbmcoXG4gKiAgIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDEwKSwgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCAyMCkgfSxcbiAqICAgeyBzdGFydDogbmV3IERhdGUoMjAxNCwgMCwgMjApLCBlbmQ6IG5ldyBEYXRlKDIwMTQsIDAsIDMwKSB9XG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVzaW5nIHRoZSBpbmNsdXNpdmUgb3B0aW9uOlxuICogYXJlSW50ZXJ2YWxzT3ZlcmxhcHBpbmcoXG4gKiAgIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDEwKSwgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCAyMCkgfSxcbiAqICAgeyBzdGFydDogbmV3IERhdGUoMjAxNCwgMCwgMjApLCBlbmQ6IG5ldyBEYXRlKDIwMTQsIDAsIDI0KSB9XG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIGFyZUludGVydmFsc092ZXJsYXBwaW5nKFxuICogICB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAxMCksIGVuZDogbmV3IERhdGUoMjAxNCwgMCwgMjApIH0sXG4gKiAgIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDIwKSwgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCAyNCkgfSxcbiAqICAgeyBpbmNsdXNpdmU6IHRydWUgfVxuICogKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGFyZUludGVydmFsc092ZXJsYXBwaW5nKGludGVydmFsTGVmdCwgaW50ZXJ2YWxSaWdodCwgb3B0aW9ucykge1xuICBjb25zdCBbbGVmdFN0YXJ0VGltZSwgbGVmdEVuZFRpbWVdID0gW1xuICAgICsoMCwgX2luZGV4LnRvRGF0ZSkoaW50ZXJ2YWxMZWZ0LnN0YXJ0KSxcbiAgICArKDAsIF9pbmRleC50b0RhdGUpKGludGVydmFsTGVmdC5lbmQpLFxuICBdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgY29uc3QgW3JpZ2h0U3RhcnRUaW1lLCByaWdodEVuZFRpbWVdID0gW1xuICAgICsoMCwgX2luZGV4LnRvRGF0ZSkoaW50ZXJ2YWxSaWdodC5zdGFydCksXG4gICAgKygwLCBfaW5kZXgudG9EYXRlKShpbnRlcnZhbFJpZ2h0LmVuZCksXG4gIF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIGlmIChvcHRpb25zPy5pbmNsdXNpdmUpXG4gICAgcmV0dXJuIGxlZnRTdGFydFRpbWUgPD0gcmlnaHRFbmRUaW1lICYmIHJpZ2h0U3RhcnRUaW1lIDw9IGxlZnRFbmRUaW1lO1xuXG4gIHJldHVybiBsZWZ0U3RhcnRUaW1lIDwgcmlnaHRFbmRUaW1lICYmIHJpZ2h0U3RhcnRUaW1lIDwgbGVmdEVuZFRpbWU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9tYXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL21pbi5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBjbGFtcFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiBhIGRhdGUgYm91bmRlZCBieSB0aGUgc3RhcnQgYW5kIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGludGVydmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDbGFtcHMgYSBkYXRlIHRvIHRoZSBsb3dlciBib3VuZCB3aXRoIHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWwgYW5kIHRoZSB1cHBlclxuICogYm91bmQgd2l0aCB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbC5cbiAqXG4gKiAtIFdoZW4gdGhlIGRhdGUgaXMgbGVzcyB0aGFuIHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWwsIHRoZSBzdGFydCBpcyByZXR1cm5lZC5cbiAqIC0gV2hlbiB0aGUgZGF0ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGVuZCBvZiB0aGUgaW50ZXJ2YWwsIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gKiAtIE90aGVyd2lzZSB0aGUgZGF0ZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGJvdW5kZWRcbiAqIEBwYXJhbSBpbnRlcnZhbCAtIFRoZSBpbnRlcnZhbCB0byBib3VuZCB0b1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGJvdW5kZWQgYnkgdGhlIHN0YXJ0IGFuZCB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGF0IGlzIE1hciwgMjEsIDIwMjEgYm91bmRlZCB0byBhbiBpbnRlcnZhbCBzdGFydGluZyBhdCBNYXIsIDIyLCAyMDIxIGFuZCBlbmRpbmcgYXQgQXByLCAwMSwgMjAyMVxuICogY29uc3QgcmVzdWx0ID0gY2xhbXAobmV3IERhdGUoMjAyMSwgMiwgMjEpLCB7XG4gKiAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDIxLCAyLCAyMiksXG4gKiAgIGVuZDogbmV3IERhdGUoMjAyMSwgMywgMSksXG4gKiB9KVxuICogLy89PiBNb24gTWFyIDIyIDIwMjEgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gY2xhbXAoZGF0ZSwgaW50ZXJ2YWwpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLm1pbikoW1xuICAgICgwLCBfaW5kZXgubWF4KShbZGF0ZSwgaW50ZXJ2YWwuc3RhcnRdKSxcbiAgICBpbnRlcnZhbC5lbmQsXG4gIF0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmNsb3Nlc3RJbmRleFRvID0gY2xvc2VzdEluZGV4VG87XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGNsb3Nlc3RJbmRleFRvXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiBhbiBpbmRleCBvZiB0aGUgY2xvc2VzdCBkYXRlIGZyb20gdGhlIGFycmF5IGNvbXBhcmluZyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiBhbiBpbmRleCBvZiB0aGUgY2xvc2VzdCBkYXRlIGZyb20gdGhlIGFycmF5IGNvbXBhcmluZyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSAtIFRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHBhcmFtIGRhdGVzIC0gVGhlIGFycmF5IHRvIHNlYXJjaFxuICpcbiAqIEByZXR1cm5zIEFuIGluZGV4IG9mIHRoZSBkYXRlIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGRhdGUgb3IgdW5kZWZpbmVkIGlmIG5vIHZhbGlkIHZhbHVlIGlzIGdpdmVuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRhdGUgaXMgY2xvc2VyIHRvIDYgU2VwdGVtYmVyIDIwMTU/XG4gKiBjb25zdCBkYXRlVG9Db21wYXJlID0gbmV3IERhdGUoMjAxNSwgOCwgNilcbiAqIGNvbnN0IGRhdGVzQXJyYXkgPSBbXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEpLFxuICogICBuZXcgRGF0ZSgyMDE2LCAwLCAxKSxcbiAqICAgbmV3IERhdGUoMjAxNywgMCwgMSlcbiAqIF1cbiAqIGNvbnN0IHJlc3VsdCA9IGNsb3Nlc3RJbmRleFRvKGRhdGVUb0NvbXBhcmUsIGRhdGVzQXJyYXkpXG4gKiAvLz0+IDFcbiAqL1xuZnVuY3Rpb24gY2xvc2VzdEluZGV4VG8oZGF0ZVRvQ29tcGFyZSwgZGF0ZXMpIHtcbiAgY29uc3QgZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlVG9Db21wYXJlKTtcblxuICBpZiAoaXNOYU4oTnVtYmVyKGRhdGUpKSkgcmV0dXJuIE5hTjtcblxuICBjb25zdCB0aW1lVG9Db21wYXJlID0gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgbGV0IHJlc3VsdDtcbiAgbGV0IG1pbkRpc3RhbmNlO1xuICBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJ0eURhdGUsIGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGlydHlEYXRlKTtcblxuICAgIGlmIChpc05hTihOdW1iZXIoY3VycmVudERhdGUpKSkge1xuICAgICAgcmVzdWx0ID0gTmFOO1xuICAgICAgbWluRGlzdGFuY2UgPSBOYU47XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyh0aW1lVG9Db21wYXJlIC0gY3VycmVudERhdGUuZ2V0VGltZSgpKTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5jbG9zZXN0VG8gPSBjbG9zZXN0VG87XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGNsb3Nlc3RUb1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gYSBkYXRlIGZyb20gdGhlIGFycmF5IGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gYSBkYXRlIGZyb20gdGhlIGFycmF5IGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVUb0NvbXBhcmUgLSBUaGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqIEBwYXJhbSBkYXRlcyAtIFRoZSBhcnJheSB0byBzZWFyY2hcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBmcm9tIHRoZSBhcnJheSBjbG9zZXN0IHRvIHRoZSBnaXZlbiBkYXRlIG9yIHVuZGVmaW5lZCBpZiBubyB2YWxpZCB2YWx1ZSBpcyBnaXZlblxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBkYXRlIGlzIGNsb3NlciB0byA2IFNlcHRlbWJlciAyMDE1OiAxIEphbnVhcnkgMjAwMCBvciAxIEphbnVhcnkgMjAzMD9cbiAqIGNvbnN0IGRhdGVUb0NvbXBhcmUgPSBuZXcgRGF0ZSgyMDE1LCA4LCA2KVxuICogY29uc3QgcmVzdWx0ID0gY2xvc2VzdFRvKGRhdGVUb0NvbXBhcmUsIFtcbiAqICAgbmV3IERhdGUoMjAwMCwgMCwgMSksXG4gKiAgIG5ldyBEYXRlKDIwMzAsIDAsIDEpXG4gKiBdKVxuICogLy89PiBUdWUgSmFuIDAxIDIwMzAgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gY2xvc2VzdFRvKGRhdGVUb0NvbXBhcmUsIGRhdGVzKSB7XG4gIGNvbnN0IGRhdGUgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGVUb0NvbXBhcmUpO1xuXG4gIGlmIChpc05hTihOdW1iZXIoZGF0ZSkpKSByZXR1cm4gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlVG9Db21wYXJlLCBOYU4pO1xuXG4gIGNvbnN0IHRpbWVUb0NvbXBhcmUgPSBkYXRlLmdldFRpbWUoKTtcblxuICBsZXQgcmVzdWx0O1xuICBsZXQgbWluRGlzdGFuY2U7XG4gIGRhdGVzLmZvckVhY2goKGRpcnR5RGF0ZSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gKDAsIF9pbmRleDIudG9EYXRlKShkaXJ0eURhdGUpO1xuXG4gICAgaWYgKGlzTmFOKE51bWJlcihjdXJyZW50RGF0ZSkpKSB7XG4gICAgICByZXN1bHQgPSAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGVUb0NvbXBhcmUsIE5hTik7XG4gICAgICBtaW5EaXN0YW5jZSA9IE5hTjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKHRpbWVUb0NvbXBhcmUgLSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkpO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICByZXN1bHQgPSBjdXJyZW50RGF0ZTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmNvbXBhcmVBc2MgPSBjb21wYXJlQXNjO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBjb21wYXJlQXNjXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbXBhcmUgdGhlIHR3byBkYXRlcyBhbmQgcmV0dXJuIC0xLCAwIG9yIDEuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wYXJlIHRoZSB0d28gZGF0ZXMgYW5kIHJldHVybiAxIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGFmdGVyIHRoZSBzZWNvbmQsXG4gKiAtMSBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBiZWZvcmUgdGhlIHNlY29uZCBvciAwIGlmIGRhdGVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBjb21wYXJpc29uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbXBhcmUgMTEgRmVicnVhcnkgMTk4NyBhbmQgMTAgSnVseSAxOTg5OlxuICogY29uc3QgcmVzdWx0ID0gY29tcGFyZUFzYyhuZXcgRGF0ZSgxOTg3LCAxLCAxMSksIG5ldyBEYXRlKDE5ODksIDYsIDEwKSlcbiAqIC8vPT4gLTFcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU29ydCB0aGUgYXJyYXkgb2YgZGF0ZXM6XG4gKiBjb25zdCByZXN1bHQgPSBbXG4gKiAgIG5ldyBEYXRlKDE5OTUsIDYsIDIpLFxuICogICBuZXcgRGF0ZSgxOTg3LCAxLCAxMSksXG4gKiAgIG5ldyBEYXRlKDE5ODksIDYsIDEwKVxuICogXS5zb3J0KGNvbXBhcmVBc2MpXG4gKiAvLz0+IFtcbiAqIC8vICAgV2VkIEZlYiAxMSAxOTg3IDAwOjAwOjAwLFxuICogLy8gICBNb24gSnVsIDEwIDE5ODkgMDA6MDA6MDAsXG4gKiAvLyAgIFN1biBKdWwgMDIgMTk5NSAwMDowMDowMFxuICogLy8gXVxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlUmlnaHQpO1xuXG4gIGNvbnN0IGRpZmYgPSBfZGF0ZUxlZnQuZ2V0VGltZSgpIC0gX2RhdGVSaWdodC5nZXRUaW1lKCk7XG5cbiAgaWYgKGRpZmYgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gICAgLy8gUmV0dXJuIDAgaWYgZGlmZiBpcyAwOyByZXR1cm4gTmFOIGlmIGRpZmYgaXMgTmFOXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5jb21wYXJlRGVzYyA9IGNvbXBhcmVEZXNjO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBjb21wYXJlRGVzY1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb21wYXJlIHRoZSB0d28gZGF0ZXMgcmV2ZXJzZSBjaHJvbm9sb2dpY2FsbHkgYW5kIHJldHVybiAtMSwgMCBvciAxLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29tcGFyZSB0aGUgdHdvIGRhdGVzIGFuZCByZXR1cm4gLTEgaWYgdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCxcbiAqIDEgaWYgdGhlIGZpcnN0IGRhdGUgaXMgYmVmb3JlIHRoZSBzZWNvbmQgb3IgMCBpZiBkYXRlcyBhcmUgZXF1YWwuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlXG4gKlxuICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiB0aGUgY29tcGFyaXNvblxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb21wYXJlIDExIEZlYnJ1YXJ5IDE5ODcgYW5kIDEwIEp1bHkgMTk4OSByZXZlcnNlIGNocm9ub2xvZ2ljYWxseTpcbiAqIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVEZXNjKG5ldyBEYXRlKDE5ODcsIDEsIDExKSwgbmV3IERhdGUoMTk4OSwgNiwgMTApKVxuICogLy89PiAxXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNvcnQgdGhlIGFycmF5IG9mIGRhdGVzIGluIHJldmVyc2UgY2hyb25vbG9naWNhbCBvcmRlcjpcbiAqIGNvbnN0IHJlc3VsdCA9IFtcbiAqICAgbmV3IERhdGUoMTk5NSwgNiwgMiksXG4gKiAgIG5ldyBEYXRlKDE5ODcsIDEsIDExKSxcbiAqICAgbmV3IERhdGUoMTk4OSwgNiwgMTApXG4gKiBdLnNvcnQoY29tcGFyZURlc2MpXG4gKiAvLz0+IFtcbiAqIC8vICAgU3VuIEp1bCAwMiAxOTk1IDAwOjAwOjAwLFxuICogLy8gICBNb24gSnVsIDEwIDE5ODkgMDA6MDA6MDAsXG4gKiAvLyAgIFdlZCBGZWIgMTEgMTk4NyAwMDowMDowMFxuICogLy8gXVxuICovXG5mdW5jdGlvbiBjb21wYXJlRGVzYyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGNvbnN0IF9kYXRlTGVmdCA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlTGVmdCk7XG4gIGNvbnN0IF9kYXRlUmlnaHQgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCBkaWZmID0gX2RhdGVMZWZ0LmdldFRpbWUoKSAtIF9kYXRlUmlnaHQuZ2V0VGltZSgpO1xuXG4gIGlmIChkaWZmID4gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgIHJldHVybiAxO1xuICAgIC8vIFJldHVybiAwIGlmIGRpZmYgaXMgMDsgcmV0dXJuIE5hTiBpZiBkaWZmIGlzIE5hTlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWZmO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2Vjb25kc0luWWVhciA9XG4gIGV4cG9ydHMuc2Vjb25kc0luV2VlayA9XG4gIGV4cG9ydHMuc2Vjb25kc0luUXVhcnRlciA9XG4gIGV4cG9ydHMuc2Vjb25kc0luTW9udGggPVxuICBleHBvcnRzLnNlY29uZHNJbk1pbnV0ZSA9XG4gIGV4cG9ydHMuc2Vjb25kc0luSG91ciA9XG4gIGV4cG9ydHMuc2Vjb25kc0luRGF5ID1cbiAgZXhwb3J0cy5xdWFydGVyc0luWWVhciA9XG4gIGV4cG9ydHMubW9udGhzSW5ZZWFyID1cbiAgZXhwb3J0cy5tb250aHNJblF1YXJ0ZXIgPVxuICBleHBvcnRzLm1pbnV0ZXNJblllYXIgPVxuICBleHBvcnRzLm1pbnV0ZXNJbk1vbnRoID1cbiAgZXhwb3J0cy5taW51dGVzSW5Ib3VyID1cbiAgZXhwb3J0cy5taW51dGVzSW5EYXkgPVxuICBleHBvcnRzLm1pblRpbWUgPVxuICBleHBvcnRzLm1pbGxpc2Vjb25kc0luV2VlayA9XG4gIGV4cG9ydHMubWlsbGlzZWNvbmRzSW5TZWNvbmQgPVxuICBleHBvcnRzLm1pbGxpc2Vjb25kc0luTWludXRlID1cbiAgZXhwb3J0cy5taWxsaXNlY29uZHNJbkhvdXIgPVxuICBleHBvcnRzLm1pbGxpc2Vjb25kc0luRGF5ID1cbiAgZXhwb3J0cy5tYXhUaW1lID1cbiAgZXhwb3J0cy5kYXlzSW5ZZWFyID1cbiAgZXhwb3J0cy5kYXlzSW5XZWVrID1cbiAgICB2b2lkIDA7IC8qKlxuICogQG1vZHVsZSBjb25zdGFudHNcbiAqIEBzdW1tYXJ5IFVzZWZ1bCBjb25zdGFudHNcbiAqIEBkZXNjcmlwdGlvblxuICogQ29sbGVjdGlvbiBvZiB1c2VmdWwgZGF0ZSBjb25zdGFudHMuXG4gKlxuICogVGhlIGNvbnN0YW50cyBjb3VsZCBiZSBpbXBvcnRlZCBmcm9tIGBkYXRlLWZucy9jb25zdGFudHNgOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBtYXhUaW1lLCBtaW5UaW1lIH0gZnJvbSBcImRhdGUtZm5zL2NvbnN0YW50c1wiO1xuICpcbiAqIGZ1bmN0aW9uIGlzQWxsb3dlZFRpbWUodGltZSkge1xuICogICByZXR1cm4gdGltZSA8PSBtYXhUaW1lICYmIHRpbWUgPj0gbWluVGltZTtcbiAqIH1cbiAqIGBgYFxuICovXG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBkYXlzSW5XZWVrXG4gKiBAc3VtbWFyeSBEYXlzIGluIDEgd2Vlay5cbiAqL1xuY29uc3QgZGF5c0luV2VlayA9IChleHBvcnRzLmRheXNJbldlZWsgPSA3KTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIGRheXNJblllYXJcbiAqIEBzdW1tYXJ5IERheXMgaW4gMSB5ZWFyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSG93IG1hbnkgZGF5cyBpbiBhIHllYXIuXG4gKlxuICogT25lIHllYXJzIGVxdWFscyAzNjUuMjQyNSBkYXlzIGFjY29yZGluZyB0byB0aGUgZm9ybXVsYTpcbiAqXG4gKiA+IExlYXAgeWVhciBvY2N1cmVzIGV2ZXJ5IDQgeWVhcnMsIGV4Y2VwdCBmb3IgeWVhcnMgdGhhdCBhcmUgZGl2aXNhYmxlIGJ5IDEwMCBhbmQgbm90IGRpdmlzYWJsZSBieSA0MDAuXG4gKiA+IDEgbWVhbiB5ZWFyID0gKDM2NSsxLzQtMS8xMDArMS80MDApIGRheXMgPSAzNjUuMjQyNSBkYXlzXG4gKi9cbmNvbnN0IGRheXNJblllYXIgPSAoZXhwb3J0cy5kYXlzSW5ZZWFyID0gMzY1LjI0MjUpO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWF4VGltZVxuICogQHN1bW1hcnkgTWF4aW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IG1heFRpbWUgfSBmcm9tIFwiZGF0ZS1mbnMvY29uc3RhbnRzXCI7XG4gKlxuICogY29uc3QgaXNWYWxpZCA9IDg2NDAwMDAwMDAwMDAwMDEgPD0gbWF4VGltZTtcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBuZXcgRGF0ZSg4NjQwMDAwMDAwMDAwMDAxKTtcbiAqIC8vPT4gSW52YWxpZCBEYXRlXG4gKi9cbmNvbnN0IG1heFRpbWUgPSAoZXhwb3J0cy5tYXhUaW1lID0gTWF0aC5wb3coMTAsIDgpICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW5UaW1lXG4gKiBAc3VtbWFyeSBNaW5pbXVtIGFsbG93ZWQgdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbWluVGltZSB9IGZyb20gXCJkYXRlLWZucy9jb25zdGFudHNcIjtcbiAqXG4gKiBjb25zdCBpc1ZhbGlkID0gLTg2NDAwMDAwMDAwMDAwMDEgPj0gbWluVGltZTtcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBuZXcgRGF0ZSgtODY0MDAwMDAwMDAwMDAwMSlcbiAqIC8vPT4gSW52YWxpZCBEYXRlXG4gKi9cbmNvbnN0IG1pblRpbWUgPSAoZXhwb3J0cy5taW5UaW1lID0gLW1heFRpbWUpO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5XZWVrXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSB3ZWVrLlxuICovXG5jb25zdCBtaWxsaXNlY29uZHNJbldlZWsgPSAoZXhwb3J0cy5taWxsaXNlY29uZHNJbldlZWsgPSA2MDQ4MDAwMDApO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5EYXlcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIGRheS5cbiAqL1xuY29uc3QgbWlsbGlzZWNvbmRzSW5EYXkgPSAoZXhwb3J0cy5taWxsaXNlY29uZHNJbkRheSA9IDg2NDAwMDAwKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luTWludXRlXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBtaW51dGVcbiAqL1xuY29uc3QgbWlsbGlzZWNvbmRzSW5NaW51dGUgPSAoZXhwb3J0cy5taWxsaXNlY29uZHNJbk1pbnV0ZSA9IDYwMDAwKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luSG91clxuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgaG91clxuICovXG5jb25zdCBtaWxsaXNlY29uZHNJbkhvdXIgPSAoZXhwb3J0cy5taWxsaXNlY29uZHNJbkhvdXIgPSAzNjAwMDAwKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luU2Vjb25kXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBzZWNvbmRcbiAqL1xuY29uc3QgbWlsbGlzZWNvbmRzSW5TZWNvbmQgPSAoZXhwb3J0cy5taWxsaXNlY29uZHNJblNlY29uZCA9IDEwMDApO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luWWVhclxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIHllYXIuXG4gKi9cbmNvbnN0IG1pbnV0ZXNJblllYXIgPSAoZXhwb3J0cy5taW51dGVzSW5ZZWFyID0gNTI1NjAwKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbnV0ZXNJbk1vbnRoXG4gKiBAc3VtbWFyeSBNaW51dGVzIGluIDEgbW9udGguXG4gKi9cbmNvbnN0IG1pbnV0ZXNJbk1vbnRoID0gKGV4cG9ydHMubWludXRlc0luTW9udGggPSA0MzIwMCk7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW51dGVzSW5EYXlcbiAqIEBzdW1tYXJ5IE1pbnV0ZXMgaW4gMSBkYXkuXG4gKi9cbmNvbnN0IG1pbnV0ZXNJbkRheSA9IChleHBvcnRzLm1pbnV0ZXNJbkRheSA9IDE0NDApO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luSG91clxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIGhvdXIuXG4gKi9cbmNvbnN0IG1pbnV0ZXNJbkhvdXIgPSAoZXhwb3J0cy5taW51dGVzSW5Ib3VyID0gNjApO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbW9udGhzSW5RdWFydGVyXG4gKiBAc3VtbWFyeSBNb250aHMgaW4gMSBxdWFydGVyLlxuICovXG5jb25zdCBtb250aHNJblF1YXJ0ZXIgPSAoZXhwb3J0cy5tb250aHNJblF1YXJ0ZXIgPSAzKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1vbnRoc0luWWVhclxuICogQHN1bW1hcnkgTW9udGhzIGluIDEgeWVhci5cbiAqL1xuY29uc3QgbW9udGhzSW5ZZWFyID0gKGV4cG9ydHMubW9udGhzSW5ZZWFyID0gMTIpO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgcXVhcnRlcnNJblllYXJcbiAqIEBzdW1tYXJ5IFF1YXJ0ZXJzIGluIDEgeWVhclxuICovXG5jb25zdCBxdWFydGVyc0luWWVhciA9IChleHBvcnRzLnF1YXJ0ZXJzSW5ZZWFyID0gNCk7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5Ib3VyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgaG91ci5cbiAqL1xuY29uc3Qgc2Vjb25kc0luSG91ciA9IChleHBvcnRzLnNlY29uZHNJbkhvdXIgPSAzNjAwKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbk1pbnV0ZVxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIG1pbnV0ZS5cbiAqL1xuY29uc3Qgc2Vjb25kc0luTWludXRlID0gKGV4cG9ydHMuc2Vjb25kc0luTWludXRlID0gNjApO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luRGF5XG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgZGF5LlxuICovXG5jb25zdCBzZWNvbmRzSW5EYXkgPSAoZXhwb3J0cy5zZWNvbmRzSW5EYXkgPSBzZWNvbmRzSW5Ib3VyICogMjQpO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luV2Vla1xuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIHdlZWsuXG4gKi9cbmNvbnN0IHNlY29uZHNJbldlZWsgPSAoZXhwb3J0cy5zZWNvbmRzSW5XZWVrID0gc2Vjb25kc0luRGF5ICogNyk7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5ZZWFyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgeWVhci5cbiAqL1xuY29uc3Qgc2Vjb25kc0luWWVhciA9IChleHBvcnRzLnNlY29uZHNJblllYXIgPSBzZWNvbmRzSW5EYXkgKiBkYXlzSW5ZZWFyKTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbk1vbnRoXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgbW9udGhcbiAqL1xuY29uc3Qgc2Vjb25kc0luTW9udGggPSAoZXhwb3J0cy5zZWNvbmRzSW5Nb250aCA9IHNlY29uZHNJblllYXIgLyAxMik7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5RdWFydGVyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgcXVhcnRlci5cbiAqL1xuY29uc3Qgc2Vjb25kc0luUXVhcnRlciA9IChleHBvcnRzLnNlY29uZHNJblF1YXJ0ZXIgPSBzZWNvbmRzSW5Nb250aCAqIDMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmNvbnN0cnVjdEZyb20gPSBjb25zdHJ1Y3RGcm9tO1xuXG4vKipcbiAqIEBuYW1lIGNvbnN0cnVjdEZyb21cbiAqIEBjYXRlZ29yeSBHZW5lcmljIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnN0cnVjdHMgYSBkYXRlIHVzaW5nIHRoZSByZWZlcmVuY2UgZGF0ZSBhbmQgdGhlIHZhbHVlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZnVuY3Rpb24gY29uc3RydWN0cyBhIG5ldyBkYXRlIHVzaW5nIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSByZWZlcmVuY2VcbiAqIGRhdGUgYW5kIHRoZSBnaXZlbiB2YWx1ZS4gSXQgaGVscHMgdG8gYnVpbGQgZ2VuZXJpYyBmdW5jdGlvbnMgdGhhdCBhY2NlcHRcbiAqIGRhdGUgZXh0ZW5zaW9ucy5cbiAqXG4gKiBJdCBkZWZhdWx0cyB0byBgRGF0ZWAgaWYgdGhlIHBhc3NlZCByZWZlcmVuY2UgZGF0ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSByZWZlcmVuY2UgZGF0ZSB0byB0YWtlIGNvbnN0cnVjdG9yIGZyb21cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBEYXRlIGluaXRpYWxpemVkIHVzaW5nIHRoZSBnaXZlbiBkYXRlIGFuZCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSAnZGF0ZS1mbnMnXG4gKlxuICogLy8gQSBmdW5jdGlvbiB0aGF0IGNsb25lcyBhIGRhdGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgdHlwZVxuICogZnVuY3Rpb24gY2xvbmVEYXRlPERhdGVUeXBlIGV4dGVuZHMgRGF0ZShkYXRlOiBEYXRlVHlwZSk6IERhdGVUeXBlIHtcbiAqICAgcmV0dXJuIGNvbnN0cnVjdEZyb20oXG4gKiAgICAgZGF0ZSwgLy8gVXNlIGNvbnRydXN0b3IgZnJvbSB0aGUgZ2l2ZW4gZGF0ZVxuICogICAgIGRhdGUuZ2V0VGltZSgpIC8vIFVzZSB0aGUgZGF0ZSB2YWx1ZSB0byBjcmVhdGUgYSBuZXcgZGF0ZVxuICogICApXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdEZyb20oZGF0ZSwgdmFsdWUpIHtcbiAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBkYXRlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuY29uc3RydWN0Tm93ID0gY29uc3RydWN0Tm93O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdEZyb20uanNcIik7XG5cbi8qKlxuICogQG5hbWUgY29uc3RydWN0Tm93XG4gKiBAY2F0ZWdvcnkgR2VuZXJpYyBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb25zdHJ1Y3RzIGEgbmV3IGN1cnJlbnQgZGF0ZSB1c2luZyB0aGUgcGFzc2VkIHZhbHVlIGNvbnN0cnVjdG9yLlxuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgbmV3IGN1cnJlbnQgZGF0ZSB1c2luZyB0aGUgY29uc3RydWN0b3IgZnJvbVxuICogdGhlIHJlZmVyZW5jZSBkYXRlLiBJdCBoZWxwcyB0byBidWlsZCBnZW5lcmljIGZ1bmN0aW9ucyB0aGF0IGFjY2VwdCBkYXRlXG4gKiBleHRlbnNpb25zIGFuZCB1c2UgdGhlIGN1cnJlbnQgZGF0ZS5cbiAqXG4gKiBJdCBkZWZhdWx0cyB0byBgRGF0ZWAgaWYgdGhlIHBhc3NlZCByZWZlcmVuY2UgZGF0ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSByZWZlcmVuY2UgZGF0ZSB0byB0YWtlIGNvbnN0cnVjdG9yIGZyb21cbiAqXG4gKiBAcmV0dXJucyBDdXJyZW50IGRhdGUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGdpdmVuIGRhdGUgY29uc3RydWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uc3RydWN0Tm93LCBpc1NhbWVEYXkgfSBmcm9tICdkYXRlLWZucydcbiAqXG4gKiBmdW5jdGlvbiBpc1RvZGF5PERhdGVUeXBlIGV4dGVuZHMgRGF0ZT4oXG4gKiAgIGRhdGU6IERhdGVUeXBlIHwgbnVtYmVyIHwgc3RyaW5nLFxuICogKTogYm9vbGVhbiB7XG4gKiAgIC8vIElmIHdlIHdlcmUgdG8gdXNlIGBuZXcgRGF0ZSgpYCBkaXJlY3RseSwgdGhlIGZ1bmN0aW9uIHdvdWxkICBiZWhhdmVcbiAqICAgLy8gZGlmZmVyZW50bHkgaW4gZGlmZmVyZW50IHRpbWV6b25lcyBhbmQgcmV0dXJuIGZhbHNlIGZvciB0aGUgc2FtZSBkYXRlLlxuICogICByZXR1cm4gaXNTYW1lRGF5KGRhdGUsIGNvbnN0cnVjdE5vdyhkYXRlKSk7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdE5vdyhkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIERhdGUubm93KCkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRheXNUb1dlZWtzID0gZGF5c1RvV2Vla3M7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGRheXNUb1dlZWtzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IGRheXMgdG8gd2Vla3MuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIGRheXMgdG8gYSBmdWxsIG51bWJlciBvZiB3ZWVrcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF5cyAtIFRoZSBudW1iZXIgb2YgZGF5cyB0byBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRheXMgY29udmVydGVkIGluIHdlZWtzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMTQgZGF5cyB0byB3ZWVrczpcbiAqIGNvbnN0IHJlc3VsdCA9IGRheXNUb1dlZWtzKDE0KVxuICogLy89PiAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEl0IHVzZXMgdHJ1bmMgcm91bmRpbmc6XG4gKiBjb25zdCByZXN1bHQgPSBkYXlzVG9XZWVrcygxMylcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBkYXlzVG9XZWVrcyhkYXlzKSB7XG4gIGNvbnN0IHdlZWtzID0gZGF5cyAvIF9pbmRleC5kYXlzSW5XZWVrO1xuICBjb25zdCByZXN1bHQgPSBNYXRoLnRydW5jKHdlZWtzKTtcbiAgLy8gUHJldmVudCBuZWdhdGl2ZSB6ZXJvXG4gIHJldHVybiByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbkJ1c2luZXNzRGF5cyA9IGRpZmZlcmVuY2VJbkJ1c2luZXNzRGF5cztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGREYXlzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL2lzU2FtZURheS5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vaXNWYWxpZC5qc1wiKTtcbnZhciBfaW5kZXg1ID0gcmVxdWlyZShcIi4vaXNXZWVrZW5kLmpzXCIpO1xudmFyIF9pbmRleDYgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluQnVzaW5lc3NEYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGJ1c2luZXNzIGRheXMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBidXNpbmVzcyBkYXkgcGVyaW9kcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqIEJ1c2luZXNzIGRheXMgYmVpbmcgZGF5cyB0aGF0IGFyZW50IGluIHRoZSB3ZWVrZW5kLlxuICogTGlrZSBgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzYCwgdGhlIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIHRpbWVzIGZyb21cbiAqIHRoZSBkYXRlcyBiZWZvcmUgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2UuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBidXNpbmVzcyBkYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGJ1c2luZXNzIGRheXMgYXJlIGJldHdlZW5cbiAqIC8vIDEwIEphbnVhcnkgMjAxNCBhbmQgMjAgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQnVzaW5lc3NEYXlzKFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDAsIDEwKVxuICogKVxuICogLy89PiAxMzZcbiAqXG4gKiAvLyBIb3cgbWFueSBidXNpbmVzcyBkYXlzIGFyZSBiZXR3ZWVuXG4gKiAvLyAzMCBOb3ZlbWJlciAyMDIxIGFuZCAxIE5vdmVtYmVyIDIwMjE/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5CdXNpbmVzc0RheXMoXG4gKiAgIG5ldyBEYXRlKDIwMjEsIDEwLCAzMCksXG4gKiAgIG5ldyBEYXRlKDIwMjEsIDEwLCAxKVxuICogKVxuICogLy89PiAyMVxuICpcbiAqIC8vIEhvdyBtYW55IGJ1c2luZXNzIGRheXMgYXJlIGJldHdlZW5cbiAqIC8vIDEgTm92ZW1iZXIgMjAyMSBhbmQgMSBEZWNlbWJlciAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQnVzaW5lc3NEYXlzKFxuICogICBuZXcgRGF0ZSgyMDIxLCAxMCwgMSksXG4gKiAgIG5ldyBEYXRlKDIwMjEsIDExLCAxKVxuICogKVxuICogLy89PiAtMjJcbiAqXG4gKiAvLyBIb3cgbWFueSBidXNpbmVzcyBkYXlzIGFyZSBiZXR3ZWVuXG4gKiAvLyAxIE5vdmVtYmVyIDIwMjEgYW5kIDEgTm92ZW1iZXIgMjAyMSA/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5CdXNpbmVzc0RheXMoXG4gKiAgIG5ldyBEYXRlKDIwMjEsIDEwLCAxKSxcbiAqICAgbmV3IERhdGUoMjAyMSwgMTAsIDEpXG4gKiApXG4gKiAvLz0+IDBcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZUluQnVzaW5lc3NEYXlzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleDYudG9EYXRlKShkYXRlTGVmdCk7XG4gIGxldCBfZGF0ZVJpZ2h0ID0gKDAsIF9pbmRleDYudG9EYXRlKShkYXRlUmlnaHQpO1xuXG4gIGlmICghKDAsIF9pbmRleDQuaXNWYWxpZCkoX2RhdGVMZWZ0KSB8fCAhKDAsIF9pbmRleDQuaXNWYWxpZCkoX2RhdGVSaWdodCkpXG4gICAgcmV0dXJuIE5hTjtcblxuICBjb25zdCBjYWxlbmRhckRpZmZlcmVuY2UgPSAoMCwgX2luZGV4Mi5kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMpKFxuICAgIF9kYXRlTGVmdCxcbiAgICBfZGF0ZVJpZ2h0LFxuICApO1xuICBjb25zdCBzaWduID0gY2FsZW5kYXJEaWZmZXJlbmNlIDwgMCA/IC0xIDogMTtcblxuICBjb25zdCB3ZWVrcyA9IE1hdGgudHJ1bmMoY2FsZW5kYXJEaWZmZXJlbmNlIC8gNyk7XG5cbiAgbGV0IHJlc3VsdCA9IHdlZWtzICogNTtcbiAgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXguYWRkRGF5cykoX2RhdGVSaWdodCwgd2Vla3MgKiA3KTtcblxuICAvLyB0aGUgbG9vcCBiZWxvdyB3aWxsIHJ1biBhdCBtb3N0IDYgdGltZXMgdG8gYWNjb3VudCBmb3IgdGhlIHJlbWFpbmluZyBkYXlzIHRoYXQgZG9uJ3QgbWFrZXVwIGEgZnVsbCB3ZWVrXG4gIHdoaWxlICghKDAsIF9pbmRleDMuaXNTYW1lRGF5KShfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpKSB7XG4gICAgLy8gc2lnbiBpcyB1c2VkIHRvIGFjY291bnQgZm9yIGJvdGggbmVnYXRpdmUgYW5kIHBvc2l0aXZlIGRpZmZlcmVuY2VzXG4gICAgcmVzdWx0ICs9ICgwLCBfaW5kZXg1LmlzV2Vla2VuZCkoX2RhdGVSaWdodCkgPyAwIDogc2lnbjtcbiAgICBfZGF0ZVJpZ2h0ID0gKDAsIF9pbmRleC5hZGREYXlzKShfZGF0ZVJpZ2h0LCBzaWduKTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgbmVnYXRpdmUgemVyb1xuICByZXR1cm4gcmVzdWx0ID09PSAwID8gMCA6IHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mRGF5LmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciBkYXlzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHRpbWVzIGFyZSByZW1vdmVkXG4gKiBmcm9tIHRoZSBkYXRlcyBhbmQgdGhlbiB0aGUgZGlmZmVyZW5jZSBpbiBkYXlzIGlzIGNhbGN1bGF0ZWQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjYWxlbmRhciBkYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIGRheXMgYXJlIGJldHdlZW5cbiAqIC8vIDIgSnVseSAyMDExIDIzOjAwOjAwIGFuZCAyIEp1bHkgMjAxMiAwMDowMDowMD9cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhcbiAqICAgbmV3IERhdGUoMjAxMiwgNiwgMiwgMCwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTEsIDYsIDIsIDIzLCAwKVxuICogKVxuICogLy89PiAzNjZcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIGRheXMgYXJlIGJldHdlZW5cbiAqIC8vIDIgSnVseSAyMDExIDIzOjU5OjAwIGFuZCAzIEp1bHkgMjAxMSAwMDowMTowMD9cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMywgMCwgMSksXG4gKiAgIG5ldyBEYXRlKDIwMTEsIDYsIDIsIDIzLCA1OSlcbiAqIClcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBzdGFydE9mRGF5TGVmdCA9ICgwLCBfaW5kZXgyLnN0YXJ0T2ZEYXkpKGRhdGVMZWZ0KTtcbiAgY29uc3Qgc3RhcnRPZkRheVJpZ2h0ID0gKDAsIF9pbmRleDIuc3RhcnRPZkRheSkoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCB0aW1lc3RhbXBMZWZ0ID1cbiAgICArc3RhcnRPZkRheUxlZnQgLVxuICAgICgwLCBfaW5kZXgzLmdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMpKHN0YXJ0T2ZEYXlMZWZ0KTtcbiAgY29uc3QgdGltZXN0YW1wUmlnaHQgPVxuICAgICtzdGFydE9mRGF5UmlnaHQgLVxuICAgICgwLCBfaW5kZXgzLmdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMpKHN0YXJ0T2ZEYXlSaWdodCk7XG5cbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgYmVjYXVzZSB0aGUgbnVtYmVyIG9mXG4gIC8vIG1pbGxpc2Vjb25kcyBpbiBhIGRheSBpcyBub3QgY29uc3RhbnQgKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2ZcbiAgLy8gdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KS5cbiAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgKHRpbWVzdGFtcExlZnQgLSB0aW1lc3RhbXBSaWdodCkgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5EYXksXG4gICk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrWWVhcnMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtZZWFycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZXRJU09XZWVrWWVhci5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtZZWFyc1xuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjYWxlbmRhciBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIGFyZSAxIEphbnVhcnkgMjAxMCBhbmQgMSBKYW51YXJ5IDIwMTI/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtZZWFycyhcbiAqICAgbmV3IERhdGUoMjAxMiwgMCwgMSksXG4gKiAgIG5ldyBEYXRlKDIwMTAsIDAsIDEpXG4gKiApXG4gKiAvLz0+IDJcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrWWVhcnMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICByZXR1cm4gKFxuICAgICgwLCBfaW5kZXguZ2V0SVNPV2Vla1llYXIpKGRhdGVMZWZ0KSAtICgwLCBfaW5kZXguZ2V0SVNPV2Vla1llYXIpKGRhdGVSaWdodClcbiAgKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5kaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtzID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrc1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIElTTyB3ZWVrcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIElTTyB3ZWVrcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjYWxlbmRhciBJU08gd2Vla3NcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgSVNPIHdlZWtzIGFyZSBiZXR3ZWVuIDYgSnVseSAyMDE0IGFuZCAyMSBKdWx5IDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtzKFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyMSksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDYpXG4gKiApXG4gKiAvLz0+IDNcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrcyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGNvbnN0IHN0YXJ0T2ZJU09XZWVrTGVmdCA9ICgwLCBfaW5kZXgyLnN0YXJ0T2ZJU09XZWVrKShkYXRlTGVmdCk7XG4gIGNvbnN0IHN0YXJ0T2ZJU09XZWVrUmlnaHQgPSAoMCwgX2luZGV4Mi5zdGFydE9mSVNPV2VlaykoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCB0aW1lc3RhbXBMZWZ0ID1cbiAgICArc3RhcnRPZklTT1dlZWtMZWZ0IC1cbiAgICAoMCwgX2luZGV4My5nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKShzdGFydE9mSVNPV2Vla0xlZnQpO1xuICBjb25zdCB0aW1lc3RhbXBSaWdodCA9XG4gICAgK3N0YXJ0T2ZJU09XZWVrUmlnaHQgLVxuICAgICgwLCBfaW5kZXgzLmdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMpKHN0YXJ0T2ZJU09XZWVrUmlnaHQpO1xuXG4gIC8vIFJvdW5kIHRoZSBudW1iZXIgb2Ygd2Vla3MgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciBiZWNhdXNlIHRoZSBudW1iZXIgb2ZcbiAgLy8gbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnQgKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2ZcbiAgLy8gdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KS5cbiAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgKHRpbWVzdGFtcExlZnQgLSB0aW1lc3RhbXBSaWdodCkgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5XZWVrLFxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgbW9udGhzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgbW9udGhzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2FsZW5kYXIgbW9udGhzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIG1vbnRocyBhcmUgYmV0d2VlbiAzMSBKYW51YXJ5IDIwMTQgYW5kIDEgU2VwdGVtYmVyIDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgMSksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDAsIDMxKVxuICogKVxuICogLy89PiA4XG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlUmlnaHQpO1xuXG4gIGNvbnN0IHllYXJEaWZmID0gX2RhdGVMZWZ0LmdldEZ1bGxZZWFyKCkgLSBfZGF0ZVJpZ2h0LmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoRGlmZiA9IF9kYXRlTGVmdC5nZXRNb250aCgpIC0gX2RhdGVSaWdodC5nZXRNb250aCgpO1xuXG4gIHJldHVybiB5ZWFyRGlmZiAqIDEyICsgbW9udGhEaWZmO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dldFF1YXJ0ZXIuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciBxdWFydGVycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIHF1YXJ0ZXJzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNhbGVuZGFyIHF1YXJ0ZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIHF1YXJ0ZXJzIGFyZSBiZXR3ZWVuIDMxIERlY2VtYmVyIDIwMTMgYW5kIDIgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiksXG4gKiAgIG5ldyBEYXRlKDIwMTMsIDExLCAzMSlcbiAqIClcbiAqIC8vPT4gM1xuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleDIudG9EYXRlKShkYXRlTGVmdCk7XG4gIGNvbnN0IF9kYXRlUmlnaHQgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGVSaWdodCk7XG5cbiAgY29uc3QgeWVhckRpZmYgPSBfZGF0ZUxlZnQuZ2V0RnVsbFllYXIoKSAtIF9kYXRlUmlnaHQuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgcXVhcnRlckRpZmYgPVxuICAgICgwLCBfaW5kZXguZ2V0UXVhcnRlcikoX2RhdGVMZWZ0KSAtICgwLCBfaW5kZXguZ2V0UXVhcnRlcikoX2RhdGVSaWdodCk7XG5cbiAgcmV0dXJuIHllYXJEaWZmICogNCArIHF1YXJ0ZXJEaWZmO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3MgPSBkaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vc3RhcnRPZldlZWsuanNcIik7XG5cbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrc30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3NcbiAqIEBjYXRlZ29yeSBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIHdlZWtzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgd2Vla3MgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjYWxlbmRhciB3ZWVrc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBjYWxlbmRhciB3ZWVrcyBhcmUgYmV0d2VlbiA1IEp1bHkgMjAxNCBhbmQgMjAgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMjApLFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCA1KVxuICogKVxuICogLy89PiAzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksXG4gKiAvLyBob3cgbWFueSBjYWxlbmRhciB3ZWVrcyBhcmUgYmV0d2VlbiA1IEp1bHkgMjAxNCBhbmQgMjAgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMjApLFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCA1KSxcbiAqICAgeyB3ZWVrU3RhcnRzT246IDEgfVxuICogKVxuICogLy89PiAyXG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3MoZGF0ZUxlZnQsIGRhdGVSaWdodCwgb3B0aW9ucykge1xuICBjb25zdCBzdGFydE9mV2Vla0xlZnQgPSAoMCwgX2luZGV4Mi5zdGFydE9mV2VlaykoZGF0ZUxlZnQsIG9wdGlvbnMpO1xuICBjb25zdCBzdGFydE9mV2Vla1JpZ2h0ID0gKDAsIF9pbmRleDIuc3RhcnRPZldlZWspKGRhdGVSaWdodCwgb3B0aW9ucyk7XG5cbiAgY29uc3QgdGltZXN0YW1wTGVmdCA9XG4gICAgK3N0YXJ0T2ZXZWVrTGVmdCAtXG4gICAgKDAsIF9pbmRleDMuZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcykoc3RhcnRPZldlZWtMZWZ0KTtcbiAgY29uc3QgdGltZXN0YW1wUmlnaHQgPVxuICAgICtzdGFydE9mV2Vla1JpZ2h0IC1cbiAgICAoMCwgX2luZGV4My5nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKShzdGFydE9mV2Vla1JpZ2h0KTtcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciBiZWNhdXNlIHRoZSBudW1iZXIgb2ZcbiAgLy8gbWlsbGlzZWNvbmRzIGluIGEgZGF5cyBpcyBub3QgY29uc3RhbnQgKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2ZcbiAgLy8gdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KS5cbiAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgKHRpbWVzdGFtcExlZnQgLSB0aW1lc3RhbXBSaWdodCkgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5XZWVrLFxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzXG4gKiBAY2F0ZWdvcnkgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciB5ZWFycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIHllYXJzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNhbGVuZGFyIHllYXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIHllYXJzIGFyZSBiZXR3ZWVuIDMxIERlY2VtYmVyIDIwMTMgYW5kIDExIEZlYnJ1YXJ5IDIwMTU/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzKFxuICogICBuZXcgRGF0ZSgyMDE1LCAxLCAxMSksXG4gKiAgIG5ldyBEYXRlKDIwMTMsIDExLCAzMSlcbiAqIClcbiAqIC8vPT4gMlxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlUmlnaHQpO1xuXG4gIHJldHVybiBfZGF0ZUxlZnQuZ2V0RnVsbFllYXIoKSAtIF9kYXRlUmlnaHQuZ2V0RnVsbFllYXIoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5kaWZmZXJlbmNlSW5EYXlzID0gZGlmZmVyZW5jZUluRGF5cztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5EYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgZGF5cyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgZGF5IHBlcmlvZHMgYmV0d2VlbiB0d28gZGF0ZXMuIEZyYWN0aW9uYWwgZGF5cyBhcmVcbiAqIHRydW5jYXRlZCB0b3dhcmRzIHplcm8uXG4gKlxuICogT25lIFwiZnVsbCBkYXlcIiBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGxvY2FsIHRpbWUgaW4gb25lIGRheSB0byB0aGUgc2FtZVxuICogbG9jYWwgdGltZSBvbiB0aGUgbmV4dCBvciBwcmV2aW91cyBkYXkuIEEgZnVsbCBkYXkgY2FuIHNvbWV0aW1lcyBiZSBsZXNzIHRoYW5cbiAqIG9yIG1vcmUgdGhhbiAyNCBob3VycyBpZiBhIGRheWxpZ2h0IHNhdmluZ3MgY2hhbmdlIGhhcHBlbnMgYmV0d2VlbiB0d28gZGF0ZXMuXG4gKlxuICogVG8gaWdub3JlIERTVCBhbmQgb25seSBtZWFzdXJlIGV4YWN0IDI0LWhvdXIgcGVyaW9kcywgdXNlIHRoaXMgaW5zdGVhZDpcbiAqIGBNYXRoLnRydW5jKGRpZmZlcmVuY2VJbkhvdXJzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpLzI0KXwwYC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgbGF0ZXIgZGF0ZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBlYXJsaWVyIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGZ1bGwgZGF5cyBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsIHRpbWV6b25lXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGZ1bGwgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTEgMjM6MDA6MDAgYW5kIDIgSnVseSAyMDEyIDAwOjAwOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluRGF5cyhcbiAqICAgbmV3IERhdGUoMjAxMiwgNiwgMiwgMCwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTEsIDYsIDIsIDIzLCAwKVxuICogKVxuICogLy89PiAzNjVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgZnVsbCBkYXlzIGFyZSBiZXR3ZWVuXG4gKiAvLyAyIEp1bHkgMjAxMSAyMzo1OTowMCBhbmQgMyBKdWx5IDIwMTEgMDA6MDE6MDA/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5EYXlzKFxuICogICBuZXcgRGF0ZSgyMDExLCA2LCAzLCAwLCAxKSxcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMiwgMjMsIDU5KVxuICogKVxuICogLy89PiAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGZ1bGwgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMSBNYXJjaCAyMDIwIDA6MDAgYW5kIDEgSnVuZSAyMDIwIDA6MDAgP1xuICogLy8gTm90ZTogYmVjYXVzZSBsb2NhbCB0aW1lIGlzIHVzZWQsIHRoZVxuICogLy8gcmVzdWx0IHdpbGwgYWx3YXlzIGJlIDkyIGRheXMsIGV2ZW4gaW5cbiAqIC8vIHRpbWUgem9uZXMgd2hlcmUgRFNUIHN0YXJ0cyBhbmQgdGhlXG4gKiAvLyBwZXJpb2QgaGFzIG9ubHkgOTIqMjQtMSBob3Vycy5cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbkRheXMoXG4gKiAgIG5ldyBEYXRlKDIwMjAsIDUsIDEpLFxuICogICBuZXcgRGF0ZSgyMDIwLCAyLCAxKVxuICogKVxuICogLy89PiA5MlxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5EYXlzKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleDIudG9EYXRlKShkYXRlTGVmdCk7XG4gIGNvbnN0IF9kYXRlUmlnaHQgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGVSaWdodCk7XG5cbiAgY29uc3Qgc2lnbiA9IGNvbXBhcmVMb2NhbEFzYyhfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpO1xuICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoXG4gICAgKDAsIF9pbmRleC5kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMpKF9kYXRlTGVmdCwgX2RhdGVSaWdodCksXG4gICk7XG5cbiAgX2RhdGVMZWZ0LnNldERhdGUoX2RhdGVMZWZ0LmdldERhdGUoKSAtIHNpZ24gKiBkaWZmZXJlbmNlKTtcblxuICAvLyBNYXRoLmFicyhkaWZmIGluIGZ1bGwgZGF5cyAtIGRpZmYgaW4gY2FsZW5kYXIgZGF5cykgPT09IDEgaWYgbGFzdCBjYWxlbmRhciBkYXkgaXMgbm90IGZ1bGxcbiAgLy8gSWYgc28sIHJlc3VsdCBtdXN0IGJlIGRlY3JlYXNlZCBieSAxIGluIGFic29sdXRlIHZhbHVlXG4gIGNvbnN0IGlzTGFzdERheU5vdEZ1bGwgPSBOdW1iZXIoXG4gICAgY29tcGFyZUxvY2FsQXNjKF9kYXRlTGVmdCwgX2RhdGVSaWdodCkgPT09IC1zaWduLFxuICApO1xuICBjb25zdCByZXN1bHQgPSBzaWduICogKGRpZmZlcmVuY2UgLSBpc0xhc3REYXlOb3RGdWxsKTtcbiAgLy8gUHJldmVudCBuZWdhdGl2ZSB6ZXJvXG4gIHJldHVybiByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0O1xufVxuXG4vLyBMaWtlIGBjb21wYXJlQXNjYCBidXQgdXNlcyBsb2NhbCB0aW1lIG5vdCBVVEMsIHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFjY3VyYXRlIGVxdWFsaXR5IGNvbXBhcmlzb25zIG9mIFVUQyB0aW1lc3RhbXBzIHRoYXQgZW5kIHVwXG4vLyBoYXZpbmcgdGhlIHNhbWUgcmVwcmVzZW50YXRpb24gaW4gbG9jYWwgdGltZSwgZS5nLiBvbmUgaG91ciBiZWZvcmVcbi8vIERTVCBlbmRzIHZzLiB0aGUgaW5zdGFudCB0aGF0IERTVCBlbmRzLlxuZnVuY3Rpb24gY29tcGFyZUxvY2FsQXNjKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgZGlmZiA9XG4gICAgZGF0ZUxlZnQuZ2V0RnVsbFllYXIoKSAtIGRhdGVSaWdodC5nZXRGdWxsWWVhcigpIHx8XG4gICAgZGF0ZUxlZnQuZ2V0TW9udGgoKSAtIGRhdGVSaWdodC5nZXRNb250aCgpIHx8XG4gICAgZGF0ZUxlZnQuZ2V0RGF0ZSgpIC0gZGF0ZVJpZ2h0LmdldERhdGUoKSB8fFxuICAgIGRhdGVMZWZ0LmdldEhvdXJzKCkgLSBkYXRlUmlnaHQuZ2V0SG91cnMoKSB8fFxuICAgIGRhdGVMZWZ0LmdldE1pbnV0ZXMoKSAtIGRhdGVSaWdodC5nZXRNaW51dGVzKCkgfHxcbiAgICBkYXRlTGVmdC5nZXRTZWNvbmRzKCkgLSBkYXRlUmlnaHQuZ2V0U2Vjb25kcygpIHx8XG4gICAgZGF0ZUxlZnQuZ2V0TWlsbGlzZWNvbmRzKCkgLSBkYXRlUmlnaHQuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cbiAgaWYgKGRpZmYgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gICAgLy8gUmV0dXJuIDAgaWYgZGlmZiBpcyAwOyByZXR1cm4gTmFOIGlmIGRpZmYgaXMgTmFOXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5kaWZmZXJlbmNlSW5Ib3VycyA9IGRpZmZlcmVuY2VJbkhvdXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL19saWIvZ2V0Um91bmRpbmdNZXRob2QuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZGlmZmVyZW5jZUluSG91cnN9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5Ib3Vyc1xuICogQGNhdGVnb3J5IEhvdXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgaG91cnMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBob3VycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgbGF0ZXIgZGF0ZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBlYXJsaWVyIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGhvdXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGhvdXJzIGFyZSBiZXR3ZWVuIDIgSnVseSAyMDE0IDA2OjUwOjAwIGFuZCAyIEp1bHkgMjAxNCAxOTowMDowMD9cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbkhvdXJzKFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyLCAxOSwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDYsIDUwKVxuICogKVxuICogLy89PiAxMlxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5Ib3VycyhkYXRlTGVmdCwgZGF0ZVJpZ2h0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRpZmYgPVxuICAgICgwLCBfaW5kZXgzLmRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcykoZGF0ZUxlZnQsIGRhdGVSaWdodCkgL1xuICAgIF9pbmRleDIubWlsbGlzZWNvbmRzSW5Ib3VyO1xuICByZXR1cm4gKDAsIF9pbmRleC5nZXRSb3VuZGluZ01ldGhvZCkob3B0aW9ucz8ucm91bmRpbmdNZXRob2QpKGRpZmYpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbklTT1dlZWtZZWFycyA9IGRpZmZlcmVuY2VJbklTT1dlZWtZZWFycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb21wYXJlQXNjLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtZZWFycy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vc3ViSVNPV2Vla1llYXJzLmpzXCIpO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluSVNPV2Vla1llYXJzXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgZnVsbCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBmdWxsIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmdWxsIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBmdWxsIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgYmV0d2VlbiAxIEphbnVhcnkgMjAxMCBhbmQgMSBKYW51YXJ5IDIwMTI/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5JU09XZWVrWWVhcnMoXG4gKiAgIG5ldyBEYXRlKDIwMTIsIDAsIDEpLFxuICogICBuZXcgRGF0ZSgyMDEwLCAwLCAxKVxuICogKVxuICogLy89PiAxXG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVuY2VJbklTT1dlZWtZZWFycyhkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGxldCBfZGF0ZUxlZnQgPSAoMCwgX2luZGV4NC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXg0LnRvRGF0ZSkoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCBzaWduID0gKDAsIF9pbmRleC5jb21wYXJlQXNjKShfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpO1xuICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoXG4gICAgKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrWWVhcnMpKF9kYXRlTGVmdCwgX2RhdGVSaWdodCksXG4gICk7XG4gIF9kYXRlTGVmdCA9ICgwLCBfaW5kZXgzLnN1YklTT1dlZWtZZWFycykoX2RhdGVMZWZ0LCBzaWduICogZGlmZmVyZW5jZSk7XG5cbiAgLy8gTWF0aC5hYnMoZGlmZiBpbiBmdWxsIElTTyB5ZWFycyAtIGRpZmYgaW4gY2FsZW5kYXIgSVNPIHllYXJzKSA9PT0gMVxuICAvLyBpZiBsYXN0IGNhbGVuZGFyIElTTyB5ZWFyIGlzIG5vdCBmdWxsXG4gIC8vIElmIHNvLCByZXN1bHQgbXVzdCBiZSBkZWNyZWFzZWQgYnkgMSBpbiBhYnNvbHV0ZSB2YWx1ZVxuICBjb25zdCBpc0xhc3RJU09XZWVrWWVhck5vdEZ1bGwgPSBOdW1iZXIoXG4gICAgKDAsIF9pbmRleC5jb21wYXJlQXNjKShfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpID09PSAtc2lnbixcbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gc2lnbiAqIChkaWZmZXJlbmNlIC0gaXNMYXN0SVNPV2Vla1llYXJOb3RGdWxsKTtcbiAgLy8gUHJldmVudCBuZWdhdGl2ZSB6ZXJvXG4gIHJldHVybiByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcyA9IGRpZmZlcmVuY2VJbk1pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IG1pbGxpc2Vjb25kcyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTQgMTI6MzA6MjAuNjAwIGFuZCAyIEp1bHkgMjAxNCAxMjozMDoyMS43MDA/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgMjEsIDcwMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgMjAsIDYwMClcbiAqIClcbiAqIC8vPT4gMTEwMFxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICByZXR1cm4gKygwLCBfaW5kZXgudG9EYXRlKShkYXRlTGVmdCkgLSArKDAsIF9pbmRleC50b0RhdGUpKGRhdGVSaWdodCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluTWludXRlcyA9IGRpZmZlcmVuY2VJbk1pbnV0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9nZXRSb3VuZGluZ01ldGhvZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBkaWZmZXJlbmNlSW5NaW51dGVzfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluTWludXRlc1xuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBtaW51dGVzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBzaWduZWQgbnVtYmVyIG9mIGZ1bGwgKHJvdW5kZWQgdG93YXJkcyAwKSBtaW51dGVzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWludXRlc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBtaW51dGVzIGFyZSBiZXR3ZWVuIDIgSnVseSAyMDE0IDEyOjA3OjU5IGFuZCAyIEp1bHkgMjAxNCAxMjoyMDowMD9cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbk1pbnV0ZXMoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAyMCwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCA3LCA1OSlcbiAqIClcbiAqIC8vPT4gMTJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgbWludXRlcyBhcmUgYmV0d2VlbiAxMDowMTo1OSBhbmQgMTA6MDA6MDBcbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbk1pbnV0ZXMoXG4gKiAgIG5ldyBEYXRlKDIwMDAsIDAsIDEsIDEwLCAwLCAwKSxcbiAqICAgbmV3IERhdGUoMjAwMCwgMCwgMSwgMTAsIDEsIDU5KVxuICogKVxuICogLy89PiAtMVxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5NaW51dGVzKGRhdGVMZWZ0LCBkYXRlUmlnaHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlmZiA9XG4gICAgKDAsIF9pbmRleDMuZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSAvXG4gICAgX2luZGV4Mi5taWxsaXNlY29uZHNJbk1pbnV0ZTtcbiAgcmV0dXJuICgwLCBfaW5kZXguZ2V0Um91bmRpbmdNZXRob2QpKG9wdGlvbnM/LnJvdW5kaW5nTWV0aG9kKShkaWZmKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5kaWZmZXJlbmNlSW5Nb250aHMgPSBkaWZmZXJlbmNlSW5Nb250aHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29tcGFyZUFzYy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL2lzTGFzdERheU9mTW9udGguanNcIik7XG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5Nb250aHNcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBmdWxsIG1vbnRocyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgbW9udGhzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzIHVzaW5nIHRydW5jIGFzIGEgZGVmYXVsdCByb3VuZGluZyBtZXRob2QuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmdWxsIG1vbnRoc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBmdWxsIG1vbnRocyBhcmUgYmV0d2VlbiAzMSBKYW51YXJ5IDIwMTQgYW5kIDEgU2VwdGVtYmVyIDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5Nb250aHMobmV3IERhdGUoMjAxNCwgOCwgMSksIG5ldyBEYXRlKDIwMTQsIDAsIDMxKSlcbiAqIC8vPT4gN1xuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5Nb250aHMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBfZGF0ZUxlZnQgPSAoMCwgX2luZGV4NC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXg0LnRvRGF0ZSkoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCBzaWduID0gKDAsIF9pbmRleC5jb21wYXJlQXNjKShfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpO1xuICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoXG4gICAgKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMpKF9kYXRlTGVmdCwgX2RhdGVSaWdodCksXG4gICk7XG4gIGxldCByZXN1bHQ7XG5cbiAgLy8gQ2hlY2sgZm9yIHRoZSBkaWZmZXJlbmNlIG9mIGxlc3MgdGhhbiBtb250aFxuICBpZiAoZGlmZmVyZW5jZSA8IDEpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChfZGF0ZUxlZnQuZ2V0TW9udGgoKSA9PT0gMSAmJiBfZGF0ZUxlZnQuZ2V0RGF0ZSgpID4gMjcpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBjaGVjayBpZiB0aGUgZGF0ZSBpcyBlbmQgb2YgRmViIGFuZCBhc3NpZ24gYSBoaWdoZXIgZW5kIG9mIG1vbnRoIGRhdGVcbiAgICAgIC8vIHRvIGNvbXBhcmUgaXQgd2l0aCBKYW5cbiAgICAgIF9kYXRlTGVmdC5zZXREYXRlKDMwKTtcbiAgICB9XG5cbiAgICBfZGF0ZUxlZnQuc2V0TW9udGgoX2RhdGVMZWZ0LmdldE1vbnRoKCkgLSBzaWduICogZGlmZmVyZW5jZSk7XG5cbiAgICAvLyBNYXRoLmFicyhkaWZmIGluIGZ1bGwgbW9udGhzIC0gZGlmZiBpbiBjYWxlbmRhciBtb250aHMpID09PSAxIGlmIGxhc3QgY2FsZW5kYXIgbW9udGggaXMgbm90IGZ1bGxcbiAgICAvLyBJZiBzbywgcmVzdWx0IG11c3QgYmUgZGVjcmVhc2VkIGJ5IDEgaW4gYWJzb2x1dGUgdmFsdWVcbiAgICBsZXQgaXNMYXN0TW9udGhOb3RGdWxsID1cbiAgICAgICgwLCBfaW5kZXguY29tcGFyZUFzYykoX2RhdGVMZWZ0LCBfZGF0ZVJpZ2h0KSA9PT0gLXNpZ247XG5cbiAgICAvLyBDaGVjayBmb3IgY2FzZXMgb2Ygb25lIGZ1bGwgY2FsZW5kYXIgbW9udGhcbiAgICBpZiAoXG4gICAgICAoMCwgX2luZGV4My5pc0xhc3REYXlPZk1vbnRoKSgoMCwgX2luZGV4NC50b0RhdGUpKGRhdGVMZWZ0KSkgJiZcbiAgICAgIGRpZmZlcmVuY2UgPT09IDEgJiZcbiAgICAgICgwLCBfaW5kZXguY29tcGFyZUFzYykoZGF0ZUxlZnQsIF9kYXRlUmlnaHQpID09PSAxXG4gICAgKSB7XG4gICAgICBpc0xhc3RNb250aE5vdEZ1bGwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBzaWduICogKGRpZmZlcmVuY2UgLSBOdW1iZXIoaXNMYXN0TW9udGhOb3RGdWxsKSk7XG4gIH1cblxuICAvLyBQcmV2ZW50IG5lZ2F0aXZlIHplcm9cbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCA/IDAgOiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluUXVhcnRlcnMgPSBkaWZmZXJlbmNlSW5RdWFydGVycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9fbGliL2dldFJvdW5kaW5nTWV0aG9kLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5Nb250aHMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBkaWZmZXJlbmNlSW5RdWFydGVyc30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJblF1YXJ0ZXJzXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBxdWFydGVycyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIHF1YXJ0ZXJzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZnVsbCBxdWFydGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBmdWxsIHF1YXJ0ZXJzIGFyZSBiZXR3ZWVuIDMxIERlY2VtYmVyIDIwMTMgYW5kIDIgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluUXVhcnRlcnMobmV3IERhdGUoMjAxNCwgNiwgMiksIG5ldyBEYXRlKDIwMTMsIDExLCAzMSkpXG4gKiAvLz0+IDJcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZUluUXVhcnRlcnMoZGF0ZUxlZnQsIGRhdGVSaWdodCwgb3B0aW9ucykge1xuICBjb25zdCBkaWZmID0gKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluTW9udGhzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSAvIDM7XG4gIHJldHVybiAoMCwgX2luZGV4LmdldFJvdW5kaW5nTWV0aG9kKShvcHRpb25zPy5yb3VuZGluZ01ldGhvZCkoZGlmZik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluU2Vjb25kcyA9IGRpZmZlcmVuY2VJblNlY29uZHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9nZXRSb3VuZGluZ01ldGhvZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZGlmZmVyZW5jZUluU2Vjb25kc30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGRpZmZlcmVuY2VJblNlY29uZHNcbiAqIEBjYXRlZ29yeSBTZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGxhdGVyIGRhdGVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgZWFybGllciBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IHNlY29uZHMgYXJlIGJldHdlZW5cbiAqIC8vIDIgSnVseSAyMDE0IDEyOjMwOjA3Ljk5OSBhbmQgMiBKdWx5IDIwMTQgMTI6MzA6MjAuMDAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluU2Vjb25kcyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgMTIsIDMwLCAyMCwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDEyLCAzMCwgNywgOTk5KVxuICogKVxuICogLy89PiAxMlxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5TZWNvbmRzKGRhdGVMZWZ0LCBkYXRlUmlnaHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlmZiA9XG4gICAgKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluTWlsbGlzZWNvbmRzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSAvIDEwMDA7XG4gIHJldHVybiAoMCwgX2luZGV4LmdldFJvdW5kaW5nTWV0aG9kKShvcHRpb25zPy5yb3VuZGluZ01ldGhvZCkoZGlmZik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluV2Vla3MgPSBkaWZmZXJlbmNlSW5XZWVrcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9fbGliL2dldFJvdW5kaW5nTWV0aG9kLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5EYXlzLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZGlmZmVyZW5jZUluV2Vla3N9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5XZWVrc1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgZnVsbCB3ZWVrcyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgd2Vla3MgYmV0d2VlbiB0d28gZGF0ZXMuIEZyYWN0aW9uYWwgd2Vla3MgYXJlXG4gKiB0cnVuY2F0ZWQgdG93YXJkcyB6ZXJvIGJ5IGRlZmF1bHQuXG4gKlxuICogT25lIFwiZnVsbCB3ZWVrXCIgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBsb2NhbCB0aW1lIGluIG9uZSBkYXkgdG8gdGhlIHNhbWVcbiAqIGxvY2FsIHRpbWUgNyBkYXlzIGVhcmxpZXIgb3IgbGF0ZXIuIEEgZnVsbCB3ZWVrIGNhbiBzb21ldGltZXMgYmUgbGVzcyB0aGFuXG4gKiBvciBtb3JlIHRoYW4gNyoyNCBob3VycyBpZiBhIGRheWxpZ2h0IHNhdmluZ3MgY2hhbmdlIGhhcHBlbnMgYmV0d2VlbiB0d28gZGF0ZXMuXG4gKlxuICogVG8gaWdub3JlIERTVCBhbmQgb25seSBtZWFzdXJlIGV4YWN0IDcqMjQtaG91ciBwZXJpb2RzLCB1c2UgdGhpcyBpbnN0ZWFkOlxuICogYE1hdGgudHJ1bmMoZGlmZmVyZW5jZUluSG91cnMoZGF0ZUxlZnQsIGRhdGVSaWdodCkvKDcqMjQpKXwwYC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgbGF0ZXIgZGF0ZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBlYXJsaWVyIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZnVsbCB3ZWVrc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBmdWxsIHdlZWtzIGFyZSBiZXR3ZWVuIDUgSnVseSAyMDE0IGFuZCAyMCBKdWx5IDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5XZWVrcyhuZXcgRGF0ZSgyMDE0LCA2LCAyMCksIG5ldyBEYXRlKDIwMTQsIDYsIDUpKVxuICogLy89PiAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGZ1bGwgd2Vla3MgYXJlIGJldHdlZW5cbiAqIC8vIDEgTWFyY2ggMjAyMCAwOjAwIGFuZCA2IEp1bmUgMjAyMCAwOjAwID9cbiAqIC8vIE5vdGU6IGJlY2F1c2UgbG9jYWwgdGltZSBpcyB1c2VkLCB0aGVcbiAqIC8vIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSA4IHdlZWtzICg1NCBkYXlzKSxcbiAqIC8vIGV2ZW4gaWYgRFNUIHN0YXJ0cyBhbmQgdGhlIHBlcmlvZCBoYXNcbiAqIC8vIG9ubHkgNTQqMjQtMSBob3Vycy5cbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlcmVuY2VJbldlZWtzKFxuICogICBuZXcgRGF0ZSgyMDIwLCA1LCAxKSxcbiAqICAgbmV3IERhdGUoMjAyMCwgMiwgNilcbiAqIClcbiAqIC8vPT4gOFxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlSW5XZWVrcyhkYXRlTGVmdCwgZGF0ZVJpZ2h0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRpZmYgPSAoMCwgX2luZGV4Mi5kaWZmZXJlbmNlSW5EYXlzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSAvIDc7XG4gIHJldHVybiAoMCwgX2luZGV4LmdldFJvdW5kaW5nTWV0aG9kKShvcHRpb25zPy5yb3VuZGluZ01ldGhvZCkoZGlmZik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGlmZmVyZW5jZUluWWVhcnMgPSBkaWZmZXJlbmNlSW5ZZWFycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb21wYXJlQXNjLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZGlmZmVyZW5jZUluWWVhcnNcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGZ1bGwgeWVhcnMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBmdWxsIHllYXJzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIGVhcmxpZXIgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZnVsbCB5ZWFyc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBmdWxsIHllYXJzIGFyZSBiZXR3ZWVuIDMxIERlY2VtYmVyIDIwMTMgYW5kIDExIEZlYnJ1YXJ5IDIwMTU/XG4gKiBjb25zdCByZXN1bHQgPSBkaWZmZXJlbmNlSW5ZZWFycyhuZXcgRGF0ZSgyMDE1LCAxLCAxMSksIG5ldyBEYXRlKDIwMTMsIDExLCAzMSkpXG4gKiAvLz0+IDFcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZUluWWVhcnMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBfZGF0ZUxlZnQgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXgzLnRvRGF0ZSkoZGF0ZVJpZ2h0KTtcblxuICBjb25zdCBzaWduID0gKDAsIF9pbmRleC5jb21wYXJlQXNjKShfZGF0ZUxlZnQsIF9kYXRlUmlnaHQpO1xuICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoXG4gICAgKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycykoX2RhdGVMZWZ0LCBfZGF0ZVJpZ2h0KSxcbiAgKTtcblxuICAvLyBTZXQgYm90aCBkYXRlcyB0byBhIHZhbGlkIGxlYXAgeWVhciBmb3IgYWNjdXJhdGUgY29tcGFyaXNvbiB3aGVuIGRlYWxpbmdcbiAgLy8gd2l0aCBsZWFwIGRheXNcbiAgX2RhdGVMZWZ0LnNldEZ1bGxZZWFyKDE1ODQpO1xuICBfZGF0ZVJpZ2h0LnNldEZ1bGxZZWFyKDE1ODQpO1xuXG4gIC8vIE1hdGguYWJzKGRpZmYgaW4gZnVsbCB5ZWFycyAtIGRpZmYgaW4gY2FsZW5kYXIgeWVhcnMpID09PSAxIGlmIGxhc3QgY2FsZW5kYXIgeWVhciBpcyBub3QgZnVsbFxuICAvLyBJZiBzbywgcmVzdWx0IG11c3QgYmUgZGVjcmVhc2VkIGJ5IDEgaW4gYWJzb2x1dGUgdmFsdWVcbiAgY29uc3QgaXNMYXN0WWVhck5vdEZ1bGwgPVxuICAgICgwLCBfaW5kZXguY29tcGFyZUFzYykoX2RhdGVMZWZ0LCBfZGF0ZVJpZ2h0KSA9PT0gLXNpZ247XG4gIGNvbnN0IHJlc3VsdCA9IHNpZ24gKiAoZGlmZmVyZW5jZSAtICtpc0xhc3RZZWFyTm90RnVsbCk7XG5cbiAgLy8gUHJldmVudCBuZWdhdGl2ZSB6ZXJvXG4gIHJldHVybiByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVhY2hEYXlPZkludGVydmFsID0gZWFjaERheU9mSW50ZXJ2YWw7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZWFjaERheU9mSW50ZXJ2YWx9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBlYWNoRGF5T2ZJbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgYXJyYXkgb2YgZGF0ZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgYXJyYXkgb2YgZGF0ZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggc3RhcnRzIG9mIGRheXMgZnJvbSB0aGUgZGF5IG9mIHRoZSBpbnRlcnZhbCBzdGFydCB0byB0aGUgZGF5IG9mIHRoZSBpbnRlcnZhbCBlbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRWFjaCBkYXkgYmV0d2VlbiA2IE9jdG9iZXIgMjAxNCBhbmQgMTAgT2N0b2JlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gZWFjaERheU9mSW50ZXJ2YWwoe1xuICogICBzdGFydDogbmV3IERhdGUoMjAxNCwgOSwgNiksXG4gKiAgIGVuZDogbmV3IERhdGUoMjAxNCwgOSwgMTApXG4gKiB9KVxuICogLy89PiBbXG4gKiAvLyAgIE1vbiBPY3QgMDYgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgVHVlIE9jdCAwNyAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBXZWQgT2N0IDA4IDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFRodSBPY3QgMDkgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgRnJpIE9jdCAxMCAyMDE0IDAwOjAwOjAwXG4gKiAvLyBdXG4gKi9cbmZ1bmN0aW9uIGVhY2hEYXlPZkludGVydmFsKGludGVydmFsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShpbnRlcnZhbC5zdGFydCk7XG4gIGNvbnN0IGVuZERhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoaW50ZXJ2YWwuZW5kKTtcblxuICBsZXQgcmV2ZXJzZWQgPSArc3RhcnREYXRlID4gK2VuZERhdGU7XG4gIGNvbnN0IGVuZFRpbWUgPSByZXZlcnNlZCA/ICtzdGFydERhdGUgOiArZW5kRGF0ZTtcbiAgY29uc3QgY3VycmVudERhdGUgPSByZXZlcnNlZCA/IGVuZERhdGUgOiBzdGFydERhdGU7XG4gIGN1cnJlbnREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gIGxldCBzdGVwID0gb3B0aW9ucz8uc3RlcCA/PyAxO1xuICBpZiAoIXN0ZXApIHJldHVybiBbXTtcbiAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgc3RlcCA9IC1zdGVwO1xuICAgIHJldmVyc2VkID0gIXJldmVyc2VkO1xuICB9XG5cbiAgY29uc3QgZGF0ZXMgPSBbXTtcblxuICB3aGlsZSAoK2N1cnJlbnREYXRlIDw9IGVuZFRpbWUpIHtcbiAgICBkYXRlcy5wdXNoKCgwLCBfaW5kZXgudG9EYXRlKShjdXJyZW50RGF0ZSkpO1xuICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gICAgY3VycmVudERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH1cblxuICByZXR1cm4gcmV2ZXJzZWQgPyBkYXRlcy5yZXZlcnNlKCkgOiBkYXRlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lYWNoSG91ck9mSW50ZXJ2YWwgPSBlYWNoSG91ck9mSW50ZXJ2YWw7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkSG91cnMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGVhY2hIb3VyT2ZJbnRlcnZhbH0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGVhY2hIb3VyT2ZJbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgYXJyYXkgb2YgaG91cnMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgYXJyYXkgb2YgaG91cnMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggc3RhcnRzIG9mIGhvdXJzIGZyb20gdGhlIGhvdXIgb2YgdGhlIGludGVydmFsIHN0YXJ0IHRvIHRoZSBob3VyIG9mIHRoZSBpbnRlcnZhbCBlbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRWFjaCBob3VyIGJldHdlZW4gNiBPY3RvYmVyIDIwMTQsIDEyOjAwIGFuZCA2IE9jdG9iZXIgMjAxNCwgMTU6MDBcbiAqIGNvbnN0IHJlc3VsdCA9IGVhY2hIb3VyT2ZJbnRlcnZhbCh7XG4gKiAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCA5LCA2LCAxMiksXG4gKiAgIGVuZDogbmV3IERhdGUoMjAxNCwgOSwgNiwgMTUpXG4gKiB9KVxuICogLy89PiBbXG4gKiAvLyAgIE1vbiBPY3QgMDYgMjAxNCAxMjowMDowMCxcbiAqIC8vICAgTW9uIE9jdCAwNiAyMDE0IDEzOjAwOjAwLFxuICogLy8gICBNb24gT2N0IDA2IDIwMTQgMTQ6MDA6MDAsXG4gKiAvLyAgIE1vbiBPY3QgMDYgMjAxNCAxNTowMDowMFxuICogLy8gXVxuICovXG5mdW5jdGlvbiBlYWNoSG91ck9mSW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhcnREYXRlID0gKDAsIF9pbmRleDIudG9EYXRlKShpbnRlcnZhbC5zdGFydCk7XG4gIGNvbnN0IGVuZERhdGUgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGludGVydmFsLmVuZCk7XG5cbiAgbGV0IHJldmVyc2VkID0gK3N0YXJ0RGF0ZSA+ICtlbmREYXRlO1xuICBjb25zdCBlbmRUaW1lID0gcmV2ZXJzZWQgPyArc3RhcnREYXRlIDogK2VuZERhdGU7XG4gIGxldCBjdXJyZW50RGF0ZSA9IHJldmVyc2VkID8gZW5kRGF0ZSA6IHN0YXJ0RGF0ZTtcbiAgY3VycmVudERhdGUuc2V0TWludXRlcygwLCAwLCAwKTtcblxuICBsZXQgc3RlcCA9IG9wdGlvbnM/LnN0ZXAgPz8gMTtcbiAgaWYgKCFzdGVwKSByZXR1cm4gW107XG4gIGlmIChzdGVwIDwgMCkge1xuICAgIHN0ZXAgPSAtc3RlcDtcbiAgICByZXZlcnNlZCA9ICFyZXZlcnNlZDtcbiAgfVxuXG4gIGNvbnN0IGRhdGVzID0gW107XG5cbiAgd2hpbGUgKCtjdXJyZW50RGF0ZSA8PSBlbmRUaW1lKSB7XG4gICAgZGF0ZXMucHVzaCgoMCwgX2luZGV4Mi50b0RhdGUpKGN1cnJlbnREYXRlKSk7XG4gICAgY3VycmVudERhdGUgPSAoMCwgX2luZGV4LmFkZEhvdXJzKShjdXJyZW50RGF0ZSwgc3RlcCk7XG4gIH1cblxuICByZXR1cm4gcmV2ZXJzZWQgPyBkYXRlcy5yZXZlcnNlKCkgOiBkYXRlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lYWNoTWludXRlT2ZJbnRlcnZhbCA9IGVhY2hNaW51dGVPZkludGVydmFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZE1pbnV0ZXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZNaW51dGUuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGVhY2hNaW51dGVPZkludGVydmFsfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZWFjaE1pbnV0ZU9mSW50ZXJ2YWxcbiAqIEBjYXRlZ29yeSBJbnRlcnZhbCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGFycmF5IG9mIG1pbnV0ZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdGhlIGFycmF5IG9mIG1pbnV0ZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggc3RhcnRzIG9mIG1pbnV0ZXMgZnJvbSB0aGUgbWludXRlIG9mIHRoZSBpbnRlcnZhbCBzdGFydCB0byB0aGUgbWludXRlIG9mIHRoZSBpbnRlcnZhbCBlbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRWFjaCBtaW51dGUgYmV0d2VlbiAxNCBPY3RvYmVyIDIwMjAsIDEzOjAwIGFuZCAxNCBPY3RvYmVyIDIwMjAsIDEzOjAzXG4gKiBjb25zdCByZXN1bHQgPSBlYWNoTWludXRlT2ZJbnRlcnZhbCh7XG4gKiAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCA5LCAxNCwgMTMpLFxuICogICBlbmQ6IG5ldyBEYXRlKDIwMTQsIDksIDE0LCAxMywgMylcbiAqIH0pXG4gKiAvLz0+IFtcbiAqIC8vICAgV2VkIE9jdCAxNCAyMDE0IDEzOjAwOjAwLFxuICogLy8gICBXZWQgT2N0IDE0IDIwMTQgMTM6MDE6MDAsXG4gKiAvLyAgIFdlZCBPY3QgMTQgMjAxNCAxMzowMjowMCxcbiAqIC8vICAgV2VkIE9jdCAxNCAyMDE0IDEzOjAzOjAwXG4gKiAvLyBdXG4gKi9cbmZ1bmN0aW9uIGVhY2hNaW51dGVPZkludGVydmFsKGludGVydmFsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9ICgwLCBfaW5kZXgyLnN0YXJ0T2ZNaW51dGUpKFxuICAgICgwLCBfaW5kZXgzLnRvRGF0ZSkoaW50ZXJ2YWwuc3RhcnQpLFxuICApO1xuICBjb25zdCBlbmREYXRlID0gKDAsIF9pbmRleDMudG9EYXRlKShpbnRlcnZhbC5lbmQpO1xuXG4gIGxldCByZXZlcnNlZCA9ICtzdGFydERhdGUgPiArZW5kRGF0ZTtcbiAgY29uc3QgZW5kVGltZSA9IHJldmVyc2VkID8gK3N0YXJ0RGF0ZSA6ICtlbmREYXRlO1xuICBsZXQgY3VycmVudERhdGUgPSByZXZlcnNlZCA/IGVuZERhdGUgOiBzdGFydERhdGU7XG5cbiAgbGV0IHN0ZXAgPSBvcHRpb25zPy5zdGVwID8/IDE7XG4gIGlmICghc3RlcCkgcmV0dXJuIFtdO1xuICBpZiAoc3RlcCA8IDApIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgcmV2ZXJzZWQgPSAhcmV2ZXJzZWQ7XG4gIH1cblxuICBjb25zdCBkYXRlcyA9IFtdO1xuXG4gIHdoaWxlICgrY3VycmVudERhdGUgPD0gZW5kVGltZSkge1xuICAgIGRhdGVzLnB1c2goKDAsIF9pbmRleDMudG9EYXRlKShjdXJyZW50RGF0ZSkpO1xuICAgIGN1cnJlbnREYXRlID0gKDAsIF9pbmRleC5hZGRNaW51dGVzKShjdXJyZW50RGF0ZSwgc3RlcCk7XG4gIH1cblxuICByZXR1cm4gcmV2ZXJzZWQgPyBkYXRlcy5yZXZlcnNlKCkgOiBkYXRlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lYWNoTW9udGhPZkludGVydmFsID0gZWFjaE1vbnRoT2ZJbnRlcnZhbDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBlYWNoTW9udGhPZkludGVydmFsfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZWFjaE1vbnRoT2ZJbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgYXJyYXkgb2YgbW9udGhzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW50ZXJ2YWwuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGFycmF5IG9mIG1vbnRocyB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBpbnRlcnZhbCAtIFRoZSBpbnRlcnZhbFxuICpcbiAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIHN0YXJ0cyBvZiBtb250aHMgZnJvbSB0aGUgbW9udGggb2YgdGhlIGludGVydmFsIHN0YXJ0IHRvIHRoZSBtb250aCBvZiB0aGUgaW50ZXJ2YWwgZW5kXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEVhY2ggbW9udGggYmV0d2VlbiA2IEZlYnJ1YXJ5IDIwMTQgYW5kIDEwIEF1Z3VzdCAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gZWFjaE1vbnRoT2ZJbnRlcnZhbCh7XG4gKiAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAxLCA2KSxcbiAqICAgZW5kOiBuZXcgRGF0ZSgyMDE0LCA3LCAxMClcbiAqIH0pXG4gKiAvLz0+IFtcbiAqIC8vICAgU2F0IEZlYiAwMSAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBTYXQgTWFyIDAxIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFR1ZSBBcHIgMDEgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgVGh1IE1heSAwMSAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBTdW4gSnVuIDAxIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFR1ZSBKdWwgMDEgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgRnJpIEF1ZyAwMSAyMDE0IDAwOjAwOjAwXG4gKiAvLyBdXG4gKi9cbmZ1bmN0aW9uIGVhY2hNb250aE9mSW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhcnREYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGludGVydmFsLnN0YXJ0KTtcbiAgY29uc3QgZW5kRGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShpbnRlcnZhbC5lbmQpO1xuXG4gIGxldCByZXZlcnNlZCA9ICtzdGFydERhdGUgPiArZW5kRGF0ZTtcbiAgY29uc3QgZW5kVGltZSA9IHJldmVyc2VkID8gK3N0YXJ0RGF0ZSA6ICtlbmREYXRlO1xuICBjb25zdCBjdXJyZW50RGF0ZSA9IHJldmVyc2VkID8gZW5kRGF0ZSA6IHN0YXJ0RGF0ZTtcbiAgY3VycmVudERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGN1cnJlbnREYXRlLnNldERhdGUoMSk7XG5cbiAgbGV0IHN0ZXAgPSBvcHRpb25zPy5zdGVwID8/IDE7XG4gIGlmICghc3RlcCkgcmV0dXJuIFtdO1xuICBpZiAoc3RlcCA8IDApIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgcmV2ZXJzZWQgPSAhcmV2ZXJzZWQ7XG4gIH1cblxuICBjb25zdCBkYXRlcyA9IFtdO1xuXG4gIHdoaWxlICgrY3VycmVudERhdGUgPD0gZW5kVGltZSkge1xuICAgIGRhdGVzLnB1c2goKDAsIF9pbmRleC50b0RhdGUpKGN1cnJlbnREYXRlKSk7XG4gICAgY3VycmVudERhdGUuc2V0TW9udGgoY3VycmVudERhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIHJldmVyc2VkID8gZGF0ZXMucmV2ZXJzZSgpIDogZGF0ZXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZWFjaFF1YXJ0ZXJPZkludGVydmFsID0gZWFjaFF1YXJ0ZXJPZkludGVydmFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZFF1YXJ0ZXJzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mUXVhcnRlci5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZWFjaFF1YXJ0ZXJPZkludGVydmFsfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZWFjaFF1YXJ0ZXJPZkludGVydmFsXG4gKiBAY2F0ZWdvcnkgSW50ZXJ2YWwgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBhcnJheSBvZiBxdWFydGVycyB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBhcnJheSBvZiBxdWFydGVycyB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBpbnRlcnZhbCAtIFRoZSBpbnRlcnZhbFxuICpcbiAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIHN0YXJ0cyBvZiBxdWFydGVycyBmcm9tIHRoZSBxdWFydGVyIG9mIHRoZSBpbnRlcnZhbCBzdGFydCB0byB0aGUgcXVhcnRlciBvZiB0aGUgaW50ZXJ2YWwgZW5kXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEVhY2ggcXVhcnRlciB3aXRoaW4gaW50ZXJ2YWwgNiBGZWJydWFyeSAyMDE0IC0gMTAgQXVndXN0IDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBlYWNoUXVhcnRlck9mSW50ZXJ2YWwoe1xuICogICBzdGFydDogbmV3IERhdGUoMjAxNCwgMSwgNiksXG4gKiAgIGVuZDogbmV3IERhdGUoMjAxNCwgNywgMTApXG4gKiB9KVxuICogLy89PiBbXG4gKiAvLyAgIFdlZCBKYW4gMDEgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgVHVlIEFwciAwMSAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBUdWUgSnVsIDAxIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyBdXG4gKi9cbmZ1bmN0aW9uIGVhY2hRdWFydGVyT2ZJbnRlcnZhbChpbnRlcnZhbCwgb3B0aW9ucykge1xuICBjb25zdCBzdGFydERhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGludGVydmFsLnN0YXJ0KTtcbiAgY29uc3QgZW5kRGF0ZSA9ICgwLCBfaW5kZXgzLnRvRGF0ZSkoaW50ZXJ2YWwuZW5kKTtcblxuICBsZXQgcmV2ZXJzZWQgPSArc3RhcnREYXRlID4gK2VuZERhdGU7XG4gIGNvbnN0IGVuZFRpbWUgPSByZXZlcnNlZFxuICAgID8gKygwLCBfaW5kZXgyLnN0YXJ0T2ZRdWFydGVyKShzdGFydERhdGUpXG4gICAgOiArKDAsIF9pbmRleDIuc3RhcnRPZlF1YXJ0ZXIpKGVuZERhdGUpO1xuICBsZXQgY3VycmVudERhdGUgPSByZXZlcnNlZFxuICAgID8gKDAsIF9pbmRleDIuc3RhcnRPZlF1YXJ0ZXIpKGVuZERhdGUpXG4gICAgOiAoMCwgX2luZGV4Mi5zdGFydE9mUXVhcnRlcikoc3RhcnREYXRlKTtcblxuICBsZXQgc3RlcCA9IG9wdGlvbnM/LnN0ZXAgPz8gMTtcbiAgaWYgKCFzdGVwKSByZXR1cm4gW107XG4gIGlmIChzdGVwIDwgMCkge1xuICAgIHN0ZXAgPSAtc3RlcDtcbiAgICByZXZlcnNlZCA9ICFyZXZlcnNlZDtcbiAgfVxuXG4gIGNvbnN0IGRhdGVzID0gW107XG5cbiAgd2hpbGUgKCtjdXJyZW50RGF0ZSA8PSBlbmRUaW1lKSB7XG4gICAgZGF0ZXMucHVzaCgoMCwgX2luZGV4My50b0RhdGUpKGN1cnJlbnREYXRlKSk7XG4gICAgY3VycmVudERhdGUgPSAoMCwgX2luZGV4LmFkZFF1YXJ0ZXJzKShjdXJyZW50RGF0ZSwgc3RlcCk7XG4gIH1cblxuICByZXR1cm4gcmV2ZXJzZWQgPyBkYXRlcy5yZXZlcnNlKCkgOiBkYXRlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lYWNoV2Vla09mSW50ZXJ2YWwgPSBlYWNoV2Vla09mSW50ZXJ2YWw7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkV2Vla3MuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZXZWVrLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBlYWNoV2Vla09mSW50ZXJ2YWx9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBlYWNoV2Vla09mSW50ZXJ2YWxcbiAqIEBjYXRlZ29yeSBJbnRlcnZhbCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGFycmF5IG9mIHdlZWtzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW50ZXJ2YWwuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGFycmF5IG9mIHdlZWtzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW50ZXJ2YWwuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGludGVydmFsIC0gVGhlIGludGVydmFsLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIHN0YXJ0cyBvZiB3ZWVrcyBmcm9tIHRoZSB3ZWVrIG9mIHRoZSBpbnRlcnZhbCBzdGFydCB0byB0aGUgd2VlayBvZiB0aGUgaW50ZXJ2YWwgZW5kXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEVhY2ggd2VlayB3aXRoaW4gaW50ZXJ2YWwgNiBPY3RvYmVyIDIwMTQgLSAyMyBOb3ZlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gZWFjaFdlZWtPZkludGVydmFsKHtcbiAqICAgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDksIDYpLFxuICogICBlbmQ6IG5ldyBEYXRlKDIwMTQsIDEwLCAyMylcbiAqIH0pXG4gKiAvLz0+IFtcbiAqIC8vICAgU3VuIE9jdCAwNSAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBTdW4gT2N0IDEyIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFN1biBPY3QgMTkgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgU3VuIE9jdCAyNiAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBTdW4gTm92IDAyIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFN1biBOb3YgMDkgMjAxNCAwMDowMDowMCxcbiAqIC8vICAgU3VuIE5vdiAxNiAyMDE0IDAwOjAwOjAwLFxuICogLy8gICBTdW4gTm92IDIzIDIwMTQgMDA6MDA6MDBcbiAqIC8vIF1cbiAqL1xuZnVuY3Rpb24gZWFjaFdlZWtPZkludGVydmFsKGludGVydmFsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9ICgwLCBfaW5kZXgzLnRvRGF0ZSkoaW50ZXJ2YWwuc3RhcnQpO1xuICBjb25zdCBlbmREYXRlID0gKDAsIF9pbmRleDMudG9EYXRlKShpbnRlcnZhbC5lbmQpO1xuXG4gIGxldCByZXZlcnNlZCA9ICtzdGFydERhdGUgPiArZW5kRGF0ZTtcbiAgY29uc3Qgc3RhcnREYXRlV2VlayA9IHJldmVyc2VkXG4gICAgPyAoMCwgX2luZGV4Mi5zdGFydE9mV2VlaykoZW5kRGF0ZSwgb3B0aW9ucylcbiAgICA6ICgwLCBfaW5kZXgyLnN0YXJ0T2ZXZWVrKShzdGFydERhdGUsIG9wdGlvbnMpO1xuICBjb25zdCBlbmREYXRlV2VlayA9IHJldmVyc2VkXG4gICAgPyAoMCwgX2luZGV4Mi5zdGFydE9mV2Vlaykoc3RhcnREYXRlLCBvcHRpb25zKVxuICAgIDogKDAsIF9pbmRleDIuc3RhcnRPZldlZWspKGVuZERhdGUsIG9wdGlvbnMpO1xuXG4gIC8vIFNvbWUgdGltZXpvbmVzIHN3aXRjaCBEU1QgYXQgbWlkbmlnaHQsIG1ha2luZyBzdGFydCBvZiBkYXkgdW5yZWxpYWJsZSBpbiB0aGVzZSB0aW1lem9uZXMsIDNwbSBpcyBhIHNhZmUgYmV0XG4gIHN0YXJ0RGF0ZVdlZWsuc2V0SG91cnMoMTUpO1xuICBlbmREYXRlV2Vlay5zZXRIb3VycygxNSk7XG5cbiAgY29uc3QgZW5kVGltZSA9ICtlbmREYXRlV2Vlay5nZXRUaW1lKCk7XG4gIGxldCBjdXJyZW50RGF0ZSA9IHN0YXJ0RGF0ZVdlZWs7XG5cbiAgbGV0IHN0ZXAgPSBvcHRpb25zPy5zdGVwID8/IDE7XG4gIGlmICghc3RlcCkgcmV0dXJuIFtdO1xuICBpZiAoc3RlcCA8IDApIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgcmV2ZXJzZWQgPSAhcmV2ZXJzZWQ7XG4gIH1cblxuICBjb25zdCBkYXRlcyA9IFtdO1xuXG4gIHdoaWxlICgrY3VycmVudERhdGUgPD0gZW5kVGltZSkge1xuICAgIGN1cnJlbnREYXRlLnNldEhvdXJzKDApO1xuICAgIGRhdGVzLnB1c2goKDAsIF9pbmRleDMudG9EYXRlKShjdXJyZW50RGF0ZSkpO1xuICAgIGN1cnJlbnREYXRlID0gKDAsIF9pbmRleC5hZGRXZWVrcykoY3VycmVudERhdGUsIHN0ZXApO1xuICAgIGN1cnJlbnREYXRlLnNldEhvdXJzKDE1KTtcbiAgfVxuXG4gIHJldHVybiByZXZlcnNlZCA/IGRhdGVzLnJldmVyc2UoKSA6IGRhdGVzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVhY2hXZWVrZW5kT2ZJbnRlcnZhbCA9IGVhY2hXZWVrZW5kT2ZJbnRlcnZhbDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9lYWNoRGF5T2ZJbnRlcnZhbC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vaXNXZWVrZW5kLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVhY2hXZWVrZW5kT2ZJbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IExpc3QgYWxsIHRoZSBTYXR1cmRheXMgYW5kIFN1bmRheXMgaW4gdGhlIGdpdmVuIGRhdGUgaW50ZXJ2YWwuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgYWxsIHRoZSBTYXR1cmRheXMgYW5kIFN1bmRheXMgaW4gdGhlIGdpdmVuIGRhdGUgaW50ZXJ2YWwuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGludGVydmFsIC0gVGhlIGdpdmVuIGludGVydmFsXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIFNhdHVyZGF5cyBhbmQgU3VuZGF5c1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBMaXN0cyBhbGwgU2F0dXJkYXlzIGFuZCBTdW5kYXlzIGluIHRoZSBnaXZlbiBkYXRlIGludGVydmFsXG4gKiBjb25zdCByZXN1bHQgPSBlYWNoV2Vla2VuZE9mSW50ZXJ2YWwoe1xuICogICBzdGFydDogbmV3IERhdGUoMjAxOCwgOCwgMTcpLFxuICogICBlbmQ6IG5ldyBEYXRlKDIwMTgsIDgsIDMwKVxuICogfSlcbiAqIC8vPT4gW1xuICogLy8gICBTYXQgU2VwIDIyIDIwMTggMDA6MDA6MDAsXG4gKiAvLyAgIFN1biBTZXAgMjMgMjAxOCAwMDowMDowMCxcbiAqIC8vICAgU2F0IFNlcCAyOSAyMDE4IDAwOjAwOjAwLFxuICogLy8gICBTdW4gU2VwIDMwIDIwMTggMDA6MDA6MDBcbiAqIC8vIF1cbiAqL1xuZnVuY3Rpb24gZWFjaFdlZWtlbmRPZkludGVydmFsKGludGVydmFsKSB7XG4gIGNvbnN0IGRhdGVJbnRlcnZhbCA9ICgwLCBfaW5kZXguZWFjaERheU9mSW50ZXJ2YWwpKGludGVydmFsKTtcbiAgY29uc3Qgd2Vla2VuZHMgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgZGF0ZUludGVydmFsLmxlbmd0aCkge1xuICAgIGNvbnN0IGRhdGUgPSBkYXRlSW50ZXJ2YWxbaW5kZXgrK107XG4gICAgaWYgKCgwLCBfaW5kZXgyLmlzV2Vla2VuZCkoZGF0ZSkpIHdlZWtlbmRzLnB1c2goZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHdlZWtlbmRzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVhY2hXZWVrZW5kT2ZNb250aCA9IGVhY2hXZWVrZW5kT2ZNb250aDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9lYWNoV2Vla2VuZE9mSW50ZXJ2YWwuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2VuZE9mTW9udGguanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZNb250aC5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBlYWNoV2Vla2VuZE9mTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBMaXN0IGFsbCB0aGUgU2F0dXJkYXlzIGFuZCBTdW5kYXlzIGluIHRoZSBnaXZlbiBtb250aC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCBhbGwgdGhlIFNhdHVyZGF5cyBhbmQgU3VuZGF5cyBpbiB0aGUgZ2l2ZW4gbW9udGguXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gbW9udGhcbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgU2F0dXJkYXlzIGFuZCBTdW5kYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIExpc3RzIGFsbCBTYXR1cmRheXMgYW5kIFN1bmRheXMgaW4gdGhlIGdpdmVuIG1vbnRoXG4gKiBjb25zdCByZXN1bHQgPSBlYWNoV2Vla2VuZE9mTW9udGgobmV3IERhdGUoMjAyMiwgMSwgMSkpXG4gKiAvLz0+IFtcbiAqIC8vICAgU2F0IEZlYiAwNSAyMDIyIDAwOjAwOjAwLFxuICogLy8gICBTdW4gRmViIDA2IDIwMjIgMDA6MDA6MDAsXG4gKiAvLyAgIFNhdCBGZWIgMTIgMjAyMiAwMDowMDowMCxcbiAqIC8vICAgU3VuIEZlYiAxMyAyMDIyIDAwOjAwOjAwLFxuICogLy8gICBTYXQgRmViIDE5IDIwMjIgMDA6MDA6MDAsXG4gKiAvLyAgIFN1biBGZWIgMjAgMjAyMiAwMDowMDowMCxcbiAqIC8vICAgU2F0IEZlYiAyNiAyMDIyIDAwOjAwOjAwLFxuICogLy8gICBTdW4gRmViIDI3IDIwMjIgMDA6MDA6MDBcbiAqIC8vIF1cbiAqL1xuZnVuY3Rpb24gZWFjaFdlZWtlbmRPZk1vbnRoKGRhdGUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoMCwgX2luZGV4My5zdGFydE9mTW9udGgpKGRhdGUpO1xuICBjb25zdCBlbmQgPSAoMCwgX2luZGV4Mi5lbmRPZk1vbnRoKShkYXRlKTtcbiAgcmV0dXJuICgwLCBfaW5kZXguZWFjaFdlZWtlbmRPZkludGVydmFsKSh7IHN0YXJ0LCBlbmQgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZWFjaFdlZWtlbmRPZlllYXIgPSBlYWNoV2Vla2VuZE9mWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9lYWNoV2Vla2VuZE9mSW50ZXJ2YWwuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2VuZE9mWWVhci5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vc3RhcnRPZlllYXIuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZWFjaFdlZWtlbmRPZlllYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IExpc3QgYWxsIHRoZSBTYXR1cmRheXMgYW5kIFN1bmRheXMgaW4gdGhlIHllYXIuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgYWxsIHRoZSBTYXR1cmRheXMgYW5kIFN1bmRheXMgaW4gdGhlIHllYXIuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4geWVhclxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBTYXR1cmRheXMgYW5kIFN1bmRheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTGlzdHMgYWxsIFNhdHVyZGF5cyBhbmQgU3VuZGF5cyBpbiB0aGUgeWVhclxuICogY29uc3QgcmVzdWx0ID0gZWFjaFdlZWtlbmRPZlllYXIobmV3IERhdGUoMjAyMCwgMSwgMSkpXG4gKiAvLz0+IFtcbiAqIC8vICAgU2F0IEphbiAwMyAyMDIwIDAwOjAwOjAwLFxuICogLy8gICBTdW4gSmFuIDA0IDIwMjAgMDA6MDA6MDAsXG4gKiAvLyAgIC4uLlxuICogLy8gICBTdW4gRGVjIDI3IDIwMjAgMDA6MDA6MDBcbiAqIC8vIF1cbiAqIF1cbiAqL1xuZnVuY3Rpb24gZWFjaFdlZWtlbmRPZlllYXIoZGF0ZSkge1xuICBjb25zdCBzdGFydCA9ICgwLCBfaW5kZXgzLnN0YXJ0T2ZZZWFyKShkYXRlKTtcbiAgY29uc3QgZW5kID0gKDAsIF9pbmRleDIuZW5kT2ZZZWFyKShkYXRlKTtcbiAgcmV0dXJuICgwLCBfaW5kZXguZWFjaFdlZWtlbmRPZkludGVydmFsKSh7IHN0YXJ0LCBlbmQgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZWFjaFllYXJPZkludGVydmFsID0gZWFjaFllYXJPZkludGVydmFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGVhY2hZZWFyT2ZJbnRlcnZhbH0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGVhY2hZZWFyT2ZJbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgYXJyYXkgb2YgeWVhcmx5IHRpbWVzdGFtcHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgYXJyYXkgb2YgeWVhcmx5IHRpbWVzdGFtcHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgaW50ZXJ2YWwuXG4gKlxuICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggc3RhcnRzIG9mIHllYXJseSB0aW1lc3RhbXBzIGZyb20gdGhlIG1vbnRoIG9mIHRoZSBpbnRlcnZhbCBzdGFydCB0byB0aGUgbW9udGggb2YgdGhlIGludGVydmFsIGVuZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFYWNoIHllYXIgYmV0d2VlbiA2IEZlYnJ1YXJ5IDIwMTQgYW5kIDEwIEF1Z3VzdCAyMDE3OlxuICogY29uc3QgcmVzdWx0ID0gZWFjaFllYXJPZkludGVydmFsKHtcbiAqICAgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDEsIDYpLFxuICogICBlbmQ6IG5ldyBEYXRlKDIwMTcsIDcsIDEwKVxuICogfSlcbiAqIC8vPT4gW1xuICogLy8gICBXZWQgSmFuIDAxIDIwMTQgMDA6MDA6MDAsXG4gKiAvLyAgIFRodSBKYW4gMDEgMjAxNSAwMDowMDowMCxcbiAqIC8vICAgRnJpIEphbiAwMSAyMDE2IDAwOjAwOjAwLFxuICogLy8gICBTdW4gSmFuIDAxIDIwMTcgMDA6MDA6MDBcbiAqIC8vIF1cbiAqL1xuZnVuY3Rpb24gZWFjaFllYXJPZkludGVydmFsKGludGVydmFsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShpbnRlcnZhbC5zdGFydCk7XG4gIGNvbnN0IGVuZERhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoaW50ZXJ2YWwuZW5kKTtcblxuICBsZXQgcmV2ZXJzZWQgPSArc3RhcnREYXRlID4gK2VuZERhdGU7XG4gIGNvbnN0IGVuZFRpbWUgPSByZXZlcnNlZCA/ICtzdGFydERhdGUgOiArZW5kRGF0ZTtcbiAgY29uc3QgY3VycmVudERhdGUgPSByZXZlcnNlZCA/IGVuZERhdGUgOiBzdGFydERhdGU7XG4gIGN1cnJlbnREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjdXJyZW50RGF0ZS5zZXRNb250aCgwLCAxKTtcblxuICBsZXQgc3RlcCA9IG9wdGlvbnM/LnN0ZXAgPz8gMTtcbiAgaWYgKCFzdGVwKSByZXR1cm4gW107XG4gIGlmIChzdGVwIDwgMCkge1xuICAgIHN0ZXAgPSAtc3RlcDtcbiAgICByZXZlcnNlZCA9ICFyZXZlcnNlZDtcbiAgfVxuXG4gIGNvbnN0IGRhdGVzID0gW107XG5cbiAgd2hpbGUgKCtjdXJyZW50RGF0ZSA8PSBlbmRUaW1lKSB7XG4gICAgZGF0ZXMucHVzaCgoMCwgX2luZGV4LnRvRGF0ZSkoY3VycmVudERhdGUpKTtcbiAgICBjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG4gIH1cblxuICByZXR1cm4gcmV2ZXJzZWQgPyBkYXRlcy5yZXZlcnNlKCkgOiBkYXRlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZkRheSA9IGVuZE9mRGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBlbmRPZkRheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGEgZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBkYXkgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMjM6NTk6NTkuOTk5XG4gKi9cbmZ1bmN0aW9uIGVuZE9mRGF5KGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIF9kYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZkRlY2FkZSA9IGVuZE9mRGVjYWRlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBlbmRPZkRlY2FkZVxuICogQGNhdGVnb3J5IERlY2FkZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIGRlY2FkZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIGRlY2FkZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmQgb2YgYSBkZWNhZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGVuZCBvZiBhIGRlY2FkZSBmb3IgMTIgTWF5IDE5ODQgMDA6MDA6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZkRlY2FkZShuZXcgRGF0ZSgxOTg0LCA0LCAxMiwgMDAsIDAwLCAwMCkpXG4gKiAvLz0+IERlYyAzMSAxOTg5IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZkRlY2FkZShkYXRlKSB7XG4gIC8vIFRPRE86IFN3aXRjaCB0byBtb3JlIHRlY2huaWNhbCBkZWZpbml0aW9uIGluIG9mIGRlY2FkZXMgdGhhdCBzdGFydCB3aXRoIDFcbiAgLy8gZW5kIHdpdGggMC4gSS5lLiAyMDAxLTIwMTAgaW5zdGVhZCBvZiBjdXJyZW50IDIwMDAtMjAwOS4gSXQncyBhIGJyZWFraW5nXG4gIC8vIGNoYW5nZSwgc28gaXQgY2FuIG9ubHkgYmUgZG9uZSBpbiA0LjAuXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgZGVjYWRlID0gOSArIE1hdGguZmxvb3IoeWVhciAvIDEwKSAqIDEwO1xuICBfZGF0ZS5zZXRGdWxsWWVhcihkZWNhZGUsIDExLCAzMSk7XG4gIF9kYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZkhvdXIgPSBlbmRPZkhvdXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVuZE9mSG91clxuICogQGNhdGVnb3J5IEhvdXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBlbmQgb2YgYW4gaG91ciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhbiBob3VyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmQgb2YgYW4gaG91clxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgZW5kIG9mIGFuIGhvdXIgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZkhvdXIobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1KSlcbiAqIC8vPT4gVHVlIFNlcCAwMiAyMDE0IDExOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZkhvdXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgX2RhdGUuc2V0TWludXRlcyg1OSwgNTksIDk5OSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZklTT1dlZWsgPSBlbmRPZklTT1dlZWs7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZW5kT2ZXZWVrLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVuZE9mSVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgZW5kIG9mIGFuIElTTyB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIGFuIElTTyB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGFuIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYW4gSVNPIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZklTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gU3VuIFNlcCAwNyAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZklTT1dlZWsoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5lbmRPZldlZWspKGRhdGUsIHsgd2Vla1N0YXJ0c09uOiAxIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVuZE9mSVNPV2Vla1llYXIgPSBlbmRPZklTT1dlZWtZZWFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dldElTT1dlZWtZZWFyLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mSVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBlbmRPZklTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBlbmQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBlbmQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsXG4gKiB3aGljaCBhbHdheXMgc3RhcnRzIDMgZGF5cyBiZWZvcmUgdGhlIHllYXIncyBmaXJzdCBUaHVyc2RheS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1OlxuICogY29uc3QgcmVzdWx0ID0gZW5kT2ZJU09XZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCA2LCAyKSlcbiAqIC8vPT4gU3VuIEphbiAwMSAyMDA2IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZklTT1dlZWtZZWFyKGRhdGUpIHtcbiAgY29uc3QgeWVhciA9ICgwLCBfaW5kZXguZ2V0SVNPV2Vla1llYXIpKGRhdGUpO1xuICBjb25zdCBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gKDAsIF9pbmRleDMuY29uc3RydWN0RnJvbSkoZGF0ZSwgMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0RnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnN0YXJ0T2ZJU09XZWVrKShmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyKTtcbiAgX2RhdGUuc2V0TWlsbGlzZWNvbmRzKF9kYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gMSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZk1pbnV0ZSA9IGVuZE9mTWludXRlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBlbmRPZk1pbnV0ZVxuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIG1pbnV0ZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIG1pbnV0ZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGEgbWludXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBtaW51dGUgZm9yIDEgRGVjZW1iZXIgMjAxNCAyMjoxNTo0NS40MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZk1pbnV0ZShuZXcgRGF0ZSgyMDE0LCAxMSwgMSwgMjIsIDE1LCA0NSwgNDAwKSlcbiAqIC8vPT4gTW9uIERlYyAwMSAyMDE0IDIyOjE1OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZk1pbnV0ZShkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXRTZWNvbmRzKDU5LCA5OTkpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW5kT2ZNb250aCA9IGVuZE9mTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVuZE9mTW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIG1vbnRoIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIGEgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGVuZCBvZiBhIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBlbmQgb2YgYSBtb250aCBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gVHVlIFNlcCAzMCAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZk1vbnRoKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IG1vbnRoID0gX2RhdGUuZ2V0TW9udGgoKTtcbiAgX2RhdGUuc2V0RnVsbFllYXIoX2RhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGggKyAxLCAwKTtcbiAgX2RhdGUuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVuZE9mUXVhcnRlciA9IGVuZE9mUXVhcnRlcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZW5kT2ZRdWFydGVyXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiBhIHllYXIgcXVhcnRlciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIHllYXIgcXVhcnRlciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGEgcXVhcnRlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgZW5kIG9mIGEgcXVhcnRlciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mUXVhcnRlcihuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDMwIDIwMTQgMjM6NTk6NTkuOTk5XG4gKi9cbmZ1bmN0aW9uIGVuZE9mUXVhcnRlcihkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBjdXJyZW50TW9udGggPSBfZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBtb250aCA9IGN1cnJlbnRNb250aCAtIChjdXJyZW50TW9udGggJSAzKSArIDM7XG4gIF9kYXRlLnNldE1vbnRoKG1vbnRoLCAwKTtcbiAgX2RhdGUuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVuZE9mU2Vjb25kID0gZW5kT2ZTZWNvbmQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVuZE9mU2Vjb25kXG4gKiBAY2F0ZWdvcnkgU2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgZW5kIG9mIGEgc2Vjb25kIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIGEgc2Vjb25kIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmQgb2YgYSBzZWNvbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGVuZCBvZiBhIHNlY29uZCBmb3IgMSBEZWNlbWJlciAyMDE0IDIyOjE1OjQ1LjQwMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mU2Vjb25kKG5ldyBEYXRlKDIwMTQsIDExLCAxLCAyMiwgMTUsIDQ1LCA0MDApKVxuICogLy89PiBNb24gRGVjIDAxIDIwMTQgMjI6MTU6NDUuOTk5XG4gKi9cbmZ1bmN0aW9uIGVuZE9mU2Vjb25kKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIF9kYXRlLnNldE1pbGxpc2Vjb25kcyg5OTkpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW5kT2ZUb2RheSA9IGVuZE9mVG9kYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZW5kT2ZEYXkuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZW5kT2ZUb2RheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiB0b2RheS5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiB0b2RheS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIHRvZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDYgT2N0b2JlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gZW5kT2ZUb2RheSgpXG4gKiAvLz0+IE1vbiBPY3QgNiAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZlRvZGF5KCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5lbmRPZkRheSkoRGF0ZS5ub3coKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW5kT2ZUb21vcnJvdyA9IGVuZE9mVG9tb3Jyb3c7IC8qKlxuICogQG5hbWUgZW5kT2ZUb21vcnJvd1xuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGVuZCBvZiB0b21vcnJvdy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiB0b21vcnJvdy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIHRvbW9ycm93XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDYgT2N0b2JlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gZW5kT2ZUb21vcnJvdygpXG4gKiAvLz0+IFR1ZSBPY3QgNyAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZlRvbW9ycm93KCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB5ZWFyID0gbm93LmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gbm93LmdldE1vbnRoKCk7XG4gIGNvbnN0IGRheSA9IG5vdy5nZXREYXRlKCk7XG5cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkgKyAxKTtcbiAgZGF0ZS5zZXRIb3VycygyMywgNTksIDU5LCA5OTkpO1xuICByZXR1cm4gZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZldlZWsgPSBlbmRPZldlZWs7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBlbmRPZldlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBlbmRPZldlZWtcbiAqIEBjYXRlZ29yeSBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgZW5kIG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGVuZCBvZiBhIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGEgd2Vla1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgZW5kIG9mIGEgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBTYXQgU2VwIDA2IDIwMTQgMjM6NTk6NTkuOTk5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIHRoZSBlbmQgb2YgdGhlIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBlbmRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAqIC8vPT4gU3VuIFNlcCAwNyAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZldlZWsoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXgyLmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyAtNyA6IDApICsgNiAtIChkYXkgLSB3ZWVrU3RhcnRzT24pO1xuXG4gIF9kYXRlLnNldERhdGUoX2RhdGUuZ2V0RGF0ZSgpICsgZGlmZik7XG4gIF9kYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbmRPZlllYXIgPSBlbmRPZlllYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGVuZE9mWWVhclxuICogQGNhdGVnb3J5IFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBlbmQgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIGEgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIGEgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgZW5kIG9mIGEgeWVhciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mWWVhcihuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDAwKSlcbiAqIC8vPT4gV2VkIERlYyAzMSAyMDE0IDIzOjU5OjU5Ljk5OVxuICovXG5mdW5jdGlvbiBlbmRPZlllYXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgeWVhciA9IF9kYXRlLmdldEZ1bGxZZWFyKCk7XG4gIF9kYXRlLnNldEZ1bGxZZWFyKHllYXIgKyAxLCAwLCAwKTtcbiAgX2RhdGUuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVuZE9mWWVzdGVyZGF5ID0gZW5kT2ZZZXN0ZXJkYXk7IC8qKlxuICogQG5hbWUgZW5kT2ZZZXN0ZXJkYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBlbmQgb2YgeWVzdGVyZGF5LlxuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZW5kIG9mIHllc3RlcmRheS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5kIG9mIHllc3RlcmRheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyA2IE9jdG9iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IGVuZE9mWWVzdGVyZGF5KClcbiAqIC8vPT4gU3VuIE9jdCA1IDIwMTQgMjM6NTk6NTkuOTk5XG4gKi9cbmZ1bmN0aW9uIGVuZE9mWWVzdGVyZGF5KCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB5ZWFyID0gbm93LmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gbm93LmdldE1vbnRoKCk7XG4gIGNvbnN0IGRheSA9IG5vdy5nZXREYXRlKCk7XG5cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkgLSAxKTtcbiAgZGF0ZS5zZXRIb3VycygyMywgNTksIDU5LCA5OTkpO1xuICByZXR1cm4gZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5mb3JtYXQgPSBleHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXR0ZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleDMuZm9ybWF0dGVycztcbiAgfSxcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9uZ0Zvcm1hdHRlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4NC5sb25nRm9ybWF0dGVycztcbiAgfSxcbn0pO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdExvY2FsZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0T3B0aW9ucy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vX2xpYi9mb3JtYXQvZm9ybWF0dGVycy5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL19saWIvcHJvdGVjdGVkVG9rZW5zLmpzXCIpO1xuXG52YXIgX2luZGV4NiA9IHJlcXVpcmUoXCIuL2lzVmFsaWQuanNcIik7XG52YXIgX2luZGV4NyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLy8gUmV4cG9ydHMgb2YgaW50ZXJuYWwgZm9yIGxpYnJhcmllcyB0byB1c2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzYzOCNpc3N1ZWNvbW1lbnQtMTg3NzA4Mjg3NFxuXG4vLyBUaGlzIFJlZ0V4cCBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0cyBzZXBhcmF0ZWQgYnkgYHxgOlxuLy8gLSBbeVlRcU1Md0lkRGVjaWhIS2ttc11vIG1hdGNoZXMgYW55IGF2YWlsYWJsZSBvcmRpbmFsIG51bWJlciB0b2tlblxuLy8gICAob25lIG9mIHRoZSBjZXJ0YWluIGxldHRlcnMgZm9sbG93ZWQgYnkgYG9gKVxuLy8gLSAoXFx3KVxcMSogbWF0Y2hlcyBhbnkgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIGxldHRlclxuLy8gLSAnJyBtYXRjaGVzIHR3byBxdW90ZSBjaGFyYWN0ZXJzIGluIGEgcm93XG4vLyAtICcoJyd8W14nXSkrKCd8JCkgbWF0Y2hlcyBhbnl0aGluZyBzdXJyb3VuZGVkIGJ5IHR3byBxdW90ZSBjaGFyYWN0ZXJzICgnKSxcbi8vICAgZXhjZXB0IGEgc2luZ2xlIHF1b3RlIHN5bWJvbCwgd2hpY2ggZW5kcyB0aGUgc2VxdWVuY2UuXG4vLyAgIFR3byBxdW90ZSBjaGFyYWN0ZXJzIGRvIG5vdCBlbmQgdGhlIHNlcXVlbmNlLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBzaW5nbGUgcXVvdGVcbi8vICAgdGhlbiB0aGUgc2VxdWVuY2Ugd2lsbCBjb250aW51ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4vLyAtIC4gbWF0Y2hlcyBhbnkgc2luZ2xlIGNoYXJhY3RlciB1bm1hdGNoZWQgYnkgcHJldmlvdXMgcGFydHMgb2YgdGhlIFJlZ0V4cHNcbmNvbnN0IGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPVxuICAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG5cbi8vIFRoaXMgUmVnRXhwIGNhdGNoZXMgc3ltYm9scyBlc2NhcGVkIGJ5IHF1b3RlcywgYW5kIGFsc29cbi8vIHNlcXVlbmNlcyBvZiBzeW1ib2xzIFAsIHAsIGFuZCB0aGUgY29tYmluYXRpb25zIGxpa2UgYFBQUFBQUFBwcHBwcGBcbmNvbnN0IGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG5cbmNvbnN0IGVzY2FwZWRTdHJpbmdSZWdFeHAgPSAvXicoW15dKj8pJz8kLztcbmNvbnN0IGRvdWJsZVF1b3RlUmVnRXhwID0gLycnL2c7XG5jb25zdCB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCA9IC9bYS16QS1aXS87XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXR9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBmb3JtYXRcbiAqIEBhbGlhcyBmb3JtYXREYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGluIHRoZSBnaXZlbiBmb3JtYXQuIFRoZSByZXN1bHQgbWF5IHZhcnkgYnkgbG9jYWxlLlxuICpcbiAqID4g4pqg77iPIFBsZWFzZSBub3RlIHRoYXQgdGhlIGBmb3JtYXRgIHRva2VucyBkaWZmZXIgZnJvbSBNb21lbnQuanMgYW5kIG90aGVyIGxpYnJhcmllcy5cbiAqID4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKiAoc2VlIHRoZSBsYXN0IGV4YW1wbGUpXG4gKlxuICogRm9ybWF0IG9mIHRoZSBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0ZpZWxkX1N5bWJvbF9UYWJsZVxuICogd2l0aCBhIGZldyBhZGRpdGlvbnMgKHNlZSBub3RlIDcgYmVsb3cgdGhlIHRhYmxlKS5cbiAqXG4gKiBBY2NlcHRlZCBwYXR0ZXJuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBhdHRlcm4gfCBSZXN1bHQgZXhhbXBsZXMgICAgICAgICAgICAgICAgICAgfCBOb3RlcyB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0cgICAgfCBBbm5vIERvbWluaSwgQmVmb3JlIENocmlzdCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHlvICAgICAgfCA0NHRoLCAxc3QsIDB0aCwgMTd0aCAgICAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlvICAgICAgfCA0NHRoLCAxc3QsIDE5MDB0aCwgMjAxN3RoICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVkgICAgfCAwMDQ0LCAwMDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgUiAgICAgICB8IC00MywgMCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSICAgICAgfCAtNDMsIDAwLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAwLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAwLCAwMDAxLCAxOTAwLCAyMDE3ICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUlJSICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUsNyB8XG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCB1ICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dSAgICAgfCAtMDQzLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSAgIHxcbiAqIHwgUXVhcnRlciAoZm9ybWF0dGluZykgICAgICAgICAgICB8IFEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgUXVhcnRlciAoc3RhbmQtYWxvbmUpICAgICAgICAgICB8IHEgICAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcSAgICAgfCBRMSwgUTIsIFEzLCBRNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgTW9udGggKGZvcm1hdHRpbmcpICAgICAgICAgICAgICB8IE0gICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTSAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTW9udGggKHN0YW5kLWFsb25lKSAgICAgICAgICAgICB8IEwgICAgICAgfCAxLCAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTCAgICAgfCBKYW4sIEZlYiwgLi4uLCBEZWMgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgICB8IHcgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgICB8IEkgICAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgICB8IGQgICAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgICB8IEQgICAgICAgfCAxLCAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgICAgfCA5ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERERCAgICAgfCAwMDEsIDAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgSVNPIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICB8IGkgICAgICAgfCAxLCAyLCAzLCAuLi4sIDcgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWlpaSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCA3ICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2MgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICB8IGEuLmFhICAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWEgICAgIHwgYW0sIHBtICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCBiLi5iYiAgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiICAgICB8IGFtLCBwbSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmJiYiAgIHwgYSwgcCwgbiwgbWkgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBCQkJCQiAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICAgIHwgMDAsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBLSyAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBrayAgICAgIHwgMjQsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1MgICAgIHwgMDAwLCAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWCAgICAgIHwgLTA4MDAsICswNTMwLCBaICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYWCAgIHwgLTA4OjAwLCArMDU6MzAsIFosICsxMjozNDo1NiAgICAgIHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHggICAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChHTVQpICAgICAgICAgICAgICAgICAgfCBPLi4uT09PIHwgR01ULTgsIEdNVCs1OjMwLCBHTVQrMCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgT09PTyAgICB8IEdNVC0wODowMCwgR01UKzA1OjMwLCBHTVQrMDA6MDAgICB8IDIgICAgIHxcbiAqIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pICB8IHouLi56enogfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCA2ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB6enp6ICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiw2ICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHR0ICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDcgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgfCBUICAgICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgICB8IFAgICAgICAgfCAwNC8yOS8xNDUzICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUCAgICAgIHwgQXByIDI5LCAxNDUzICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQICAgICB8IEFwcmlsIDI5dGgsIDE0NTMgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUFAgICAgfCBGcmlkYXksIEFwcmlsIDI5dGgsIDE0NTMgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIHRpbWUgICAgICAgICAgICAgfCBwICAgICAgIHwgMTI6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcCAgICAgfCAxMjowMDowMCBBTSBHTVQrMiAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcHBwICAgIHwgMTI6MDA6MDAgQU0gR01UKzAyOjAwICAgICAgICAgICAgIHwgMiw3ICAgfFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgUHAgICAgICB8IDA0LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQcHAgICAgfCBBcHIgMjksIDE0NTMsIDEyOjAwOjAwIEFNICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBwcHAgIHwgQXByaWwgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUHBwcHB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyBhdCAuLi4gICB8IDIsNyAgIHxcbiAqIE5vdGVzOlxuICogMS4gXCJGb3JtYXR0aW5nXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcbiAqICAgIGFyZSB0aGUgc2FtZSBhcyBcInN0YW5kLWFsb25lXCIgdW5pdHMsIGJ1dCBhcmUgZGlmZmVyZW50IGluIHNvbWUgbGFuZ3VhZ2VzLlxuICogICAgXCJGb3JtYXR0aW5nXCIgdW5pdHMgYXJlIGRlY2xpbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgb2YgdGhlIGxhbmd1YWdlXG4gKiAgICBpbiB0aGUgY29udGV4dCBvZiBhIGRhdGUuIFwiU3RhbmQtYWxvbmVcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXI6XG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBMTExMJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZCdgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdkbyBNTU1NJywge2xvY2FsZTogY3N9KSAvLz0+ICc2LiBsaXN0b3BhZHUnYFxuICpcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxuICogICAgdGhlIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIChzZWUgYmVsb3cpLlxuICogICAgSWYgdGhlIHNlcXVlbmNlIGlzIGxvbmdlciB0aGFuIGxpc3RlZCBpbiB0YWJsZSAoZS5nLiBgRUVFRUVFRUVFRUVgKVxuICogICAgdGhlIG91dHB1dCB3aWxsIGJlIHRoZSBzYW1lIGFzIGRlZmF1bHQgcGF0dGVybiBmb3IgdGhpcyB1bml0LCB1c3VhbGx5XG4gKiAgICB0aGUgbG9uZ2VzdCBvbmUgKGluIGNhc2Ugb2YgSVNPIHdlZWtkYXlzLCBgRUVFRWApLiBEZWZhdWx0IHBhdHRlcm5zIGZvciB1bml0c1xuICogICAgYXJlIG1hcmtlZCB3aXRoIFwiMlwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU0nKSAvLz0+ICdOb3YnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NJykgLy89PiAnTidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqIDMuIFNvbWUgcGF0dGVybnMgY291bGQgYmUgdW5saW1pdGVkIGxlbmd0aCAoc3VjaCBhcyBgeXl5eXl5eXlgKS5cbiAqICAgIFRoZSBvdXRwdXQgd2lsbCBiZSBwYWRkZWQgd2l0aCB6ZXJvcyB0byBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAneXl5eXl5eXknKSAvLz0+ICcwMDAwMjAxNydgXG4gKlxuICogNC4gYFFRUVFRYCBhbmQgYHFxcXFxYCBjb3VsZCBiZSBub3Qgc3RyaWN0bHkgbnVtZXJpY2FsIGluIHNvbWUgbG9jYWxlcy5cbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXG4gKlxuICogNS4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIHBhdHRlcm5zIGFyZSBCLkMuIHllYXJzOlxuICpcbiAqICAgIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tfC0tLS0tfFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcbiAqICAgIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gKiAgICB8IEJDIDIgfCAgIDIgfCAgLTEgfFxuICpcbiAqICAgIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAqICAgIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZDpcbiAqXG4gKiAgICB8IFllYXIgfCBgeXlgIHwgYHV1YCB8XG4gKiAgICB8LS0tLS0tfC0tLS0tLXwtLS0tLS18XG4gKiAgICB8IDEgICAgfCAgIDAxIHwgICAwMSB8XG4gKiAgICB8IDE0ICAgfCAgIDE0IHwgICAxNCB8XG4gKiAgICB8IDM3NiAgfCAgIDc2IHwgIDM3NiB8XG4gKiAgICB8IDE0NTMgfCAgIDUzIHwgMTQ1MyB8XG4gKlxuICogICAgVGhlIHNhbWUgZGlmZmVyZW5jZSBpcyB0cnVlIGZvciBsb2NhbCBhbmQgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJzIChgWWAgYW5kIGBSYCksXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXG4gKiAgICBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAoY29tcGFyZSBbZ2V0SVNPV2Vla1llYXJdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0SVNPV2Vla1llYXIpXG4gKiAgICBhbmQgW2dldFdlZWtZZWFyXShodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL2dldFdlZWtZZWFyKSkuXG4gKlxuICogNi4gU3BlY2lmaWMgbm9uLWxvY2F0aW9uIHRpbWV6b25lcyBhcmUgY3VycmVudGx5IHVuYXZhaWxhYmxlIGluIGBkYXRlLWZuc2AsXG4gKiAgICBzbyByaWdodCBub3cgdGhlc2UgdG9rZW5zIGZhbGwgYmFjayB0byBHTVQgdGltZXpvbmVzLlxuICpcbiAqIDcuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqICAgIC0gYGlgOiBJU08gZGF5IG9mIHdlZWtcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqICAgIC0gYHRgOiBzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgVGA6IG1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAqICAgIC0gYG9gOiBvcmRpbmFsIG51bWJlciBtb2RpZmllclxuICogICAgLSBgUGA6IGxvbmcgbG9jYWxpemVkIGRhdGVcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXG4gKlxuICogOC4gYFlZYCBhbmQgYFlZWVlgIHRva2VucyByZXByZXNlbnQgd2Vlay1udW1iZXJpbmcgeWVhcnMgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggeWVhcnMuXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiA5LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIGRheXMgb2YgdGhlIG1vbnRoLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbERheU9mWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICpcbiAqIEB0aHJvd3MgYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICogQHRocm93cyBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbG9jYWxpemVgIHByb3BlcnR5XG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXRMb25nYCBwcm9wZXJ0eVxuICogQHRocm93cyB1c2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aCB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIHVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aCB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTEgRmVicnVhcnkgMjAxNCBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCAxLCAxMSksICdNTS9kZC95eXl5JylcbiAqIC8vPT4gJzAyLzExLzIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAyIEp1bHkgMjAxNCBpbiBFc3BlcmFudG86XG4gKiBpbXBvcnQgeyBlb0xvY2FsZSB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgXCJkbyAnZGUnIE1NTU0geXl5eVwiLCB7XG4gKiAgIGxvY2FsZTogZW9Mb2NhbGVcbiAqIH0pXG4gKiAvLz0+ICcyLWEgZGUganVsaW8gMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXNjYXBlIHN0cmluZyBieSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyczpcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA2LCAyLCAxNSksIFwiaCAnbycnY2xvY2snXCIpXG4gKiAvLz0+IFwiMyBvJ2Nsb2NrXCJcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGRhdGUsIGZvcm1hdFN0ciwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXgyLmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCBsb2NhbGUgPVxuICAgIG9wdGlvbnM/LmxvY2FsZSA/PyBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgPz8gX2luZGV4LmRlZmF1bHRMb2NhbGU7XG5cbiAgY29uc3QgZmlyc3RXZWVrQ29udGFpbnNEYXRlID1cbiAgICBvcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBvcHRpb25zPy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgMTtcblxuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IG9yaWdpbmFsRGF0ZSA9ICgwLCBfaW5kZXg3LnRvRGF0ZSkoZGF0ZSk7XG5cbiAgaWYgKCEoMCwgX2luZGV4Ni5pc1ZhbGlkKShvcmlnaW5hbERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBsZXQgcGFydHMgPSBmb3JtYXRTdHJcbiAgICAubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHApXG4gICAgLm1hcCgoc3Vic3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcbiAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCJwXCIgfHwgZmlyc3RDaGFyYWN0ZXIgPT09IFwiUFwiKSB7XG4gICAgICAgIGNvbnN0IGxvbmdGb3JtYXR0ZXIgPSBfaW5kZXg0LmxvbmdGb3JtYXR0ZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcbiAgICAgICAgcmV0dXJuIGxvbmdGb3JtYXR0ZXIoc3Vic3RyaW5nLCBsb2NhbGUuZm9ybWF0TG9uZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Vic3RyaW5nO1xuICAgIH0pXG4gICAgLmpvaW4oXCJcIilcbiAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cClcbiAgICAubWFwKChzdWJzdHJpbmcpID0+IHtcbiAgICAgIC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgIGlmIChzdWJzdHJpbmcgPT09IFwiJydcIikge1xuICAgICAgICByZXR1cm4geyBpc1Rva2VuOiBmYWxzZSwgdmFsdWU6IFwiJ1wiIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSBcIidcIikge1xuICAgICAgICByZXR1cm4geyBpc1Rva2VuOiBmYWxzZSwgdmFsdWU6IGNsZWFuRXNjYXBlZFN0cmluZyhzdWJzdHJpbmcpIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaW5kZXgzLmZvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdKSB7XG4gICAgICAgIHJldHVybiB7IGlzVG9rZW46IHRydWUsIHZhbHVlOiBzdWJzdHJpbmcgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICBcIkZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgXCIgK1xuICAgICAgICAgICAgZmlyc3RDaGFyYWN0ZXIgK1xuICAgICAgICAgICAgXCJgXCIsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGlzVG9rZW46IGZhbHNlLCB2YWx1ZTogc3Vic3RyaW5nIH07XG4gICAgfSk7XG5cbiAgLy8gaW52b2tlIGxvY2FsaXplIHByZXByb2Nlc3NvciAob25seSBmb3IgZnJlbmNoIGxvY2FsZXMgYXQgdGhlIG1vbWVudClcbiAgaWYgKGxvY2FsZS5sb2NhbGl6ZS5wcmVwcm9jZXNzb3IpIHtcbiAgICBwYXJ0cyA9IGxvY2FsZS5sb2NhbGl6ZS5wcmVwcm9jZXNzb3Iob3JpZ2luYWxEYXRlLCBwYXJ0cyk7XG4gIH1cblxuICBjb25zdCBmb3JtYXR0ZXJPcHRpb25zID0ge1xuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlLFxuICB9O1xuXG4gIHJldHVybiBwYXJ0c1xuICAgIC5tYXAoKHBhcnQpID0+IHtcbiAgICAgIGlmICghcGFydC5pc1Rva2VuKSByZXR1cm4gcGFydC52YWx1ZTtcblxuICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0LnZhbHVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucz8udXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zICYmXG4gICAgICAgICAgKDAsIF9pbmRleDUuaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKSh0b2tlbikpIHx8XG4gICAgICAgICghb3B0aW9ucz8udXNlQWRkaXRpb25hbERheU9mWWVhclRva2VucyAmJlxuICAgICAgICAgICgwLCBfaW5kZXg1LmlzUHJvdGVjdGVkRGF5T2ZZZWFyVG9rZW4pKHRva2VuKSlcbiAgICAgICkge1xuICAgICAgICAoMCwgX2luZGV4NS53YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKSh0b2tlbiwgZm9ybWF0U3RyLCBTdHJpbmcoZGF0ZSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBfaW5kZXgzLmZvcm1hdHRlcnNbdG9rZW5bMF1dO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcmlnaW5hbERhdGUsIHRva2VuLCBsb2NhbGUubG9jYWxpemUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH0pXG4gICAgLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICBjb25zdCBtYXRjaGVkID0gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cCk7XG5cbiAgaWYgKCFtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdERpc3RhbmNlID0gZm9ybWF0RGlzdGFuY2U7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29tcGFyZUFzYy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5Nb250aHMuanNcIik7XG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJblNlY29uZHMuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxudmFyIF9pbmRleDYgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRMb2NhbGUuanNcIik7XG52YXIgX2luZGV4NyA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG52YXIgX2luZGV4OCA9IHJlcXVpcmUoXCIuL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGZvcm1hdERpc3RhbmNlfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0RGlzdGFuY2VcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcyBpbiB3b3Jkcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMgaW4gd29yZHMuXG4gKlxuICogfCBEaXN0YW5jZSBiZXR3ZWVuIGRhdGVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJlc3VsdCAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAwIC4uLiAzMCBzZWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlc3MgdGhhbiBhIG1pbnV0ZSAgfFxuICogfCAzMCBzZWNzIC4uLiAxIG1pbiAzMCBzZWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDEgbWludXRlICAgICAgICAgICAgfFxuICogfCAxIG1pbiAzMCBzZWNzIC4uLiA0NCBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFsyLi40NF0gbWludXRlcyAgICAgfFxuICogfCA0NCBtaW5zIC4uLiAzMCBzZWNzIC4uLiA4OSBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFib3V0IDEgaG91ciAgICAgICAgfFxuICogfCA4OSBtaW5zIDMwIHNlY3MgLi4uIDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICB8IGFib3V0IFsyLi4yNF0gaG91cnMgfFxuICogfCAyMyBocnMgNTkgbWlucyAzMCBzZWNzIC4uLiA0MSBocnMgNTkgbWlucyAzMCBzZWNzICAgICAgICAgICAgICAgICB8IDEgZGF5ICAgICAgICAgICAgICAgfFxuICogfCA0MSBocnMgNTkgbWlucyAzMCBzZWNzIC4uLiAyOSBkYXlzIDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgICAgICAgICB8IFsyLi4zMF0gZGF5cyAgICAgICAgfFxuICogfCAyOSBkYXlzIDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDQ0IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyB8IGFib3V0IDEgbW9udGggICAgICAgfFxuICogfCA0NCBkYXlzIDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDU5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyB8IGFib3V0IDIgbW9udGhzICAgICAgfFxuICogfCA1OSBkYXlzIDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDEgeXIgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFsyLi4xMl0gbW9udGhzICAgICAgfFxuICogfCAxIHlyIC4uLiAxIHlyIDMgbW9udGhzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFib3V0IDEgeWVhciAgICAgICAgfFxuICogfCAxIHlyIDMgbW9udGhzIC4uLiAxIHlyIDkgbW9udGggcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG92ZXIgMSB5ZWFyICAgICAgICAgfFxuICogfCAxIHlyIDkgbW9udGhzIC4uLiAyIHlycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFsbW9zdCAyIHllYXJzICAgICAgfFxuICogfCBOIHlycyAuLi4gTiB5cnMgMyBtb250aHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFib3V0IE4geWVhcnMgICAgICAgfFxuICogfCBOIHlycyAzIG1vbnRocyAuLi4gTiB5cnMgOSBtb250aHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG92ZXIgTiB5ZWFycyAgICAgICAgfFxuICogfCBOIHlycyA5IG1vbnRocyAuLi4gTisxIHlycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFsbW9zdCBOKzEgeWVhcnMgICAgfFxuICpcbiAqIFdpdGggYG9wdGlvbnMuaW5jbHVkZVNlY29uZHMgPT0gdHJ1ZWA6XG4gKiB8IERpc3RhbmNlIGJldHdlZW4gZGF0ZXMgfCBSZXN1bHQgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IDAgc2VjcyAuLi4gNSBzZWNzICAgICAgfCBsZXNzIHRoYW4gNSBzZWNvbmRzICB8XG4gKiB8IDUgc2VjcyAuLi4gMTAgc2VjcyAgICAgfCBsZXNzIHRoYW4gMTAgc2Vjb25kcyB8XG4gKiB8IDEwIHNlY3MgLi4uIDIwIHNlY3MgICAgfCBsZXNzIHRoYW4gMjAgc2Vjb25kcyB8XG4gKiB8IDIwIHNlY3MgLi4uIDQwIHNlY3MgICAgfCBoYWxmIGEgbWludXRlICAgICAgICB8XG4gKiB8IDQwIHNlY3MgLi4uIDYwIHNlY3MgICAgfCBsZXNzIHRoYW4gYSBtaW51dGUgICB8XG4gKiB8IDYwIHNlY3MgLi4uIDkwIHNlY3MgICAgfCAxIG1pbnV0ZSAgICAgICAgICAgICB8XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZVxuICogQHBhcmFtIGJhc2VEYXRlIC0gVGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgaW4gd29yZHNcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYGJhc2VEYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdERpc3RhbmNlYCBwcm9wZXJ0eVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGF0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgSnVseSAyMDE0IGFuZCAxIEphbnVhcnkgMjAxNT9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlKG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBuZXcgRGF0ZSgyMDE1LCAwLCAxKSlcbiAqIC8vPT4gJzYgbW9udGhzJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGF0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDEgSmFudWFyeSAyMDE1IDAwOjAwOjE1XG4gKiAvLyBhbmQgMSBKYW51YXJ5IDIwMTUgMDA6MDA6MDAsIGluY2x1ZGluZyBzZWNvbmRzP1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2UoXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEsIDAsIDAsIDE1KSxcbiAqICAgbmV3IERhdGUoMjAxNSwgMCwgMSwgMCwgMCwgMCksXG4gKiAgIHsgaW5jbHVkZVNlY29uZHM6IHRydWUgfVxuICogKVxuICogLy89PiAnbGVzcyB0aGFuIDIwIHNlY29uZHMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGZyb20gMSBKYW51YXJ5IDIwMTZcbiAqIC8vIHRvIDEgSmFudWFyeSAyMDE1LCB3aXRoIGEgc3VmZml4P1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2UobmV3IERhdGUoMjAxNSwgMCwgMSksIG5ldyBEYXRlKDIwMTYsIDAsIDEpLCB7XG4gKiAgIGFkZFN1ZmZpeDogdHJ1ZVxuICogfSlcbiAqIC8vPT4gJ2Fib3V0IDEgeWVhciBhZ28nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMSBBdWd1c3QgMjAxNiBhbmQgMSBKYW51YXJ5IDIwMTUgaW4gRXNwZXJhbnRvP1xuICogaW1wb3J0IHsgZW9Mb2NhbGUgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZShuZXcgRGF0ZSgyMDE2LCA3LCAxKSwgbmV3IERhdGUoMjAxNSwgMCwgMSksIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJ3BsaSBvbCAxIGphcm8nXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0RGlzdGFuY2UoZGF0ZSwgYmFzZURhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoMCwgX2luZGV4Ny5nZXREZWZhdWx0T3B0aW9ucykoKTtcbiAgY29uc3QgbG9jYWxlID1cbiAgICBvcHRpb25zPy5sb2NhbGUgPz8gZGVmYXVsdE9wdGlvbnMubG9jYWxlID8/IF9pbmRleDYuZGVmYXVsdExvY2FsZTtcbiAgY29uc3QgbWludXRlc0luQWxtb3N0VHdvRGF5cyA9IDI1MjA7XG5cbiAgY29uc3QgY29tcGFyaXNvbiA9ICgwLCBfaW5kZXguY29tcGFyZUFzYykoZGF0ZSwgYmFzZURhdGUpO1xuXG4gIGlmIChpc05hTihjb21wYXJpc29uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0aW1lIHZhbHVlXCIpO1xuICB9XG5cbiAgY29uc3QgbG9jYWxpemVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgIGFkZFN1ZmZpeDogb3B0aW9ucz8uYWRkU3VmZml4LFxuICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb24sXG4gIH0pO1xuXG4gIGxldCBkYXRlTGVmdDtcbiAgbGV0IGRhdGVSaWdodDtcbiAgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG4gICAgZGF0ZUxlZnQgPSAoMCwgX2luZGV4NS50b0RhdGUpKGJhc2VEYXRlKTtcbiAgICBkYXRlUmlnaHQgPSAoMCwgX2luZGV4NS50b0RhdGUpKGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGVMZWZ0ID0gKDAsIF9pbmRleDUudG9EYXRlKShkYXRlKTtcbiAgICBkYXRlUmlnaHQgPSAoMCwgX2luZGV4NS50b0RhdGUpKGJhc2VEYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHNlY29uZHMgPSAoMCwgX2luZGV4NC5kaWZmZXJlbmNlSW5TZWNvbmRzKShkYXRlUmlnaHQsIGRhdGVMZWZ0KTtcbiAgY29uc3Qgb2Zmc2V0SW5TZWNvbmRzID1cbiAgICAoKDAsIF9pbmRleDguZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcykoZGF0ZVJpZ2h0KSAtXG4gICAgICAoMCwgX2luZGV4OC5nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKShkYXRlTGVmdCkpIC9cbiAgICAxMDAwO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZCgoc2Vjb25kcyAtIG9mZnNldEluU2Vjb25kcykgLyA2MCk7XG4gIGxldCBtb250aHM7XG5cbiAgLy8gMCB1cCB0byAyIG1pbnNcbiAgaWYgKG1pbnV0ZXMgPCAyKSB7XG4gICAgaWYgKG9wdGlvbnM/LmluY2x1ZGVTZWNvbmRzKSB7XG4gICAgICBpZiAoc2Vjb25kcyA8IDUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcImxlc3NUaGFuWFNlY29uZHNcIiwgNSwgbG9jYWxpemVPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vjb25kcyA8IDEwKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJsZXNzVGhhblhTZWNvbmRzXCIsIDEwLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgMjApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcImxlc3NUaGFuWFNlY29uZHNcIiwgMjAsIGxvY2FsaXplT3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHNlY29uZHMgPCA0MCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwiaGFsZkFNaW51dGVcIiwgMCwgbG9jYWxpemVPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vjb25kcyA8IDYwKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJsZXNzVGhhblhNaW51dGVzXCIsIDEsIGxvY2FsaXplT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwieE1pbnV0ZXNcIiwgMSwgbG9jYWxpemVPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1pbnV0ZXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcImxlc3NUaGFuWE1pbnV0ZXNcIiwgMSwgbG9jYWxpemVPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4TWludXRlc1wiLCBtaW51dGVzLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIgbWlucyB1cCB0byAwLjc1IGhyc1xuICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCA0NSkge1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4TWludXRlc1wiLCBtaW51dGVzLCBsb2NhbGl6ZU9wdGlvbnMpO1xuXG4gICAgLy8gMC43NSBocnMgdXAgdG8gMS41IGhyc1xuICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCA5MCkge1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJhYm91dFhIb3Vyc1wiLCAxLCBsb2NhbGl6ZU9wdGlvbnMpO1xuXG4gICAgLy8gMS41IGhycyB1cCB0byAyNCBocnNcbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgX2luZGV4Mi5taW51dGVzSW5EYXkpIHtcbiAgICBjb25zdCBob3VycyA9IE1hdGgucm91bmQobWludXRlcyAvIDYwKTtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwiYWJvdXRYSG91cnNcIiwgaG91cnMsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIGRheSB1cCB0byAxLjc1IGRheXNcbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgbWludXRlc0luQWxtb3N0VHdvRGF5cykge1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4RGF5c1wiLCAxLCBsb2NhbGl6ZU9wdGlvbnMpO1xuXG4gICAgLy8gMS43NSBkYXlzIHVwIHRvIDMwIGRheXNcbiAgfSBlbHNlIGlmIChtaW51dGVzIDwgX2luZGV4Mi5taW51dGVzSW5Nb250aCkge1xuICAgIGNvbnN0IGRheXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXMgLyBfaW5kZXgyLm1pbnV0ZXNJbkRheSk7XG4gICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcInhEYXlzXCIsIGRheXMsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIG1vbnRoIHVwIHRvIDIgbW9udGhzXG4gIH0gZWxzZSBpZiAobWludXRlcyA8IF9pbmRleDIubWludXRlc0luTW9udGggKiAyKSB7XG4gICAgbW9udGhzID0gTWF0aC5yb3VuZChtaW51dGVzIC8gX2luZGV4Mi5taW51dGVzSW5Nb250aCk7XG4gICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcImFib3V0WE1vbnRoc1wiLCBtb250aHMsIGxvY2FsaXplT3B0aW9ucyk7XG4gIH1cblxuICBtb250aHMgPSAoMCwgX2luZGV4My5kaWZmZXJlbmNlSW5Nb250aHMpKGRhdGVSaWdodCwgZGF0ZUxlZnQpO1xuXG4gIC8vIDIgbW9udGhzIHVwIHRvIDEyIG1vbnRoc1xuICBpZiAobW9udGhzIDwgMTIpIHtcbiAgICBjb25zdCBuZWFyZXN0TW9udGggPSBNYXRoLnJvdW5kKG1pbnV0ZXMgLyBfaW5kZXgyLm1pbnV0ZXNJbk1vbnRoKTtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwieE1vbnRoc1wiLCBuZWFyZXN0TW9udGgsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIHllYXIgdXAgdG8gbWF4IERhdGVcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtb250aHNTaW5jZVN0YXJ0T2ZZZWFyID0gbW9udGhzICUgMTI7XG4gICAgY29uc3QgeWVhcnMgPSBNYXRoLnRydW5jKG1vbnRocyAvIDEyKTtcblxuICAgIC8vIE4geWVhcnMgdXAgdG8gMSB5ZWFycyAzIG1vbnRoc1xuICAgIGlmIChtb250aHNTaW5jZVN0YXJ0T2ZZZWFyIDwgMykge1xuICAgICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcImFib3V0WFllYXJzXCIsIHllYXJzLCBsb2NhbGl6ZU9wdGlvbnMpO1xuXG4gICAgICAvLyBOIHllYXJzIDMgbW9udGhzIHVwIHRvIE4geWVhcnMgOSBtb250aHNcbiAgICB9IGVsc2UgaWYgKG1vbnRoc1NpbmNlU3RhcnRPZlllYXIgPCA5KSB7XG4gICAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwib3ZlclhZZWFyc1wiLCB5ZWFycywgbG9jYWxpemVPcHRpb25zKTtcblxuICAgICAgLy8gTiB5ZWFycyA5IG1vbnRocyB1cCB0byBOIHllYXIgMTIgbW9udGhzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJhbG1vc3RYWWVhcnNcIiwgeWVhcnMgKyAxLCBsb2NhbGl6ZU9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdERpc3RhbmNlU3RyaWN0ID0gZm9ybWF0RGlzdGFuY2VTdHJpY3Q7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0TG9jYWxlLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9fbGliL2dldFJvdW5kaW5nTWV0aG9kLmpzXCIpO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL2NvbXBhcmVBc2MuanNcIik7XG52YXIgX2luZGV4NiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIF9pbmRleDcgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXREaXN0YW5jZVN0cmljdH0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFRoZSB1bml0IHVzZWQgdG8gZm9ybWF0IHRoZSBkaXN0YW5jZSBpbiB7QGxpbmsgZm9ybWF0RGlzdGFuY2VTdHJpY3R9LlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0RGlzdGFuY2VTdHJpY3RcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcyBpbiB3b3Jkcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMgaW4gd29yZHMsIHVzaW5nIHN0cmljdCB1bml0cy5cbiAqIFRoaXMgaXMgbGlrZSBgZm9ybWF0RGlzdGFuY2VgLCBidXQgZG9lcyBub3QgdXNlIGhlbHBlcnMgbGlrZSAnYWxtb3N0JywgJ292ZXInLFxuICogJ2xlc3MgdGhhbicgYW5kIHRoZSBsaWtlLlxuICpcbiAqIHwgRGlzdGFuY2UgYmV0d2VlbiBkYXRlcyB8IFJlc3VsdCAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IDAgLi4uIDU5IHNlY3MgICAgICAgICAgfCBbMC4uNTldIHNlY29uZHMgICAgIHxcbiAqIHwgMSAuLi4gNTkgbWlucyAgICAgICAgICB8IFsxLi41OV0gbWludXRlcyAgICAgfFxuICogfCAxIC4uLiAyMyBocnMgICAgICAgICAgIHwgWzEuLjIzXSBob3VycyAgICAgICB8XG4gKiB8IDEgLi4uIDI5IGRheXMgICAgICAgICAgfCBbMS4uMjldIGRheXMgICAgICAgIHxcbiAqIHwgMSAuLi4gMTEgbW9udGhzICAgICAgICB8IFsxLi4xMV0gbW9udGhzICAgICAgfFxuICogfCAxIC4uLiBOIHllYXJzICAgICAgICAgIHwgWzEuLk5dICB5ZWFycyAgICAgICB8XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZVxuICogQHBhcmFtIGJhc2VEYXRlIC0gVGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgaW4gd29yZHNcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYGJhc2VEYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYG9wdGlvbnMudW5pdGAgbXVzdCBiZSAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICdtb250aCcgb3IgJ3llYXInXG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXREaXN0YW5jZWAgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIEp1bHkgMjAxNCBhbmQgMSBKYW51YXJ5IDIwMTU/XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZVN0cmljdChuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgbmV3IERhdGUoMjAxNSwgMCwgMikpXG4gKiAvLz0+ICc2IG1vbnRocydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAxIEphbnVhcnkgMjAxNSAwMDowMDoxNVxuICogLy8gYW5kIDEgSmFudWFyeSAyMDE1IDAwOjAwOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VTdHJpY3QoXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEsIDAsIDAsIDE1KSxcbiAqICAgbmV3IERhdGUoMjAxNSwgMCwgMSwgMCwgMCwgMClcbiAqIClcbiAqIC8vPT4gJzE1IHNlY29uZHMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGZyb20gMSBKYW51YXJ5IDIwMTZcbiAqIC8vIHRvIDEgSmFudWFyeSAyMDE1LCB3aXRoIGEgc3VmZml4P1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VTdHJpY3QobmV3IERhdGUoMjAxNSwgMCwgMSksIG5ldyBEYXRlKDIwMTYsIDAsIDEpLCB7XG4gKiAgIGFkZFN1ZmZpeDogdHJ1ZVxuICogfSlcbiAqIC8vPT4gJzEgeWVhciBhZ28nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGZyb20gMSBKYW51YXJ5IDIwMTZcbiAqIC8vIHRvIDEgSmFudWFyeSAyMDE1LCBpbiBtaW51dGVzP1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VTdHJpY3QobmV3IERhdGUoMjAxNiwgMCwgMSksIG5ldyBEYXRlKDIwMTUsIDAsIDEpLCB7XG4gKiAgIHVuaXQ6ICdtaW51dGUnXG4gKiB9KVxuICogLy89PiAnNTI1NjAwIG1pbnV0ZXMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGZyb20gMSBKYW51YXJ5IDIwMTVcbiAqIC8vIHRvIDI4IEphbnVhcnkgMjAxNSwgaW4gbW9udGhzLCByb3VuZGVkIHVwP1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VTdHJpY3QobmV3IERhdGUoMjAxNSwgMCwgMjgpLCBuZXcgRGF0ZSgyMDE1LCAwLCAxKSwge1xuICogICB1bml0OiAnbW9udGgnLFxuICogICByb3VuZGluZ01ldGhvZDogJ2NlaWwnXG4gKiB9KVxuICogLy89PiAnMSBtb250aCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAxIEF1Z3VzdCAyMDE2IGFuZCAxIEphbnVhcnkgMjAxNSBpbiBFc3BlcmFudG8/XG4gKiBpbXBvcnQgeyBlb0xvY2FsZSB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlU3RyaWN0KG5ldyBEYXRlKDIwMTYsIDcsIDEpLCBuZXcgRGF0ZSgyMDE1LCAwLCAxKSwge1xuICogICBsb2NhbGU6IGVvTG9jYWxlXG4gKiB9KVxuICogLy89PiAnMSBqYXJvJ1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdERpc3RhbmNlU3RyaWN0KGRhdGUsIGJhc2VEYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gKDAsIF9pbmRleDIuZ2V0RGVmYXVsdE9wdGlvbnMpKCk7XG4gIGNvbnN0IGxvY2FsZSA9XG4gICAgb3B0aW9ucz8ubG9jYWxlID8/IGRlZmF1bHRPcHRpb25zLmxvY2FsZSA/PyBfaW5kZXguZGVmYXVsdExvY2FsZTtcblxuICBjb25zdCBjb21wYXJpc29uID0gKDAsIF9pbmRleDUuY29tcGFyZUFzYykoZGF0ZSwgYmFzZURhdGUpO1xuXG4gIGlmIChpc05hTihjb21wYXJpc29uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0aW1lIHZhbHVlXCIpO1xuICB9XG5cbiAgY29uc3QgbG9jYWxpemVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgIGFkZFN1ZmZpeDogb3B0aW9ucz8uYWRkU3VmZml4LFxuICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb24sXG4gIH0pO1xuXG4gIGxldCBkYXRlTGVmdDtcbiAgbGV0IGRhdGVSaWdodDtcbiAgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG4gICAgZGF0ZUxlZnQgPSAoMCwgX2luZGV4Ny50b0RhdGUpKGJhc2VEYXRlKTtcbiAgICBkYXRlUmlnaHQgPSAoMCwgX2luZGV4Ny50b0RhdGUpKGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGVMZWZ0ID0gKDAsIF9pbmRleDcudG9EYXRlKShkYXRlKTtcbiAgICBkYXRlUmlnaHQgPSAoMCwgX2luZGV4Ny50b0RhdGUpKGJhc2VEYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHJvdW5kaW5nTWV0aG9kID0gKDAsIF9pbmRleDMuZ2V0Um91bmRpbmdNZXRob2QpKFxuICAgIG9wdGlvbnM/LnJvdW5kaW5nTWV0aG9kID8/IFwicm91bmRcIixcbiAgKTtcblxuICBjb25zdCBtaWxsaXNlY29uZHMgPSBkYXRlUmlnaHQuZ2V0VGltZSgpIC0gZGF0ZUxlZnQuZ2V0VGltZSgpO1xuICBjb25zdCBtaW51dGVzID0gbWlsbGlzZWNvbmRzIC8gX2luZGV4Ni5taWxsaXNlY29uZHNJbk1pbnV0ZTtcblxuICBjb25zdCB0aW1lem9uZU9mZnNldCA9XG4gICAgKDAsIF9pbmRleDQuZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcykoZGF0ZVJpZ2h0KSAtXG4gICAgKDAsIF9pbmRleDQuZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcykoZGF0ZUxlZnQpO1xuXG4gIC8vIFVzZSBEU1Qtbm9ybWFsaXplZCBkaWZmZXJlbmNlIGluIG1pbnV0ZXMgZm9yIHllYXJzLCBtb250aHMgYW5kIGRheXM7XG4gIC8vIHVzZSByZWd1bGFyIGRpZmZlcmVuY2UgaW4gbWludXRlcyBmb3IgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMuXG4gIGNvbnN0IGRzdE5vcm1hbGl6ZWRNaW51dGVzID1cbiAgICAobWlsbGlzZWNvbmRzIC0gdGltZXpvbmVPZmZzZXQpIC8gX2luZGV4Ni5taWxsaXNlY29uZHNJbk1pbnV0ZTtcblxuICBjb25zdCBkZWZhdWx0VW5pdCA9IG9wdGlvbnM/LnVuaXQ7XG4gIGxldCB1bml0O1xuICBpZiAoIWRlZmF1bHRVbml0KSB7XG4gICAgaWYgKG1pbnV0ZXMgPCAxKSB7XG4gICAgICB1bml0ID0gXCJzZWNvbmRcIjtcbiAgICB9IGVsc2UgaWYgKG1pbnV0ZXMgPCA2MCkge1xuICAgICAgdW5pdCA9IFwibWludXRlXCI7XG4gICAgfSBlbHNlIGlmIChtaW51dGVzIDwgX2luZGV4Ni5taW51dGVzSW5EYXkpIHtcbiAgICAgIHVuaXQgPSBcImhvdXJcIjtcbiAgICB9IGVsc2UgaWYgKGRzdE5vcm1hbGl6ZWRNaW51dGVzIDwgX2luZGV4Ni5taW51dGVzSW5Nb250aCkge1xuICAgICAgdW5pdCA9IFwiZGF5XCI7XG4gICAgfSBlbHNlIGlmIChkc3ROb3JtYWxpemVkTWludXRlcyA8IF9pbmRleDYubWludXRlc0luWWVhcikge1xuICAgICAgdW5pdCA9IFwibW9udGhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IFwieWVhclwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1bml0ID0gZGVmYXVsdFVuaXQ7XG4gIH1cblxuICAvLyAwIHVwIHRvIDYwIHNlY29uZHNcbiAgaWYgKHVuaXQgPT09IFwic2Vjb25kXCIpIHtcbiAgICBjb25zdCBzZWNvbmRzID0gcm91bmRpbmdNZXRob2QobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcInhTZWNvbmRzXCIsIHNlY29uZHMsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIHVwIHRvIDYwIG1pbnNcbiAgfSBlbHNlIGlmICh1bml0ID09PSBcIm1pbnV0ZVwiKSB7XG4gICAgY29uc3Qgcm91bmRlZE1pbnV0ZXMgPSByb3VuZGluZ01ldGhvZChtaW51dGVzKTtcbiAgICByZXR1cm4gbG9jYWxlLmZvcm1hdERpc3RhbmNlKFwieE1pbnV0ZXNcIiwgcm91bmRlZE1pbnV0ZXMsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIHVwIHRvIDI0IGhvdXJzXG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gXCJob3VyXCIpIHtcbiAgICBjb25zdCBob3VycyA9IHJvdW5kaW5nTWV0aG9kKG1pbnV0ZXMgLyA2MCk7XG4gICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcInhIb3Vyc1wiLCBob3VycywgbG9jYWxpemVPcHRpb25zKTtcblxuICAgIC8vIDEgdXAgdG8gMzAgZGF5c1xuICB9IGVsc2UgaWYgKHVuaXQgPT09IFwiZGF5XCIpIHtcbiAgICBjb25zdCBkYXlzID0gcm91bmRpbmdNZXRob2QoZHN0Tm9ybWFsaXplZE1pbnV0ZXMgLyBfaW5kZXg2Lm1pbnV0ZXNJbkRheSk7XG4gICAgcmV0dXJuIGxvY2FsZS5mb3JtYXREaXN0YW5jZShcInhEYXlzXCIsIGRheXMsIGxvY2FsaXplT3B0aW9ucyk7XG5cbiAgICAvLyAxIHVwIHRvIDEyIG1vbnRoc1xuICB9IGVsc2UgaWYgKHVuaXQgPT09IFwibW9udGhcIikge1xuICAgIGNvbnN0IG1vbnRocyA9IHJvdW5kaW5nTWV0aG9kKFxuICAgICAgZHN0Tm9ybWFsaXplZE1pbnV0ZXMgLyBfaW5kZXg2Lm1pbnV0ZXNJbk1vbnRoLFxuICAgICk7XG4gICAgcmV0dXJuIG1vbnRocyA9PT0gMTIgJiYgZGVmYXVsdFVuaXQgIT09IFwibW9udGhcIlxuICAgICAgPyBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4WWVhcnNcIiwgMSwgbG9jYWxpemVPcHRpb25zKVxuICAgICAgOiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4TW9udGhzXCIsIG1vbnRocywgbG9jYWxpemVPcHRpb25zKTtcblxuICAgIC8vIDEgeWVhciB1cCB0byBtYXggRGF0ZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHllYXJzID0gcm91bmRpbmdNZXRob2QoZHN0Tm9ybWFsaXplZE1pbnV0ZXMgLyBfaW5kZXg2Lm1pbnV0ZXNJblllYXIpO1xuICAgIHJldHVybiBsb2NhbGUuZm9ybWF0RGlzdGFuY2UoXCJ4WWVhcnNcIiwgeWVhcnMsIGxvY2FsaXplT3B0aW9ucyk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5mb3JtYXREaXN0YW5jZVRvTm93ID0gZm9ybWF0RGlzdGFuY2VUb05vdztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG5cbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZm9ybWF0RGlzdGFuY2UuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXREaXN0YW5jZVRvTm93fSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0RGlzdGFuY2VUb05vd1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGUgYW5kIG5vdyBpbiB3b3Jkcy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGUgYW5kIG5vdyBpbiB3b3Jkcy5cbiAqXG4gKiB8IERpc3RhbmNlIHRvIG5vdyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUmVzdWx0ICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IDAgLi4uIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVzcyB0aGFuIGEgbWludXRlICB8XG4gKiB8IDMwIHNlY3MgLi4uIDEgbWluIDMwIHNlY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMSBtaW51dGUgICAgICAgICAgICB8XG4gKiB8IDEgbWluIDMwIHNlY3MgLi4uIDQ0IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjQ0XSBtaW51dGVzICAgICB8XG4gKiB8IDQ0IG1pbnMgLi4uIDMwIHNlY3MgLi4uIDg5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSBob3VyICAgICAgICB8XG4gKiB8IDg5IG1pbnMgMzAgc2VjcyAuLi4gMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgWzIuLjI0XSBob3VycyB8XG4gKiB8IDIzIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgICAgICAgICAgICAgICAgIHwgMSBkYXkgICAgICAgICAgICAgICB8XG4gKiB8IDQxIGhycyA1OSBtaW5zIDMwIHNlY3MgLi4uIDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAgICAgICAgIHwgWzIuLjMwXSBkYXlzICAgICAgICB8XG4gKiB8IDI5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNDQgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMSBtb250aCAgICAgICB8XG4gKiB8IDQ0IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gNTkgZGF5cyAyMyBocnMgNTkgbWlucyAzMCBzZWNzIHwgYWJvdXQgMiBtb250aHMgICAgICB8XG4gKiB8IDU5IGRheXMgMjMgaHJzIDU5IG1pbnMgMzAgc2VjcyAuLi4gMSB5ciAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWzIuLjEyXSBtb250aHMgICAgICB8XG4gKiB8IDEgeXIgLi4uIDEgeXIgMyBtb250aHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgMSB5ZWFyICAgICAgICB8XG4gKiB8IDEgeXIgMyBtb250aHMgLi4uIDEgeXIgOSBtb250aCBzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciAxIHllYXIgICAgICAgICB8XG4gKiB8IDEgeXIgOSBtb250aHMgLi4uIDIgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IDIgeWVhcnMgICAgICB8XG4gKiB8IE4geXJzIC4uLiBOIHlycyAzIG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWJvdXQgTiB5ZWFycyAgICAgICB8XG4gKiB8IE4geXJzIDMgbW9udGhzIC4uLiBOIHlycyA5IG1vbnRocyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3ZlciBOIHllYXJzICAgICAgICB8XG4gKiB8IE4geXJzIDkgbW9udGhzIC4uLiBOKzEgeXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWxtb3N0IE4rMSB5ZWFycyAgICB8XG4gKlxuICogV2l0aCBgb3B0aW9ucy5pbmNsdWRlU2Vjb25kcyA9PSB0cnVlYDpcbiAqIHwgRGlzdGFuY2UgdG8gbm93ICAgICB8IFJlc3VsdCAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgMCBzZWNzIC4uLiA1IHNlY3MgICB8IGxlc3MgdGhhbiA1IHNlY29uZHMgIHxcbiAqIHwgNSBzZWNzIC4uLiAxMCBzZWNzICB8IGxlc3MgdGhhbiAxMCBzZWNvbmRzIHxcbiAqIHwgMTAgc2VjcyAuLi4gMjAgc2VjcyB8IGxlc3MgdGhhbiAyMCBzZWNvbmRzIHxcbiAqIHwgMjAgc2VjcyAuLi4gNDAgc2VjcyB8IGhhbGYgYSBtaW51dGUgICAgICAgIHxcbiAqIHwgNDAgc2VjcyAuLi4gNjAgc2VjcyB8IGxlc3MgdGhhbiBhIG1pbnV0ZSAgIHxcbiAqIHwgNjAgc2VjcyAuLi4gOTAgc2VjcyB8IDEgbWludXRlICAgICAgICAgICAgIHxcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGluIHdvcmRzXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXREaXN0YW5jZWAgcHJvcGVydHlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgMSBKYW51YXJ5IDIwMTUsIHdoYXQgaXMgdGhlIGRpc3RhbmNlIHRvIDIgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VUb05vdyhcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMilcbiAqIClcbiAqIC8vPT4gJzYgbW9udGhzJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiBub3cgaXMgMSBKYW51YXJ5IDIwMTUgMDA6MDA6MDAsXG4gKiAvLyB3aGF0IGlzIHRoZSBkaXN0YW5jZSB0byAxIEphbnVhcnkgMjAxNSAwMDowMDoxNSwgaW5jbHVkaW5nIHNlY29uZHM/XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZVRvTm93KFxuICogICBuZXcgRGF0ZSgyMDE1LCAwLCAxLCAwLCAwLCAxNSksXG4gKiAgIHtpbmNsdWRlU2Vjb25kczogdHJ1ZX1cbiAqIClcbiAqIC8vPT4gJ2xlc3MgdGhhbiAyMCBzZWNvbmRzJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAxIEphbnVhcnkgMjAxNSxcbiAqIC8vIHdoYXQgaXMgdGhlIGRpc3RhbmNlIHRvIDEgSmFudWFyeSAyMDE2LCB3aXRoIGEgc3VmZml4P1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VUb05vdyhcbiAqICAgbmV3IERhdGUoMjAxNiwgMCwgMSksXG4gKiAgIHthZGRTdWZmaXg6IHRydWV9XG4gKiApXG4gKiAvLz0+ICdpbiBhYm91dCAxIHllYXInXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDEgSmFudWFyeSAyMDE1LFxuICogLy8gd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMSBBdWd1c3QgMjAxNiBpbiBFc3BlcmFudG8/XG4gKiBjb25zdCBlb0xvY2FsZSA9IHJlcXVpcmUoJ2RhdGUtZm5zL2xvY2FsZS9lbycpXG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZVRvTm93KFxuICogICBuZXcgRGF0ZSgyMDE2LCA3LCAxKSxcbiAqICAge2xvY2FsZTogZW9Mb2NhbGV9XG4gKiApXG4gKiAvLz0+ICdwbGkgb2wgMSBqYXJvJ1xuICovXG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZVRvTm93KGRhdGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLmZvcm1hdERpc3RhbmNlKShcbiAgICBkYXRlLFxuICAgICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSxcbiAgICBvcHRpb25zLFxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdERpc3RhbmNlVG9Ob3dTdHJpY3QgPSBmb3JtYXREaXN0YW5jZVRvTm93U3RyaWN0O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2Zvcm1hdERpc3RhbmNlU3RyaWN0LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXREaXN0YW5jZVRvTm93U3RyaWN0fSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0RGlzdGFuY2VUb05vd1N0cmljdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGUgYW5kIG5vdyBpbiB3b3Jkcy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzIGluIHdvcmRzLCB1c2luZyBzdHJpY3QgdW5pdHMuXG4gKiBUaGlzIGlzIGxpa2UgYGZvcm1hdERpc3RhbmNlYCwgYnV0IGRvZXMgbm90IHVzZSBoZWxwZXJzIGxpa2UgJ2FsbW9zdCcsICdvdmVyJyxcbiAqICdsZXNzIHRoYW4nIGFuZCB0aGUgbGlrZS5cbiAqXG4gKiB8IERpc3RhbmNlIGJldHdlZW4gZGF0ZXMgfCBSZXN1bHQgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAwIC4uLiA1OSBzZWNzICAgICAgICAgIHwgWzAuLjU5XSBzZWNvbmRzICAgICB8XG4gKiB8IDEgLi4uIDU5IG1pbnMgICAgICAgICAgfCBbMS4uNTldIG1pbnV0ZXMgICAgIHxcbiAqIHwgMSAuLi4gMjMgaHJzICAgICAgICAgICB8IFsxLi4yM10gaG91cnMgICAgICAgfFxuICogfCAxIC4uLiAyOSBkYXlzICAgICAgICAgIHwgWzEuLjI5XSBkYXlzICAgICAgICB8XG4gKiB8IDEgLi4uIDExIG1vbnRocyAgICAgICAgfCBbMS4uMTFdIG1vbnRocyAgICAgIHxcbiAqIHwgMSAuLi4gTiB5ZWFycyAgICAgICAgICB8IFsxLi5OXSAgeWVhcnMgICAgICAgfFxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgaW4gd29yZHNcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdERpc3RhbmNlYCBwcm9wZXJ0eVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAxIEphbnVhcnkgMjAxNSwgd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMiBKdWx5IDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXREaXN0YW5jZVRvTm93U3RyaWN0KFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyKVxuICogKVxuICogLy89PiAnNiBtb250aHMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIG5vdyBpcyAxIEphbnVhcnkgMjAxNSAwMDowMDowMCxcbiAqIC8vIHdoYXQgaXMgdGhlIGRpc3RhbmNlIHRvIDEgSmFudWFyeSAyMDE1IDAwOjAwOjE1LCBpbmNsdWRpbmcgc2Vjb25kcz9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3dTdHJpY3QoXG4gKiAgIG5ldyBEYXRlKDIwMTUsIDAsIDEsIDAsIDAsIDE1KVxuICogKVxuICogLy89PiAnMTUgc2Vjb25kcydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgMSBKYW51YXJ5IDIwMTUsXG4gKiAvLyB3aGF0IGlzIHRoZSBkaXN0YW5jZSB0byAxIEphbnVhcnkgMjAxNiwgd2l0aCBhIHN1ZmZpeD9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3dTdHJpY3QoXG4gKiAgIG5ldyBEYXRlKDIwMTYsIDAsIDEpLFxuICogICB7YWRkU3VmZml4OiB0cnVlfVxuICogKVxuICogLy89PiAnaW4gMSB5ZWFyJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAyOCBKYW51YXJ5IDIwMTUsXG4gKiAvLyB3aGF0IGlzIHRoZSBkaXN0YW5jZSB0byAxIEphbnVhcnkgMjAxNSwgaW4gbW9udGhzLCByb3VuZGVkIHVwPz9cbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdERpc3RhbmNlVG9Ob3dTdHJpY3QobmV3IERhdGUoMjAxNSwgMCwgMSksIHtcbiAqICAgdW5pdDogJ21vbnRoJyxcbiAqICAgcm91bmRpbmdNZXRob2Q6ICdjZWlsJ1xuICogfSlcbiAqIC8vPT4gJzEgbW9udGgnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDEgSmFudWFyeSAyMDE1LFxuICogLy8gd2hhdCBpcyB0aGUgZGlzdGFuY2UgdG8gMSBKYW51YXJ5IDIwMTYgaW4gRXNwZXJhbnRvP1xuICogY29uc3QgZW9Mb2NhbGUgPSByZXF1aXJlKCdkYXRlLWZucy9sb2NhbGUvZW8nKVxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VUb05vd1N0cmljdChcbiAqICAgbmV3IERhdGUoMjAxNiwgMCwgMSksXG4gKiAgIHtsb2NhbGU6IGVvTG9jYWxlfVxuICogKVxuICogLy89PiAnMSBqYXJvJ1xuICovXG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZVRvTm93U3RyaWN0KGRhdGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguZm9ybWF0RGlzdGFuY2VTdHJpY3QpKFxuICAgIGRhdGUsXG4gICAgKDAsIF9pbmRleDIuY29uc3RydWN0Tm93KShkYXRlKSxcbiAgICBvcHRpb25zLFxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdER1cmF0aW9uID0gZm9ybWF0RHVyYXRpb247XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRMb2NhbGUuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXREdXJhdGlvbn0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG5jb25zdCBkZWZhdWx0Rm9ybWF0ID0gW1xuICBcInllYXJzXCIsXG4gIFwibW9udGhzXCIsXG4gIFwid2Vla3NcIixcbiAgXCJkYXlzXCIsXG4gIFwiaG91cnNcIixcbiAgXCJtaW51dGVzXCIsXG4gIFwic2Vjb25kc1wiLFxuXTtcblxuLyoqXG4gKiBAbmFtZSBmb3JtYXREdXJhdGlvblxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXRzIGEgZHVyYXRpb24gaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gaHVtYW4tcmVhZGFibGUgZHVyYXRpb24gc3RyaW5nIGkuZS4gXCI5IG1vbnRocyAyIGRheXNcIlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBmb3JtYXRcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvcm1hdCBmdWxsIGR1cmF0aW9uXG4gKiBmb3JtYXREdXJhdGlvbih7XG4gKiAgIHllYXJzOiAyLFxuICogICBtb250aHM6IDksXG4gKiAgIHdlZWtzOiAxLFxuICogICBkYXlzOiA3LFxuICogICBob3VyczogNSxcbiAqICAgbWludXRlczogOSxcbiAqICAgc2Vjb25kczogMzBcbiAqIH0pXG4gKiAvLz0+ICcyIHllYXJzIDkgbW9udGhzIDEgd2VlayA3IGRheXMgNSBob3VycyA5IG1pbnV0ZXMgMzAgc2Vjb25kcydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9ybWF0IHBhcnRpYWwgZHVyYXRpb25cbiAqIGZvcm1hdER1cmF0aW9uKHsgbW9udGhzOiA5LCBkYXlzOiAyIH0pXG4gKiAvLz0+ICc5IG1vbnRocyAyIGRheXMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEN1c3RvbWl6ZSB0aGUgZm9ybWF0XG4gKiBmb3JtYXREdXJhdGlvbihcbiAqICAge1xuICogICAgIHllYXJzOiAyLFxuICogICAgIG1vbnRoczogOSxcbiAqICAgICB3ZWVrczogMSxcbiAqICAgICBkYXlzOiA3LFxuICogICAgIGhvdXJzOiA1LFxuICogICAgIG1pbnV0ZXM6IDksXG4gKiAgICAgc2Vjb25kczogMzBcbiAqICAgfSxcbiAqICAgeyBmb3JtYXQ6IFsnbW9udGhzJywgJ3dlZWtzJ10gfVxuICogKSA9PT0gJzkgbW9udGhzIDEgd2VlaydcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3VzdG9taXplIHRoZSB6ZXJvcyBwcmVzZW5jZVxuICogZm9ybWF0RHVyYXRpb24oeyB5ZWFyczogMCwgbW9udGhzOiA5IH0pXG4gKiAvLz0+ICc5IG1vbnRocydcbiAqIGZvcm1hdER1cmF0aW9uKHsgeWVhcnM6IDAsIG1vbnRoczogOSB9LCB7IHplcm86IHRydWUgfSlcbiAqIC8vPT4gJzAgeWVhcnMgOSBtb250aHMnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEN1c3RvbWl6ZSB0aGUgZGVsaW1pdGVyXG4gKiBmb3JtYXREdXJhdGlvbih7IHllYXJzOiAyLCBtb250aHM6IDksIHdlZWtzOiAzIH0sIHsgZGVsaW1pdGVyOiAnLCAnIH0pXG4gKiAvLz0+ICcyIHllYXJzLCA5IG1vbnRocywgMyB3ZWVrcydcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoMCwgX2luZGV4Mi5nZXREZWZhdWx0T3B0aW9ucykoKTtcbiAgY29uc3QgbG9jYWxlID1cbiAgICBvcHRpb25zPy5sb2NhbGUgPz8gZGVmYXVsdE9wdGlvbnMubG9jYWxlID8/IF9pbmRleC5kZWZhdWx0TG9jYWxlO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gZGVmYXVsdEZvcm1hdDtcbiAgY29uc3QgemVybyA9IG9wdGlvbnM/Lnplcm8gPz8gZmFsc2U7XG4gIGNvbnN0IGRlbGltaXRlciA9IG9wdGlvbnM/LmRlbGltaXRlciA/PyBcIiBcIjtcblxuICBpZiAoIWxvY2FsZS5mb3JtYXREaXN0YW5jZSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gZm9ybWF0XG4gICAgLnJlZHVjZSgoYWNjLCB1bml0KSA9PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IGB4JHt1bml0LnJlcGxhY2UoLyheLikvLCAobSkgPT4gbS50b1VwcGVyQ2FzZSgpKX1gO1xuICAgICAgY29uc3QgdmFsdWUgPSBkdXJhdGlvblt1bml0XTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICh6ZXJvIHx8IGR1cmF0aW9uW3VuaXRdKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChsb2NhbGUuZm9ybWF0RGlzdGFuY2UodG9rZW4sIHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5qb2luKGRlbGltaXRlcik7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5mb3JtYXRJU08gPSBmb3JtYXRJU087XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL19saWIvYWRkTGVhZGluZ1plcm9zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZm9ybWF0SVNPfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0SVNPXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkIChodHRwczovL3N1cHBvcnQuc2FzLmNvbS9kb2N1bWVudGF0aW9uL2NkbC9lbi9scmRpY3QvNjQzMTYvSFRNTC9kZWZhdWx0L3ZpZXdlci5odG0jYTAwMzE2OTgxNC5odG0pLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gSVNPIDg2MDEgZm9ybWF0LiBPcHRpb25zIG1heSBiZSBwYXNzZWQgdG8gY29udHJvbCB0aGUgcGFydHMgYW5kIG5vdGF0aW9ucyBvZiB0aGUgZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyAoaW4gbG9jYS5sIHRpbWUgem9uZSlcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDE4IFNlcHRlbWJlciAyMDE5IGluIElTTyA4NjAxIGZvcm1hdCAobG9jYWwgdGltZSB6b25lIGlzIFVUQyk6XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRJU08obmV3IERhdGUoMjAxOSwgOCwgMTgsIDE5LCAwLCA1MikpXG4gKiAvLz0+ICcyMDE5LTA5LTE4VDE5OjAwOjUyWidcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDE4IFNlcHRlbWJlciAyMDE5IGluIElTTyA4NjAxLCBzaG9ydCBmb3JtYXQgKGxvY2FsIHRpbWUgem9uZSBpcyBVVEMpOlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0SVNPKG5ldyBEYXRlKDIwMTksIDgsIDE4LCAxOSwgMCwgNTIpLCB7IGZvcm1hdDogJ2Jhc2ljJyB9KVxuICogLy89PiAnMjAxOTA5MThUMTkwMDUyJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDg2MDEgZm9ybWF0LCBkYXRlIG9ubHk6XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRJU08obmV3IERhdGUoMjAxOSwgOCwgMTgsIDE5LCAwLCA1MiksIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KVxuICogLy89PiAnMjAxOS0wOS0xOCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDE4IFNlcHRlbWJlciAyMDE5IGluIElTTyA4NjAxIGZvcm1hdCwgdGltZSBvbmx5IChsb2NhbCB0aW1lIHpvbmUgaXMgVVRDKTpcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdElTTyhuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSwgeyByZXByZXNlbnRhdGlvbjogJ3RpbWUnIH0pXG4gKiAvLz0+ICcxOTowMDo1MlonXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElTTyhkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuXG4gIGlmIChpc05hTihfZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgPz8gXCJleHRlbmRlZFwiO1xuICBjb25zdCByZXByZXNlbnRhdGlvbiA9IG9wdGlvbnM/LnJlcHJlc2VudGF0aW9uID8/IFwiY29tcGxldGVcIjtcblxuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgbGV0IHR6T2Zmc2V0ID0gXCJcIjtcblxuICBjb25zdCBkYXRlRGVsaW1pdGVyID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCIgPyBcIi1cIiA6IFwiXCI7XG4gIGNvbnN0IHRpbWVEZWxpbWl0ZXIgPSBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiA/IFwiOlwiIDogXCJcIjtcblxuICAvLyBSZXByZXNlbnRhdGlvbiBpcyBlaXRoZXIgJ2RhdGUnIG9yICdjb21wbGV0ZSdcbiAgaWYgKHJlcHJlc2VudGF0aW9uICE9PSBcInRpbWVcIikge1xuICAgIGNvbnN0IGRheSA9ICgwLCBfaW5kZXgyLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgICBjb25zdCBtb250aCA9ICgwLCBfaW5kZXgyLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuICAgIGNvbnN0IHllYXIgPSAoMCwgX2luZGV4Mi5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuXG4gICAgLy8geXl5eU1NZGQgb3IgeXl5eS1NTS1kZC5cbiAgICByZXN1bHQgPSBgJHt5ZWFyfSR7ZGF0ZURlbGltaXRlcn0ke21vbnRofSR7ZGF0ZURlbGltaXRlcn0ke2RheX1gO1xuICB9XG5cbiAgLy8gUmVwcmVzZW50YXRpb24gaXMgZWl0aGVyICd0aW1lJyBvciAnY29tcGxldGUnXG4gIGlmIChyZXByZXNlbnRhdGlvbiAhPT0gXCJkYXRlXCIpIHtcbiAgICAvLyBBZGQgdGhlIHRpbWV6b25lLlxuICAgIGNvbnN0IG9mZnNldCA9IF9kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICBjb25zdCBhYnNvbHV0ZU9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICBjb25zdCBob3VyT2Zmc2V0ID0gKDAsIF9pbmRleDIuYWRkTGVhZGluZ1plcm9zKShcbiAgICAgICAgTWF0aC50cnVuYyhhYnNvbHV0ZU9mZnNldCAvIDYwKSxcbiAgICAgICAgMixcbiAgICAgICk7XG4gICAgICBjb25zdCBtaW51dGVPZmZzZXQgPSAoMCwgX2luZGV4Mi5hZGRMZWFkaW5nWmVyb3MpKGFic29sdXRlT2Zmc2V0ICUgNjAsIDIpO1xuICAgICAgLy8gSWYgbGVzcyB0aGFuIDAsIHRoZSBzaWduIGlzICssIGJlY2F1c2UgaXQgaXMgYWhlYWQgb2YgdGltZS5cbiAgICAgIGNvbnN0IHNpZ24gPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcblxuICAgICAgdHpPZmZzZXQgPSBgJHtzaWdufSR7aG91ck9mZnNldH06JHttaW51dGVPZmZzZXR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHpPZmZzZXQgPSBcIlpcIjtcbiAgICB9XG5cbiAgICBjb25zdCBob3VyID0gKDAsIF9pbmRleDIuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICBjb25zdCBtaW51dGUgPSAoMCwgX2luZGV4Mi5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gICAgY29uc3Qgc2Vjb25kID0gKDAsIF9pbmRleDIuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRTZWNvbmRzKCksIDIpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBhbHNvIGRhdGUsIHNlcGFyYXRlIGl0IHdpdGggdGltZSB3aXRoICdUJ1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IHJlc3VsdCA9PT0gXCJcIiA/IFwiXCIgOiBcIlRcIjtcblxuICAgIC8vIENyZWF0ZXMgYSB0aW1lIHN0cmluZyBjb25zaXN0aW5nIG9mIGhvdXIsIG1pbnV0ZSwgYW5kIHNlY29uZCwgc2VwYXJhdGVkIGJ5IGRlbGltaXRlcnMsIGlmIGRlZmluZWQuXG4gICAgY29uc3QgdGltZSA9IFtob3VyLCBtaW51dGUsIHNlY29uZF0uam9pbih0aW1lRGVsaW1pdGVyKTtcblxuICAgIC8vIEhIbW1zcyBvciBISDptbTpzcy5cbiAgICByZXN1bHQgPSBgJHtyZXN1bHR9JHtzZXBhcmF0b3J9JHt0aW1lfSR7dHpPZmZzZXR9YDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZm9ybWF0SVNPOTA3NSA9IGZvcm1hdElTTzkwNzU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaXNWYWxpZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL19saWIvYWRkTGVhZGluZ1plcm9zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZm9ybWF0SVNPOTA3NX0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGZvcm1hdElTTzkwNzVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlIGFjY29yZGluZyB0byB0aGUgSVNPIDkwNzUgc3RhbmRhcmQgKGh0dHBzOi8vZGV2Lm15c3FsLmNvbS9kb2MvcmVmbWFuLzUuNy9lbi9kYXRlLWFuZC10aW1lLWZ1bmN0aW9ucy5odG1sI2Z1bmN0aW9uX2dldC1mb3JtYXQpLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gSVNPIDkwNzUgZm9ybWF0LiBPcHRpb25zIG1heSBiZSBwYXNzZWQgdG8gY29udHJvbCB0aGUgcGFydHMgYW5kIG5vdGF0aW9ucyBvZiB0aGUgZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICpcbiAqIEB0aHJvd3MgYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDkwNzUgZm9ybWF0OlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0SVNPOTA3NShuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSlcbiAqIC8vPT4gJzIwMTktMDktMTggMTk6MDA6NTInXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxOCBTZXB0ZW1iZXIgMjAxOSBpbiBJU08gOTA3NSwgc2hvcnQgZm9ybWF0OlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0SVNPOTA3NShuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSwgeyBmb3JtYXQ6ICdiYXNpYycgfSlcbiAqIC8vPT4gJzIwMTkwOTE4IDE5MDA1MidcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDE4IFNlcHRlbWJlciAyMDE5IGluIElTTyA5MDc1IGZvcm1hdCwgZGF0ZSBvbmx5OlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0SVNPOTA3NShuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pXG4gKiAvLz0+ICcyMDE5LTA5LTE4J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gSVNPIDkwNzUgZm9ybWF0LCB0aW1lIG9ubHk6XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRJU085MDc1KG5ldyBEYXRlKDIwMTksIDgsIDE4LCAxOSwgMCwgNTIpLCB7IHJlcHJlc2VudGF0aW9uOiAndGltZScgfSlcbiAqIC8vPT4gJzE5OjAwOjUyJ1xuICovXG5mdW5jdGlvbiBmb3JtYXRJU085MDc1KGRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGUpO1xuXG4gIGlmICghKDAsIF9pbmRleC5pc1ZhbGlkKShfZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGltZSB2YWx1ZVwiKTtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcImV4dGVuZGVkXCI7XG4gIGNvbnN0IHJlcHJlc2VudGF0aW9uID0gb3B0aW9ucz8ucmVwcmVzZW50YXRpb24gPz8gXCJjb21wbGV0ZVwiO1xuXG4gIGxldCByZXN1bHQgPSBcIlwiO1xuXG4gIGNvbnN0IGRhdGVEZWxpbWl0ZXIgPSBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiA/IFwiLVwiIDogXCJcIjtcbiAgY29uc3QgdGltZURlbGltaXRlciA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiID8gXCI6XCIgOiBcIlwiO1xuXG4gIC8vIFJlcHJlc2VudGF0aW9uIGlzIGVpdGhlciAnZGF0ZScgb3IgJ2NvbXBsZXRlJ1xuICBpZiAocmVwcmVzZW50YXRpb24gIT09IFwidGltZVwiKSB7XG4gICAgY29uc3QgZGF5ID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgIGNvbnN0IG1vbnRoID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgY29uc3QgeWVhciA9ICgwLCBfaW5kZXgzLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0RnVsbFllYXIoKSwgNCk7XG5cbiAgICAvLyB5eXl5TU1kZCBvciB5eXl5LU1NLWRkLlxuICAgIHJlc3VsdCA9IGAke3llYXJ9JHtkYXRlRGVsaW1pdGVyfSR7bW9udGh9JHtkYXRlRGVsaW1pdGVyfSR7ZGF5fWA7XG4gIH1cblxuICAvLyBSZXByZXNlbnRhdGlvbiBpcyBlaXRoZXIgJ3RpbWUnIG9yICdjb21wbGV0ZSdcbiAgaWYgKHJlcHJlc2VudGF0aW9uICE9PSBcImRhdGVcIikge1xuICAgIGNvbnN0IGhvdXIgPSAoMCwgX2luZGV4My5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldEhvdXJzKCksIDIpO1xuICAgIGNvbnN0IG1pbnV0ZSA9ICgwLCBfaW5kZXgzLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0TWludXRlcygpLCAyKTtcbiAgICBjb25zdCBzZWNvbmQgPSAoMCwgX2luZGV4My5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldFNlY29uZHMoKSwgMik7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGFsc28gZGF0ZSwgc2VwYXJhdGUgaXQgd2l0aCB0aW1lIHdpdGggYSBzcGFjZVxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHJlc3VsdCA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIjtcblxuICAgIC8vIEhIbW1zcyBvciBISDptbTpzcy5cbiAgICByZXN1bHQgPSBgJHtyZXN1bHR9JHtzZXBhcmF0b3J9JHtob3VyfSR7dGltZURlbGltaXRlcn0ke21pbnV0ZX0ke3RpbWVEZWxpbWl0ZXJ9JHtzZWNvbmR9YDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZm9ybWF0SVNPRHVyYXRpb24gPSBmb3JtYXRJU09EdXJhdGlvbjtcblxuLyoqXG4gKiBAbmFtZSBmb3JtYXRJU09EdXJhdGlvblxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgYSBkdXJhdGlvbiBvYmplY3QgYWNjb3JkaW5nIGFzIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRm9ybWF0IGEgZHVyYXRpb24gb2JqZWN0IGFjY29yZGluZyB0byB0aGUgSVNPIDg2MDEgZHVyYXRpb24gc3RhbmRhcmQgKGh0dHBzOi8vd3d3LmRpZ2kuY29tL3Jlc291cmNlcy9kb2N1bWVudGF0aW9uL2RpZ2lkb2NzLy85MDAwMTQ4OC0xMy9yZWZlcmVuY2Uvcl9pc29fODYwMV9kdXJhdGlvbl9mb3JtYXQuaHRtKVxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBmb3JtYXRcbiAqXG4gKiBAcmV0dXJucyBUaGUgSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvcm1hdCB0aGUgZ2l2ZW4gZHVyYXRpb24gYXMgSVNPIDg2MDEgc3RyaW5nXG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRJU09EdXJhdGlvbih7XG4gKiAgIHllYXJzOiAzOSxcbiAqICAgbW9udGhzOiAyLFxuICogICBkYXlzOiAyMCxcbiAqICAgaG91cnM6IDcsXG4gKiAgIG1pbnV0ZXM6IDUsXG4gKiAgIHNlY29uZHM6IDBcbiAqIH0pXG4gKiAvLz0+ICdQMzlZMk0yMERUMEgwTTBTJ1xuICovXG5mdW5jdGlvbiBmb3JtYXRJU09EdXJhdGlvbihkdXJhdGlvbikge1xuICBjb25zdCB7XG4gICAgeWVhcnMgPSAwLFxuICAgIG1vbnRocyA9IDAsXG4gICAgZGF5cyA9IDAsXG4gICAgaG91cnMgPSAwLFxuICAgIG1pbnV0ZXMgPSAwLFxuICAgIHNlY29uZHMgPSAwLFxuICB9ID0gZHVyYXRpb247XG5cbiAgcmV0dXJuIGBQJHt5ZWFyc31ZJHttb250aHN9TSR7ZGF5c31EVCR7aG91cnN9SCR7bWludXRlc31NJHtzZWNvbmRzfVNgO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdFJGQzMzMzkgPSBmb3JtYXRSRkMzMzM5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2lzVmFsaWQuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vX2xpYi9hZGRMZWFkaW5nWmVyb3MuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBmb3JtYXRSRkMzMzM5fSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZm9ybWF0UkZDMzMzOVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUgYWNjb3JkaW5nIHRvIHRoZSBSRkMgMzMzOSBzdGFuZGFyZCAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjYpLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gUkZDIDMzMzkgZm9ybWF0LiBPcHRpb25zIG1heSBiZSBwYXNzZWQgdG8gY29udHJvbCB0aGUgcGFydHMgYW5kIG5vdGF0aW9ucyBvZiB0aGUgZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICpcbiAqIEB0aHJvd3MgYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gUkZDIDMzMzkgZm9ybWF0OlxuICogZm9ybWF0UkZDMzMzOShuZXcgRGF0ZSgyMDE5LCA4LCAxOCwgMTksIDAsIDUyKSlcbiAqIC8vPT4gJzIwMTktMDktMThUMTk6MDA6NTJaJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgMTggU2VwdGVtYmVyIDIwMTkgaW4gUkZDIDMzMzkgZm9ybWF0LCAzIGRpZ2l0cyBvZiBzZWNvbmQgZnJhY3Rpb25cbiAqIGZvcm1hdFJGQzMzMzkobmV3IERhdGUoMjAxOSwgOCwgMTgsIDE5LCAwLCA1MiwgMjM0KSwge1xuICogICBmcmFjdGlvbkRpZ2l0czogM1xuICogfSlcbiAqIC8vPT4gJzIwMTktMDktMThUMTk6MDA6NTIuMjM0WidcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDIudG9EYXRlKShkYXRlKTtcblxuICBpZiAoISgwLCBfaW5kZXguaXNWYWxpZCkoX2RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IG9wdGlvbnM/LmZyYWN0aW9uRGlnaXRzID8/IDA7XG5cbiAgY29uc3QgZGF5ID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXREYXRlKCksIDIpO1xuICBjb25zdCBtb250aCA9ICgwLCBfaW5kZXgzLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuICBjb25zdCBob3VyID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgY29uc3QgbWludXRlID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICBjb25zdCBzZWNvbmQgPSAoMCwgX2luZGV4My5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldFNlY29uZHMoKSwgMik7XG5cbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBpZiAoZnJhY3Rpb25EaWdpdHMgPiAwKSB7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gX2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgY29uc3QgZnJhY3Rpb25hbFNlY29uZHMgPSBNYXRoLnRydW5jKFxuICAgICAgbWlsbGlzZWNvbmRzICogTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzIC0gMyksXG4gICAgKTtcbiAgICBmcmFjdGlvbmFsU2Vjb25kID1cbiAgICAgIFwiLlwiICsgKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShmcmFjdGlvbmFsU2Vjb25kcywgZnJhY3Rpb25EaWdpdHMpO1xuICB9XG5cbiAgbGV0IG9mZnNldCA9IFwiXCI7XG4gIGNvbnN0IHR6T2Zmc2V0ID0gX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICBpZiAodHpPZmZzZXQgIT09IDApIHtcbiAgICBjb25zdCBhYnNvbHV0ZU9mZnNldCA9IE1hdGguYWJzKHR6T2Zmc2V0KTtcbiAgICBjb25zdCBob3VyT2Zmc2V0ID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShcbiAgICAgIE1hdGgudHJ1bmMoYWJzb2x1dGVPZmZzZXQgLyA2MCksXG4gICAgICAyLFxuICAgICk7XG4gICAgY29uc3QgbWludXRlT2Zmc2V0ID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShhYnNvbHV0ZU9mZnNldCAlIDYwLCAyKTtcbiAgICAvLyBJZiBsZXNzIHRoYW4gMCwgdGhlIHNpZ24gaXMgKywgYmVjYXVzZSBpdCBpcyBhaGVhZCBvZiB0aW1lLlxuICAgIGNvbnN0IHNpZ24gPSB0ek9mZnNldCA8IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gICAgb2Zmc2V0ID0gYCR7c2lnbn0ke2hvdXJPZmZzZXR9OiR7bWludXRlT2Zmc2V0fWA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gXCJaXCI7XG4gIH1cblxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSR7ZnJhY3Rpb25hbFNlY29uZH0ke29mZnNldH1gO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZvcm1hdFJGQzcyMzEgPSBmb3JtYXRSRkM3MjMxO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2lzVmFsaWQuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vX2xpYi9hZGRMZWFkaW5nWmVyb3MuanNcIik7XG5cbmNvbnN0IGRheXMgPSBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl07XG5cbmNvbnN0IG1vbnRocyA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbi8qKlxuICogQG5hbWUgZm9ybWF0UkZDNzIzMVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUgYWNjb3JkaW5nIHRvIHRoZSBSRkMgNzIzMSBzdGFuZGFyZCAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi03LjEuMS4xKS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGluIFJGQyA3MjMxIGZvcm1hdC5cbiAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgaW4gVVRDIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxOCBTZXB0ZW1iZXIgMjAxOSBpbiBSRkMgNzIzMSBmb3JtYXQ6XG4gKiBjb25zdCByZXN1bHQgPSBmb3JtYXRSRkM3MjMxKG5ldyBEYXRlKDIwMTksIDgsIDE4LCAxOSwgMCwgNTIpKVxuICogLy89PiAnV2VkLCAxOCBTZXAgMjAxOSAxOTowMDo1MiBHTVQnXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFJGQzcyMzEoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG5cbiAgaWYgKCEoMCwgX2luZGV4LmlzVmFsaWQpKF9kYXRlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0aW1lIHZhbHVlXCIpO1xuICB9XG5cbiAgY29uc3QgZGF5TmFtZSA9IGRheXNbX2RhdGUuZ2V0VVRDRGF5KCldO1xuICBjb25zdCBkYXlPZk1vbnRoID0gKDAsIF9pbmRleDMuYWRkTGVhZGluZ1plcm9zKShfZGF0ZS5nZXRVVENEYXRlKCksIDIpO1xuICBjb25zdCBtb250aE5hbWUgPSBtb250aHNbX2RhdGUuZ2V0VVRDTW9udGgoKV07XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG4gIGNvbnN0IGhvdXIgPSAoMCwgX2luZGV4My5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldFVUQ0hvdXJzKCksIDIpO1xuICBjb25zdCBtaW51dGUgPSAoMCwgX2luZGV4My5hZGRMZWFkaW5nWmVyb3MpKF9kYXRlLmdldFVUQ01pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNlY29uZCA9ICgwLCBfaW5kZXgzLmFkZExlYWRpbmdaZXJvcykoX2RhdGUuZ2V0VVRDU2Vjb25kcygpLCAyKTtcblxuICAvLyBSZXN1bHQgdmFyaWFibGVzLlxuICByZXR1cm4gYCR7ZGF5TmFtZX0sICR7ZGF5T2ZNb250aH0gJHttb250aE5hbWV9ICR7eWVhcn0gJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9IEdNVGA7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZm9ybWF0UmVsYXRpdmUgPSBmb3JtYXRSZWxhdGl2ZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2Zvcm1hdC5qc1wiKTtcblxudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0TG9jYWxlLmpzXCIpO1xudmFyIF9pbmRleDUgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZm9ybWF0UmVsYXRpdmV9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBmb3JtYXRSZWxhdGl2ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXByZXNlbnQgdGhlIGRhdGUgaW4gd29yZHMgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGJhc2UgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlcHJlc2VudCB0aGUgZGF0ZSBpbiB3b3JkcyByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gYmFzZSBkYXRlLlxuICpcbiAqIHwgRGlzdGFuY2UgdG8gdGhlIGJhc2UgZGF0ZSB8IFJlc3VsdCAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IFByZXZpb3VzIDYgZGF5cyAgICAgICAgICAgfCBsYXN0IFN1bmRheSBhdCAwNDozMCBBTSAgIHxcbiAqIHwgTGFzdCBkYXkgICAgICAgICAgICAgICAgICB8IHllc3RlcmRheSBhdCAwNDozMCBBTSAgICAgfFxuICogfCBTYW1lIGRheSAgICAgICAgICAgICAgICAgIHwgdG9kYXkgYXQgMDQ6MzAgQU0gICAgICAgICB8XG4gKiB8IE5leHQgZGF5ICAgICAgICAgICAgICAgICAgfCB0b21vcnJvdyBhdCAwNDozMCBBTSAgICAgIHxcbiAqIHwgTmV4dCA2IGRheXMgICAgICAgICAgICAgICB8IFN1bmRheSBhdCAwNDozMCBBTSAgICAgICAgfFxuICogfCBPdGhlciAgICAgICAgICAgICAgICAgICAgIHwgMTIvMzEvMjAxNyAgICAgICAgICAgICAgICB8XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXRcbiAqIEBwYXJhbSBiYXNlRGF0ZSAtIFRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaW4gd29yZHNcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYGJhc2VEYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGxvY2FsaXplYCBwcm9wZXJ0eVxuICogQHRocm93cyBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdFJlbGF0aXZlYCBwcm9wZXJ0eVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgdGhlIGRhdGUgb2YgNiBkYXlzIGFnbyBpbiB3b3JkcyByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gYmFzZSBkYXRlLiBJbiB0aGlzIGV4YW1wbGUsIHRvZGF5IGlzIFdlZG5lc2RheVxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0UmVsYXRpdmUoc3ViRGF5cyhuZXcgRGF0ZSgpLCA2KSwgbmV3IERhdGUoKSlcbiAqIC8vPT4gXCJsYXN0IFRodXJzZGF5IGF0IDEyOjQ1IEFNXCJcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUoZGF0ZSwgYmFzZURhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBfYmFzZURhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGJhc2VEYXRlKTtcblxuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXg1LmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCBsb2NhbGUgPVxuICAgIG9wdGlvbnM/LmxvY2FsZSA/PyBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgPz8gX2luZGV4NC5kZWZhdWx0TG9jYWxlO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IGRpZmYgPSAoMCwgX2luZGV4LmRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cykoX2RhdGUsIF9iYXNlRGF0ZSk7XG5cbiAgaWYgKGlzTmFOKGRpZmYpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBsZXQgdG9rZW47XG4gIGlmIChkaWZmIDwgLTYpIHtcbiAgICB0b2tlbiA9IFwib3RoZXJcIjtcbiAgfSBlbHNlIGlmIChkaWZmIDwgLTEpIHtcbiAgICB0b2tlbiA9IFwibGFzdFdlZWtcIjtcbiAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgIHRva2VuID0gXCJ5ZXN0ZXJkYXlcIjtcbiAgfSBlbHNlIGlmIChkaWZmIDwgMSkge1xuICAgIHRva2VuID0gXCJ0b2RheVwiO1xuICB9IGVsc2UgaWYgKGRpZmYgPCAyKSB7XG4gICAgdG9rZW4gPSBcInRvbW9ycm93XCI7XG4gIH0gZWxzZSBpZiAoZGlmZiA8IDcpIHtcbiAgICB0b2tlbiA9IFwibmV4dFdlZWtcIjtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IFwib3RoZXJcIjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdFN0ciA9IGxvY2FsZS5mb3JtYXRSZWxhdGl2ZSh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwge1xuICAgIGxvY2FsZSxcbiAgICB3ZWVrU3RhcnRzT24sXG4gIH0pO1xuICByZXR1cm4gKDAsIF9pbmRleDIuZm9ybWF0KShfZGF0ZSwgZm9ybWF0U3RyLCB7IGxvY2FsZSwgd2Vla1N0YXJ0c09uIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmZyb21Vbml4VGltZSA9IGZyb21Vbml4VGltZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZnJvbVVuaXhUaW1lXG4gKiBAY2F0ZWdvcnkgVGltZXN0YW1wIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIGRhdGUgZnJvbSBhIFVuaXggdGltZXN0YW1wLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlIGEgZGF0ZSBmcm9tIGEgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpLiBEZWNpbWFsIHZhbHVlcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAqXG4gKiBAcGFyYW0gdW5peFRpbWUgLSBUaGUgZ2l2ZW4gVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIHRoZSBkYXRlIDI5IEZlYnJ1YXJ5IDIwMTIgMTE6NDU6MDU6XG4gKiBjb25zdCByZXN1bHQgPSBmcm9tVW5peFRpbWUoMTMzMDUxNTkwNSlcbiAqIC8vPT4gV2VkIEZlYiAyOSAyMDEyIDExOjQ1OjA1XG4gKi9cbmZ1bmN0aW9uIGZyb21Vbml4VGltZSh1bml4VGltZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC50b0RhdGUpKHVuaXhUaW1lICogMTAwMCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0RGF0ZSA9IGdldERhdGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldERhdGVcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF5IG9mIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgbW9udGggaXMgMjkgRmVicnVhcnkgMjAxMj9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldERhdGUobmV3IERhdGUoMjAxMiwgMSwgMjkpKVxuICogLy89PiAyOVxuICovXG5mdW5jdGlvbiBnZXREYXRlKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGRheU9mTW9udGggPSBfZGF0ZS5nZXREYXRlKCk7XG4gIHJldHVybiBkYXlPZk1vbnRoO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldERheSA9IGdldERheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0RGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF5IG9mIHdlZWssIDAgcmVwcmVzZW50cyBTdW5kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggZGF5IG9mIHRoZSB3ZWVrIGlzIDI5IEZlYnJ1YXJ5IDIwMTI/XG4gKiBjb25zdCByZXN1bHQgPSBnZXREYXkobmV3IERhdGUoMjAxMiwgMSwgMjkpKVxuICogLy89PiAzXG4gKi9cbmZ1bmN0aW9uIGdldERheShkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcbiAgcmV0dXJuIGRheTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXREYXlPZlllYXIgPSBnZXREYXlPZlllYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mWWVhci5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldERheU9mWWVhclxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGRheSBvZiB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgZGF5IG9mIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF5IG9mIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggZGF5IG9mIHRoZSB5ZWFyIGlzIDIgSnVseSAyMDE0P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0RGF5T2ZZZWFyKG5ldyBEYXRlKDIwMTQsIDYsIDIpKVxuICogLy89PiAxODNcbiAqL1xuZnVuY3Rpb24gZ2V0RGF5T2ZZZWFyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkaWZmID0gKDAsIF9pbmRleC5kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMpKFxuICAgIF9kYXRlLFxuICAgICgwLCBfaW5kZXgyLnN0YXJ0T2ZZZWFyKShfZGF0ZSksXG4gICk7XG4gIGNvbnN0IGRheU9mWWVhciA9IGRpZmYgKyAxO1xuICByZXR1cm4gZGF5T2ZZZWFyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldERheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldERheXNJbk1vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBkYXlzIGFyZSBpbiBGZWJydWFyeSAyMDAwP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0RGF5c0luTW9udGgobmV3IERhdGUoMjAwMCwgMSkpXG4gKiAvLz0+IDI5XG4gKi9cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBtb250aEluZGV4ID0gX2RhdGUuZ2V0TW9udGgoKTtcbiAgY29uc3QgbGFzdERheU9mTW9udGggPSAoMCwgX2luZGV4Mi5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgbGFzdERheU9mTW9udGguc2V0RnVsbFllYXIoeWVhciwgbW9udGhJbmRleCArIDEsIDApO1xuICBsYXN0RGF5T2ZNb250aC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGxhc3REYXlPZk1vbnRoLmdldERhdGUoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXREYXlzSW5ZZWFyID0gZ2V0RGF5c0luWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pc0xlYXBZZWFyLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0RGF5c0luWWVhclxuICogQGNhdGVnb3J5IFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkYXlzIGluIGEgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBIb3cgbWFueSBkYXlzIGFyZSBpbiAyMDEyP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0RGF5c0luWWVhcihuZXcgRGF0ZSgyMDEyLCAwLCAxKSlcbiAqIC8vPT4gMzY2XG4gKi9cbmZ1bmN0aW9uIGdldERheXNJblllYXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG5cbiAgaWYgKFN0cmluZyhuZXcgRGF0ZShfZGF0ZSkpID09PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2luZGV4LmlzTGVhcFllYXIpKF9kYXRlKSA/IDM2NiA6IDM2NTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXREZWNhZGUgPSBnZXREZWNhZGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldERlY2FkZVxuICogQGNhdGVnb3J5IERlY2FkZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGRlY2FkZSBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgZGVjYWRlIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgeWVhciBvZiBkZWNhZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggZGVjYWRlIGJlbG9uZ3MgMjcgTm92ZW1iZXIgMTk0Mj9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldERlY2FkZShuZXcgRGF0ZSgxOTQyLCAxMCwgMjcpKVxuICogLy89PiAxOTQwXG4gKi9cbmZ1bmN0aW9uIGdldERlY2FkZShkYXRlKSB7XG4gIC8vIFRPRE86IFN3aXRjaCB0byBtb3JlIHRlY2huaWNhbCBkZWZpbml0aW9uIGluIG9mIGRlY2FkZXMgdGhhdCBzdGFydCB3aXRoIDFcbiAgLy8gZW5kIHdpdGggMC4gSS5lLiAyMDAxLTIwMTAgaW5zdGVhZCBvZiBjdXJyZW50IDIwMDAtMjAwOS4gSXQncyBhIGJyZWFraW5nXG4gIC8vIGNoYW5nZSwgc28gaXQgY2FuIG9ubHkgYmUgZG9uZSBpbiA0LjAuXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgZGVjYWRlID0gTWF0aC5mbG9vcih5ZWFyIC8gMTApICogMTA7XG4gIHJldHVybiBkZWNhZGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0RGVmYXVsdE9wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucztcblxudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0RGVmYXVsdE9wdGlvbnNcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IGRlZmF1bHQgb3B0aW9ucy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGRlZmF1bHRzIGZvclxuICogYG9wdGlvbnMubG9jYWxlYCwgYG9wdGlvbnMud2Vla1N0YXJ0c09uYCBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYFxuICogYXJndW1lbnRzIGZvciBhbGwgZnVuY3Rpb25zLlxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIHRoZXNlIHdpdGggW3NldERlZmF1bHRPcHRpb25zXShodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldERlZmF1bHRPcHRpb25zKS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBvcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlc3VsdCA9IGdldERlZmF1bHRPcHRpb25zKClcbiAqIC8vPT4ge31cbiAqXG4gKiBAZXhhbXBsZVxuICogc2V0RGVmYXVsdE9wdGlvbnMoeyB3ZWVrU3RhcnNPbjogMSwgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0IH0pXG4gKiBjb25zdCByZXN1bHQgPSBnZXREZWZhdWx0T3B0aW9ucygpXG4gKiAvLz0+IHsgd2Vla1N0YXJzT246IDEsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNCB9XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKDAsIF9pbmRleC5nZXREZWZhdWx0T3B0aW9ucykoKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0SG91cnMgPSBnZXRIb3VycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0SG91cnNcbiAqIEBjYXRlZ29yeSBIb3VyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgaG91cnMgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGhvdXJzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgaG91cnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSBob3VycyBvZiAyOSBGZWJydWFyeSAyMDEyIDExOjQ1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gZ2V0SG91cnMobmV3IERhdGUoMjAxMiwgMSwgMjksIDExLCA0NSkpXG4gKiAvLz0+IDExXG4gKi9cbmZ1bmN0aW9uIGdldEhvdXJzKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGhvdXJzID0gX2RhdGUuZ2V0SG91cnMoKTtcbiAgcmV0dXJuIGhvdXJzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldElTT0RheSA9IGdldElTT0RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0SVNPRGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGRheSBvZiB0aGUgSVNPIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGRheSBvZiB0aGUgSVNPIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUsXG4gKiB3aGljaCBpcyA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSBldGMuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF5IG9mIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgSVNPIHdlZWsgaXMgMjYgRmVicnVhcnkgMjAxMj9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldElTT0RheShuZXcgRGF0ZSgyMDEyLCAxLCAyNikpXG4gKiAvLz0+IDdcbiAqL1xuZnVuY3Rpb24gZ2V0SVNPRGF5KGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGxldCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcblxuICBpZiAoZGF5ID09PSAwKSB7XG4gICAgZGF5ID0gNztcbiAgfVxuXG4gIHJldHVybiBkYXk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0SVNPV2VlayA9IGdldElTT1dlZWs7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mSVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vc3RhcnRPZklTT1dlZWtZZWFyLmpzXCIpO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0SVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgSVNPIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIElTTyB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIElTTy13ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDIgSmFudWFyeSAyMDA1P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0SVNPV2VlayhuZXcgRGF0ZSgyMDA1LCAwLCAyKSlcbiAqIC8vPT4gNTNcbiAqL1xuZnVuY3Rpb24gZ2V0SVNPV2VlayhkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDQudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgZGlmZiA9XG4gICAgKygwLCBfaW5kZXgyLnN0YXJ0T2ZJU09XZWVrKShfZGF0ZSkgLVxuICAgICsoMCwgX2luZGV4My5zdGFydE9mSVNPV2Vla1llYXIpKF9kYXRlKTtcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIHdlZWtzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgYmVjYXVzZSB0aGUgbnVtYmVyIG9mXG4gIC8vIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5XZWVrKSArIDE7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0SVNPV2Vla1llYXIgPSBnZXRJU09XZWVrWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mSVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldElTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUsXG4gKiB3aGljaCBhbHdheXMgc3RhcnRzIDMgZGF5cyBiZWZvcmUgdGhlIHllYXIncyBmaXJzdCBUaHVyc2RheS5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBJU08td2VlayBudW1iZXJpbmcgeWVhciBpcyAyIEphbnVhcnkgMjAwNT9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldElTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDAsIDIpKVxuICogLy89PiAyMDA0XG4gKi9cbmZ1bmN0aW9uIGdldElTT1dlZWtZZWFyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuICBjb25zdCBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRGdWxsWWVhcih5ZWFyICsgMSwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhciA9ICgwLCBfaW5kZXgyLnN0YXJ0T2ZJU09XZWVrKShcbiAgICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLFxuICApO1xuXG4gIGNvbnN0IGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIDApO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldEZ1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBzdGFydE9mVGhpc1llYXIgPSAoMCwgX2luZGV4Mi5zdGFydE9mSVNPV2VlaykoXG4gICAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhcixcbiAgKTtcblxuICBpZiAoX2RhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDE7XG4gIH0gZWxzZSBpZiAoX2RhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXRJU09XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZFdlZWtzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrWWVhci5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBnZXRJU09XZWVrc0luWWVhclxuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIElTTyB3ZWVrcyBpbiBhIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgd2Vla3MgYXJlIGluIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIDIwMTU/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRJU09XZWVrc0luWWVhcihuZXcgRGF0ZSgyMDE1LCAxLCAxMSkpXG4gKiAvLz0+IDUzXG4gKi9cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKGRhdGUpIHtcbiAgY29uc3QgdGhpc1llYXIgPSAoMCwgX2luZGV4My5zdGFydE9mSVNPV2Vla1llYXIpKGRhdGUpO1xuICBjb25zdCBuZXh0WWVhciA9ICgwLCBfaW5kZXgzLnN0YXJ0T2ZJU09XZWVrWWVhcikoXG4gICAgKDAsIF9pbmRleC5hZGRXZWVrcykodGhpc1llYXIsIDYwKSxcbiAgKTtcbiAgY29uc3QgZGlmZiA9ICtuZXh0WWVhciAtICt0aGlzWWVhcjtcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIHdlZWtzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgYmVjYXVzZSB0aGUgbnVtYmVyIG9mXG4gIC8vIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBfaW5kZXgyLm1pbGxpc2Vjb25kc0luV2Vlayk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0TWlsbGlzZWNvbmRzID0gZ2V0TWlsbGlzZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBnZXRNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG1pbGxpc2Vjb25kcyBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbWlsbGlzZWNvbmRzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbWlsbGlzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEdldCB0aGUgbWlsbGlzZWNvbmRzIG9mIDI5IEZlYnJ1YXJ5IDIwMTIgMTE6NDU6MDUuMTIzOlxuICogY29uc3QgcmVzdWx0ID0gZ2V0TWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTIsIDEsIDI5LCAxMSwgNDUsIDUsIDEyMykpXG4gKiAvLz0+IDEyM1xuICovXG5mdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgbWlsbGlzZWNvbmRzID0gX2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBtaWxsaXNlY29uZHM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0TWludXRlcyA9IGdldE1pbnV0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldE1pbnV0ZXNcbiAqIEBjYXRlZ29yeSBNaW51dGUgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBtaW51dGVzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBtaW51dGVzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbWludXRlc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIG1pbnV0ZXMgb2YgMjkgRmVicnVhcnkgMjAxMiAxMTo0NTowNTpcbiAqIGNvbnN0IHJlc3VsdCA9IGdldE1pbnV0ZXMobmV3IERhdGUoMjAxMiwgMSwgMjksIDExLCA0NSwgNSkpXG4gKiAvLz0+IDQ1XG4gKi9cbmZ1bmN0aW9uIGdldE1pbnV0ZXMoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgbWludXRlcyA9IF9kYXRlLmdldE1pbnV0ZXMoKTtcbiAgcmV0dXJuIG1pbnV0ZXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0TW9udGggPSBnZXRNb250aDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0TW9udGhcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG1vbnRoIGluZGV4ICgwLTExKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBtb250aCBpcyAyOSBGZWJydWFyeSAyMDEyP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0TW9udGgobmV3IERhdGUoMjAxMiwgMSwgMjkpKVxuICogLy89PiAxXG4gKi9cbmZ1bmN0aW9uIGdldE1vbnRoKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IG1vbnRoID0gX2RhdGUuZ2V0TW9udGgoKTtcbiAgcmV0dXJuIG1vbnRoO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldE92ZXJsYXBwaW5nRGF5c0luSW50ZXJ2YWxzID0gZ2V0T3ZlcmxhcHBpbmdEYXlzSW5JbnRlcnZhbHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBnZXRPdmVybGFwcGluZ0RheXNJbkludGVydmFsc1xuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGRheXMgdGhhdCBvdmVybGFwIGluIHR3byB0aW1lIGludGVydmFsc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgZGF5cyB0aGF0IG92ZXJsYXAgaW4gdHdvIHRpbWUgaW50ZXJ2YWxzLiBJdCB1c2VzIHRoZSB0aW1lXG4gKiBiZXR3ZWVuIGRhdGVzIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRheXMsIHJvdW5kaW5nIGl0IHVwIHRvIGluY2x1ZGVcbiAqIHBhcnRpYWwgZGF5cy5cbiAqXG4gKiBUd28gZXF1YWwgMC1sZW5ndGggaW50ZXJ2YWxzIHdpbGwgcmVzdWx0IGluIDAuIFR3byBlcXVhbCAxbXMgaW50ZXJ2YWxzIHdpbGxcbiAqIHJlc3VsdCBpbiAxLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBpbnRlcnZhbExlZnQgLSBUaGUgZmlyc3QgaW50ZXJ2YWwgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBpbnRlcnZhbFJpZ2h0IC0gVGhlIHNlY29uZCBpbnRlcnZhbCB0byBjb21wYXJlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGF5cyB0aGF0IG92ZXJsYXAgaW4gdHdvIHRpbWUgaW50ZXJ2YWxzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBvdmVybGFwcGluZyB0aW1lIGludGVydmFscyBhZGRzIDEgZm9yIGVhY2ggc3RhcnRlZCBvdmVybGFwcGluZyBkYXk6XG4gKiBnZXRPdmVybGFwcGluZ0RheXNJbkludGVydmFscyhcbiAqICAgeyBzdGFydDogbmV3IERhdGUoMjAxNCwgMCwgMTApLCBlbmQ6IG5ldyBEYXRlKDIwMTQsIDAsIDIwKSB9LFxuICogICB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAxNyksIGVuZDogbmV3IERhdGUoMjAxNCwgMCwgMjEpIH1cbiAqIClcbiAqIC8vPT4gM1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3Igbm9uLW92ZXJsYXBwaW5nIHRpbWUgaW50ZXJ2YWxzIHJldHVybnMgMDpcbiAqIGdldE92ZXJsYXBwaW5nRGF5c0luSW50ZXJ2YWxzKFxuICogICB7IHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAxMCksIGVuZDogbmV3IERhdGUoMjAxNCwgMCwgMjApIH0sXG4gKiAgIHsgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDIxKSwgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCAyMikgfVxuICogKVxuICogLy89PiAwXG4gKi9cblxuZnVuY3Rpb24gZ2V0T3ZlcmxhcHBpbmdEYXlzSW5JbnRlcnZhbHMoaW50ZXJ2YWxMZWZ0LCBpbnRlcnZhbFJpZ2h0KSB7XG4gIGNvbnN0IFtsZWZ0U3RhcnQsIGxlZnRFbmRdID0gW1xuICAgICsoMCwgX2luZGV4My50b0RhdGUpKGludGVydmFsTGVmdC5zdGFydCksXG4gICAgKygwLCBfaW5kZXgzLnRvRGF0ZSkoaW50ZXJ2YWxMZWZ0LmVuZCksXG4gIF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBjb25zdCBbcmlnaHRTdGFydCwgcmlnaHRFbmRdID0gW1xuICAgICsoMCwgX2luZGV4My50b0RhdGUpKGludGVydmFsUmlnaHQuc3RhcnQpLFxuICAgICsoMCwgX2luZGV4My50b0RhdGUpKGludGVydmFsUmlnaHQuZW5kKSxcbiAgXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cbiAgLy8gUHJldmVudCBOYU4gcmVzdWx0IGlmIGludGVydmFscyBkb24ndCBvdmVybGFwIGF0IGFsbC5cbiAgY29uc3QgaXNPdmVybGFwcGluZyA9IGxlZnRTdGFydCA8IHJpZ2h0RW5kICYmIHJpZ2h0U3RhcnQgPCBsZWZ0RW5kO1xuICBpZiAoIWlzT3ZlcmxhcHBpbmcpIHJldHVybiAwO1xuXG4gIC8vIFJlbW92ZSB0aGUgdGltZXpvbmUgb2Zmc2V0IHRvIG5lZ2F0ZSB0aGUgRFNUIGVmZmVjdCBvbiBjYWxjdWxhdGlvbnMuXG4gIGNvbnN0IG92ZXJsYXBMZWZ0ID0gcmlnaHRTdGFydCA8IGxlZnRTdGFydCA/IGxlZnRTdGFydCA6IHJpZ2h0U3RhcnQ7XG4gIGNvbnN0IGxlZnQgPVxuICAgIG92ZXJsYXBMZWZ0IC0gKDAsIF9pbmRleC5nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKShvdmVybGFwTGVmdCk7XG4gIGNvbnN0IG92ZXJsYXBSaWdodCA9IHJpZ2h0RW5kID4gbGVmdEVuZCA/IGxlZnRFbmQgOiByaWdodEVuZDtcbiAgY29uc3QgcmlnaHQgPVxuICAgIG92ZXJsYXBSaWdodCAtICgwLCBfaW5kZXguZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcykob3ZlcmxhcFJpZ2h0KTtcblxuICAvLyBDZWlsIHRoZSBudW1iZXIgdG8gaW5jbHVkZSBwYXJ0aWFsIGRheXMgdG9vLlxuICByZXR1cm4gTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gX2luZGV4Mi5taWxsaXNlY29uZHNJbkRheSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0UXVhcnRlciA9IGdldFF1YXJ0ZXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldFF1YXJ0ZXJcbiAqIEBjYXRlZ29yeSBRdWFydGVyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgeWVhciBxdWFydGVyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSB5ZWFyIHF1YXJ0ZXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBxdWFydGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHF1YXJ0ZXIgaXMgMiBKdWx5IDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRRdWFydGVyKG5ldyBEYXRlKDIwMTQsIDYsIDIpKVxuICogLy89PiAzXG4gKi9cbmZ1bmN0aW9uIGdldFF1YXJ0ZXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgcXVhcnRlciA9IE1hdGgudHJ1bmMoX2RhdGUuZ2V0TW9udGgoKSAvIDMpICsgMTtcbiAgcmV0dXJuIHF1YXJ0ZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0U2Vjb25kcyA9IGdldFNlY29uZHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldFNlY29uZHNcbiAqIEBjYXRlZ29yeSBTZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBzZWNvbmRzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBzZWNvbmRzIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc2Vjb25kc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIHNlY29uZHMgb2YgMjkgRmVicnVhcnkgMjAxMiAxMTo0NTowNS4xMjM6XG4gKiBjb25zdCByZXN1bHQgPSBnZXRTZWNvbmRzKG5ldyBEYXRlKDIwMTIsIDEsIDI5LCAxMSwgNDUsIDUsIDEyMykpXG4gKiAvLz0+IDVcbiAqL1xuZnVuY3Rpb24gZ2V0U2Vjb25kcyhkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBzZWNvbmRzID0gX2RhdGUuZ2V0U2Vjb25kcygpO1xuICByZXR1cm4gc2Vjb25kcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXRUaW1lID0gZ2V0VGltZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0VGltZVxuICogQGNhdGVnb3J5IFRpbWVzdGFtcCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSB0aW1lc3RhbXBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSB0aW1lc3RhbXAgb2YgMjkgRmVicnVhcnkgMjAxMiAxMTo0NTowNS4xMjM6XG4gKiBjb25zdCByZXN1bHQgPSBnZXRUaW1lKG5ldyBEYXRlKDIwMTIsIDEsIDI5LCAxMSwgNDUsIDUsIDEyMykpXG4gKiAvLz0+IDEzMzA1MTU5MDUxMjNcbiAqL1xuZnVuY3Rpb24gZ2V0VGltZShkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBfZGF0ZS5nZXRUaW1lKCk7XG4gIHJldHVybiB0aW1lc3RhbXA7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0VW5peFRpbWUgPSBnZXRVbml4VGltZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgZ2V0VW5peFRpbWVcbiAqIEBjYXRlZ29yeSBUaW1lc3RhbXAgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBzZWNvbmRzIHRpbWVzdGFtcCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgc2Vjb25kcyB0aW1lc3RhbXAgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSB0aW1lc3RhbXBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSB0aW1lc3RhbXAgb2YgMjkgRmVicnVhcnkgMjAxMiAxMTo0NTowNSBDRVQ6XG4gKiBjb25zdCByZXN1bHQgPSBnZXRVbml4VGltZShuZXcgRGF0ZSgyMDEyLCAxLCAyOSwgMTEsIDQ1LCA1KSlcbiAqIC8vPT4gMTMzMDUxMjMwNVxuICovXG5mdW5jdGlvbiBnZXRVbml4VGltZShkYXRlKSB7XG4gIHJldHVybiBNYXRoLnRydW5jKCsoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSkgLyAxMDAwKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5nZXRXZWVrID0gZ2V0V2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZXZWVrLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9zdGFydE9mV2Vla1llYXIuanNcIik7XG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGdldFdlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBnZXRXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGxvY2FsIHdlZWsgaW5kZXggb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGxvY2FsIHdlZWsgaW5kZXggb2YgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgZXhhY3QgY2FsY3VsYXRpb24gZGVwZW5kcyBvbiB0aGUgdmFsdWVzIG9mXG4gKiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gICh3aGljaCBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaylcbiAqIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgICh3aGljaCBpcyB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzIGFsd2F5cyBpblxuICogdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIpXG4gKlxuICogV2VlayBudW1iZXJpbmc6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlZWsjVGhlX0lTT193ZWVrX2RhdGVfc3lzdGVtXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggd2VlayBvZiB0aGUgbG9jYWwgd2VlayBudW1iZXJpbmcgeWVhciBpcyAyIEphbnVhcnkgMjAwNSB3aXRoIGRlZmF1bHQgb3B0aW9ucz9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldFdlZWsobmV3IERhdGUoMjAwNSwgMCwgMikpXG4gKiAvLz0+IDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggd2VlayBvZiB0aGUgbG9jYWwgd2VlayBudW1iZXJpbmcgeWVhciBpcyAyIEphbnVhcnkgMjAwNSxcbiAqIC8vIGlmIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLFxuICogLy8gYW5kIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGFsd2F5cyBjb250YWlucyA0IEphbnVhcnk/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrKG5ldyBEYXRlKDIwMDUsIDAsIDIpLCB7XG4gKiAgIHdlZWtTdGFydHNPbjogMSxcbiAqICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0XG4gKiB9KVxuICogLy89PiA1M1xuICovXG5cbmZ1bmN0aW9uIGdldFdlZWsoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXg0LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGRpZmYgPVxuICAgICsoMCwgX2luZGV4Mi5zdGFydE9mV2VlaykoX2RhdGUsIG9wdGlvbnMpIC1cbiAgICArKDAsIF9pbmRleDMuc3RhcnRPZldlZWtZZWFyKShfZGF0ZSwgb3B0aW9ucyk7XG5cbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiB3ZWVrcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIGJlY2F1c2UgdGhlIG51bWJlciBvZlxuICAvLyBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudCAoZS5nLiBpdCdzIGRpZmZlcmVudCBpbiB0aGUgd2VlayBvZlxuICAvLyB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpLlxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gX2luZGV4Lm1pbGxpc2Vjb25kc0luV2VlaykgKyAxO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldFdlZWtPZk1vbnRoID0gZ2V0V2Vla09mTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2V0RGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZ2V0RGF5LmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9zdGFydE9mTW9udGguanNcIik7XG5cbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0T3B0aW9ucy5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGdldFdlZWtPZk1vbnRofSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZ2V0V2Vla09mTW9udGhcbiAqIEBjYXRlZ29yeSBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgd2VlayBvZiB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIHdlZWsgb2YgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgd2VlayBvZiBtb250aFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB3ZWVrIG9mIHRoZSBtb250aCBpcyA5IE5vdmVtYmVyIDIwMTc/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrT2ZNb250aChuZXcgRGF0ZSgyMDE3LCAxMCwgOSkpXG4gKiAvLz0+IDJcbiAqL1xuZnVuY3Rpb24gZ2V0V2Vla09mTW9udGgoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXg0LmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IGN1cnJlbnREYXlPZk1vbnRoID0gKDAsIF9pbmRleC5nZXREYXRlKShkYXRlKTtcbiAgaWYgKGlzTmFOKGN1cnJlbnREYXlPZk1vbnRoKSkgcmV0dXJuIE5hTjtcblxuICBjb25zdCBzdGFydFdlZWtEYXkgPSAoMCwgX2luZGV4Mi5nZXREYXkpKCgwLCBfaW5kZXgzLnN0YXJ0T2ZNb250aCkoZGF0ZSkpO1xuXG4gIGxldCBsYXN0RGF5T2ZGaXJzdFdlZWsgPSB3ZWVrU3RhcnRzT24gLSBzdGFydFdlZWtEYXk7XG4gIGlmIChsYXN0RGF5T2ZGaXJzdFdlZWsgPD0gMCkgbGFzdERheU9mRmlyc3RXZWVrICs9IDc7XG5cbiAgY29uc3QgcmVtYWluaW5nRGF5c0FmdGVyRmlyc3RXZWVrID0gY3VycmVudERheU9mTW9udGggLSBsYXN0RGF5T2ZGaXJzdFdlZWs7XG4gIHJldHVybiBNYXRoLmNlaWwocmVtYWluaW5nRGF5c0FmdGVyRmlyc3RXZWVrIC8gNykgKyAxO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldFdlZWtZZWFyID0gZ2V0V2Vla1llYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vc3RhcnRPZldlZWsuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZ2V0V2Vla1llYXJ9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBnZXRXZWVrWWVhclxuICogQGNhdGVnb3J5IFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIGV4YWN0IGNhbGN1bGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlcyBvZlxuICogYG9wdGlvbnMud2Vla1N0YXJ0c09uYCAod2hpY2ggaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWspXG4gKiBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAod2hpY2ggaXMgdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW5cbiAqIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyKVxuICpcbiAqIFdlZWsgbnVtYmVyaW5nOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWVrI1RoZV9JU09fd2Vla19kYXRlX3N5c3RlbVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB3ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDI2IERlY2VtYmVyIDIwMDQgd2l0aCB0aGUgZGVmYXVsdCBzZXR0aW5ncz9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldFdlZWtZZWFyKG5ldyBEYXRlKDIwMDQsIDExLCAyNikpXG4gKiAvLz0+IDIwMDVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggd2VlayBudW1iZXJpbmcgeWVhciBpcyAyNiBEZWNlbWJlciAyMDA0IGlmIHdlZWsgc3RhcnRzIG9uIFNhdHVyZGF5P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla1llYXIobmV3IERhdGUoMjAwNCwgMTEsIDI2KSwgeyB3ZWVrU3RhcnRzT246IDYgfSlcbiAqIC8vPT4gMjAwNFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB3ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDI2IERlY2VtYmVyIDIwMDQgaWYgdGhlIGZpcnN0IHdlZWsgY29udGFpbnMgNCBKYW51YXJ5P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla1llYXIobmV3IERhdGUoMjAwNCwgMTEsIDI2KSwgeyBmaXJzdFdlZWtDb250YWluc0RhdGU6IDQgfSlcbiAqIC8vPT4gMjAwNFxuICovXG5mdW5jdGlvbiBnZXRXZWVrWWVhcihkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDMudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgeWVhciA9IF9kYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoMCwgX2luZGV4NC5nZXREZWZhdWx0T3B0aW9ucykoKTtcbiAgY29uc3QgZmlyc3RXZWVrQ29udGFpbnNEYXRlID1cbiAgICBvcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBvcHRpb25zPy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgMTtcblxuICBjb25zdCBmaXJzdFdlZWtPZk5leHRZZWFyID0gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRGdWxsWWVhcih5ZWFyICsgMSwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3Qgc3RhcnRPZk5leHRZZWFyID0gKDAsIF9pbmRleDIuc3RhcnRPZldlZWspKFxuICAgIGZpcnN0V2Vla09mTmV4dFllYXIsXG4gICAgb3B0aW9ucyxcbiAgKTtcblxuICBjb25zdCBmaXJzdFdlZWtPZlRoaXNZZWFyID0gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgZmlyc3RXZWVrT2ZUaGlzWWVhci5zZXRGdWxsWWVhcih5ZWFyLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBzdGFydE9mVGhpc1llYXIgPSAoMCwgX2luZGV4Mi5zdGFydE9mV2VlaykoXG4gICAgZmlyc3RXZWVrT2ZUaGlzWWVhcixcbiAgICBvcHRpb25zLFxuICApO1xuXG4gIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmdldFdlZWtzSW5Nb250aCA9IGdldFdlZWtzSW5Nb250aDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9sYXN0RGF5T2ZNb250aC5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vc3RhcnRPZk1vbnRoLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgZ2V0V2Vla3NJbk1vbnRofSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZ2V0V2Vla3NJbk1vbnRoXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciB3ZWVrcyBhIG1vbnRoIHNwYW5zLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgd2Vla3MgdGhlIG1vbnRoIGluIHRoZSBnaXZlbiBkYXRlIHNwYW5zLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNhbGVuZGFyIHdlZWtzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIHdlZWtzIGRvZXMgRmVicnVhcnkgMjAxNSBzcGFuP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla3NJbk1vbnRoKG5ldyBEYXRlKDIwMTUsIDEsIDgpKVxuICogLy89PiA0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksXG4gKiAvLyBob3cgbWFueSBjYWxlbmRhciB3ZWVrcyBkb2VzIEp1bHkgMjAxNyBzcGFuP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla3NJbk1vbnRoKG5ldyBEYXRlKDIwMTcsIDYsIDUpLCB7IHdlZWtTdGFydHNPbjogMSB9KVxuICogLy89PiA2XG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtzSW5Nb250aChkYXRlLCBvcHRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgKDAsIF9pbmRleC5kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzKShcbiAgICAgICgwLCBfaW5kZXgyLmxhc3REYXlPZk1vbnRoKShkYXRlKSxcbiAgICAgICgwLCBfaW5kZXgzLnN0YXJ0T2ZNb250aCkoZGF0ZSksXG4gICAgICBvcHRpb25zLFxuICAgICkgKyAxXG4gICk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZ2V0WWVhciA9IGdldFllYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGdldFllYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggeWVhciBpcyAyIEp1bHkgMjAxND9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldFllYXIobmV3IERhdGUoMjAxNCwgNiwgMikpXG4gKiAvLz0+IDIwMTRcbiAqL1xuZnVuY3Rpb24gZ2V0WWVhcihkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSkuZ2V0RnVsbFllYXIoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5ob3Vyc1RvTWlsbGlzZWNvbmRzID0gaG91cnNUb01pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaG91cnNUb01pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5ICBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgaG91cnMgdG8gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBob3VycyB0byBhIGZ1bGwgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaG91cnMgLSBudW1iZXIgb2YgaG91cnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBob3VycyBjb252ZXJ0ZWQgdG8gbWlsbGlzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMiBob3VycyB0byBtaWxsaXNlY29uZHM6XG4gKiBjb25zdCByZXN1bHQgPSBob3Vyc1RvTWlsbGlzZWNvbmRzKDIpXG4gKiAvLz0+IDcyMDAwMDBcbiAqL1xuZnVuY3Rpb24gaG91cnNUb01pbGxpc2Vjb25kcyhob3Vycykge1xuICByZXR1cm4gTWF0aC50cnVuYyhob3VycyAqIF9pbmRleC5taWxsaXNlY29uZHNJbkhvdXIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmhvdXJzVG9NaW51dGVzID0gaG91cnNUb01pbnV0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGhvdXJzVG9NaW51dGVzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IGhvdXJzIHRvIG1pbnV0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIGhvdXJzIHRvIGEgZnVsbCBudW1iZXIgb2YgbWludXRlcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gaG91cnMgLSBudW1iZXIgb2YgaG91cnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBob3VycyBjb252ZXJ0ZWQgaW4gbWludXRlc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDIgaG91cnMgdG8gbWludXRlczpcbiAqIGNvbnN0IHJlc3VsdCA9IGhvdXJzVG9NaW51dGVzKDIpXG4gKiAvLz0+IDEyMFxuICovXG5mdW5jdGlvbiBob3Vyc1RvTWludXRlcyhob3Vycykge1xuICByZXR1cm4gTWF0aC50cnVuYyhob3VycyAqIF9pbmRleC5taW51dGVzSW5Ib3VyKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5ob3Vyc1RvU2Vjb25kcyA9IGhvdXJzVG9TZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBob3Vyc1RvU2Vjb25kc1xuICogQGNhdGVnb3J5IENvbnZlcnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCBob3VycyB0byBzZWNvbmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBob3VycyB0byBhIGZ1bGwgbnVtYmVyIG9mIHNlY29uZHMuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGhvdXJzIC0gVGhlIG51bWJlciBvZiBob3VycyB0byBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGhvdXJzIGNvbnZlcnRlZCBpbiBzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMiBob3VycyB0byBzZWNvbmRzOlxuICogY29uc3QgcmVzdWx0ID0gaG91cnNUb1NlY29uZHMoMilcbiAqIC8vPT4gNzIwMFxuICovXG5mdW5jdGlvbiBob3Vyc1RvU2Vjb25kcyhob3Vycykge1xuICByZXR1cm4gTWF0aC50cnVuYyhob3VycyAqIF9pbmRleC5zZWNvbmRzSW5Ib3VyKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXhba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9hZGRCdXNpbmVzc0RheXMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL2FkZERheXMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL2FkZEhvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDUgPSByZXF1aXJlKFwiLi9hZGRJU09XZWVrWWVhcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NiA9IHJlcXVpcmUoXCIuL2FkZE1pbGxpc2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg3ID0gcmVxdWlyZShcIi4vYWRkTWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDdba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg4ID0gcmVxdWlyZShcIi4vYWRkTW9udGhzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4OFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDhba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDkgPSByZXF1aXJlKFwiLi9hZGRRdWFydGVycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMCA9IHJlcXVpcmUoXCIuL2FkZFNlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTEgPSByZXF1aXJlKFwiLi9hZGRXZWVrcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDExW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMiA9IHJlcXVpcmUoXCIuL2FkZFllYXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEzID0gcmVxdWlyZShcIi4vYXJlSW50ZXJ2YWxzT3ZlcmxhcHBpbmcuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTQgPSByZXF1aXJlKFwiLi9jbGFtcC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNSA9IHJlcXVpcmUoXCIuL2Nsb3Nlc3RJbmRleFRvLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2ID0gcmVxdWlyZShcIi4vY2xvc2VzdFRvLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE3ID0gcmVxdWlyZShcIi4vY29tcGFyZUFzYy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxN1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOCA9IHJlcXVpcmUoXCIuL2NvbXBhcmVEZXNjLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MThba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE5ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxOVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdE5vdy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMSA9IHJlcXVpcmUoXCIuL2RheXNUb1dlZWtzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIxW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIyID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQnVzaW5lc3NEYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIzID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI0ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJJU09XZWVrWWVhcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjRba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjUgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhcklTT1dlZWtzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDI1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI2ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyNikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjcgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDI3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4Mjdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI4ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDI4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyOFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDI4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyOSA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4Mjlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyOVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzAgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5EYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MzApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDMwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MzBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDMxID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluSG91cnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MzFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzMVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5JU09XZWVrWWVhcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MzJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzMltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzMgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5NaWxsaXNlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MzNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzQgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5NaW51dGVzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MzQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDM0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MzRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDM1ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluTW9udGhzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MzUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDM1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MzVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDM2ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluUXVhcnRlcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzNikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MzZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzNltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzcgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5TZWNvbmRzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MzcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDM3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4Mzdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDM4ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluV2Vla3MuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgzOCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4Mzhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzOFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MzkgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5ZZWFycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDM5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgzOVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDM5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg0MCA9IHJlcXVpcmUoXCIuL2VhY2hEYXlPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQxID0gcmVxdWlyZShcIi4vZWFjaEhvdXJPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQxW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQyID0gcmVxdWlyZShcIi4vZWFjaE1pbnV0ZU9mSW50ZXJ2YWwuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg0MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NDJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg0MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NDMgPSByZXF1aXJlKFwiLi9lYWNoTW9udGhPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQ0ID0gcmVxdWlyZShcIi4vZWFjaFF1YXJ0ZXJPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQ0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQ1ID0gcmVxdWlyZShcIi4vZWFjaFdlZWtPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQ1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQ2ID0gcmVxdWlyZShcIi4vZWFjaFdlZWtlbmRPZkludGVydmFsLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQ2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQ3ID0gcmVxdWlyZShcIi4vZWFjaFdlZWtlbmRPZk1vbnRoLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NDcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDQ3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NDdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQ4ID0gcmVxdWlyZShcIi4vZWFjaFdlZWtlbmRPZlllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg0OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NDhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg0OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NDkgPSByZXF1aXJlKFwiLi9lYWNoWWVhck9mSW50ZXJ2YWwuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg0OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NDlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg0OVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NTAgPSByZXF1aXJlKFwiLi9lbmRPZkRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDUwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1MFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDUwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg1MSA9IHJlcXVpcmUoXCIuL2VuZE9mRGVjYWRlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDUxW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NTFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDUyID0gcmVxdWlyZShcIi4vZW5kT2ZIb3VyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NTIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDUyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NTJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDUzID0gcmVxdWlyZShcIi4vZW5kT2ZJU09XZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NTMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDUzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NTNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDU0ID0gcmVxdWlyZShcIi4vZW5kT2ZJU09XZWVrWWVhci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDU0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDU0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg1NSA9IHJlcXVpcmUoXCIuL2VuZE9mTWludXRlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NTUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDU1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NTVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDU2ID0gcmVxdWlyZShcIi4vZW5kT2ZNb250aC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDU2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDU2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg1NyA9IHJlcXVpcmUoXCIuL2VuZE9mUXVhcnRlci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDU3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1N1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDU3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg1OCA9IHJlcXVpcmUoXCIuL2VuZE9mU2Vjb25kLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDU4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NThba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDU5ID0gcmVxdWlyZShcIi4vZW5kT2ZUb2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDU5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg1OVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDU5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg2MCA9IHJlcXVpcmUoXCIuL2VuZE9mVG9tb3Jyb3cuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2MCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NjBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg2MFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NjEgPSByZXF1aXJlKFwiLi9lbmRPZldlZWsuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2MSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NjFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg2MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NjIgPSByZXF1aXJlKFwiLi9lbmRPZlllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NjJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg2MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NjMgPSByZXF1aXJlKFwiLi9lbmRPZlllc3RlcmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDYzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg2M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDYzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg2NCA9IHJlcXVpcmUoXCIuL2Zvcm1hdC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDY0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg2NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDY0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg2NSA9IHJlcXVpcmUoXCIuL2Zvcm1hdERpc3RhbmNlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NjUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDY1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NjVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDY2ID0gcmVxdWlyZShcIi4vZm9ybWF0RGlzdGFuY2VTdHJpY3QuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2NikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NjZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg2NltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NjcgPSByZXF1aXJlKFwiLi9mb3JtYXREaXN0YW5jZVRvTm93LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NjcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDY3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4Njdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDY4ID0gcmVxdWlyZShcIi4vZm9ybWF0RGlzdGFuY2VUb05vd1N0cmljdC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDY4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg2OFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDY4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg2OSA9IHJlcXVpcmUoXCIuL2Zvcm1hdER1cmF0aW9uLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NjkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDY5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4Njlba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDcwID0gcmVxdWlyZShcIi4vZm9ybWF0SVNPLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NzApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDcwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NzBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDcxID0gcmVxdWlyZShcIi4vZm9ybWF0SVNPOTA3NS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDcxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg3MVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDcxW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg3MiA9IHJlcXVpcmUoXCIuL2Zvcm1hdElTT0R1cmF0aW9uLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NzIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDcyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NzJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDczID0gcmVxdWlyZShcIi4vZm9ybWF0UkZDMzMzOS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDczKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg3M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDczW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg3NCA9IHJlcXVpcmUoXCIuL2Zvcm1hdFJGQzcyMzEuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg3NCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NzRba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg3NFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NzUgPSByZXF1aXJlKFwiLi9mb3JtYXRSZWxhdGl2ZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDc1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg3NVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDc1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg3NiA9IHJlcXVpcmUoXCIuL2Zyb21Vbml4VGltZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDc2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg3NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDc2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg3NyA9IHJlcXVpcmUoXCIuL2dldERhdGUuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg3NykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4Nzdba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg3N1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NzggPSByZXF1aXJlKFwiLi9nZXREYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg3OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4Nzhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg3OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4NzkgPSByZXF1aXJlKFwiLi9nZXREYXlPZlllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg3OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4Nzlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg3OVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4ODAgPSByZXF1aXJlKFwiLi9nZXREYXlzSW5Nb250aC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDgwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg4MFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDgwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg4MSA9IHJlcXVpcmUoXCIuL2dldERheXNJblllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg4MSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4ODFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg4MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4ODIgPSByZXF1aXJlKFwiLi9nZXREZWNhZGUuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg4MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4ODJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg4MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4ODMgPSByZXF1aXJlKFwiLi9nZXREZWZhdWx0T3B0aW9ucy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDgzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg4M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDgzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg4NCA9IHJlcXVpcmUoXCIuL2dldEhvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4ODQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDg0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4ODRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDg1ID0gcmVxdWlyZShcIi4vZ2V0SVNPRGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4ODUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDg1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4ODVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDg2ID0gcmVxdWlyZShcIi4vZ2V0SVNPV2Vlay5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDg2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg4NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDg2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg4NyA9IHJlcXVpcmUoXCIuL2dldElTT1dlZWtZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4ODcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDg3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4ODdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDg4ID0gcmVxdWlyZShcIi4vZ2V0SVNPV2Vla3NJblllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg4OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4ODhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg4OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4ODkgPSByZXF1aXJlKFwiLi9nZXRNaWxsaXNlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg4OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4ODlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg4OVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4OTAgPSByZXF1aXJlKFwiLi9nZXRNaW51dGVzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4OTApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDkwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4OTBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDkxID0gcmVxdWlyZShcIi4vZ2V0TW9udGguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg5MSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4OTFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg5MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4OTIgPSByZXF1aXJlKFwiLi9nZXRPdmVybGFwcGluZ0RheXNJbkludGVydmFscy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDkyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg5MltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDkyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg5MyA9IHJlcXVpcmUoXCIuL2dldFF1YXJ0ZXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg5MykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4OTNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg5M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4OTQgPSByZXF1aXJlKFwiLi9nZXRTZWNvbmRzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4OTQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDk0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4OTRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDk1ID0gcmVxdWlyZShcIi4vZ2V0VGltZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDk1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg5NVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDk1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg5NiA9IHJlcXVpcmUoXCIuL2dldFVuaXhUaW1lLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4OTYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDk2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4OTZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDk3ID0gcmVxdWlyZShcIi4vZ2V0V2Vlay5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDk3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg5N1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDk3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXg5OCA9IHJlcXVpcmUoXCIuL2dldFdlZWtPZk1vbnRoLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4OTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDk4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4OThba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDk5ID0gcmVxdWlyZShcIi4vZ2V0V2Vla1llYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg5OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4OTlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXg5OVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTAwID0gcmVxdWlyZShcIi4vZ2V0V2Vla3NJbk1vbnRoLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTAwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMDBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMDBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEwMSA9IHJlcXVpcmUoXCIuL2dldFllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMDEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEwMVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEwMVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTAyID0gcmVxdWlyZShcIi4vaG91cnNUb01pbGxpc2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTAyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTAyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMDMgPSByZXF1aXJlKFwiLi9ob3Vyc1RvTWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTAzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTAzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMDQgPSByZXF1aXJlKFwiLi9ob3Vyc1RvU2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTA0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTA0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMDUgPSByZXF1aXJlKFwiLi9pbnRlcnZhbC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwNSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTA1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTA1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMDYgPSByZXF1aXJlKFwiLi9pbnRlcnZhbFRvRHVyYXRpb24uanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMDYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEwNltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEwNltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTA3ID0gcmVxdWlyZShcIi4vaW50bEZvcm1hdC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwNykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTA3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTA3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMDggPSByZXF1aXJlKFwiLi9pbnRsRm9ybWF0RGlzdGFuY2UuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMDgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEwOFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEwOFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTA5ID0gcmVxdWlyZShcIi4vaXNBZnRlci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEwOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTA5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTA5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTAgPSByZXF1aXJlKFwiLi9pc0JlZm9yZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTEwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTEwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTEgPSByZXF1aXJlKFwiLi9pc0RhdGUuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDExMVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDExMVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTEyID0gcmVxdWlyZShcIi4vaXNFcXVhbC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTEyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTEyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTMgPSByZXF1aXJlKFwiLi9pc0V4aXN0cy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTEzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTEzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTQgPSByZXF1aXJlKFwiLi9pc0ZpcnN0RGF5T2ZNb250aC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTE0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTE0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTUgPSByZXF1aXJlKFwiLi9pc0ZyaWRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExNSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTE1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTE1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTYgPSByZXF1aXJlKFwiLi9pc0Z1dHVyZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExNikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTE2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTE2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMTcgPSByZXF1aXJlKFwiLi9pc0xhc3REYXlPZk1vbnRoLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTE3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMTdba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMTdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDExOCA9IHJlcXVpcmUoXCIuL2lzTGVhcFllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDExOFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDExOFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTE5ID0gcmVxdWlyZShcIi4vaXNNYXRjaC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDExOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTE5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTE5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMjAgPSByZXF1aXJlKFwiLi9pc01vbmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEyMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTIwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTIwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMjEgPSByZXF1aXJlKFwiLi9pc1Bhc3QuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMjEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyMVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEyMVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTIyID0gcmVxdWlyZShcIi4vaXNTYW1lRGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTIyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMjJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMjJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEyMyA9IHJlcXVpcmUoXCIuL2lzU2FtZUhvdXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMjMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyM1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEyM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTI0ID0gcmVxdWlyZShcIi4vaXNTYW1lSVNPV2Vlay5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEyNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTI0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTI0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMjUgPSByZXF1aXJlKFwiLi9pc1NhbWVJU09XZWVrWWVhci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEyNSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTI1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTI1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMjYgPSByZXF1aXJlKFwiLi9pc1NhbWVNaW51dGUuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMjYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyNltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEyNltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTI3ID0gcmVxdWlyZShcIi4vaXNTYW1lTW9udGguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMjcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyN1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEyN1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTI4ID0gcmVxdWlyZShcIi4vaXNTYW1lUXVhcnRlci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEyOCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTI4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTI4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMjkgPSByZXF1aXJlKFwiLi9pc1NhbWVTZWNvbmQuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMjkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEyOVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEyOVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTMwID0gcmVxdWlyZShcIi4vaXNTYW1lV2Vlay5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEzMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTMwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTMwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMzEgPSByZXF1aXJlKFwiLi9pc1NhbWVZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTMxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMzFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMzFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEzMiA9IHJlcXVpcmUoXCIuL2lzU2F0dXJkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMzIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEzMltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEzMltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTMzID0gcmVxdWlyZShcIi4vaXNTdW5kYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxMzMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDEzM1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDEzM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTM0ID0gcmVxdWlyZShcIi4vaXNUaGlzSG91ci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEzNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTM0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTM0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMzUgPSByZXF1aXJlKFwiLi9pc1RoaXNJU09XZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTM1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMzVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMzVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEzNiA9IHJlcXVpcmUoXCIuL2lzVGhpc01pbnV0ZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEzNikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTM2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTM2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMzcgPSByZXF1aXJlKFwiLi9pc1RoaXNNb250aC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEzNykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTM3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTM3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxMzggPSByZXF1aXJlKFwiLi9pc1RoaXNRdWFydGVyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTM4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxMzhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxMzhba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDEzOSA9IHJlcXVpcmUoXCIuL2lzVGhpc1NlY29uZC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDEzOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTM5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTM5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNDAgPSByZXF1aXJlKFwiLi9pc1RoaXNXZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTQwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNDBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNDBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE0MSA9IHJlcXVpcmUoXCIuL2lzVGhpc1llYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNDEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE0MVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTQyID0gcmVxdWlyZShcIi4vaXNUaHVyc2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE0MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTQyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTQyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNDMgPSByZXF1aXJlKFwiLi9pc1RvZGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTQzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNDNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNDNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE0NCA9IHJlcXVpcmUoXCIuL2lzVG9tb3Jyb3cuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNDQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE0NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0NFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTQ1ID0gcmVxdWlyZShcIi4vaXNUdWVzZGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTQ1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNDVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNDVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE0NiA9IHJlcXVpcmUoXCIuL2lzVmFsaWQuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNDYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE0NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0NltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTQ3ID0gcmVxdWlyZShcIi4vaXNXZWRuZXNkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNDcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE0N1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0N1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTQ4ID0gcmVxdWlyZShcIi4vaXNXZWVrZW5kLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTQ4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNDhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNDhba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE0OSA9IHJlcXVpcmUoXCIuL2lzV2l0aGluSW50ZXJ2YWwuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNDkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE0OVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE0OVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTUwID0gcmVxdWlyZShcIi4vaXNZZXN0ZXJkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1MFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1MFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTUxID0gcmVxdWlyZShcIi4vbGFzdERheU9mRGVjYWRlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTUxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNTFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNTFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE1MiA9IHJlcXVpcmUoXCIuL2xhc3REYXlPZklTT1dlZWsuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1MltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTUzID0gcmVxdWlyZShcIi4vbGFzdERheU9mSVNPV2Vla1llYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTU0ID0gcmVxdWlyZShcIi4vbGFzdERheU9mTW9udGguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1NFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTU1ID0gcmVxdWlyZShcIi4vbGFzdERheU9mUXVhcnRlci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE1NSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTU1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTU1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNTYgPSByZXF1aXJlKFwiLi9sYXN0RGF5T2ZXZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTU2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNTZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNTZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE1NyA9IHJlcXVpcmUoXCIuL2xhc3REYXlPZlllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1N1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1N1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTU4ID0gcmVxdWlyZShcIi4vbGlnaHRGb3JtYXQuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE1OFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE1OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTU5ID0gcmVxdWlyZShcIi4vbWF4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTU5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNTlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNTlba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2MCA9IHJlcXVpcmUoXCIuL21pbGxpc2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE2MCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTYwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTYwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNjEgPSByZXF1aXJlKFwiLi9taWxsaXNlY29uZHNUb0hvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTYxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNjFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNjFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2MiA9IHJlcXVpcmUoXCIuL21pbGxpc2Vjb25kc1RvTWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE2MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTYyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTYyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNjMgPSByZXF1aXJlKFwiLi9taWxsaXNlY29uZHNUb1NlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNjMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE2M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE2M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTY0ID0gcmVxdWlyZShcIi4vbWluLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTY0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNjRba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNjRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2NSA9IHJlcXVpcmUoXCIuL21pbnV0ZXNUb0hvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTY1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNjVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNjVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2NiA9IHJlcXVpcmUoXCIuL21pbnV0ZXNUb01pbGxpc2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE2NikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTY2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTY2W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNjcgPSByZXF1aXJlKFwiLi9taW51dGVzVG9TZWNvbmRzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTY3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNjdba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNjdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE2OCA9IHJlcXVpcmUoXCIuL21vbnRoc1RvUXVhcnRlcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNjgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE2OFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE2OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTY5ID0gcmVxdWlyZShcIi4vbW9udGhzVG9ZZWFycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE2OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTY5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTY5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNzAgPSByZXF1aXJlKFwiLi9uZXh0RGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTcwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxNzBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxNzBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE3MSA9IHJlcXVpcmUoXCIuL25leHRGcmlkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNzEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE3MVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE3MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTcyID0gcmVxdWlyZShcIi4vbmV4dE1vbmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTcyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTcyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNzMgPSByZXF1aXJlKFwiLi9uZXh0U2F0dXJkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNzMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE3M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE3M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTc0ID0gcmVxdWlyZShcIi4vbmV4dFN1bmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3NCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTc0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTc0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNzUgPSByZXF1aXJlKFwiLi9uZXh0VGh1cnNkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNzUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE3NVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE3NVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTc2ID0gcmVxdWlyZShcIi4vbmV4dFR1ZXNkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxNzYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE3NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE3NltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTc3ID0gcmVxdWlyZShcIi4vbmV4dFdlZG5lc2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3NykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTc3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTc3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNzggPSByZXF1aXJlKFwiLi9wYXJzZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTc4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTc4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxNzkgPSByZXF1aXJlKFwiLi9wYXJzZUlTTy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE3OSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTc5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTc5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxODAgPSByZXF1aXJlKFwiLi9wYXJzZUpTT04uanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxODApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE4MFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE4MFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTgxID0gcmVxdWlyZShcIi4vcHJldmlvdXNEYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxODEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE4MVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE4MVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTgyID0gcmVxdWlyZShcIi4vcHJldmlvdXNGcmlkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxODIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE4MltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE4MltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTgzID0gcmVxdWlyZShcIi4vcHJldmlvdXNNb25kYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxODMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE4M1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE4M1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTg0ID0gcmVxdWlyZShcIi4vcHJldmlvdXNTYXR1cmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE4NCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTg0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTg0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxODUgPSByZXF1aXJlKFwiLi9wcmV2aW91c1N1bmRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE4NSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTg1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTg1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxODYgPSByZXF1aXJlKFwiLi9wcmV2aW91c1RodXJzZGF5LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTg2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxODZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxODZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE4NyA9IHJlcXVpcmUoXCIuL3ByZXZpb3VzVHVlc2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE4NykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTg3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTg3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxODggPSByZXF1aXJlKFwiLi9wcmV2aW91c1dlZG5lc2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE4OCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTg4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTg4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxODkgPSByZXF1aXJlKFwiLi9xdWFydGVyc1RvTW9udGhzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTg5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxODlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxODlba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE5MCA9IHJlcXVpcmUoXCIuL3F1YXJ0ZXJzVG9ZZWFycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5MCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTkwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTkwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOTEgPSByZXF1aXJlKFwiLi9yb3VuZFRvTmVhcmVzdEhvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTkxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxOTFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxOTFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDE5MiA9IHJlcXVpcmUoXCIuL3JvdW5kVG9OZWFyZXN0TWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTkyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTkyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOTMgPSByZXF1aXJlKFwiLi9zZWNvbmRzVG9Ib3Vycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5MykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTkzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTkzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOTQgPSByZXF1aXJlKFwiLi9zZWNvbmRzVG9NaWxsaXNlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxOTQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE5NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE5NFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTk1ID0gcmVxdWlyZShcIi4vc2Vjb25kc1RvTWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5NSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTk1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTk1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOTYgPSByZXF1aXJlKFwiLi9zZXQuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxOTYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE5NltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE5NltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTk3ID0gcmVxdWlyZShcIi4vc2V0RGF0ZS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDE5NykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MTk3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MTk3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgxOTggPSByZXF1aXJlKFwiLi9zZXREYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgxOTgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDE5OFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDE5OFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MTk5ID0gcmVxdWlyZShcIi4vc2V0RGF5T2ZZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MTk5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgxOTlba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgxOTlba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwMCA9IHJlcXVpcmUoXCIuL3NldERlZmF1bHRPcHRpb25zLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjAwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwMSA9IHJlcXVpcmUoXCIuL3NldEhvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjAxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwMiA9IHJlcXVpcmUoXCIuL3NldElTT0RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIwMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjAyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjAyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMDMgPSByZXF1aXJlKFwiLi9zZXRJU09XZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjAzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwNCA9IHJlcXVpcmUoXCIuL3NldElTT1dlZWtZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjA0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDRba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwNSA9IHJlcXVpcmUoXCIuL3NldE1pbGxpc2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIwNSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjA1W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjA1W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMDYgPSByZXF1aXJlKFwiLi9zZXRNaW51dGVzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjA2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwNyA9IHJlcXVpcmUoXCIuL3NldE1vbnRoLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjA3KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMDdba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMDdba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIwOCA9IHJlcXVpcmUoXCIuL3NldFF1YXJ0ZXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMDgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIwOFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIwOFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjA5ID0gcmVxdWlyZShcIi4vc2V0U2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIwOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjA5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjA5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMTAgPSByZXF1aXJlKFwiLi9zZXRXZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMTBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMTBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxMSA9IHJlcXVpcmUoXCIuL3NldFdlZWtZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjExKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMTFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMTFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxMiA9IHJlcXVpcmUoXCIuL3NldFllYXIuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMTIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIxMltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIxMltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjEzID0gcmVxdWlyZShcIi4vc3RhcnRPZkRheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIxMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjEzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjEzW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMTQgPSByZXF1aXJlKFwiLi9zdGFydE9mRGVjYWRlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjE0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMTRba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMTRba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxNSA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZIb3VyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjE1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMTVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMTVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxNiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjE2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMTZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMTZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxNyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrWWVhci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIxNykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjE3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjE3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMTggPSByZXF1aXJlKFwiLi9zdGFydE9mTWludXRlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjE4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMThba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMThba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIxOSA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZNb250aC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIxOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjE5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjE5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMjAgPSByZXF1aXJlKFwiLi9zdGFydE9mUXVhcnRlci5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIyMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjIwW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjIwW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMjEgPSByZXF1aXJlKFwiLi9zdGFydE9mU2Vjb25kLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjIxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMjFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMjFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIyMiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZUb2RheS5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIyMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjIyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjIyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMjMgPSByZXF1aXJlKFwiLi9zdGFydE9mVG9tb3Jyb3cuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMjMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIyM1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIyM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjI0ID0gcmVxdWlyZShcIi4vc3RhcnRPZldlZWsuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMjQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIyNFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIyNFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjI1ID0gcmVxdWlyZShcIi4vc3RhcnRPZldlZWtZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjI1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMjVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMjVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIyNiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZZZWFyLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjI2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMjZba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMjZba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIyNyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZZZXN0ZXJkYXkuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMjcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIyN1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIyN1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjI4ID0gcmVxdWlyZShcIi4vc3ViLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjI4KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMjhba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMjhba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIyOSA9IHJlcXVpcmUoXCIuL3N1YkJ1c2luZXNzRGF5cy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIyOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjI5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjI5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMzAgPSByZXF1aXJlKFwiLi9zdWJEYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjMwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMzBba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMzBba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIzMSA9IHJlcXVpcmUoXCIuL3N1YkhvdXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjMxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyMzFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyMzFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDIzMiA9IHJlcXVpcmUoXCIuL3N1YklTT1dlZWtZZWFycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIzMikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjMyW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjMyW2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMzMgPSByZXF1aXJlKFwiLi9zdWJNaWxsaXNlY29uZHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMzMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIzM1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIzM1trZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjM0ID0gcmVxdWlyZShcIi4vc3ViTWludXRlcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIzNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjM0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjM0W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMzUgPSByZXF1aXJlKFwiLi9zdWJNb250aHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMzUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIzNVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIzNVtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjM2ID0gcmVxdWlyZShcIi4vc3ViUXVhcnRlcnMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyMzYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDIzNltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDIzNltrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjM3ID0gcmVxdWlyZShcIi4vc3ViU2Vjb25kcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIzNykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjM3W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjM3W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMzggPSByZXF1aXJlKFwiLi9zdWJXZWVrcy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIzOCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjM4W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjM4W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyMzkgPSByZXF1aXJlKFwiLi9zdWJZZWFycy5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDIzOSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MjM5W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4MjM5W2tleV07XG4gICAgfSxcbiAgfSk7XG59KTtcbnZhciBfaW5kZXgyNDAgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyNDApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDI0MFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDI0MFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjQxID0gcmVxdWlyZShcIi4vdHJhbnNwb3NlLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjQxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyNDFba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNDFba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI0MiA9IHJlcXVpcmUoXCIuL3dlZWtzVG9EYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjQyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyNDJba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNDJba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI0MyA9IHJlcXVpcmUoXCIuL3llYXJzVG9EYXlzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjQzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyNDNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNDNba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xudmFyIF9pbmRleDI0NCA9IHJlcXVpcmUoXCIuL3llYXJzVG9Nb250aHMuanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgyNDQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDI0NFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDI0NFtrZXldO1xuICAgIH0sXG4gIH0pO1xufSk7XG52YXIgX2luZGV4MjQ1ID0gcmVxdWlyZShcIi4veWVhcnNUb1F1YXJ0ZXJzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MjQ1KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXgyNDVba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgyNDVba2V5XTtcbiAgICB9LFxuICB9KTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmludGVydmFsID0gaW50ZXJ2YWw7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgaW50ZXJ2YWx9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBpbnRlcnZhbFxuICogQGNhdGVnb3J5IEludGVydmFsIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENyZWF0ZXMgYW4gaW50ZXJ2YWwgb2JqZWN0IGFuZCB2YWxpZGF0ZXMgaXRzIHZhbHVlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBub3JtYWxpemVkIGludGVydmFsIG9iamVjdCBhbmQgdmFsaWRhdGVzIGl0cyB2YWx1ZXMuIElmIHRoZSBpbnRlcnZhbCBpcyBpbnZhbGlkLCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBzdGFydCAtIFRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZiB0aGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAdGhyb3dzIGBTdGFydCBkYXRlIGlzIGludmFsaWRgIHdoZW4gYHN0YXJ0YCBpcyBpbnZhbGlkLlxuICogQHRocm93cyBgRW5kIGRhdGUgaXMgaW52YWxpZGAgd2hlbiBgZW5kYCBpcyBpbnZhbGlkLlxuICogQHRocm93cyBgRW5kIGRhdGUgbXVzdCBiZSBhZnRlciBzdGFydCBkYXRlYCB3aGVuIGVuZCBpcyBiZWZvcmUgYHN0YXJ0YCBhbmQgYG9wdGlvbnMuYXNzZXJ0UG9zaXRpdmVgIGlzIHRydWUuXG4gKlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgYW5kIHZhbGlkYXRlZCBpbnRlcnZhbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGludGVydmFsKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgY29uc3QgX3N0YXJ0ID0gKDAsIF9pbmRleC50b0RhdGUpKHN0YXJ0KTtcbiAgaWYgKGlzTmFOKCtfc3RhcnQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgZGF0ZSBpcyBpbnZhbGlkXCIpO1xuXG4gIGNvbnN0IF9lbmQgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZW5kKTtcbiAgaWYgKGlzTmFOKCtfZW5kKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVuZCBkYXRlIGlzIGludmFsaWRcIik7XG5cbiAgaWYgKG9wdGlvbnM/LmFzc2VydFBvc2l0aXZlICYmICtfc3RhcnQgPiArX2VuZClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRW5kIGRhdGUgbXVzdCBiZSBhZnRlciBzdGFydCBkYXRlXCIpO1xuXG4gIHJldHVybiB7IHN0YXJ0OiBfc3RhcnQsIGVuZDogX2VuZCB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmludGVydmFsVG9EdXJhdGlvbiA9IGludGVydmFsVG9EdXJhdGlvbjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGQuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJbkRheXMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJbkhvdXJzLmpzXCIpO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5NaW51dGVzLmpzXCIpO1xudmFyIF9pbmRleDUgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5Nb250aHMuanNcIik7XG52YXIgX2luZGV4NiA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJblNlY29uZHMuanNcIik7XG52YXIgX2luZGV4NyA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJblllYXJzLmpzXCIpO1xudmFyIF9pbmRleDggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaW50ZXJ2YWxUb0R1cmF0aW9uXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgaW50ZXJ2YWwgdG8gZHVyYXRpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgYSBpbnRlcnZhbCBvYmplY3QgdG8gYSBkdXJhdGlvbiBvYmplY3QuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGludGVydmFsIC0gVGhlIGludGVydmFsIHRvIGNvbnZlcnQgdG8gZHVyYXRpb25cbiAqXG4gKiBAcmV0dXJucyBUaGUgZHVyYXRpb24gb2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEdldCB0aGUgZHVyYXRpb24gYmV0d2VlbiBKYW51YXJ5IDE1LCAxOTI5IGFuZCBBcHJpbCA0LCAxOTY4LlxuICogaW50ZXJ2YWxUb0R1cmF0aW9uKHtcbiAqICAgc3RhcnQ6IG5ldyBEYXRlKDE5MjksIDAsIDE1LCAxMiwgMCwgMCksXG4gKiAgIGVuZDogbmV3IERhdGUoMTk2OCwgMywgNCwgMTksIDUsIDApXG4gKiB9KVxuICogLy8gPT4geyB5ZWFyczogMzksIG1vbnRoczogMiwgZGF5czogMjAsIGhvdXJzOiA3LCBtaW51dGVzOiA1LCBzZWNvbmRzOiAwIH1cbiAqL1xuZnVuY3Rpb24gaW50ZXJ2YWxUb0R1cmF0aW9uKGludGVydmFsKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKDAsIF9pbmRleDgudG9EYXRlKShpbnRlcnZhbC5zdGFydCk7XG4gIGNvbnN0IGVuZCA9ICgwLCBfaW5kZXg4LnRvRGF0ZSkoaW50ZXJ2YWwuZW5kKTtcblxuICBjb25zdCBkdXJhdGlvbiA9IHt9O1xuXG4gIGNvbnN0IHllYXJzID0gKDAsIF9pbmRleDcuZGlmZmVyZW5jZUluWWVhcnMpKGVuZCwgc3RhcnQpO1xuICBpZiAoeWVhcnMpIGR1cmF0aW9uLnllYXJzID0geWVhcnM7XG5cbiAgY29uc3QgcmVtYWluaW5nTW9udGhzID0gKDAsIF9pbmRleC5hZGQpKHN0YXJ0LCB7IHllYXJzOiBkdXJhdGlvbi55ZWFycyB9KTtcblxuICBjb25zdCBtb250aHMgPSAoMCwgX2luZGV4NS5kaWZmZXJlbmNlSW5Nb250aHMpKGVuZCwgcmVtYWluaW5nTW9udGhzKTtcbiAgaWYgKG1vbnRocykgZHVyYXRpb24ubW9udGhzID0gbW9udGhzO1xuXG4gIGNvbnN0IHJlbWFpbmluZ0RheXMgPSAoMCwgX2luZGV4LmFkZCkocmVtYWluaW5nTW9udGhzLCB7XG4gICAgbW9udGhzOiBkdXJhdGlvbi5tb250aHMsXG4gIH0pO1xuXG4gIGNvbnN0IGRheXMgPSAoMCwgX2luZGV4Mi5kaWZmZXJlbmNlSW5EYXlzKShlbmQsIHJlbWFpbmluZ0RheXMpO1xuICBpZiAoZGF5cykgZHVyYXRpb24uZGF5cyA9IGRheXM7XG5cbiAgY29uc3QgcmVtYWluaW5nSG91cnMgPSAoMCwgX2luZGV4LmFkZCkocmVtYWluaW5nRGF5cywge1xuICAgIGRheXM6IGR1cmF0aW9uLmRheXMsXG4gIH0pO1xuXG4gIGNvbnN0IGhvdXJzID0gKDAsIF9pbmRleDMuZGlmZmVyZW5jZUluSG91cnMpKGVuZCwgcmVtYWluaW5nSG91cnMpO1xuICBpZiAoaG91cnMpIGR1cmF0aW9uLmhvdXJzID0gaG91cnM7XG5cbiAgY29uc3QgcmVtYWluaW5nTWludXRlcyA9ICgwLCBfaW5kZXguYWRkKShyZW1haW5pbmdIb3Vycywge1xuICAgIGhvdXJzOiBkdXJhdGlvbi5ob3VycyxcbiAgfSk7XG5cbiAgY29uc3QgbWludXRlcyA9ICgwLCBfaW5kZXg0LmRpZmZlcmVuY2VJbk1pbnV0ZXMpKGVuZCwgcmVtYWluaW5nTWludXRlcyk7XG4gIGlmIChtaW51dGVzKSBkdXJhdGlvbi5taW51dGVzID0gbWludXRlcztcblxuICBjb25zdCByZW1haW5pbmdTZWNvbmRzID0gKDAsIF9pbmRleC5hZGQpKHJlbWFpbmluZ01pbnV0ZXMsIHtcbiAgICBtaW51dGVzOiBkdXJhdGlvbi5taW51dGVzLFxuICB9KTtcblxuICBjb25zdCBzZWNvbmRzID0gKDAsIF9pbmRleDYuZGlmZmVyZW5jZUluU2Vjb25kcykoZW5kLCByZW1haW5pbmdTZWNvbmRzKTtcbiAgaWYgKHNlY29uZHMpIGR1cmF0aW9uLnNlY29uZHMgPSBzZWNvbmRzO1xuXG4gIHJldHVybiBkdXJhdGlvbjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pbnRsRm9ybWF0ID0gaW50bEZvcm1hdDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogVGhlIGxvY2FsZSBzdHJpbmcgKHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNsb2NhbGVzX2FyZ3VtZW50KS5cbiAqL1xuXG4vKipcbiAqIFRoZSBmb3JtYXQgb3B0aW9ucyAoc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL0RhdGVUaW1lRm9ybWF0L0RhdGVUaW1lRm9ybWF0I29wdGlvbnMpXG4gKi9cblxuLyoqXG4gKiBUaGUgbG9jYWxlIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBpbnRsRm9ybWF0XG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZSB3aXRoIEludGwuRGF0ZVRpbWVGb3JtYXQgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvRGF0ZVRpbWVGb3JtYXQpLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC5cbiAqIFRoZSBtZXRob2QgdXNlcyBbYEludGwuRGF0ZVRpbWVGb3JtYXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL0RhdGVUaW1lRm9ybWF0KSBpbnNpZGUuXG4gKiBmb3JtYXRPcHRpb25zIGFyZSB0aGUgc2FtZSBhcyBbYEludGwuRGF0ZVRpbWVGb3JtYXRgIG9wdGlvbnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvRGF0ZVRpbWVGb3JtYXQjdXNpbmdfb3B0aW9ucylcbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IGJlZm9yZSBOb2RlIHZlcnNpb24gMTMuMC4wLCBvbmx5IHRoZSBsb2NhbGUgZGF0YSBmb3IgZW4tVVMgaXMgYXZhaWxhYmxlIGJ5IGRlZmF1bHQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXRcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCA0IE9jdG9iZXIgMjAxOSBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAqIGNvbnN0IHJlc3VsdCA9IGludGxGb3JtYXQobmV3IERhdGUoMjAxOSwgOSwgNCwgMTIsIDMwLCAxMywgNDU2KSlcbiAqIC8vPT4gMTAvNC8yMDE5XG4gKi9cblxuLyoqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHBhcmFtIGxvY2FsZU9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBsb2NhbGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCA0IE9jdG9iZXIgMjAxOSBpbiBLb3JlYW4uXG4gKiAvLyBDb252ZXJ0IHRoZSBkYXRlIHdpdGggbG9jYWxlJ3Mgb3B0aW9ucy5cbiAqIGNvbnN0IHJlc3VsdCA9IGludGxGb3JtYXQobmV3IERhdGUoMjAxOSwgOSwgNCwgMTIsIDMwLCAxMywgNDU2KSwge1xuICogICBsb2NhbGU6ICdrby1LUicsXG4gKiB9KVxuICogLy89PiAyMDE5LiAxMC4gNC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gZm9ybWF0XG4gKiBAcGFyYW0gZm9ybWF0T3B0aW9ucyAtIFRoZSBmb3JtYXQgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqXG4gKiBAdGhyb3dzIGBkYXRlYCBtdXN0IG5vdCBiZSBJbnZhbGlkIERhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDQgT2N0b2JlciAyMDE5LlxuICogLy8gQ29udmVydCB0aGUgZGF0ZSB3aXRoIGZvcm1hdCdzIG9wdGlvbnMuXG4gKiBjb25zdCByZXN1bHQgPSBpbnRsRm9ybWF0LmRlZmF1bHQobmV3IERhdGUoMjAxOSwgOSwgNCwgMTIsIDMwLCAxMywgNDU2KSwge1xuICogICB5ZWFyOiAnbnVtZXJpYycsXG4gKiAgIG1vbnRoOiAnbnVtZXJpYycsXG4gKiAgIGRheTogJ251bWVyaWMnLFxuICogICBob3VyOiAnbnVtZXJpYycsXG4gKiB9KVxuICogLy89PiAxMC80LzIwMTksIDEyIFBNXG4gKi9cblxuLyoqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHBhcmFtIGZvcm1hdE9wdGlvbnMgLSBUaGUgZm9ybWF0IG9wdGlvbnNcbiAqIEBwYXJhbSBsb2NhbGVPcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggbG9jYWxlXG4gKlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICpcbiAqIEB0aHJvd3MgYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXByZXNlbnQgNCBPY3RvYmVyIDIwMTkgaW4gR2VybWFuLlxuICogLy8gQ29udmVydCB0aGUgZGF0ZSB3aXRoIGZvcm1hdCdzIG9wdGlvbnMgYW5kIGxvY2FsZSdzIG9wdGlvbnMuXG4gKiBjb25zdCByZXN1bHQgPSBpbnRsRm9ybWF0KG5ldyBEYXRlKDIwMTksIDksIDQsIDEyLCAzMCwgMTMsIDQ1NiksIHtcbiAqICAgd2Vla2RheTogJ2xvbmcnLFxuICogICB5ZWFyOiAnbnVtZXJpYycsXG4gKiAgIG1vbnRoOiAnbG9uZycsXG4gKiAgIGRheTogJ251bWVyaWMnLFxuICogfSwge1xuICogICBsb2NhbGU6ICdkZS1ERScsXG4gKiB9KVxuICogLy89PiBGcmVpdGFnLCA0LiBPa3RvYmVyIDIwMTlcbiAqL1xuXG5mdW5jdGlvbiBpbnRsRm9ybWF0KGRhdGUsIGZvcm1hdE9yTG9jYWxlLCBsb2NhbGVPcHRpb25zKSB7XG4gIGxldCBmb3JtYXRPcHRpb25zO1xuXG4gIGlmIChpc0Zvcm1hdE9wdGlvbnMoZm9ybWF0T3JMb2NhbGUpKSB7XG4gICAgZm9ybWF0T3B0aW9ucyA9IGZvcm1hdE9yTG9jYWxlO1xuICB9IGVsc2Uge1xuICAgIGxvY2FsZU9wdGlvbnMgPSBmb3JtYXRPckxvY2FsZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGVPcHRpb25zPy5sb2NhbGUsIGZvcm1hdE9wdGlvbnMpLmZvcm1hdChcbiAgICAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSksXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybWF0T3B0aW9ucyhvcHRzKSB7XG4gIHJldHVybiBvcHRzICE9PSB1bmRlZmluZWQgJiYgIShcImxvY2FsZVwiIGluIG9wdHMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmludGxGb3JtYXREaXN0YW5jZSA9IGludGxGb3JtYXREaXN0YW5jZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocy5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycy5qc1wiKTtcbnZhciBfaW5kZXg1ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcy5qc1wiKTtcbnZhciBfaW5kZXg2ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycy5qc1wiKTtcbnZhciBfaW5kZXg3ID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluSG91cnMuanNcIik7XG52YXIgX2luZGV4OCA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJbk1pbnV0ZXMuanNcIik7XG52YXIgX2luZGV4OSA9IHJlcXVpcmUoXCIuL2RpZmZlcmVuY2VJblNlY29uZHMuanNcIik7XG52YXIgX2luZGV4MTAgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBpbnRsRm9ybWF0RGlzdGFuY2V9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBUaGUgdW5pdCB1c2VkIHRvIGZvcm1hdCB0aGUgZGlzdGFuY2UgaW4ge0BsaW5rIGludGxGb3JtYXREaXN0YW5jZX0uXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBpbnRsRm9ybWF0RGlzdGFuY2VcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0cyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBkYXRlcyBpbiBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBkYXRlcyBhbmQgZm9ybWF0cyBpdCBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBwaWNrIHRoZSBtb3N0IGFwcHJvcHJpYXRlIHVuaXQgZGVwZW5kaW5nIG9uIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGRhdGVzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIGRpc3RhbmNlIGlzIGEgZmV3IGhvdXJzLCBpdCBtaWdodCByZXR1cm4gYHggaG91cnNgLiBJZiB0aGUgZGlzdGFuY2UgaXMgYSBmZXcgbW9udGhzLCBpdCBtaWdodCByZXR1cm4gYHggbW9udGhzYC5cbiAqXG4gKiBZb3UgY2FuIGFsc28gc3BlY2lmeSBhIHVuaXQgdG8gZm9yY2UgdXNpbmcgaXQgcmVnYXJkbGVzcyBvZiB0aGUgZGlzdGFuY2UgdG8gZ2V0IGEgcmVzdWx0IGxpa2UgYDEyMzQ1NiBob3Vyc2AuXG4gKlxuICogU2VlIHRoZSB0YWJsZSBiZWxvdyBmb3IgdGhlIHVuaXQgcGlja2luZyBsb2dpYzpcbiAqXG4gKiB8IERpc3RhbmNlIGJldHdlZW4gZGF0ZXMgfCBSZXN1bHQgKHBhc3QpICB8IFJlc3VsdCAoZnV0dXJlKSB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IDAgc2Vjb25kcyAgICAgICAgICAgICAgfCBub3cgICAgICAgICAgICB8IG5vdyAgICAgICAgICAgICB8XG4gKiB8IDEtNTkgc2Vjb25kcyAgICAgICAgICAgfCBYIHNlY29uZHMgYWdvICB8IGluIFggc2Vjb25kcyAgICB8XG4gKiB8IDEtNTkgbWludXRlcyAgICAgICAgICAgfCBYIG1pbnV0ZXMgYWdvICB8IGluIFggbWludXRlcyAgICB8XG4gKiB8IDEtMjMgaG91cnMgICAgICAgICAgICAgfCBYIGhvdXJzIGFnbyAgICB8IGluIFggaG91cnMgICAgICB8XG4gKiB8IDEgZGF5ICAgICAgICAgICAgICAgICAgfCB5ZXN0ZXJkYXkgICAgICB8IHRvbW9ycm93ICAgICAgICB8XG4gKiB8IDItNiBkYXlzICAgICAgICAgICAgICAgfCBYIGRheXMgYWdvICAgICB8IGluIFggZGF5cyAgICAgICB8XG4gKiB8IDcgZGF5cyAgICAgICAgICAgICAgICAgfCBsYXN0IHdlZWsgICAgICB8IG5leHQgd2VlayAgICAgICB8XG4gKiB8IDggZGF5cy0xIG1vbnRoICAgICAgICAgfCBYIHdlZWtzIGFnbyAgICB8IGluIFggd2Vla3MgICAgICB8XG4gKiB8IDEgbW9udGggICAgICAgICAgICAgICAgfCBsYXN0IG1vbnRoICAgICB8IG5leHQgbW9udGggICAgICB8XG4gKiB8IDItMyBtb250aHMgICAgICAgICAgICAgfCBYIG1vbnRocyBhZ28gICB8IGluIFggbW9udGhzICAgICB8XG4gKiB8IDEgcXVhcnRlciAgICAgICAgICAgICAgfCBsYXN0IHF1YXJ0ZXIgICB8IG5leHQgcXVhcnRlciAgICB8XG4gKiB8IDItMyBxdWFydGVycyAgICAgICAgICAgfCBYIHF1YXJ0ZXJzIGFnbyB8IGluIFggcXVhcnRlcnMgICB8XG4gKiB8IDEgeWVhciAgICAgICAgICAgICAgICAgfCBsYXN0IHllYXIgICAgICB8IG5leHQgeWVhciAgICAgICB8XG4gKiB8IDIrIHllYXJzICAgICAgICAgICAgICAgfCBYIHllYXJzIGFnbyAgICB8IGluIFggeWVhcnMgICAgICB8XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZVxuICogQHBhcmFtIGJhc2VEYXRlIC0gVGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogU2VlIE1ETiBmb3IgZGV0YWlscyBbTG9jYWxlIGlkZW50aWZpY2F0aW9uIGFuZCBuZWdvdGlhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNsb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9uKVxuICogVGhlIG5hcnJvdyBvbmUgY291bGQgYmUgc2ltaWxhciB0byB0aGUgc2hvcnQgb25lIGZvciBzb21lIGxvY2FsZXMuXG4gKlxuICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGluIHdvcmRzIGFjY29yZGluZyB0byBsYW5ndWFnZS1zZW5zaXRpdmUgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nLlxuICpcbiAqIEB0aHJvd3MgYGRhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICogQHRocm93cyBgYmFzZURhdGVgIG11c3Qgbm90IGJlIEludmFsaWQgRGF0ZVxuICogQHRocm93cyBgb3B0aW9ucy51bml0YCBtdXN0IG5vdCBiZSBpbnZhbGlkIFVuaXRcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IG5vdCBiZSBpbnZhbGlkIGxvY2FsZVxuICogQHRocm93cyBgb3B0aW9ucy5sb2NhbGVNYXRjaGVyYCBtdXN0IG5vdCBiZSBpbnZhbGlkIGxvY2FsZU1hdGNoZXJcbiAqIEB0aHJvd3MgYG9wdGlvbnMubnVtZXJpY2AgbXVzdCBub3QgYmUgaW52YWxpZCBudW1lcmljXG4gKiBAdGhyb3dzIGBvcHRpb25zLnN0eWxlYCBtdXN0IG5vdCBiZSBpbnZhbGlkIHN0eWxlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoYXQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGVzIHdoZW4gdGhlIGZpc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kP1xuICogaW50bEZvcm1hdERpc3RhbmNlKFxuICogICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMSwgMzAsIDApLFxuICogICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMCwgMzAsIDApXG4gKiApXG4gKiAvLz0+ICdpbiAxIGhvdXInXG4gKlxuICogLy8gV2hhdCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0ZXMgd2hlbiB0aGUgZmlzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kP1xuICogaW50bEZvcm1hdERpc3RhbmNlKFxuICogICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMCwgMzAsIDApLFxuICogICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMSwgMzAsIDApXG4gKiApXG4gKiAvLz0+ICcxIGhvdXIgYWdvJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVc2UgdGhlIHVuaXQgb3B0aW9uIHRvIGZvcmNlIHRoZSBmdW5jdGlvbiB0byBvdXRwdXQgdGhlIHJlc3VsdCBpbiBxdWFydGVycy4gV2l0aG91dCBzZXR0aW5nIGl0LCB0aGUgZXhhbXBsZSB3b3VsZCByZXR1cm4gXCJuZXh0IHllYXJcIlxuICogaW50bEZvcm1hdERpc3RhbmNlKFxuICogICBuZXcgRGF0ZSgxOTg3LCA2LCA0LCAxMCwgMzAsIDApLFxuICogICBuZXcgRGF0ZSgxOTg2LCAzLCA0LCAxMCwgMzAsIDApLFxuICogICB7IHVuaXQ6ICdxdWFydGVyJyB9XG4gKiApXG4gKiAvLz0+ICdpbiA1IHF1YXJ0ZXJzJ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBVc2UgdGhlIGxvY2FsZSBvcHRpb24gdG8gZ2V0IHRoZSByZXN1bHQgaW4gU3BhbmlzaC4gV2l0aG91dCBzZXR0aW5nIGl0LCB0aGUgZXhhbXBsZSB3b3VsZCByZXR1cm4gXCJpbiAxIGhvdXJcIi5cbiAqIGludGxGb3JtYXREaXN0YW5jZShcbiAqICAgbmV3IERhdGUoMTk4NiwgMywgNCwgMTEsIDMwLCAwKSxcbiAqICAgbmV3IERhdGUoMTk4NiwgMywgNCwgMTAsIDMwLCAwKSxcbiAqICAgeyBsb2NhbGU6ICdlcycgfVxuICogKVxuICogLy89PiAnZGVudHJvIGRlIDEgaG9yYSdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVXNlIHRoZSBudW1lcmljIG9wdGlvbiB0byBmb3JjZSB0aGUgZnVuY3Rpb24gdG8gdXNlIG51bWVyaWMgdmFsdWVzLiBXaXRob3V0IHNldHRpbmcgaXQsIHRoZSBleGFtcGxlIHdvdWxkIHJldHVybiBcInRvbW9ycm93XCIuXG4gKiBpbnRsRm9ybWF0RGlzdGFuY2UoXG4gKiAgIG5ldyBEYXRlKDE5ODYsIDMsIDUsIDExLCAzMCwgMCksXG4gKiAgIG5ldyBEYXRlKDE5ODYsIDMsIDQsIDExLCAzMCwgMCksXG4gKiAgIHsgbnVtZXJpYzogJ2Fsd2F5cycgfVxuICogKVxuICogLy89PiAnaW4gMSBkYXknXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVzZSB0aGUgc3R5bGUgb3B0aW9uIHRvIGZvcmNlIHRoZSBmdW5jdGlvbiB0byB1c2Ugc2hvcnQgdmFsdWVzLiBXaXRob3V0IHNldHRpbmcgaXQsIHRoZSBleGFtcGxlIHdvdWxkIHJldHVybiBcImluIDIgeWVhcnNcIi5cbiAqIGludGxGb3JtYXREaXN0YW5jZShcbiAqICAgbmV3IERhdGUoMTk4OCwgMywgNCwgMTEsIDMwLCAwKSxcbiAqICAgbmV3IERhdGUoMTk4NiwgMywgNCwgMTEsIDMwLCAwKSxcbiAqICAgeyBzdHlsZTogJ3Nob3J0JyB9XG4gKiApXG4gKiAvLz0+ICdpbiAyIHlyJ1xuICovXG5mdW5jdGlvbiBpbnRsRm9ybWF0RGlzdGFuY2UoZGF0ZSwgYmFzZURhdGUsIG9wdGlvbnMpIHtcbiAgbGV0IHZhbHVlID0gMDtcbiAgbGV0IHVuaXQ7XG4gIGNvbnN0IGRhdGVMZWZ0ID0gKDAsIF9pbmRleDEwLnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGRhdGVSaWdodCA9ICgwLCBfaW5kZXgxMC50b0RhdGUpKGJhc2VEYXRlKTtcblxuICBpZiAoIW9wdGlvbnM/LnVuaXQpIHtcbiAgICAvLyBHZXQgdGhlIHVuaXQgYmFzZWQgb24gZGlmZkluU2Vjb25kcyBjYWxjdWxhdGlvbnMgaWYgbm8gdW5pdCBpcyBzcGVjaWZpZWRcbiAgICBjb25zdCBkaWZmSW5TZWNvbmRzID0gKDAsIF9pbmRleDkuZGlmZmVyZW5jZUluU2Vjb25kcykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7IC8vIFRoZSBzbWFsbGVzdCB1bml0XG5cbiAgICBpZiAoTWF0aC5hYnMoZGlmZkluU2Vjb25kcykgPCBfaW5kZXguc2Vjb25kc0luTWludXRlKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg5LmRpZmZlcmVuY2VJblNlY29uZHMpKGRhdGVMZWZ0LCBkYXRlUmlnaHQpO1xuICAgICAgdW5pdCA9IFwic2Vjb25kXCI7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmSW5TZWNvbmRzKSA8IF9pbmRleC5zZWNvbmRzSW5Ib3VyKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg4LmRpZmZlcmVuY2VJbk1pbnV0ZXMpKGRhdGVMZWZ0LCBkYXRlUmlnaHQpO1xuICAgICAgdW5pdCA9IFwibWludXRlXCI7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIE1hdGguYWJzKGRpZmZJblNlY29uZHMpIDwgX2luZGV4LnNlY29uZHNJbkRheSAmJlxuICAgICAgTWF0aC5hYnMoKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSkgPCAxXG4gICAgKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg3LmRpZmZlcmVuY2VJbkhvdXJzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgICAgIHVuaXQgPSBcImhvdXJcIjtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgTWF0aC5hYnMoZGlmZkluU2Vjb25kcykgPCBfaW5kZXguc2Vjb25kc0luV2VlayAmJlxuICAgICAgKHZhbHVlID0gKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSkgJiZcbiAgICAgIE1hdGguYWJzKHZhbHVlKSA8IDdcbiAgICApIHtcbiAgICAgIHVuaXQgPSBcImRheVwiO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGlmZkluU2Vjb25kcykgPCBfaW5kZXguc2Vjb25kc0luTW9udGgpIHtcbiAgICAgIHZhbHVlID0gKDAsIF9pbmRleDUuZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgICB1bml0ID0gXCJ3ZWVrXCI7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmSW5TZWNvbmRzKSA8IF9pbmRleC5zZWNvbmRzSW5RdWFydGVyKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXgzLmRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgICAgIHVuaXQgPSBcIm1vbnRoXCI7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmSW5TZWNvbmRzKSA8IF9pbmRleC5zZWNvbmRzSW5ZZWFyKSB7XG4gICAgICBpZiAoKDAsIF9pbmRleDQuZGlmZmVyZW5jZUluQ2FsZW5kYXJRdWFydGVycykoZGF0ZUxlZnQsIGRhdGVSaWdodCkgPCA0KSB7XG4gICAgICAgIC8vIFRvIGZpbHRlciBvdXQgY2FzZXMgdGhhdCBhcmUgbGVzcyB0aGFuIGEgeWVhciBidXQgbWF0Y2ggNCBxdWFydGVyc1xuICAgICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg0LmRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMpKGRhdGVMZWZ0LCBkYXRlUmlnaHQpO1xuICAgICAgICB1bml0ID0gXCJxdWFydGVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg2LmRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMpKGRhdGVMZWZ0LCBkYXRlUmlnaHQpO1xuICAgICAgICB1bml0ID0gXCJ5ZWFyXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gKDAsIF9pbmRleDYuZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgICB1bml0ID0gXCJ5ZWFyXCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgdmFsdWUgaWYgdW5pdCBpcyBzcGVjaWZpZWRcbiAgICB1bml0ID0gb3B0aW9ucz8udW5pdDtcbiAgICBpZiAodW5pdCA9PT0gXCJzZWNvbmRcIikge1xuICAgICAgdmFsdWUgPSAoMCwgX2luZGV4OS5kaWZmZXJlbmNlSW5TZWNvbmRzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwibWludXRlXCIpIHtcbiAgICAgIHZhbHVlID0gKDAsIF9pbmRleDguZGlmZmVyZW5jZUluTWludXRlcykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSBcImhvdXJcIikge1xuICAgICAgdmFsdWUgPSAoMCwgX2luZGV4Ny5kaWZmZXJlbmNlSW5Ib3VycykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSBcImRheVwiKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXgyLmRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSBcIndlZWtcIikge1xuICAgICAgdmFsdWUgPSAoMCwgX2luZGV4NS5kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwibW9udGhcIikge1xuICAgICAgdmFsdWUgPSAoMCwgX2luZGV4My5kaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocykoZGF0ZUxlZnQsIGRhdGVSaWdodCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSBcInF1YXJ0ZXJcIikge1xuICAgICAgdmFsdWUgPSAoMCwgX2luZGV4NC5kaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzKShkYXRlTGVmdCwgZGF0ZVJpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwieWVhclwiKSB7XG4gICAgICB2YWx1ZSA9ICgwLCBfaW5kZXg2LmRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMpKGRhdGVMZWZ0LCBkYXRlUmlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJ0ZiA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChvcHRpb25zPy5sb2NhbGUsIHtcbiAgICBsb2NhbGVNYXRjaGVyOiBvcHRpb25zPy5sb2NhbGVNYXRjaGVyLFxuICAgIG51bWVyaWM6IG9wdGlvbnM/Lm51bWVyaWMgfHwgXCJhdXRvXCIsXG4gICAgc3R5bGU6IG9wdGlvbnM/LnN0eWxlLFxuICB9KTtcblxuICByZXR1cm4gcnRmLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBZnRlciA9IGlzQWZ0ZXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzQWZ0ZXJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGFmdGVyIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAqIEBwYXJhbSBkYXRlVG9Db21wYXJlIC0gVGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXG4gKlxuICogQHJldHVybnMgVGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCBkYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEwIEp1bHkgMTk4OSBhZnRlciAxMSBGZWJydWFyeSAxOTg3P1xuICogY29uc3QgcmVzdWx0ID0gaXNBZnRlcihuZXcgRGF0ZSgxOTg5LCA2LCAxMCksIG5ldyBEYXRlKDE5ODcsIDEsIDExKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc0FmdGVyKGRhdGUsIGRhdGVUb0NvbXBhcmUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IF9kYXRlVG9Db21wYXJlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gX2RhdGUuZ2V0VGltZSgpID4gX2RhdGVUb0NvbXBhcmUuZ2V0VGltZSgpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQmVmb3JlID0gaXNCZWZvcmU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzQmVmb3JlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGJlZm9yZSB0aGUgb3RoZXIgb25lIHRvIHJldHVybiB0cnVlXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSAtIFRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICpcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMTAgSnVseSAxOTg5IGJlZm9yZSAxMSBGZWJydWFyeSAxOTg3P1xuICogY29uc3QgcmVzdWx0ID0gaXNCZWZvcmUobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmVmb3JlKGRhdGUsIGRhdGVUb0NvbXBhcmUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IF9kYXRlVG9Db21wYXJlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVUb0NvbXBhcmUpO1xuICByZXR1cm4gK19kYXRlIDwgK19kYXRlVG9Db21wYXJlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTsgLyoqXG4gKiBAbmFtZSBpc0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIHZhbHVlIGEgZGF0ZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZS4gVGhlIGZ1bmN0aW9uIHdvcmtzIGZvciBkYXRlcyB0cmFuc2ZlcnJlZCBhY3Jvc3MgaWZyYW1lcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGEgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZSgpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUobmV3IERhdGUoTmFOKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3Igc29tZSB2YWx1ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZSgnMjAxNC0wMi0zMScpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBvYmplY3Q6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUoe30pXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBEYXRlXVwiKVxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzRXF1YWwgPSBpc0VxdWFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc0VxdWFsXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgZXF1YWw/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgZXF1YWxcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgSnVseSAyMDE0IDA2OjMwOjQ1LjAwMCBhbmQgMiBKdWx5IDIwMTQgMDY6MzA6NDUuNTAwIGVxdWFsP1xuICogY29uc3QgcmVzdWx0ID0gaXNFcXVhbChcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgNiwgMzAsIDQ1LCAwKSxcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgNiwgMzAsIDQ1LCA1MDApXG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwobGVmdERhdGUsIHJpZ2h0RGF0ZSkge1xuICBjb25zdCBfZGF0ZUxlZnQgPSAoMCwgX2luZGV4LnRvRGF0ZSkobGVmdERhdGUpO1xuICBjb25zdCBfZGF0ZVJpZ2h0ID0gKDAsIF9pbmRleC50b0RhdGUpKHJpZ2h0RGF0ZSk7XG4gIHJldHVybiArX2RhdGVMZWZ0ID09PSArX2RhdGVSaWdodDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0V4aXN0cyA9IGlzRXhpc3RzOyAvKipcbiAqIEBuYW1lIGlzRXhpc3RzXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIGV4aXN0cz9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGNvbnZlcnQgdG8gYW4gZXhpc3RpbmcgZGF0ZS5cbiAqXG4gKiBAcGFyYW0geWVhciAtIFRoZSB5ZWFyIG9mIHRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gbW9udGggLSBUaGUgbW9udGggb2YgdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBkYXkgLSBUaGUgZGF5IG9mIHRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkYXRlIGV4aXN0c1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0V4aXN0cygyMDE4LCAwLCAzMSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGludmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRXhpc3RzKDIwMTgsIDEsIDMxKVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0V4aXN0cyh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIChcbiAgICBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiZcbiAgICBkYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoICYmXG4gICAgZGF0ZS5nZXREYXRlKCkgPT09IGRheVxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzRmlyc3REYXlPZk1vbnRoID0gaXNGaXJzdERheU9mTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzRmlyc3REYXlPZk1vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcblxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDEgU2VwdGVtYmVyIDIwMTQgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoP1xuICogY29uc3QgcmVzdWx0ID0gaXNGaXJzdERheU9mTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNGaXJzdERheU9mTW9udGgoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpLmdldERhdGUoKSA9PT0gMTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0ZyaWRheSA9IGlzRnJpZGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc0ZyaWRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgRnJpZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgRnJpZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyBGcmlkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMjYgU2VwdGVtYmVyIDIwMTQgRnJpZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNGcmlkYXkobmV3IERhdGUoMjAxNCwgOCwgMjYpKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzRnJpZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKS5nZXREYXkoKSA9PT0gNTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0Z1dHVyZSA9IGlzRnV0dXJlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc0Z1dHVyZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgZnV0dXJlP1xuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBmdXR1cmU/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIGluIHRoZSBmdXR1cmVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQsIGlzIDMxIERlY2VtYmVyIDIwMTQgaW4gdGhlIGZ1dHVyZT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzRnV0dXJlKG5ldyBEYXRlKDIwMTQsIDExLCAzMSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNGdXR1cmUoZGF0ZSkge1xuICByZXR1cm4gKygwLCBfaW5kZXgudG9EYXRlKShkYXRlKSA+IERhdGUubm93KCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNMYXN0RGF5T2ZNb250aCA9IGlzTGFzdERheU9mTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZW5kT2ZEYXkuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2VuZE9mTW9udGguanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc0xhc3REYXlPZk1vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdGhlIGxhc3QgZGF5IG9mIGEgbW9udGg/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSB0aGUgbGFzdCBkYXkgb2YgYSBtb250aD9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG5cbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIHRoZSBsYXN0IGRheSBvZiBhIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDI4IEZlYnJ1YXJ5IDIwMTQgdGhlIGxhc3QgZGF5IG9mIGEgbW9udGg/XG4gKiBjb25zdCByZXN1bHQgPSBpc0xhc3REYXlPZk1vbnRoKG5ldyBEYXRlKDIwMTQsIDEsIDI4KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc0xhc3REYXlPZk1vbnRoKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICByZXR1cm4gKygwLCBfaW5kZXguZW5kT2ZEYXkpKF9kYXRlKSA9PT0gKygwLCBfaW5kZXgyLmVuZE9mTW9udGgpKF9kYXRlKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0xlYXBZZWFyID0gaXNMZWFwWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNMZWFwWWVhclxuICogQGNhdGVnb3J5IFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIGxlYXAgeWVhcj9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBsZWFwIHllYXI/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIGluIHRoZSBsZWFwIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMSBTZXB0ZW1iZXIgMjAxMiBpbiB0aGUgbGVhcCB5ZWFyP1xuICogY29uc3QgcmVzdWx0ID0gaXNMZWFwWWVhcihuZXcgRGF0ZSgyMDEyLCA4LCAxKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc0xlYXBZZWFyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNNYXRjaCA9IGlzTWF0Y2g7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaXNWYWxpZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBpc01hdGNofSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgaXNNYXRjaFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSB2YWxpZGF0ZXMgdGhlIGRhdGUgc3RyaW5nIGFnYWluc3QgZ2l2ZW4gZm9ybWF0c1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSB0cnVlIGlmIGdpdmVuIGRhdGUgaXMgc3RyaW5nIGNvcnJlY3QgYWdhaW5zdCB0aGUgZ2l2ZW4gZm9ybWF0IGVsc2VcbiAqIHdpbGwgcmV0dXJuIGZhbHNlLlxuICpcbiAqID4g4pqg77iPIFBsZWFzZSBub3RlIHRoYXQgdGhlIGBmb3JtYXRgIHRva2VucyBkaWZmZXIgZnJvbSBNb21lbnQuanMgYW5kIG90aGVyIGxpYnJhcmllcy5cbiAqID4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogVGhlIGNoYXJhY3RlcnMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgd3JhcHBlZCBiZXR3ZWVuIHR3byBzaW5nbGUgcXVvdGVzIGNoYXJhY3RlcnMgKCcpIGFyZSBlc2NhcGVkLlxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXG4gKlxuICogRm9ybWF0IG9mIHRoZSBmb3JtYXQgc3RyaW5nIGlzIGJhc2VkIG9uIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIHdpdGggYSBmZXcgYWRkaXRpb25zIChzZWUgbm90ZSA1IGJlbG93IHRoZSB0YWJsZSkuXG4gKlxuICogTm90IGFsbCB0b2tlbnMgYXJlIGNvbXBhdGlibGUuIENvbWJpbmF0aW9ucyB0aGF0IGRvbid0IG1ha2Ugc2Vuc2Ugb3IgY291bGQgbGVhZCB0byBidWdzIGFyZSBwcm9oaWJpdGVkXG4gKiBhbmQgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAuIEZvciBleGFtcGxlIHVzYWdlIG9mIDI0LWhvdXIgZm9ybWF0IHRva2VuIHdpdGggQU0vUE0gdG9rZW4gd2lsbCB0aHJvdyBhbiBleGNlcHRpb246XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaXNNYXRjaCgnMjMgQU0nLCAnSEggYScpXG4gKiAvLz0+IFJhbmdlRXJyb3I6IFRoZSBmb3JtYXQgc3RyaW5nIG11c3RuJ3QgY29udGFpbiBgSEhgIGFuZCBgYWAgYXQgdGhlIHNhbWUgdGltZVxuICogYGBgXG4gKlxuICogU2VlIHRoZSBjb21wYXRpYmlsaXR5IHRhYmxlOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC9lLzJQQUNYLTF2UU9QVTN4VWhwbGxsNmR5b01tVlVYSEtsXzhDUkRzNl91ZUxtZXgzU29xd2h1b2xrdU4zTzA1bDRycXg1aDFkS1g4ZWI0NlVsLUNDU3JxL3B1Ymh0bWw/Z2lkPTAmc2luZ2xlPXRydWVcbiAqXG4gKiBBY2NlcHRlZCBmb3JtYXQgc3RyaW5nIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxQcmlvcnwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAxNDAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCAxMzAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcsIDk5OTkgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCA5OTk5OTk5dGggICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDEyMywgOTk5ICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCAxMzAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcsIDkwMDAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCA5OTk5OTk5dGggICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0LDYgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDEyMywgOTk5ICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDQsNiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCAxMzAgfCBSICAgICAgIHwgLTQzLCAxLCAxOTAwLCAyMDE3LCA5OTk5LCAtOTk5OSAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlIgICAgICB8IC00MywgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDEsIDEyMywgOTk5LCAtOTk5ICAgICAgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDEsIDIwMTcsIDk5OTksIC05OTk5ICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCw1IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IDEzMCB8IHUgICAgICAgfCAtNDMsIDEsIDE5MDAsIDIwMTcsIDk5OTksIC05OTkgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgOTksIC05OSAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTIzLCA5OTksIC05OTkgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMjAxNywgOTk5OSwgLTk5OTkgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgMTIwIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgMTIwIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgMTEwIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgMTEwIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgMTAwIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgMTAwIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgIDkwIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgIDkwIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCAgOTAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgIDkwIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8IDUgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8ICA5MCB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCAgOTAgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDgwIHwgYS4uYWFhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGFhYWEgICAgfCBhLm0uLCBwLm0uICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBhYWFhYSAgIHwgYSwgcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgIHwgIDgwIHwgYi4uYmJiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBiYmJiYiAgIHwgYSwgcCwgbiwgbWkgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgIDgwIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBCQkJCQiAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBoaCAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBISCAgICAgIHwgMDAsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBLSyAgICAgIHwgMDEsIDAyLCAuLi4sIDExLCAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgIDcwIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBrayAgICAgIHwgMjQsIDAxLCAwMiwgLi4uLCAyMyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDYwIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIDUwIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBzcyAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgIDQwIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHR0ICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCAgMzAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgIHwgIDIwIHwgVCAgICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFRUICAgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3LyBaKSAgICAgICAgfCAgMTAgfCBYICAgICAgIHwgLTA4LCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFggICAgICB8IC0wODAwLCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWCAgICAgfCAtMDg6MDAsICswNTozMCwgWiAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFhYICAgIHwgLTA4MDAsICswNTMwLCBaLCArMTIzNDU2ICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYWFggICB8IC0wODowMCwgKzA1OjMwLCBaLCArMTI6MzQ6NTYgICAgICB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgICB8ICAxMCB8IHggICAgICAgfCAtMDgsICswNTMwLCArMDAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eCAgICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4ICAgICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eHggICAgfCAtMDgwMCwgKzA1MzAsICswMDAwLCArMTIzNDU2ICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHh4eCAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCwgKzEyOjM0OjU2IHwgICAgICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgIE5BIHwgUCAgICAgICB8IDA1LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQICAgICAgfCBNYXkgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFAgICAgIHwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQUCAgICB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgICAgICAgICAgICB8IDIsNSw4IHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8ICBOQSB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgIE5BIHwgUHAgICAgICB8IDA1LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQcHAgICAgfCBNYXkgMjksIDE0NTMsIDEyOjAwOjAwIEFNICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBwcCAgIHwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBQUHBwICB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICB8IDIsNSw4IHxcbiAqIE5vdGVzOlxuICogMS4gXCJGb3JtYXR0aW5nXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcbiAqICAgIGFyZSB0aGUgc2FtZSBhcyBcInN0YW5kLWFsb25lXCIgdW5pdHMsIGJ1dCBhcmUgZGlmZmVyZW50IGluIHNvbWUgbGFuZ3VhZ2VzLlxuICogICAgXCJGb3JtYXR0aW5nXCIgdW5pdHMgYXJlIGRlY2xpbmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgb2YgdGhlIGxhbmd1YWdlXG4gKiAgICBpbiB0aGUgY29udGV4dCBvZiBhIGRhdGUuIFwiU3RhbmQtYWxvbmVcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXIuXG4gKiAgICBJbiBgZm9ybWF0YCBmdW5jdGlvbiwgdGhleSB3aWxsIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdDpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogICAgYGlzTWF0Y2hgIHdpbGwgdHJ5IHRvIG1hdGNoIGJvdGggZm9ybWF0dGluZyBhbmQgc3RhbmQtYWxvbmUgdW5pdHMgaW50ZXJjaGFuZ2FibHkuXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlOlxuICogICAgLSBmb3IgbnVtZXJpY2FsIHVuaXRzIChgeXl5eXl5eXlgKSBgaXNNYXRjaGAgd2lsbCB0cnkgdG8gbWF0Y2ggYSBudW1iZXJcbiAqICAgICAgYXMgd2lkZSBhcyB0aGUgc2VxdWVuY2VcbiAqICAgIC0gZm9yIHRleHQgdW5pdHMgKGBNTU1NTU1NTWApIGBpc01hdGNoYCB3aWxsIHRyeSB0byBtYXRjaCB0aGUgd2lkZXN0IHZhcmlhdGlvbiBvZiB0aGUgdW5pdC5cbiAqICAgICAgVGhlc2UgdmFyaWF0aW9ucyBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAzLiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA0LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIHdpbGwgdHJ5IHRvIGd1ZXNzIHRoZSBjZW50dXJ5IG9mIHR3byBkaWdpdCB5ZWFyIGJ5IHByb3hpbWl0eSB3aXRoIGByZWZlcmVuY2VEYXRlYDpcbiAqXG4gKiAgICBgaXNNYXRjaCgnNTAnLCAneXknKSAvLz0+IHRydWVgXG4gKlxuICogICAgYGlzTWF0Y2goJzc1JywgJ3l5JykgLy89PiB0cnVlYFxuICpcbiAqICAgIHdoaWxlIGB1dWAgd2lsbCB1c2UgdGhlIHllYXIgYXMgaXM6XG4gKlxuICogICAgYGlzTWF0Y2goJzUwJywgJ3V1JykgLy89PiB0cnVlYFxuICpcbiAqICAgIGBpc01hdGNoKCc3NScsICd1dScpIC8vPT4gdHJ1ZWBcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtzZXRJU09XZWVrWWVhcl0oaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9zZXRJU09XZWVrWWVhcilcbiAqICAgIGFuZCBbc2V0V2Vla1llYXJdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3Mvc2V0V2Vla1llYXIpKS5cbiAqXG4gKiA1LiBUaGVzZSBwYXR0ZXJucyBhcmUgbm90IGluIHRoZSBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiAgICAtIGBpYDogSVNPIGRheSBvZiB3ZWVrXG4gKiAgICAtIGBJYDogSVNPIHdlZWsgb2YgeWVhclxuICogICAgLSBgUmA6IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKiAgICAtIGBvYDogb3JkaW5hbCBudW1iZXIgbW9kaWZpZXJcbiAqICAgIC0gYFBgOiBsb25nIGxvY2FsaXplZCBkYXRlXG4gKiAgICAtIGBwYDogbG9uZyBsb2NhbGl6ZWQgdGltZVxuICpcbiAqIDYuIGBZWWAgYW5kIGBZWVlZYCB0b2tlbnMgcmVwcmVzZW50IHdlZWstbnVtYmVyaW5nIHllYXJzIGJ1dCB0aGV5IGFyZSBvZnRlbiBjb25mdXNlZCB3aXRoIHllYXJzLlxuICogICAgWW91IHNob3VsZCBlbmFibGUgYG9wdGlvbnMudXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogNy4gYERgIGFuZCBgRERgIHRva2VucyByZXByZXNlbnQgZGF5cyBvZiB0aGUgeWVhciBidXQgdGhleSBhcmUgb2Z0aGVuIGNvbmZ1c2VkIHdpdGggZGF5cyBvZiB0aGUgbW9udGguXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogOC4gYFArYCB0b2tlbnMgZG8gbm90IGhhdmUgYSBkZWZpbmVkIHByaW9yaXR5IHNpbmNlIHRoZXkgYXJlIG1lcmVseSBhbGlhc2VzIHRvIG90aGVyIHRva2VucyBiYXNlZFxuICogICAgb24gdGhlIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiAgICB1c2luZyBgZW4tVVNgIGxvY2FsZTogYFBgID0+IGBNTS9kZC95eXl5YFxuICogICAgdXNpbmcgYGVuLVVTYCBsb2NhbGU6IGBwYCA9PiBgaGg6bW0gYWBcbiAqICAgIHVzaW5nIGBwdC1CUmAgbG9jYWxlOiBgUGAgPT4gYGRkL01NL3l5eXlgXG4gKiAgICB1c2luZyBgcHQtQlJgIGxvY2FsZTogYHBgID0+IGBISDptbWBcbiAqXG4gKiBWYWx1ZXMgd2lsbCBiZSBjaGVja2VkIGluIHRoZSBkZXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXG4gKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAqXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBtYXRjaGVkIChlLmcuIHdoZW4gbWF0Y2hpbmcgc3RyaW5nICdKYW51YXJ5IDFzdCcgd2l0aG91dCBhIHllYXIpLFxuICogdGhlIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gdG9kYXkncyB1c2luZyBgbmV3IERhdGUoKWAgZGF0ZSB3aGljaCB3b3JrcyBhcyBhIGNvbnRleHQgb2YgcGFyc2luZy5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGByZWZlcmVuY2VEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlU3RyIC0gVGhlIGRhdGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBzdHJpbmcgb2YgdG9rZW5zXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiAgIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiBAcmV0dXJucyBJcyBmb3JtYXQgc3RyaW5nIGEgbWF0Y2ggZm9yIGRhdGUgc3RyaW5nP1xuICpcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYG1hdGNoYCBwcm9wZXJ0eVxuICogQHRocm93cyB1c2UgYHl5eXlgIGluc3RlYWQgb2YgYFlZWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGB5eWAgaW5zdGVhZCBvZiBgWVlgIGZvciBmb3JtYXR0aW5nIHllYXJzOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGBkYCBpbnN0ZWFkIG9mIGBEYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIHVzZSBgZGRgIGluc3RlYWQgb2YgYEREYCBmb3IgZm9ybWF0dGluZyBkYXlzIG9mIHRoZSBtb250aDsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBNYXRjaCAxMSBGZWJydWFyeSAyMDE0IGZyb20gbWlkZGxlLWVuZGlhbiBmb3JtYXQ6XG4gKiBjb25zdCByZXN1bHQgPSBpc01hdGNoKCcwMi8xMS8yMDE0JywgJ01NL2RkL3l5eXknKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE1hdGNoIDI4dGggb2YgRmVicnVhcnkgaW4gRXNwZXJhbnRvIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gKiBpbXBvcnQgZW8gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogY29uc3QgcmVzdWx0ID0gaXNNYXRjaCgnMjgtYSBkZSBmZWJydWFybycsIFwiZG8gJ2RlJyBNTU1NXCIsIHtcbiAqICAgbG9jYWxlOiBlb1xuICogfSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc01hdGNoKGRhdGVTdHIsIGZvcm1hdFN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gKDAsIF9pbmRleC5pc1ZhbGlkKShcbiAgICAoMCwgX2luZGV4Mi5wYXJzZSkoZGF0ZVN0ciwgZm9ybWF0U3RyLCBuZXcgRGF0ZSgpLCBvcHRpb25zKSxcbiAgKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc01vbmRheSA9IGlzTW9uZGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc01vbmRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgTW9uZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgTW9uZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyBNb25kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMjIgU2VwdGVtYmVyIDIwMTQgTW9uZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNNb25kYXkobmV3IERhdGUoMjAxNCwgOCwgMjIpKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzTW9uZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKS5nZXREYXkoKSA9PT0gMTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1Bhc3QgPSBpc1Bhc3Q7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzUGFzdFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgcGFzdD9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgcGFzdD9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgaW4gdGhlIHBhc3RcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQsIGlzIDIgSnVseSAyMDE0IGluIHRoZSBwYXN0P1xuICogY29uc3QgcmVzdWx0ID0gaXNQYXN0KG5ldyBEYXRlKDIwMTQsIDYsIDIpKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGFzdChkYXRlKSB7XG4gIHJldHVybiArKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpIDwgRGF0ZS5ub3coKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1NhbWVEYXkgPSBpc1NhbWVEYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vc3RhcnRPZkRheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVEYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBkYXkgKGFuZCB5ZWFyIGFuZCBtb250aCk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuXG4gKiBAcmV0dXJucyBUaGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMDY6MDA6MDAgYW5kIDQgU2VwdGVtYmVyIDE4OjAwOjAwIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAwKSwgbmV3IERhdGUoMjAxNCwgOCwgNCwgMTgsIDApKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciBhbmQgNCBPY3RvYmVyIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0KSwgbmV3IERhdGUoMjAxNCwgOSwgNCkpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciwgMjAxNCBhbmQgNCBTZXB0ZW1iZXIsIDIwMTUgaW4gdGhlIHNhbWUgZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDQpLCBuZXcgRGF0ZSgyMDE1LCA4LCA0KSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTYW1lRGF5KGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgZGF0ZUxlZnRTdGFydE9mRGF5ID0gKDAsIF9pbmRleC5zdGFydE9mRGF5KShkYXRlTGVmdCk7XG4gIGNvbnN0IGRhdGVSaWdodFN0YXJ0T2ZEYXkgPSAoMCwgX2luZGV4LnN0YXJ0T2ZEYXkpKGRhdGVSaWdodCk7XG5cbiAgcmV0dXJuICtkYXRlTGVmdFN0YXJ0T2ZEYXkgPT09ICtkYXRlUmlnaHRTdGFydE9mRGF5O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzU2FtZUhvdXIgPSBpc1NhbWVIb3VyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZIb3VyLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzU2FtZUhvdXJcbiAqIEBjYXRlZ29yeSBIb3VyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgaG91ciAoYW5kIHNhbWUgZGF5KT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgaG91ciAoYW5kIHNhbWUgZGF5KT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgaG91ciAoYW5kIHNhbWUgZGF5KVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMjAxNCAwNjowMDowMCBhbmQgNCBTZXB0ZW1iZXIgMDY6MzA6MDAgaW4gdGhlIHNhbWUgaG91cj9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZUhvdXIobmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMCksIG5ldyBEYXRlKDIwMTQsIDgsIDQsIDYsIDMwKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMjAxNCAwNjowMDowMCBhbmQgNSBTZXB0ZW1iZXIgMDY6MDA6MDAgaW4gdGhlIHNhbWUgaG91cj9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZUhvdXIobmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMCksIG5ldyBEYXRlKDIwMTQsIDgsIDUsIDYsIDApKVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1NhbWVIb3VyKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgZGF0ZUxlZnRTdGFydE9mSG91ciA9ICgwLCBfaW5kZXguc3RhcnRPZkhvdXIpKGRhdGVMZWZ0KTtcbiAgY29uc3QgZGF0ZVJpZ2h0U3RhcnRPZkhvdXIgPSAoMCwgX2luZGV4LnN0YXJ0T2ZIb3VyKShkYXRlUmlnaHQpO1xuXG4gIHJldHVybiArZGF0ZUxlZnRTdGFydE9mSG91ciA9PT0gK2RhdGVSaWdodFN0YXJ0T2ZIb3VyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzU2FtZUlTT1dlZWsgPSBpc1NhbWVJU09XZWVrO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2lzU2FtZVdlZWsuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNTYW1lSVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgSVNPIHdlZWsgKGFuZCB5ZWFyKT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgSVNPIHdlZWsgKGFuZCB5ZWFyKT9cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIElTTyB3ZWVrIChhbmQgeWVhcilcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDEgU2VwdGVtYmVyIDIwMTQgYW5kIDcgU2VwdGVtYmVyIDIwMTQgaW4gdGhlIHNhbWUgSVNPIHdlZWs/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVJU09XZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCBuZXcgRGF0ZSgyMDE0LCA4LCA3KSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgMSBTZXB0ZW1iZXIgMjAxNCBhbmQgMSBTZXB0ZW1iZXIgMjAxNSBpbiB0aGUgc2FtZSBJU08gd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZUlTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMSksIG5ldyBEYXRlKDIwMTUsIDgsIDEpKVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1NhbWVJU09XZWVrKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguaXNTYW1lV2VlaykoZGF0ZUxlZnQsIGRhdGVSaWdodCwgeyB3ZWVrU3RhcnRzT246IDEgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNTYW1lSVNPV2Vla1llYXIgPSBpc1NhbWVJU09XZWVrWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zdGFydE9mSVNPV2Vla1llYXIuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNTYW1lSVNPV2Vla1llYXJcbiAqIEBjYXRlZ29yeSBJU08gV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhcj9cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSAyOSBEZWNlbWJlciAyMDAzIGFuZCAyIEphbnVhcnkgMjAwNSBpbiB0aGUgc2FtZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhcj9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZUlTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDMsIDExLCAyOSksIG5ldyBEYXRlKDIwMDUsIDAsIDIpKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZUlTT1dlZWtZZWFyKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgZGF0ZUxlZnRTdGFydE9mWWVhciA9ICgwLCBfaW5kZXguc3RhcnRPZklTT1dlZWtZZWFyKShkYXRlTGVmdCk7XG4gIGNvbnN0IGRhdGVSaWdodFN0YXJ0T2ZZZWFyID0gKDAsIF9pbmRleC5zdGFydE9mSVNPV2Vla1llYXIpKGRhdGVSaWdodCk7XG5cbiAgcmV0dXJuICtkYXRlTGVmdFN0YXJ0T2ZZZWFyID09PSArZGF0ZVJpZ2h0U3RhcnRPZlllYXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNTYW1lTWludXRlID0gaXNTYW1lTWludXRlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZNaW51dGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNTYW1lTWludXRlXG4gKiBAY2F0ZWdvcnkgTWludXRlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgbWludXRlIChhbmQgaG91ciBhbmQgZGF5KT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgbWludXRlIChhbmQgaG91ciBhbmQgZGF5KT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgbWludXRlIChhbmQgaG91ciBhbmQgZGF5KVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMjAxNCAwNjozMDowMCBhbmQgNCBTZXB0ZW1iZXIgMjAxNCAwNjozMDoxNSBpbiB0aGUgc2FtZSBtaW51dGU/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVNaW51dGUoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDgsIDQsIDYsIDMwKSxcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMzAsIDE1KVxuICogKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciAyMDE0IDA2OjMwOjAwIGFuZCA1IFNlcHRlbWJlciAyMDE0IDA2OjMwOjAwIGluIHRoZSBzYW1lIG1pbnV0ZT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZU1pbnV0ZShcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMzApLFxuICogICBuZXcgRGF0ZSgyMDE0LCA4LCA1LCA2LCAzMClcbiAqIClcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTYW1lTWludXRlKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgZGF0ZUxlZnRTdGFydE9mTWludXRlID0gKDAsIF9pbmRleC5zdGFydE9mTWludXRlKShkYXRlTGVmdCk7XG4gIGNvbnN0IGRhdGVSaWdodFN0YXJ0T2ZNaW51dGUgPSAoMCwgX2luZGV4LnN0YXJ0T2ZNaW51dGUpKGRhdGVSaWdodCk7XG5cbiAgcmV0dXJuICtkYXRlTGVmdFN0YXJ0T2ZNaW51dGUgPT09ICtkYXRlUmlnaHRTdGFydE9mTWludXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzU2FtZU1vbnRoID0gaXNTYW1lTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzU2FtZU1vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBtb250aCAoYW5kIHllYXIpP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBtb250aCAoYW5kIHllYXIpP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBmaXJzdCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSBtb250aCAoYW5kIHllYXIpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSAyIFNlcHRlbWJlciAyMDE0IGFuZCAyNSBTZXB0ZW1iZXIgMjAxNCBpbiB0aGUgc2FtZSBtb250aD9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZU1vbnRoKG5ldyBEYXRlKDIwMTQsIDgsIDIpLCBuZXcgRGF0ZSgyMDE0LCA4LCAyNSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDIgU2VwdGVtYmVyIDIwMTQgYW5kIDI1IFNlcHRlbWJlciAyMDE1IGluIHRoZSBzYW1lIG1vbnRoP1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMiksIG5ldyBEYXRlKDIwMTUsIDgsIDI1KSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTYW1lTW9udGgoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBfZGF0ZUxlZnQgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZUxlZnQpO1xuICBjb25zdCBfZGF0ZVJpZ2h0ID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVSaWdodCk7XG4gIHJldHVybiAoXG4gICAgX2RhdGVMZWZ0LmdldEZ1bGxZZWFyKCkgPT09IF9kYXRlUmlnaHQuZ2V0RnVsbFllYXIoKSAmJlxuICAgIF9kYXRlTGVmdC5nZXRNb250aCgpID09PSBfZGF0ZVJpZ2h0LmdldE1vbnRoKClcbiAgKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1NhbWVRdWFydGVyID0gaXNTYW1lUXVhcnRlcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zdGFydE9mUXVhcnRlci5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVRdWFydGVyXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIHF1YXJ0ZXIgKGFuZCB5ZWFyKT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgcXVhcnRlciAoYW5kIHllYXIpP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBmaXJzdCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrXG5cbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgcXVhcnRlciAoYW5kIHllYXIpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSAxIEphbnVhcnkgMjAxNCBhbmQgOCBNYXJjaCAyMDE0IGluIHRoZSBzYW1lIHF1YXJ0ZXI/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVRdWFydGVyKG5ldyBEYXRlKDIwMTQsIDAsIDEpLCBuZXcgRGF0ZSgyMDE0LCAyLCA4KSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgMSBKYW51YXJ5IDIwMTQgYW5kIDEgSmFudWFyeSAyMDE1IGluIHRoZSBzYW1lIHF1YXJ0ZXI/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVRdWFydGVyKG5ldyBEYXRlKDIwMTQsIDAsIDEpLCBuZXcgRGF0ZSgyMDE1LCAwLCAxKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTYW1lUXVhcnRlcihkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGNvbnN0IGRhdGVMZWZ0U3RhcnRPZlF1YXJ0ZXIgPSAoMCwgX2luZGV4LnN0YXJ0T2ZRdWFydGVyKShkYXRlTGVmdCk7XG4gIGNvbnN0IGRhdGVSaWdodFN0YXJ0T2ZRdWFydGVyID0gKDAsIF9pbmRleC5zdGFydE9mUXVhcnRlcikoZGF0ZVJpZ2h0KTtcblxuICByZXR1cm4gK2RhdGVMZWZ0U3RhcnRPZlF1YXJ0ZXIgPT09ICtkYXRlUmlnaHRTdGFydE9mUXVhcnRlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1NhbWVTZWNvbmQgPSBpc1NhbWVTZWNvbmQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vc3RhcnRPZlNlY29uZC5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVTZWNvbmRcbiAqIEBjYXRlZ29yeSBTZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBzZWNvbmQgKGFuZCBob3VyIGFuZCBkYXkpP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBzZWNvbmQgKGFuZCBob3VyIGFuZCBkYXkpP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlTGVmdCAtIFRoZSBmaXJzdCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gZGF0ZVJpZ2h0IC0gVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSBzZWNvbmQgKGFuZCBob3VyIGFuZCBkYXkpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciAyMDE0IDA2OjMwOjE1LjAwMCBhbmQgNCBTZXB0ZW1iZXIgMjAxNCAwNjozMC4xNS41MDAgaW4gdGhlIHNhbWUgc2Vjb25kP1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lU2Vjb25kKFxuICogICBuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAzMCwgMTUpLFxuICogICBuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAzMCwgMTUsIDUwMClcbiAqIClcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMjAxNCAwNjowMDoxNS4wMDAgYW5kIDQgU2VwdGVtYmVyIDIwMTQgMDY6MDEuMTUuMDAwIGluIHRoZSBzYW1lIHNlY29uZD9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZVNlY29uZChcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMCwgMTUpLFxuICogICBuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAxLCAxNSlcbiAqIClcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDQgU2VwdGVtYmVyIDIwMTQgMDY6MDA6MTUuMDAwIGFuZCA1IFNlcHRlbWJlciAyMDE0IDA2OjAwLjE1LjAwMCBpbiB0aGUgc2FtZSBzZWNvbmQ/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVTZWNvbmQoXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDgsIDQsIDYsIDAsIDE1KSxcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgNSwgNiwgMCwgMTUpXG4gKiApXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZVNlY29uZChkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGNvbnN0IGRhdGVMZWZ0U3RhcnRPZlNlY29uZCA9ICgwLCBfaW5kZXguc3RhcnRPZlNlY29uZCkoZGF0ZUxlZnQpO1xuICBjb25zdCBkYXRlUmlnaHRTdGFydE9mU2Vjb25kID0gKDAsIF9pbmRleC5zdGFydE9mU2Vjb25kKShkYXRlUmlnaHQpO1xuXG4gIHJldHVybiArZGF0ZUxlZnRTdGFydE9mU2Vjb25kID09PSArZGF0ZVJpZ2h0U3RhcnRPZlNlY29uZDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1NhbWVXZWVrID0gaXNTYW1lV2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zdGFydE9mV2Vlay5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGlzU2FtZVdlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIHdlZWsgKGFuZCBtb250aCBhbmQgeWVhcik/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIHdlZWsgKGFuZCBtb250aCBhbmQgeWVhcik/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGVMZWZ0IC0gVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBkYXRlUmlnaHQgLSBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgd2VlayAoYW5kIG1vbnRoIGFuZCB5ZWFyKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgMzEgQXVndXN0IDIwMTQgYW5kIDQgU2VwdGVtYmVyIDIwMTQgaW4gdGhlIHNhbWUgd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZVdlZWsobmV3IERhdGUoMjAxNCwgNywgMzEpLCBuZXcgRGF0ZSgyMDE0LCA4LCA0KSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB3ZWVrIHN0YXJ0cyB3aXRoIE1vbmRheSxcbiAqIC8vIGFyZSAzMSBBdWd1c3QgMjAxNCBhbmQgNCBTZXB0ZW1iZXIgMjAxNCBpbiB0aGUgc2FtZSB3ZWVrP1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lV2VlayhuZXcgRGF0ZSgyMDE0LCA3LCAzMSksIG5ldyBEYXRlKDIwMTQsIDgsIDQpLCB7XG4gKiAgIHdlZWtTdGFydHNPbjogMVxuICogfSlcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDEgSmFudWFyeSAyMDE0IGFuZCAxIEphbnVhcnkgMjAxNSBpbiB0aGUgc2FtZSB3ZWVrP1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lV2VlayhuZXcgRGF0ZSgyMDE0LCAwLCAxKSwgbmV3IERhdGUoMjAxNSwgMCwgMSkpXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZVdlZWsoZGF0ZUxlZnQsIGRhdGVSaWdodCwgb3B0aW9ucykge1xuICBjb25zdCBkYXRlTGVmdFN0YXJ0T2ZXZWVrID0gKDAsIF9pbmRleC5zdGFydE9mV2VlaykoZGF0ZUxlZnQsIG9wdGlvbnMpO1xuICBjb25zdCBkYXRlUmlnaHRTdGFydE9mV2VlayA9ICgwLCBfaW5kZXguc3RhcnRPZldlZWspKGRhdGVSaWdodCwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuICtkYXRlTGVmdFN0YXJ0T2ZXZWVrID09PSArZGF0ZVJpZ2h0U3RhcnRPZldlZWs7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNTYW1lWWVhciA9IGlzU2FtZVllYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzU2FtZVllYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgeWVhcj9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgaW4gdGhlIHNhbWUgeWVhcj9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgMiBTZXB0ZW1iZXIgMjAxNCBhbmQgMjUgU2VwdGVtYmVyIDIwMTQgaW4gdGhlIHNhbWUgeWVhcj9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZVllYXIobmV3IERhdGUoMjAxNCwgOCwgMiksIG5ldyBEYXRlKDIwMTQsIDgsIDI1KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1NhbWVZZWFyKGRhdGVMZWZ0LCBkYXRlUmlnaHQpIHtcbiAgY29uc3QgX2RhdGVMZWZ0ID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGVMZWZ0KTtcbiAgY29uc3QgX2RhdGVSaWdodCA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlUmlnaHQpO1xuICByZXR1cm4gX2RhdGVMZWZ0LmdldEZ1bGxZZWFyKCkgPT09IF9kYXRlUmlnaHQuZ2V0RnVsbFllYXIoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1NhdHVyZGF5ID0gaXNTYXR1cmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNTYXR1cmRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgU2F0dXJkYXk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBTYXR1cmRheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgU2F0dXJkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMjcgU2VwdGVtYmVyIDIwMTQgU2F0dXJkYXk/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhdHVyZGF5KG5ldyBEYXRlKDIwMTQsIDgsIDI3KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1NhdHVyZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKS5nZXREYXkoKSA9PT0gNjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1N1bmRheSA9IGlzU3VuZGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1N1bmRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgU3VuZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgU3VuZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyBTdW5kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXMgMjEgU2VwdGVtYmVyIDIwMTQgU3VuZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNTdW5kYXkobmV3IERhdGUoMjAxNCwgOCwgMjEpKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzU3VuZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKS5nZXREYXkoKSA9PT0gMDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1RoaXNIb3VyID0gaXNUaGlzSG91cjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2lzU2FtZUhvdXIuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNUaGlzSG91clxuICogQGNhdGVnb3J5IEhvdXIgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgaG91ciBhcyB0aGUgY3VycmVudCBkYXRlP1xuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBzYW1lIGhvdXIgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgaW4gdGhpcyBob3VyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIG5vdyBpcyAyNSBTZXB0ZW1iZXIgMjAxNCAxODozMDoxNS41MDAsXG4gKiAvLyBpcyAyNSBTZXB0ZW1iZXIgMjAxNCAxODowMDowMCBpbiB0aGlzIGhvdXI/XG4gKiBjb25zdCByZXN1bHQgPSBpc1RoaXNIb3VyKG5ldyBEYXRlKDIwMTQsIDgsIDI1LCAxOCkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNUaGlzSG91cihkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4Mi5pc1NhbWVIb3VyKShkYXRlLCAoMCwgX2luZGV4LmNvbnN0cnVjdE5vdykoZGF0ZSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzVGhpc0lTT1dlZWsgPSBpc1RoaXNJU09XZWVrO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdE5vdy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vaXNTYW1lSVNPV2Vlay5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1RoaXNJU09XZWVrXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgSVNPIHdlZWsgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSBJU08gd2VlayBhcyB0aGUgY3VycmVudCBkYXRlP1xuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgaW4gdGhpcyBJU08gd2Vla1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAyNSBTZXB0ZW1iZXIgMjAxNCwgaXMgMjIgU2VwdGVtYmVyIDIwMTQgaW4gdGhpcyBJU08gd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVGhpc0lTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMjIpKVxuICogLy89PiB0cnVlXG4gKi9cblxuZnVuY3Rpb24gaXNUaGlzSVNPV2VlayhkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4Mi5pc1NhbWVJU09XZWVrKShkYXRlLCAoMCwgX2luZGV4LmNvbnN0cnVjdE5vdykoZGF0ZSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzVGhpc01pbnV0ZSA9IGlzVGhpc01pbnV0ZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2lzU2FtZU1pbnV0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1RoaXNNaW51dGVcbiAqIEBjYXRlZ29yeSBNaW51dGUgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgbWludXRlIGFzIHRoZSBjdXJyZW50IGRhdGU/XG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgbWludXRlIGFzIHRoZSBjdXJyZW50IGRhdGU/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIGluIHRoaXMgbWludXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIG5vdyBpcyAyNSBTZXB0ZW1iZXIgMjAxNCAxODozMDoxNS41MDAsXG4gKiAvLyBpcyAyNSBTZXB0ZW1iZXIgMjAxNCAxODozMDowMCBpbiB0aGlzIG1pbnV0ZT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVGhpc01pbnV0ZShuZXcgRGF0ZSgyMDE0LCA4LCAyNSwgMTgsIDMwKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGlzVGhpc01pbnV0ZShkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4Mi5pc1NhbWVNaW51dGUpKGRhdGUsICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUaGlzTW9udGggPSBpc1RoaXNNb250aDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2lzU2FtZU1vbnRoLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVGhpc01vbnRoXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgbW9udGggYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSBtb250aCBhcyB0aGUgY3VycmVudCBkYXRlP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyBpbiB0aGlzIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDI1IFNlcHRlbWJlciAyMDE0LCBpcyAxNSBTZXB0ZW1iZXIgMjAxNCBpbiB0aGlzIG1vbnRoP1xuICogY29uc3QgcmVzdWx0ID0gaXNUaGlzTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMTUpKVxuICogLy89PiB0cnVlXG4gKi9cblxuZnVuY3Rpb24gaXNUaGlzTW9udGgoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleDIuaXNTYW1lTW9udGgpKGRhdGUsICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUaGlzUXVhcnRlciA9IGlzVGhpc1F1YXJ0ZXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0Tm93LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9pc1NhbWVRdWFydGVyLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVGhpc1F1YXJ0ZXJcbiAqIEBjYXRlZ29yeSBRdWFydGVyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBzYW1lIHF1YXJ0ZXIgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSBxdWFydGVyIGFzIHRoZSBjdXJyZW50IGRhdGU/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIGluIHRoaXMgcXVhcnRlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAyNSBTZXB0ZW1iZXIgMjAxNCwgaXMgMiBKdWx5IDIwMTQgaW4gdGhpcyBxdWFydGVyP1xuICogY29uc3QgcmVzdWx0ID0gaXNUaGlzUXVhcnRlcihuZXcgRGF0ZSgyMDE0LCA2LCAyKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1RoaXNRdWFydGVyKGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLmlzU2FtZVF1YXJ0ZXIpKGRhdGUsICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUaGlzU2Vjb25kID0gaXNUaGlzU2Vjb25kO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdE5vdy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vaXNTYW1lU2Vjb25kLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVGhpc1NlY29uZFxuICogQGNhdGVnb3J5IFNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSBzZWNvbmQgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSBzZWNvbmQgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgaW4gdGhpcyBzZWNvbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgbm93IGlzIDI1IFNlcHRlbWJlciAyMDE0IDE4OjMwOjE1LjUwMCxcbiAqIC8vIGlzIDI1IFNlcHRlbWJlciAyMDE0IDE4OjMwOjE1LjAwMCBpbiB0aGlzIHNlY29uZD9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVGhpc1NlY29uZChuZXcgRGF0ZSgyMDE0LCA4LCAyNSwgMTgsIDMwLCAxNSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNUaGlzU2Vjb25kKGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLmlzU2FtZVNlY29uZCkoZGF0ZSwgKDAsIF9pbmRleC5jb25zdHJ1Y3ROb3cpKGRhdGUpKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc1RoaXNXZWVrID0gaXNUaGlzV2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2lzU2FtZVdlZWsuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBpc1RoaXNXZWVrfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgaXNUaGlzV2Vla1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIHNhbWUgd2VlayBhcyB0aGUgY3VycmVudCBkYXRlP1xuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBzYW1lIHdlZWsgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgaW4gdGhpcyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDI1IFNlcHRlbWJlciAyMDE0LCBpcyAyMSBTZXB0ZW1iZXIgMjAxNCBpbiB0aGlzIHdlZWs/XG4gKiBjb25zdCByZXN1bHQgPSBpc1RoaXNXZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIxKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAyNSBTZXB0ZW1iZXIgMjAxNCBhbmQgd2VlayBzdGFydHMgd2l0aCBNb25kYXlcbiAqIC8vIGlzIDIxIFNlcHRlbWJlciAyMDE0IGluIHRoaXMgd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVGhpc1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMjEpLCB7IHdlZWtTdGFydHNPbjogMSB9KVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1RoaXNXZWVrKGRhdGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLmlzU2FtZVdlZWspKGRhdGUsICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSwgb3B0aW9ucyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUaGlzWWVhciA9IGlzVGhpc1llYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0Tm93LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9pc1NhbWVZZWFyLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVGhpc1llYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBzYW1lIHllYXIgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSB5ZWFyIGFzIHRoZSBjdXJyZW50IGRhdGU/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIGluIHRoaXMgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyAyNSBTZXB0ZW1iZXIgMjAxNCwgaXMgMiBKdWx5IDIwMTQgaW4gdGhpcyB5ZWFyP1xuICogY29uc3QgcmVzdWx0ID0gaXNUaGlzWWVhcihuZXcgRGF0ZSgyMDE0LCA2LCAyKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1RoaXNZZWFyKGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgyLmlzU2FtZVllYXIpKGRhdGUsICgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUaHVyc2RheSA9IGlzVGh1cnNkYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVGh1cnNkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIFRodXJzZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgVGh1cnNkYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIFRodXJzZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDI1IFNlcHRlbWJlciAyMDE0IFRodXJzZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNUaHVyc2RheShuZXcgRGF0ZSgyMDE0LCA4LCAyNSkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNUaHVyc2RheShkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSkuZ2V0RGF5KCkgPT09IDQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNUb2RheSA9IGlzVG9kYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0Tm93LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9pc1NhbWVEYXkuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNUb2RheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgdG9kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQsIGlzIDYgT2N0b2JlciAxNDowMDowMCB0b2RheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVG9kYXkobmV3IERhdGUoMjAxNCwgOSwgNiwgMTQsIDApKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzVG9kYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleDIuaXNTYW1lRGF5KShkYXRlLCAoMCwgX2luZGV4LmNvbnN0cnVjdE5vdykoZGF0ZSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzVG9tb3Jyb3cgPSBpc1RvbW9ycm93O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZERheXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdE5vdy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vaXNTYW1lRGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVG9tb3Jyb3dcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdG9tb3Jyb3c/XG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgdG9tb3Jyb3c/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIHRvbW9ycm93XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDYgT2N0b2JlciAyMDE0LCBpcyA3IE9jdG9iZXIgMTQ6MDA6MDAgdG9tb3Jyb3c/XG4gKiBjb25zdCByZXN1bHQgPSBpc1RvbW9ycm93KG5ldyBEYXRlKDIwMTQsIDksIDcsIDE0LCAwKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1RvbW9ycm93KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgzLmlzU2FtZURheSkoXG4gICAgZGF0ZSxcbiAgICAoMCwgX2luZGV4LmFkZERheXMpKCgwLCBfaW5kZXgyLmNvbnN0cnVjdE5vdykoZGF0ZSksIDEpLFxuICApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzVHVlc2RheSA9IGlzVHVlc2RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNUdWVzZGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSBUdWVzZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgVHVlc2RheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgVHVlc2RheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJcyAyMyBTZXB0ZW1iZXIgMjAxNCBUdWVzZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNUdWVzZGF5KG5ldyBEYXRlKDIwMTQsIDgsIDIzKSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1R1ZXNkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpLmdldERheSgpID09PSAyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzVmFsaWQgPSBpc1ZhbGlkO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2lzRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGlzVmFsaWRcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgdmFsaWQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGZhbHNlIGlmIGFyZ3VtZW50IGlzIEludmFsaWQgRGF0ZSBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlKVxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRlIGlzIHZhbGlkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgdmFsdWUsIGNvbnZlcnRhYmxlIGludG8gYSBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZCgxMzkzODA0ODAwMDAwKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgnJykpXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQoZGF0ZSkge1xuICBpZiAoISgwLCBfaW5kZXguaXNEYXRlKShkYXRlKSAmJiB0eXBlb2YgZGF0ZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG4gIHJldHVybiAhaXNOYU4oTnVtYmVyKF9kYXRlKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNXZWRuZXNkYXkgPSBpc1dlZG5lc2RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgaXNXZWRuZXNkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIFdlZG5lc2RheT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIFdlZG5lc2RheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgV2VkbmVzZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzIDI0IFNlcHRlbWJlciAyMDE0IFdlZG5lc2RheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzV2VkbmVzZGF5KG5ldyBEYXRlKDIwMTQsIDgsIDI0KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1dlZG5lc2RheShkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSkuZ2V0RGF5KCkgPT09IDM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNXZWVrZW5kID0gaXNXZWVrZW5kO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1dlZWtlbmRcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IERvZXMgdGhlIGdpdmVuIGRhdGUgZmFsbCBvbiBhIHdlZWtlbmQ/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEb2VzIHRoZSBnaXZlbiBkYXRlIGZhbGwgb24gYSB3ZWVrZW5kP1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBmYWxscyBvbiBhIHdlZWtlbmRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRG9lcyA1IE9jdG9iZXIgMjAxNCBmYWxsIG9uIGEgd2Vla2VuZD9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzV2Vla2VuZChuZXcgRGF0ZSgyMDE0LCA5LCA1KSlcbiAqIC8vPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1dlZWtlbmQoZGF0ZSkge1xuICBjb25zdCBkYXkgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSkuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgfHwgZGF5ID09PSA2O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzV2l0aGluSW50ZXJ2YWwgPSBpc1dpdGhpbkludGVydmFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1dpdGhpbkludGVydmFsXG4gKiBAY2F0ZWdvcnkgSW50ZXJ2YWwgSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIGRhdGUgd2l0aGluIHRoZSBpbnRlcnZhbD9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIElzIHRoZSBnaXZlbiBkYXRlIHdpdGhpbiB0aGUgaW50ZXJ2YWw/IChJbmNsdWRpbmcgc3RhcnQgYW5kIGVuZC4pXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGludGVydmFsIC0gVGhlIGludGVydmFsIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgd2l0aGluIHRoZSBpbnRlcnZhbFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGRhdGUgd2l0aGluIHRoZSBpbnRlcnZhbDpcbiAqIGlzV2l0aGluSW50ZXJ2YWwobmV3IERhdGUoMjAxNCwgMCwgMyksIHtcbiAqICAgc3RhcnQ6IG5ldyBEYXRlKDIwMTQsIDAsIDEpLFxuICogICBlbmQ6IG5ldyBEYXRlKDIwMTQsIDAsIDcpXG4gKiB9KVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgZGF0ZSBvdXRzaWRlIG9mIHRoZSBpbnRlcnZhbDpcbiAqIGlzV2l0aGluSW50ZXJ2YWwobmV3IERhdGUoMjAxNCwgMCwgMTApLCB7XG4gKiAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCAwLCAxKSxcbiAqICAgZW5kOiBuZXcgRGF0ZSgyMDE0LCAwLCA3KVxuICogfSlcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGRhdGUgZXF1YWwgdG8gaW50ZXJ2YWwgc3RhcnQ6XG4gKiBpc1dpdGhpbkludGVydmFsKGRhdGUsIHsgc3RhcnQsIGVuZDogZGF0ZSB9KVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgZGF0ZSBlcXVhbCB0byBpbnRlcnZhbCBlbmQ6XG4gKiBpc1dpdGhpbkludGVydmFsKGRhdGUsIHsgc3RhcnQ6IGRhdGUsIGVuZCB9KVxuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1dpdGhpbkludGVydmFsKGRhdGUsIGludGVydmFsKSB7XG4gIGNvbnN0IHRpbWUgPSArKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBbc3RhcnRUaW1lLCBlbmRUaW1lXSA9IFtcbiAgICArKDAsIF9pbmRleC50b0RhdGUpKGludGVydmFsLnN0YXJ0KSxcbiAgICArKDAsIF9pbmRleC50b0RhdGUpKGludGVydmFsLmVuZCksXG4gIF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIHJldHVybiB0aW1lID49IHN0YXJ0VGltZSAmJiB0aW1lIDw9IGVuZFRpbWU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNZZXN0ZXJkYXkgPSBpc1llc3RlcmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3ROb3cuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2lzU2FtZURheS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vc3ViRGF5cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBpc1llc3RlcmRheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB5ZXN0ZXJkYXk/XG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgeWVzdGVyZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyB5ZXN0ZXJkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQsIGlzIDUgT2N0b2JlciAxNDowMDowMCB5ZXN0ZXJkYXk/XG4gKiBjb25zdCByZXN1bHQgPSBpc1llc3RlcmRheShuZXcgRGF0ZSgyMDE0LCA5LCA1LCAxNCwgMCkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNZZXN0ZXJkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleDIuaXNTYW1lRGF5KShcbiAgICBkYXRlLFxuICAgICgwLCBfaW5kZXgzLnN1YkRheXMpKCgwLCBfaW5kZXguY29uc3RydWN0Tm93KShkYXRlKSwgMSksXG4gICk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubGFzdERheU9mRGVjYWRlID0gbGFzdERheU9mRGVjYWRlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBsYXN0RGF5T2ZEZWNhZGVcbiAqIEBjYXRlZ29yeSBEZWNhZGUgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBsYXN0IGRheSBvZiBhIGRlY2FkZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIGEgZGVjYWRlIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGxhc3QgZGF5IG9mIGEgZGVjYWRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBsYXN0IGRheSBvZiBhIGRlY2FkZSBmb3IgMjEgRGVjZW1iZXIgMjAxMiAyMToxMjowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZkRlY2FkZShuZXcgRGF0ZSgyMDEyLCAxMSwgMjEsIDIxLCAxMiwgMDApKVxuICogLy89PiBXZWQgRGVjIDMxIDIwMTkgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gbGFzdERheU9mRGVjYWRlKGRhdGUpIHtcbiAgLy8gVE9ETzogU3dpdGNoIHRvIG1vcmUgdGVjaG5pY2FsIGRlZmluaXRpb24gaW4gb2YgZGVjYWRlcyB0aGF0IHN0YXJ0IHdpdGggMVxuICAvLyBlbmQgd2l0aCAwLiBJLmUuIDIwMDEtMjAxMCBpbnN0ZWFkIG9mIGN1cnJlbnQgMjAwMC0yMDA5LiBJdCdzIGEgYnJlYWtpbmdcbiAgLy8gY2hhbmdlLCBzbyBpdCBjYW4gb25seSBiZSBkb25lIGluIDQuMC5cbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBkZWNhZGUgPSA5ICsgTWF0aC5mbG9vcih5ZWFyIC8gMTApICogMTA7XG4gIF9kYXRlLnNldEZ1bGxZZWFyKGRlY2FkZSArIDEsIDAsIDApO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmxhc3REYXlPZklTT1dlZWsgPSBsYXN0RGF5T2ZJU09XZWVrO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2xhc3REYXlPZldlZWsuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbGFzdERheU9mSVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYW4gSVNPIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBsYXN0IGRheSBvZiBhbiBJU08gd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGxhc3QgZGF5IG9mIGFuIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBsYXN0IGRheSBvZiBhbiBJU08gd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZklTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gU3VuIFNlcCAwNyAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGxhc3REYXlPZklTT1dlZWsoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5sYXN0RGF5T2ZXZWVrKShkYXRlLCB7IHdlZWtTdGFydHNPbjogMSB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5sYXN0RGF5T2ZJU09XZWVrWWVhciA9IGxhc3REYXlPZklTT1dlZWtZZWFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dldElTT1dlZWtZZWFyLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdGFydE9mSVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBsYXN0RGF5T2ZJU09XZWVrWWVhclxuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBsYXN0IGRheSBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcixcbiAqIHdoaWNoIGFsd2F5cyBzdGFydHMgMyBkYXlzIGJlZm9yZSB0aGUgeWVhcidzIGZpcnN0IFRodXJzZGF5LlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGxhc3QgZGF5IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIGZvciAyIEp1bHkgMjAwNTpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZklTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDYsIDIpKVxuICogLy89PiBTdW4gSmFuIDAxIDIwMDYgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gbGFzdERheU9mSVNPV2Vla1llYXIoZGF0ZSkge1xuICBjb25zdCB5ZWFyID0gKDAsIF9pbmRleC5nZXRJU09XZWVrWWVhcikoZGF0ZSk7XG4gIGNvbnN0IGZvdXJ0aE9mSmFudWFyeSA9ICgwLCBfaW5kZXgzLmNvbnN0cnVjdEZyb20pKGRhdGUsIDApO1xuICBmb3VydGhPZkphbnVhcnkuc2V0RnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDIuc3RhcnRPZklTT1dlZWspKGZvdXJ0aE9mSmFudWFyeSk7XG4gIF9kYXRlLnNldERhdGUoX2RhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5sYXN0RGF5T2ZNb250aCA9IGxhc3REYXlPZk1vbnRoO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBsYXN0RGF5T2ZNb250aFxuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYSBtb250aCBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIGEgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGxhc3QgZGF5IG9mIGEgbW9udGhcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGxhc3QgZGF5IG9mIGEgbW9udGggZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBsYXN0RGF5T2ZNb250aChuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDMwIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gbGFzdERheU9mTW9udGgoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgbW9udGggPSBfZGF0ZS5nZXRNb250aCgpO1xuICBfZGF0ZS5zZXRGdWxsWWVhcihfZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCArIDEsIDApO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmxhc3REYXlPZlF1YXJ0ZXIgPSBsYXN0RGF5T2ZRdWFydGVyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBsYXN0RGF5T2ZRdWFydGVyXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIGEgeWVhciBxdWFydGVyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYSB5ZWFyIHF1YXJ0ZXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGxhc3QgZGF5IG9mIGEgcXVhcnRlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgbGFzdCBkYXkgb2YgYSBxdWFydGVyIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gbGFzdERheU9mUXVhcnRlcihuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDMwIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gbGFzdERheU9mUXVhcnRlcihkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBjdXJyZW50TW9udGggPSBfZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBtb250aCA9IGN1cnJlbnRNb250aCAtIChjdXJyZW50TW9udGggJSAzKSArIDM7XG4gIF9kYXRlLnNldE1vbnRoKG1vbnRoLCAwKTtcbiAgX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5sYXN0RGF5T2ZXZWVrID0gbGFzdERheU9mV2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0T3B0aW9ucy5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGxhc3REYXlPZldlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBsYXN0RGF5T2ZXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBsYXN0IGRheSBvZiBhIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGxhc3QgZGF5IG9mIGEgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gU2F0IFNlcCAwNiAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIHRoZSBsYXN0IGRheSBvZiB0aGUgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAqIC8vPT4gU3VuIFNlcCAwNyAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGxhc3REYXlPZldlZWsoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXgyLmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyAtNyA6IDApICsgNiAtIChkYXkgLSB3ZWVrU3RhcnRzT24pO1xuXG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBfZGF0ZS5zZXREYXRlKF9kYXRlLmdldERhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubGFzdERheU9mWWVhciA9IGxhc3REYXlPZlllYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIGxhc3REYXlPZlllYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgbGFzdCBkYXkgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBsYXN0IGRheSBvZiBhIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIGxhc3QgZGF5IG9mIGEgeWVhciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IGxhc3REYXlPZlllYXIobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwMCkpXG4gKiAvLz0+IFdlZCBEZWMgMzEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBsYXN0RGF5T2ZZZWFyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICBfZGF0ZS5zZXRGdWxsWWVhcih5ZWFyICsgMSwgMCwgMCk7XG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubGlnaHRGb3JtYXQgPSBsaWdodEZvcm1hdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpZ2h0Rm9ybWF0dGVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgzLmxpZ2h0Rm9ybWF0dGVycztcbiAgfSxcbn0pO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2lzVmFsaWQuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vX2xpYi9mb3JtYXQvbGlnaHRGb3JtYXR0ZXJzLmpzXCIpO1xuXG4vLyBSZXhwb3J0cyBvZiBpbnRlcm5hbCBmb3IgbGlicmFyaWVzIHRvIHVzZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNjM4I2lzc3VlY29tbWVudC0xODc3MDgyODc0XG5cbi8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuY29uc3QgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IC8oXFx3KVxcMSp8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XG5cbmNvbnN0IGVzY2FwZWRTdHJpbmdSZWdFeHAgPSAvXicoW15dKj8pJz8kLztcbmNvbnN0IGRvdWJsZVF1b3RlUmVnRXhwID0gLycnL2c7XG5jb25zdCB1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCA9IC9bYS16QS1aXS87XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEBuYW1lIGxpZ2h0Rm9ybWF0XG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGluIHRoZSBnaXZlbiBmb3JtYXQuIFVubGlrZSBgZm9ybWF0YCxcbiAqIGBsaWdodEZvcm1hdGAgZG9lc24ndCB1c2UgbG9jYWxlcyBhbmQgb3V0cHV0cyBkYXRlIHVzaW5nIHRoZSBtb3N0IHBvcHVsYXIgdG9rZW5zLlxuICpcbiAqID4g4pqg77iPIFBsZWFzZSBub3RlIHRoYXQgdGhlIGBsaWdodEZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKlxuICogQWNjZXB0ZWQgcGF0dGVybnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQYXR0ZXJuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWFhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eSAgICAgfCAwNDQsIDAwMSwgMDAwLCAwMTcgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8XG4gKiB8IE1vbnRoIChmb3JtYXR0aW5nKSAgICAgICAgICAgICAgfCBNICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgICB8IGggICAgICAgfCAxLCAyLCAuLi4sIDExLCAxMiAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaGggICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgICB8IHMgICAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc3MgICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTICAgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gZm9ybWF0IC0gVGhlIHN0cmluZyBvZiB0b2tlbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgSW52YWxpZCB0aW1lIHZhbHVlYCBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gKiBAdGhyb3dzIGZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHQgPSBsaWdodEZvcm1hdChuZXcgRGF0ZSgyMDE0LCAxLCAxMSksICd5eXl5LU1NLWRkJylcbiAqIC8vPT4gJzIwMTQtMDItMTEnXG4gKi9cbmZ1bmN0aW9uIGxpZ2h0Rm9ybWF0KGRhdGUsIGZvcm1hdFN0cikge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG5cbiAgaWYgKCEoMCwgX2luZGV4LmlzVmFsaWQpKF9kYXRlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0aW1lIHZhbHVlXCIpO1xuICB9XG5cbiAgY29uc3QgdG9rZW5zID0gZm9ybWF0U3RyLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApO1xuXG4gIC8vIFRoZSBvbmx5IGNhc2Ugd2hlbiBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwIGRvZXNuJ3QgbWF0Y2ggdGhlIHN0cmluZyBpcyB3aGVuIGl0J3MgZW1wdHlcbiAgaWYgKCF0b2tlbnMpIHJldHVybiBcIlwiO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHRva2Vuc1xuICAgIC5tYXAoKHN1YnN0cmluZykgPT4ge1xuICAgICAgLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxuICAgICAgaWYgKHN1YnN0cmluZyA9PT0gXCInJ1wiKSB7XG4gICAgICAgIHJldHVybiBcIidcIjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybWF0dGVyID0gX2luZGV4My5saWdodEZvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKF9kYXRlLCBzdWJzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgIFwiRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGBcIiArXG4gICAgICAgICAgICBmaXJzdENoYXJhY3RlciArXG4gICAgICAgICAgICBcImBcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YnN0cmluZztcbiAgICB9KVxuICAgIC5qb2luKFwiXCIpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXNbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmJ1aWxkRm9ybWF0TG9uZ0ZuID0gYnVpbGRGb3JtYXRMb25nRm47XG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0TG9uZ0ZuKGFyZ3MpIHtcbiAgcmV0dXJuIChvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgU3RyaW5nKClcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICBjb25zdCBmb3JtYXQgPSBhcmdzLmZvcm1hdHNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0c1thcmdzLmRlZmF1bHRXaWR0aF07XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5idWlsZExvY2FsaXplRm4gPSBidWlsZExvY2FsaXplRm47IC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogVGhlIGxvY2FsaXplIGZ1bmN0aW9uIGFyZ3VtZW50IGNhbGxiYWNrIHdoaWNoIGFsbG93cyB0byBjb252ZXJ0IHJhdyB2YWx1ZSB0b1xuICogdGhlIGFjdHVhbCB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB2YWx1ZVxuICovXG5cbi8qKlxuICogVGhlIG1hcCBvZiBsb2NhbGl6ZWQgdmFsdWVzIGZvciBlYWNoIHdpZHRoLlxuICovXG5cbi8qKlxuICogVGhlIGluZGV4IHR5cGUgb2YgdGhlIGxvY2FsZSB1bml0IHZhbHVlLiBJdCB0eXBlcyBjb252ZXJzaW9uIG9mIHVuaXRzIG9mXG4gKiB2YWx1ZXMgdGhhdCBkb24ndCBzdGFydCBhdCAwIChpLmUuIHF1YXJ0ZXJzKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB1bml0IHZhbHVlIHRvIHRoZSB0dXBsZSBvZiB2YWx1ZXMuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGVyYSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgQkMsXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgcmVwcmVzZW50cyBBRC5cbiAqL1xuXG4vKipcbiAqIFRoZSB0dXBsZSBvZiBsb2NhbGl6ZWQgcXVhcnRlciB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgUTEuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGRheSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgU3VuZGF5LlxuICovXG5cbi8qKlxuICogVGhlIHR1cGxlIG9mIGxvY2FsaXplZCBtb250aCB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgSmFudWFyeS5cbiAqL1xuXG5mdW5jdGlvbiBidWlsZExvY2FsaXplRm4oYXJncykge1xuICByZXR1cm4gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IG9wdGlvbnM/LmNvbnRleHQgPyBTdHJpbmcob3B0aW9ucy5jb250ZXh0KSA6IFwic3RhbmRhbG9uZVwiO1xuXG4gICAgbGV0IHZhbHVlc0FycmF5O1xuICAgIGlmIChjb250ZXh0ID09PSBcImZvcm1hdHRpbmdcIiAmJiBhcmdzLmZvcm1hdHRpbmdWYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdEZvcm1hdHRpbmdXaWR0aCB8fCBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucz8ud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBkZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhbHVlc0FycmF5ID1cbiAgICAgICAgYXJncy5mb3JtYXR0aW5nVmFsdWVzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHRpbmdWYWx1ZXNbZGVmYXVsdFdpZHRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFdpZHRoID0gYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnM/LndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG5cbiAgICAgIHZhbHVlc0FycmF5ID0gYXJncy52YWx1ZXNbd2lkdGhdIHx8IGFyZ3MudmFsdWVzW2RlZmF1bHRXaWR0aF07XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYXJncy5hcmd1bWVudENhbGxiYWNrID8gYXJncy5hcmd1bWVudENhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEZvciBzb21lIHJlYXNvbiBUeXBlU2NyaXB0IGp1c3QgZG9uJ3Qgd2FudCB0byBtYXRjaCBpdCwgbm8gbWF0dGVyIGhvdyBoYXJkIHdlIHRyeS4gSSBjaGFsbGVuZ2UgeW91IHRvIHRyeSB0byByZW1vdmUgaXQhXG4gICAgcmV0dXJuIHZhbHVlc0FycmF5W2luZGV4XTtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5idWlsZE1hdGNoRm4gPSBidWlsZE1hdGNoRm47XG5cbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hGbihhcmdzKSB7XG4gIHJldHVybiAoc3RyaW5nLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG5cbiAgICBjb25zdCBtYXRjaFBhdHRlcm4gPVxuICAgICAgKHdpZHRoICYmIGFyZ3MubWF0Y2hQYXR0ZXJuc1t3aWR0aF0pIHx8XG4gICAgICBhcmdzLm1hdGNoUGF0dGVybnNbYXJncy5kZWZhdWx0TWF0Y2hXaWR0aF07XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gobWF0Y2hQYXR0ZXJuKTtcblxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG5cbiAgICBjb25zdCBwYXJzZVBhdHRlcm5zID1cbiAgICAgICh3aWR0aCAmJiBhcmdzLnBhcnNlUGF0dGVybnNbd2lkdGhdKSB8fFxuICAgICAgYXJncy5wYXJzZVBhdHRlcm5zW2FyZ3MuZGVmYXVsdFBhcnNlV2lkdGhdO1xuXG4gICAgY29uc3Qga2V5ID0gQXJyYXkuaXNBcnJheShwYXJzZVBhdHRlcm5zKVxuICAgICAgPyBmaW5kSW5kZXgocGFyc2VQYXR0ZXJucywgKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChtYXRjaGVkU3RyaW5nKSlcbiAgICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gSSBjaGFsbGFuZ2UgeW91IHRvIGZpeCB0aGUgdHlwZVxuICAgICAgICBmaW5kS2V5KHBhcnNlUGF0dGVybnMsIChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QobWF0Y2hlZFN0cmluZykpO1xuXG4gICAgbGV0IHZhbHVlO1xuXG4gICAgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2soa2V5KSA6IGtleTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFja1xuICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgICAgIG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSlcbiAgICAgIDogdmFsdWU7XG5cbiAgICBjb25zdCByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcblxuICAgIHJldHVybiB7IHZhbHVlLCByZXN0IH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJlxuICAgICAgcHJlZGljYXRlKG9iamVjdFtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgYXJyYXkubGVuZ3RoOyBrZXkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba2V5XSkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuYnVpbGRNYXRjaFBhdHRlcm5GbiA9IGJ1aWxkTWF0Y2hQYXR0ZXJuRm47XG5cbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oYXJncykge1xuICByZXR1cm4gKHN0cmluZywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2goYXJncy5tYXRjaFBhdHRlcm4pO1xuICAgIGlmICghbWF0Y2hSZXN1bHQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcblxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MucGFyc2VQYXR0ZXJuKTtcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICBsZXQgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2tcbiAgICAgID8gYXJncy52YWx1ZUNhbGxiYWNrKHBhcnNlUmVzdWx0WzBdKVxuICAgICAgOiBwYXJzZVJlc3VsdFswXTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEkgY2hhbGxhbmdlIHlvdSB0byBmaXggdGhlIHR5cGVcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIGNvbnN0IHJlc3QgPSBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHsgdmFsdWUsIHJlc3QgfTtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lblVTID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2VuLVVTL19saWIvZm9ybWF0RGlzdGFuY2UuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2VuLVVTL19saWIvZm9ybWF0TG9uZy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vZW4tVVMvX2xpYi9mb3JtYXRSZWxhdGl2ZS5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vZW4tVVMvX2xpYi9sb2NhbGl6ZS5qc1wiKTtcbnZhciBfaW5kZXg1ID0gcmVxdWlyZShcIi4vZW4tVVMvX2xpYi9tYXRjaC5qc1wiKTtcblxuLyoqXG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUgKFVuaXRlZCBTdGF0ZXMpLlxuICogQGxhbmd1YWdlIEVuZ2xpc2hcbiAqIEBpc28tNjM5LTIgZW5nXG4gKiBAYXV0aG9yIFNhc2hhIEtvc3MgW0Brb3Nzbm9jb3JwXShodHRwczovL2dpdGh1Yi5jb20va29zc25vY29ycClcbiAqIEBhdXRob3IgTGVzaGEgS29zcyBbQGxlc2hha29zc10oaHR0cHM6Ly9naXRodWIuY29tL2xlc2hha29zcylcbiAqL1xuY29uc3QgZW5VUyA9IChleHBvcnRzLmVuVVMgPSB7XG4gIGNvZGU6IFwiZW4tVVNcIixcbiAgZm9ybWF0RGlzdGFuY2U6IF9pbmRleC5mb3JtYXREaXN0YW5jZSxcbiAgZm9ybWF0TG9uZzogX2luZGV4Mi5mb3JtYXRMb25nLFxuICBmb3JtYXRSZWxhdGl2ZTogX2luZGV4My5mb3JtYXRSZWxhdGl2ZSxcbiAgbG9jYWxpemU6IF9pbmRleDQubG9jYWxpemUsXG4gIG1hdGNoOiBfaW5kZXg1Lm1hdGNoLFxuICBvcHRpb25zOiB7XG4gICAgd2Vla1N0YXJ0c09uOiAwIC8qIFN1bmRheSAqLyxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDEsXG4gIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5mb3JtYXREaXN0YW5jZSA9IHZvaWQgMDtcblxuY29uc3QgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBvbmU6IFwibGVzcyB0aGFuIGEgc2Vjb25kXCIsXG4gICAgb3RoZXI6IFwibGVzcyB0aGFuIHt7Y291bnR9fSBzZWNvbmRzXCIsXG4gIH0sXG5cbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6IFwiMSBzZWNvbmRcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gc2Vjb25kc1wiLFxuICB9LFxuXG4gIGhhbGZBTWludXRlOiBcImhhbGYgYSBtaW51dGVcIixcblxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiBcImxlc3MgdGhhbiBhIG1pbnV0ZVwiLFxuICAgIG90aGVyOiBcImxlc3MgdGhhbiB7e2NvdW50fX0gbWludXRlc1wiLFxuICB9LFxuXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiBcIjEgbWludXRlXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IG1pbnV0ZXNcIixcbiAgfSxcblxuICBhYm91dFhIb3Vyczoge1xuICAgIG9uZTogXCJhYm91dCAxIGhvdXJcIixcbiAgICBvdGhlcjogXCJhYm91dCB7e2NvdW50fX0gaG91cnNcIixcbiAgfSxcblxuICB4SG91cnM6IHtcbiAgICBvbmU6IFwiMSBob3VyXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IGhvdXJzXCIsXG4gIH0sXG5cbiAgeERheXM6IHtcbiAgICBvbmU6IFwiMSBkYXlcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gZGF5c1wiLFxuICB9LFxuXG4gIGFib3V0WFdlZWtzOiB7XG4gICAgb25lOiBcImFib3V0IDEgd2Vla1wiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSB3ZWVrc1wiLFxuICB9LFxuXG4gIHhXZWVrczoge1xuICAgIG9uZTogXCIxIHdlZWtcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gd2Vla3NcIixcbiAgfSxcblxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSBtb250aFwiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSBtb250aHNcIixcbiAgfSxcblxuICB4TW9udGhzOiB7XG4gICAgb25lOiBcIjEgbW9udGhcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gbW9udGhzXCIsXG4gIH0sXG5cbiAgYWJvdXRYWWVhcnM6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwiYWJvdXQge3tjb3VudH19IHllYXJzXCIsXG4gIH0sXG5cbiAgeFllYXJzOiB7XG4gICAgb25lOiBcIjEgeWVhclwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxuXG4gIG92ZXJYWWVhcnM6IHtcbiAgICBvbmU6IFwib3ZlciAxIHllYXJcIixcbiAgICBvdGhlcjogXCJvdmVyIHt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxuXG4gIGFsbW9zdFhZZWFyczoge1xuICAgIG9uZTogXCJhbG1vc3QgMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwiYWxtb3N0IHt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxufTtcblxuY29uc3QgZm9ybWF0RGlzdGFuY2UgPSAodG9rZW4sIGNvdW50LCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3QgdG9rZW5WYWx1ZSA9IGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXTtcbiAgaWYgKHR5cGVvZiB0b2tlblZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmVzdWx0ID0gdG9rZW5WYWx1ZTtcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub25lO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWUub3RoZXIucmVwbGFjZShcInt7Y291bnR9fVwiLCBjb3VudC50b1N0cmluZygpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zPy5hZGRTdWZmaXgpIHtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uICYmIG9wdGlvbnMuY29tcGFyaXNvbiA+IDApIHtcbiAgICAgIHJldHVybiBcImluIFwiICsgcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgXCIgYWdvXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmZvcm1hdERpc3RhbmNlID0gZm9ybWF0RGlzdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZm9ybWF0TG9uZyA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vX2xpYi9idWlsZEZvcm1hdExvbmdGbi5qc1wiKTtcblxuY29uc3QgZGF0ZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwiRUVFRSwgTU1NTSBkbywgeVwiLFxuICBsb25nOiBcIk1NTU0gZG8sIHlcIixcbiAgbWVkaXVtOiBcIk1NTSBkLCB5XCIsXG4gIHNob3J0OiBcIk1NL2RkL3l5eXlcIixcbn07XG5cbmNvbnN0IHRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcImg6bW06c3MgYSB6enp6XCIsXG4gIGxvbmc6IFwiaDptbTpzcyBhIHpcIixcbiAgbWVkaXVtOiBcImg6bW06c3MgYVwiLFxuICBzaG9ydDogXCJoOm1tIGFcIixcbn07XG5cbmNvbnN0IGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIGxvbmc6IFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVwiLFxuICBtZWRpdW06IFwie3tkYXRlfX0sIHt7dGltZX19XCIsXG4gIHNob3J0OiBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiLFxufTtcblxuY29uc3QgZm9ybWF0TG9uZyA9IChleHBvcnRzLmZvcm1hdExvbmcgPSB7XG4gIGRhdGU6ICgwLCBfaW5kZXguYnVpbGRGb3JtYXRMb25nRm4pKHtcbiAgICBmb3JtYXRzOiBkYXRlRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6IFwiZnVsbFwiLFxuICB9KSxcblxuICB0aW1lOiAoMCwgX2luZGV4LmJ1aWxkRm9ybWF0TG9uZ0ZuKSh7XG4gICAgZm9ybWF0czogdGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiBcImZ1bGxcIixcbiAgfSksXG5cbiAgZGF0ZVRpbWU6ICgwLCBfaW5kZXguYnVpbGRGb3JtYXRMb25nRm4pKHtcbiAgICBmb3JtYXRzOiBkYXRlVGltZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiBcImZ1bGxcIixcbiAgfSksXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5mb3JtYXRSZWxhdGl2ZSA9IHZvaWQgMDtcblxuY29uc3QgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBcIidsYXN0JyBlZWVlICdhdCcgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ3llc3RlcmRheSBhdCcgcFwiLFxuICB0b2RheTogXCIndG9kYXkgYXQnIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ3RvbW9ycm93IGF0JyBwXCIsXG4gIG5leHRXZWVrOiBcImVlZWUgJ2F0JyBwXCIsXG4gIG90aGVyOiBcIlBcIixcbn07XG5cbmNvbnN0IGZvcm1hdFJlbGF0aXZlID0gKHRva2VuLCBfZGF0ZSwgX2Jhc2VEYXRlLCBfb3B0aW9ucykgPT5cbiAgZm9ybWF0UmVsYXRpdmVMb2NhbGVbdG9rZW5dO1xuZXhwb3J0cy5mb3JtYXRSZWxhdGl2ZSA9IGZvcm1hdFJlbGF0aXZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmxvY2FsaXplID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi9fbGliL2J1aWxkTG9jYWxpemVGbi5qc1wiKTtcblxuY29uc3QgZXJhVmFsdWVzID0ge1xuICBuYXJyb3c6IFtcIkJcIiwgXCJBXCJdLFxuICBhYmJyZXZpYXRlZDogW1wiQkNcIiwgXCJBRFwiXSxcbiAgd2lkZTogW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdLFxufTtcblxuY29uc3QgcXVhcnRlclZhbHVlcyA9IHtcbiAgbmFycm93OiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCJdLFxuICBhYmJyZXZpYXRlZDogW1wiUTFcIiwgXCJRMlwiLCBcIlEzXCIsIFwiUTRcIl0sXG4gIHdpZGU6IFtcIjFzdCBxdWFydGVyXCIsIFwiMm5kIHF1YXJ0ZXJcIiwgXCIzcmQgcXVhcnRlclwiLCBcIjR0aCBxdWFydGVyXCJdLFxufTtcblxuLy8gTm90ZTogaW4gRW5nbGlzaCwgdGhlIG5hbWVzIG9mIGRheXMgb2YgdGhlIHdlZWsgYW5kIG1vbnRocyBhcmUgY2FwaXRhbGl6ZWQuXG4vLyBJZiB5b3UgYXJlIG1ha2luZyBhIG5ldyBsb2NhbGUgYmFzZWQgb24gdGhpcyBvbmUsIGNoZWNrIGlmIHRoZSBzYW1lIGlzIHRydWUgZm9yIHRoZSBsYW5ndWFnZSB5b3UncmUgd29ya2luZyBvbi5cbi8vIEdlbmVyYWxseSwgZm9ybWF0dGVkIGRhdGVzIHNob3VsZCBsb29rIGxpa2UgdGhleSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHNlbnRlbmNlLFxuLy8gZS5nLiBpbiBTcGFuaXNoIGxhbmd1YWdlIHRoZSB3ZWVrZGF5cyBhbmQgbW9udGhzIHNob3VsZCBiZSBpbiB0aGUgbG93ZXJjYXNlLlxuY29uc3QgbW9udGhWYWx1ZXMgPSB7XG4gIG5hcnJvdzogW1wiSlwiLCBcIkZcIiwgXCJNXCIsIFwiQVwiLCBcIk1cIiwgXCJKXCIsIFwiSlwiLCBcIkFcIiwgXCJTXCIsIFwiT1wiLCBcIk5cIiwgXCJEXCJdLFxuICBhYmJyZXZpYXRlZDogW1xuICAgIFwiSmFuXCIsXG4gICAgXCJGZWJcIixcbiAgICBcIk1hclwiLFxuICAgIFwiQXByXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1blwiLFxuICAgIFwiSnVsXCIsXG4gICAgXCJBdWdcIixcbiAgICBcIlNlcFwiLFxuICAgIFwiT2N0XCIsXG4gICAgXCJOb3ZcIixcbiAgICBcIkRlY1wiLFxuICBdLFxuXG4gIHdpZGU6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiLFxuICBdLFxufTtcblxuY29uc3QgZGF5VmFsdWVzID0ge1xuICBuYXJyb3c6IFtcIlNcIiwgXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIl0sXG4gIHNob3J0OiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgd2lkZTogW1xuICAgIFwiU3VuZGF5XCIsXG4gICAgXCJNb25kYXlcIixcbiAgICBcIlR1ZXNkYXlcIixcbiAgICBcIldlZG5lc2RheVwiLFxuICAgIFwiVGh1cnNkYXlcIixcbiAgICBcIkZyaWRheVwiLFxuICAgIFwiU2F0dXJkYXlcIixcbiAgXSxcbn07XG5cbmNvbnN0IGRheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06IFwiYVwiLFxuICAgIHBtOiBcInBcIixcbiAgICBtaWRuaWdodDogXCJtaVwiLFxuICAgIG5vb246IFwiblwiLFxuICAgIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICAgIGFmdGVybm9vbjogXCJhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJuaWdodFwiLFxuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiBcIkFNXCIsXG4gICAgcG06IFwiUE1cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICAgIGFmdGVybm9vbjogXCJhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJuaWdodFwiLFxuICB9LFxuICB3aWRlOiB7XG4gICAgYW06IFwiYS5tLlwiLFxuICAgIHBtOiBcInAubS5cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICAgIGFmdGVybm9vbjogXCJhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJuaWdodFwiLFxuICB9LFxufTtcblxuY29uc3QgZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyA9IHtcbiAgbmFycm93OiB7XG4gICAgYW06IFwiYVwiLFxuICAgIHBtOiBcInBcIixcbiAgICBtaWRuaWdodDogXCJtaVwiLFxuICAgIG5vb246IFwiblwiLFxuICAgIG1vcm5pbmc6IFwiaW4gdGhlIG1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiaW4gdGhlIGFmdGVybm9vblwiLFxuICAgIGV2ZW5pbmc6IFwiaW4gdGhlIGV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJhdCBuaWdodFwiLFxuICB9LFxuICBhYmJyZXZpYXRlZDoge1xuICAgIGFtOiBcIkFNXCIsXG4gICAgcG06IFwiUE1cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwiaW4gdGhlIG1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiaW4gdGhlIGFmdGVybm9vblwiLFxuICAgIGV2ZW5pbmc6IFwiaW4gdGhlIGV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJhdCBuaWdodFwiLFxuICB9LFxuICB3aWRlOiB7XG4gICAgYW06IFwiYS5tLlwiLFxuICAgIHBtOiBcInAubS5cIixcbiAgICBtaWRuaWdodDogXCJtaWRuaWdodFwiLFxuICAgIG5vb246IFwibm9vblwiLFxuICAgIG1vcm5pbmc6IFwiaW4gdGhlIG1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiaW4gdGhlIGFmdGVybm9vblwiLFxuICAgIGV2ZW5pbmc6IFwiaW4gdGhlIGV2ZW5pbmdcIixcbiAgICBuaWdodDogXCJhdCBuaWdodFwiLFxuICB9LFxufTtcblxuY29uc3Qgb3JkaW5hbE51bWJlciA9IChkaXJ0eU51bWJlciwgX29wdGlvbnMpID0+IHtcbiAgY29uc3QgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcblxuICAvLyBJZiBvcmRpbmFsIG51bWJlcnMgZGVwZW5kIG9uIGNvbnRleHQsIGZvciBleGFtcGxlLFxuICAvLyBpZiB0aGV5IGFyZSBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCBncmFtbWF0aWNhbCBnZW5kZXJzLFxuICAvLyB1c2UgYG9wdGlvbnMudW5pdGAuXG4gIC8vXG4gIC8vIGB1bml0YCBjYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RhdGUnLCAnZGF5T2ZZZWFyJyxcbiAgLy8gJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLlxuXG4gIGNvbnN0IHJlbTEwMCA9IG51bWJlciAlIDEwMDtcbiAgaWYgKHJlbTEwMCA+IDIwIHx8IHJlbTEwMCA8IDEwKSB7XG4gICAgc3dpdGNoIChyZW0xMDAgJSAxMCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgXCJzdFwiO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgXCJuZFwiO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbnVtYmVyICsgXCJyZFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyICsgXCJ0aFwiO1xufTtcblxuY29uc3QgbG9jYWxpemUgPSAoZXhwb3J0cy5sb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcixcblxuICBlcmE6ICgwLCBfaW5kZXguYnVpbGRMb2NhbGl6ZUZuKSh7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgcXVhcnRlcjogKDAsIF9pbmRleC5idWlsZExvY2FsaXplRm4pKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgICBhcmd1bWVudENhbGxiYWNrOiAocXVhcnRlcikgPT4gcXVhcnRlciAtIDEsXG4gIH0pLFxuXG4gIG1vbnRoOiAoMCwgX2luZGV4LmJ1aWxkTG9jYWxpemVGbikoe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgZGF5OiAoMCwgX2luZGV4LmJ1aWxkTG9jYWxpemVGbikoe1xuICAgIHZhbHVlczogZGF5VmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxuXG4gIGRheVBlcmlvZDogKDAsIF9pbmRleC5idWlsZExvY2FsaXplRm4pKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6IFwid2lkZVwiLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubWF0Y2ggPSB2b2lkIDA7XG5cbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vX2xpYi9idWlsZE1hdGNoRm4uanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4uanNcIik7XG5cbmNvbnN0IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2k7XG5jb25zdCBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcblxuY29uc3QgbWF0Y2hFcmFQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihifGEpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihiXFwuP1xccz9jXFwuP3xiXFwuP1xccz9jXFwuP1xccz9lXFwuP3xhXFwuP1xccz9kXFwuP3xjXFwuP1xccz9lXFwuPykvaSxcbiAgd2lkZTogL14oYmVmb3JlIGNocmlzdHxiZWZvcmUgY29tbW9uIGVyYXxhbm5vIGRvbWluaXxjb21tb24gZXJhKS9pLFxufTtcbmNvbnN0IHBhcnNlRXJhUGF0dGVybnMgPSB7XG4gIGFueTogWy9eYi9pLCAvXihhfGMpL2ldLFxufTtcblxuY29uc3QgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaSxcbn07XG5jb25zdCBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV0sXG59O1xuXG5jb25zdCBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgd2lkZTogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaSxcbn07XG5jb25zdCBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogW1xuICAgIC9eai9pLFxuICAgIC9eZi9pLFxuICAgIC9ebS9pLFxuICAgIC9eYS9pLFxuICAgIC9ebS9pLFxuICAgIC9eai9pLFxuICAgIC9eai9pLFxuICAgIC9eYS9pLFxuICAgIC9ecy9pLFxuICAgIC9eby9pLFxuICAgIC9ebi9pLFxuICAgIC9eZC9pLFxuICBdLFxuXG4gIGFueTogW1xuICAgIC9eamEvaSxcbiAgICAvXmYvaSxcbiAgICAvXm1hci9pLFxuICAgIC9eYXAvaSxcbiAgICAvXm1heS9pLFxuICAgIC9eanVuL2ksXG4gICAgL15qdWwvaSxcbiAgICAvXmF1L2ksXG4gICAgL15zL2ksXG4gICAgL15vL2ksXG4gICAgL15uL2ksXG4gICAgL15kL2ksXG4gIF0sXG59O1xuXG5jb25zdCBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtdHdmXS9pLFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzdW58bW9ufHR1ZXx3ZWR8dGh1fGZyaXxzYXQpL2ksXG4gIHdpZGU6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pLFxufTtcbmNvbnN0IHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXSxcbn07XG5cbmNvbnN0IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxufTtcbmNvbnN0IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXmEvaSxcbiAgICBwbTogL15wL2ksXG4gICAgbWlkbmlnaHQ6IC9ebWkvaSxcbiAgICBub29uOiAvXm5vL2ksXG4gICAgbW9ybmluZzogL21vcm5pbmcvaSxcbiAgICBhZnRlcm5vb246IC9hZnRlcm5vb24vaSxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxuICAgIG5pZ2h0OiAvbmlnaHQvaSxcbiAgfSxcbn07XG5cbmNvbnN0IG1hdGNoID0gKGV4cG9ydHMubWF0Y2ggPSB7XG4gIG9yZGluYWxOdW1iZXI6ICgwLCBfaW5kZXgyLmJ1aWxkTWF0Y2hQYXR0ZXJuRm4pKHtcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgcGFyc2VQYXR0ZXJuOiBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHZhbHVlQ2FsbGJhY2s6ICh2YWx1ZSkgPT4gcGFyc2VJbnQodmFsdWUsIDEwKSxcbiAgfSksXG5cbiAgZXJhOiAoMCwgX2luZGV4LmJ1aWxkTWF0Y2hGbikoe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwid2lkZVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRXJhUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCIsXG4gIH0pLFxuXG4gIHF1YXJ0ZXI6ICgwLCBfaW5kZXguYnVpbGRNYXRjaEZuKSh7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwid2lkZVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiLFxuICAgIHZhbHVlQ2FsbGJhY2s6IChpbmRleCkgPT4gaW5kZXggKyAxLFxuICB9KSxcblxuICBtb250aDogKDAsIF9pbmRleC5idWlsZE1hdGNoRm4pKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaE1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwid2lkZVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgfSksXG5cbiAgZGF5OiAoMCwgX2luZGV4LmJ1aWxkTWF0Y2hGbikoe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwid2lkZVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCIsXG4gIH0pLFxuXG4gIGRheVBlcmlvZDogKDAsIF9pbmRleC5idWlsZE1hdGNoRm4pKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcImFueVwiLFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCIsXG4gIH0pLFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubWF4ID0gbWF4O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBtYXhcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBsYXRlc3Qgb2YgdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBsYXRlc3Qgb2YgdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlcyAtIFRoZSBkYXRlcyB0byBjb21wYXJlXG4gKlxuICogQHJldHVybnMgVGhlIGxhdGVzdCBvZiB0aGUgZGF0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggb2YgdGhlc2UgZGF0ZXMgaXMgdGhlIGxhdGVzdD9cbiAqIGNvbnN0IHJlc3VsdCA9IG1heChbXG4gKiAgIG5ldyBEYXRlKDE5ODksIDYsIDEwKSxcbiAqICAgbmV3IERhdGUoMTk4NywgMSwgMTEpLFxuICogICBuZXcgRGF0ZSgxOTk1LCA2LCAyKSxcbiAqICAgbmV3IERhdGUoMTk5MCwgMCwgMSlcbiAqIF0pXG4gKiAvLz0+IFN1biBKdWwgMDIgMTk5NSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBtYXgoZGF0ZXMpIHtcbiAgbGV0IHJlc3VsdDtcbiAgZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlydHlEYXRlKSB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGlydHlEYXRlKTtcblxuICAgIGlmIChcbiAgICAgIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICByZXN1bHQgPCBjdXJyZW50RGF0ZSB8fFxuICAgICAgaXNOYU4oTnVtYmVyKGN1cnJlbnREYXRlKSlcbiAgICApIHtcbiAgICAgIHJlc3VsdCA9IGN1cnJlbnREYXRlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdCB8fCBuZXcgRGF0ZShOYU4pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnlcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gdGhlIHNwZWNpZmllZCwgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiB0aGUgc3BlY2lmaWVkLCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMuXG4gKlxuICogT25lIHllYXJzIGVxdWFscyAzNjUuMjQyNSBkYXlzIGFjY29yZGluZyB0byB0aGUgZm9ybXVsYTpcbiAqXG4gKiA+IExlYXAgeWVhciBvY2N1cmVzIGV2ZXJ5IDQgeWVhcnMsIGV4Y2VwdCBmb3IgeWVhcnMgdGhhdCBhcmUgZGl2aXNhYmxlIGJ5IDEwMCBhbmQgbm90IGRpdmlzYWJsZSBieSA0MDAuXG4gKiA+IDEgbWVhbiB5ZWFyID0gKDM2NSsxLzQtMS8xMDArMS80MDApIGRheXMgPSAzNjUuMjQyNSBkYXlzXG4gKlxuICogT25lIG1vbnRoIGlzIGEgeWVhciBkaXZpZGVkIGJ5IDEyLlxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBvYmplY3Qgd2l0aCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgdG8gYmUgYWRkZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG1pbGxpc2Vjb25kc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyAxIHllYXIgaW4gbWlsbGlzZWNvbmRzXG4gKiBtaWxsaXNlY29uZHMoeyB5ZWFyczogMSB9KVxuICogLy89PiAzMTU1Njk1MjAwMFxuICpcbiAqIC8vIDMgbW9udGhzIGluIG1pbGxpc2Vjb25kc1xuICogbWlsbGlzZWNvbmRzKHsgbW9udGhzOiAzIH0pXG4gKiAvLz0+IDc4ODkyMzgwMDBcbiAqL1xuZnVuY3Rpb24gbWlsbGlzZWNvbmRzKHsgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzIH0pIHtcbiAgbGV0IHRvdGFsRGF5cyA9IDA7XG5cbiAgaWYgKHllYXJzKSB0b3RhbERheXMgKz0geWVhcnMgKiBfaW5kZXguZGF5c0luWWVhcjtcbiAgaWYgKG1vbnRocykgdG90YWxEYXlzICs9IG1vbnRocyAqIChfaW5kZXguZGF5c0luWWVhciAvIDEyKTtcbiAgaWYgKHdlZWtzKSB0b3RhbERheXMgKz0gd2Vla3MgKiA3O1xuICBpZiAoZGF5cykgdG90YWxEYXlzICs9IGRheXM7XG5cbiAgbGV0IHRvdGFsU2Vjb25kcyA9IHRvdGFsRGF5cyAqIDI0ICogNjAgKiA2MDtcblxuICBpZiAoaG91cnMpIHRvdGFsU2Vjb25kcyArPSBob3VycyAqIDYwICogNjA7XG4gIGlmIChtaW51dGVzKSB0b3RhbFNlY29uZHMgKz0gbWludXRlcyAqIDYwO1xuICBpZiAoc2Vjb25kcykgdG90YWxTZWNvbmRzICs9IHNlY29uZHM7XG5cbiAgcmV0dXJuIE1hdGgudHJ1bmModG90YWxTZWNvbmRzICogMTAwMCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubWlsbGlzZWNvbmRzVG9Ib3VycyA9IG1pbGxpc2Vjb25kc1RvSG91cnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc1RvSG91cnNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIGhvdXJzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYSBmdWxsIG51bWJlciBvZiBob3Vycy5cbiAqXG4gKiBAcGFyYW0gbWlsbGlzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgY29udmVydGVkIGluIGhvdXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgNzIwMDAwMCBtaWxsaXNlY29uZHMgdG8gaG91cnM6XG4gKiBjb25zdCByZXN1bHQgPSBtaWxsaXNlY29uZHNUb0hvdXJzKDcyMDAwMDApXG4gKiAvLz0+IDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXQgdXNlcyBmbG9vciByb3VuZGluZzpcbiAqIGNvbnN0IHJlc3VsdCA9IG1pbGxpc2Vjb25kc1RvSG91cnMoNzE5OTk5OSlcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBtaWxsaXNlY29uZHNUb0hvdXJzKG1pbGxpc2Vjb25kcykge1xuICBjb25zdCBob3VycyA9IG1pbGxpc2Vjb25kcyAvIF9pbmRleC5taWxsaXNlY29uZHNJbkhvdXI7XG4gIHJldHVybiBNYXRoLnRydW5jKGhvdXJzKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5taWxsaXNlY29uZHNUb01pbnV0ZXMgPSBtaWxsaXNlY29uZHNUb01pbnV0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc1RvTWludXRlc1xuICogQGNhdGVnb3J5IENvbnZlcnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCBtaWxsaXNlY29uZHMgdG8gbWludXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGEgZnVsbCBudW1iZXIgb2YgbWludXRlcy5cbiAqXG4gKiBAcGFyYW0gbWlsbGlzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgY29udmVydGVkIGluIG1pbnV0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCA2MDAwMCBtaWxsaXNlY29uZHMgdG8gbWludXRlczpcbiAqIGNvbnN0IHJlc3VsdCA9IG1pbGxpc2Vjb25kc1RvTWludXRlcyg2MDAwMClcbiAqIC8vPT4gMVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJdCB1c2VzIGZsb29yIHJvdW5kaW5nOlxuICogY29uc3QgcmVzdWx0ID0gbWlsbGlzZWNvbmRzVG9NaW51dGVzKDExOTk5OSlcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBtaWxsaXNlY29uZHNUb01pbnV0ZXMobWlsbGlzZWNvbmRzKSB7XG4gIGNvbnN0IG1pbnV0ZXMgPSBtaWxsaXNlY29uZHMgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5NaW51dGU7XG4gIHJldHVybiBNYXRoLnRydW5jKG1pbnV0ZXMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm1pbGxpc2Vjb25kc1RvU2Vjb25kcyA9IG1pbGxpc2Vjb25kc1RvU2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbWlsbGlzZWNvbmRzVG9TZWNvbmRzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IG1pbGxpc2Vjb25kcyB0byBzZWNvbmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gYSBmdWxsIG51bWJlciBvZiBzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBjb252ZXJ0ZWQgaW4gc2Vjb25kc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDEwMDAgbWlsaXNlY29uZHMgdG8gc2Vjb25kczpcbiAqIGNvbnN0IHJlc3VsdCA9IG1pbGxpc2Vjb25kc1RvU2Vjb25kcygxMDAwKVxuICogLy89PiAxXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEl0IHVzZXMgZmxvb3Igcm91bmRpbmc6XG4gKiBjb25zdCByZXN1bHQgPSBtaWxsaXNlY29uZHNUb1NlY29uZHMoMTk5OSlcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBtaWxsaXNlY29uZHNUb1NlY29uZHMobWlsbGlzZWNvbmRzKSB7XG4gIGNvbnN0IHNlY29uZHMgPSBtaWxsaXNlY29uZHMgLyBfaW5kZXgubWlsbGlzZWNvbmRzSW5TZWNvbmQ7XG4gIHJldHVybiBNYXRoLnRydW5jKHNlY29uZHMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm1pbiA9IG1pbjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbWluXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybnMgdGhlIGVhcmxpZXN0IG9mIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdGhlIGVhcmxpZXN0IG9mIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZXMgLSBUaGUgZGF0ZXMgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm5zIFRoZSBlYXJsaWVzdCBvZiB0aGUgZGF0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggb2YgdGhlc2UgZGF0ZXMgaXMgdGhlIGVhcmxpZXN0P1xuICogY29uc3QgcmVzdWx0ID0gbWluKFtcbiAqICAgbmV3IERhdGUoMTk4OSwgNiwgMTApLFxuICogICBuZXcgRGF0ZSgxOTg3LCAxLCAxMSksXG4gKiAgIG5ldyBEYXRlKDE5OTUsIDYsIDIpLFxuICogICBuZXcgRGF0ZSgxOTkwLCAwLCAxKVxuICogXSlcbiAqIC8vPT4gV2VkIEZlYiAxMSAxOTg3IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG1pbihkYXRlcykge1xuICBsZXQgcmVzdWx0O1xuXG4gIGRhdGVzLmZvckVhY2goKGRpcnR5RGF0ZSkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGlydHlEYXRlKTtcbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQgPiBkYXRlIHx8IGlzTmFOKCtkYXRlKSkge1xuICAgICAgcmVzdWx0ID0gZGF0ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQgfHwgbmV3IERhdGUoTmFOKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5taW51dGVzVG9Ib3VycyA9IG1pbnV0ZXNUb0hvdXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBtaW51dGVzVG9Ib3Vyc1xuICogQGNhdGVnb3J5IENvbnZlcnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCBtaW51dGVzIHRvIGhvdXJzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBtaW51dGVzIHRvIGEgZnVsbCBudW1iZXIgb2YgaG91cnMuXG4gKlxuICogQHBhcmFtIG1pbnV0ZXMgLSBUaGUgbnVtYmVyIG9mIG1pbnV0ZXMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaW51dGVzIGNvbnZlcnRlZCBpbiBob3Vyc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDE0MCBtaW51dGVzIHRvIGhvdXJzOlxuICogY29uc3QgcmVzdWx0ID0gbWludXRlc1RvSG91cnMoMTIwKVxuICogLy89PiAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEl0IHVzZXMgZmxvb3Igcm91bmRpbmc6XG4gKiBjb25zdCByZXN1bHQgPSBtaW51dGVzVG9Ib3VycygxNzkpXG4gKiAvLz0+IDJcbiAqL1xuZnVuY3Rpb24gbWludXRlc1RvSG91cnMobWludXRlcykge1xuICBjb25zdCBob3VycyA9IG1pbnV0ZXMgLyBfaW5kZXgubWludXRlc0luSG91cjtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoaG91cnMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm1pbnV0ZXNUb01pbGxpc2Vjb25kcyA9IG1pbnV0ZXNUb01pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbWludXRlc1RvTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IG1pbnV0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBtaW51dGVzIHRvIGEgZnVsbCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSBtaW51dGVzIC0gVGhlIG51bWJlciBvZiBtaW51dGVzIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWludXRlcyBjb252ZXJ0ZWQgaW4gbWlsbGlzZWNvbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMiBtaW51dGVzIHRvIG1pbGxpc2Vjb25kc1xuICogY29uc3QgcmVzdWx0ID0gbWludXRlc1RvTWlsbGlzZWNvbmRzKDIpXG4gKiAvLz0+IDEyMDAwMFxuICovXG5mdW5jdGlvbiBtaW51dGVzVG9NaWxsaXNlY29uZHMobWludXRlcykge1xuICByZXR1cm4gTWF0aC50cnVuYyhtaW51dGVzICogX2luZGV4Lm1pbGxpc2Vjb25kc0luTWludXRlKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5taW51dGVzVG9TZWNvbmRzID0gbWludXRlc1RvU2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbWludXRlc1RvU2Vjb25kc1xuICogQGNhdGVnb3J5IENvbnZlcnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCBtaW51dGVzIHRvIHNlY29uZHMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIG1pbnV0ZXMgdG8gYSBmdWxsIG51bWJlciBvZiBzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSBtaW51dGVzIC0gVGhlIG51bWJlciBvZiBtaW51dGVzIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWludXRlcyBjb252ZXJ0ZWQgaW4gc2Vjb25kc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDIgbWludXRlcyB0byBzZWNvbmRzXG4gKiBjb25zdCByZXN1bHQgPSBtaW51dGVzVG9TZWNvbmRzKDIpXG4gKiAvLz0+IDEyMFxuICovXG5mdW5jdGlvbiBtaW51dGVzVG9TZWNvbmRzKG1pbnV0ZXMpIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMobWludXRlcyAqIF9pbmRleC5zZWNvbmRzSW5NaW51dGUpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm1vbnRoc1RvUXVhcnRlcnMgPSBtb250aHNUb1F1YXJ0ZXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBtb250aHNUb1F1YXJ0ZXJzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IG51bWJlciBvZiBtb250aHMgdG8gcXVhcnRlcnMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIG1vbnRocyB0byBhIGZ1bGwgbnVtYmVyIG9mIHF1YXJ0ZXJzLlxuICpcbiAqIEBwYXJhbSBtb250aHMgLSBUaGUgbnVtYmVyIG9mIG1vbnRocyB0byBiZSBjb252ZXJ0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtb250aHMgY29udmVydGVkIGluIHF1YXJ0ZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgNiBtb250aHMgdG8gcXVhcnRlcnM6XG4gKiBjb25zdCByZXN1bHQgPSBtb250aHNUb1F1YXJ0ZXJzKDYpXG4gKiAvLz0+IDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSXQgdXNlcyBmbG9vciByb3VuZGluZzpcbiAqIGNvbnN0IHJlc3VsdCA9IG1vbnRoc1RvUXVhcnRlcnMoNylcbiAqIC8vPT4gMlxuICovXG5mdW5jdGlvbiBtb250aHNUb1F1YXJ0ZXJzKG1vbnRocykge1xuICBjb25zdCBxdWFydGVycyA9IG1vbnRocyAvIF9pbmRleC5tb250aHNJblF1YXJ0ZXI7XG4gIHJldHVybiBNYXRoLnRydW5jKHF1YXJ0ZXJzKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5tb250aHNUb1llYXJzID0gbW9udGhzVG9ZZWFycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgbW9udGhzVG9ZZWFyc1xuICogQGNhdGVnb3J5IENvbnZlcnNpb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCBudW1iZXIgb2YgbW9udGhzIHRvIHllYXJzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBtb250aHMgdG8gYSBmdWxsIG51bWJlciBvZiB5ZWFycy5cbiAqXG4gKiBAcGFyYW0gbW9udGhzIC0gVGhlIG51bWJlciBvZiBtb250aHMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtb250aHMgY29udmVydGVkIGluIHllYXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMzYgbW9udGhzIHRvIHllYXJzOlxuICogY29uc3QgcmVzdWx0ID0gbW9udGhzVG9ZZWFycygzNilcbiAqIC8vPT4gM1xuICpcbiAqIC8vIEl0IHVzZXMgZmxvb3Igcm91bmRpbmc6XG4gKiBjb25zdCByZXN1bHQgPSBtb250aHNUb1llYXJzKDQwKVxuICogLy89PiAzXG4gKi9cbmZ1bmN0aW9uIG1vbnRoc1RvWWVhcnMobW9udGhzKSB7XG4gIGNvbnN0IHllYXJzID0gbW9udGhzIC8gX2luZGV4Lm1vbnRoc0luWWVhcjtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeWVhcnMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLm5leHREYXkgPSBuZXh0RGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZERheXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2dldERheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBuZXh0RGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBuZXh0IGRheSBvZiB0aGUgd2Vlaz9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIG5leHQgZGF5IG9mIHRoZSB3ZWVrPyAwLTYgdGhlIGRheSBvZiB0aGUgd2VlaywgMCByZXByZXNlbnRzIFN1bmRheS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0gZGF5IC0gZGF5IG9mIHRoZSB3ZWVrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgdGhlIG5leHQgZGF5IG9mIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgbmV4dCBNb25kYXkgYWZ0ZXIgTWFyLCAyMCwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IG5leHREYXkobmV3IERhdGUoMjAyMCwgMiwgMjApLCAxKVxuICogLy89PiBNb24gTWFyIDIzIDIwMjAgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgbmV4dCBUdWVzZGF5IGFmdGVyIE1hciwgMjEsIDIwMjA/XG4gKiBjb25zdCByZXN1bHQgPSBuZXh0RGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIxKSwgMilcbiAqIC8vPT4gVHVlIE1hciAyNCAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG5leHREYXkoZGF0ZSwgZGF5KSB7XG4gIGxldCBkZWx0YSA9IGRheSAtICgwLCBfaW5kZXgyLmdldERheSkoZGF0ZSk7XG4gIGlmIChkZWx0YSA8PSAwKSBkZWx0YSArPSA3O1xuXG4gIHJldHVybiAoMCwgX2luZGV4LmFkZERheXMpKGRhdGUsIGRlbHRhKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5uZXh0RnJpZGF5ID0gbmV4dEZyaWRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9uZXh0RGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG5leHRGcmlkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIG5leHQgRnJpZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgbmV4dCBGcmlkYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKlxuICogQHJldHVybnMgVGhlIG5leHQgRnJpZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIG5leHQgRnJpZGF5IGFmdGVyIE1hciwgMjIsIDIwMjA/XG4gKiBjb25zdCByZXN1bHQgPSBuZXh0RnJpZGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIyKSlcbiAqIC8vPT4gRnJpIE1hciAyNyAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG5leHRGcmlkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5uZXh0RGF5KShkYXRlLCA1KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5uZXh0TW9uZGF5ID0gbmV4dE1vbmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9uZXh0RGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG5leHRNb25kYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIG5leHQgTW9uZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgbmV4dCBNb25kYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKlxuICogQHJldHVybnMgVGhlIG5leHQgTW9uZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIG5leHQgTW9uZGF5IGFmdGVyIE1hciwgMjIsIDIwMjA/XG4gKiBjb25zdCByZXN1bHQgPSBuZXh0TW9uZGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIyKSlcbiAqIC8vPT4gTW9uIE1hciAyMyAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG5leHRNb25kYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5uZXh0RGF5KShkYXRlLCAxKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5uZXh0U2F0dXJkYXkgPSBuZXh0U2F0dXJkYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vbmV4dERheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBuZXh0U2F0dXJkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIG5leHQgU2F0dXJkYXk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBXaGVuIGlzIHRoZSBuZXh0IFNhdHVyZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXh0IFNhdHVyZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIG5leHQgU2F0dXJkYXkgYWZ0ZXIgTWFyLCAyMiwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IG5leHRTYXR1cmRheShuZXcgRGF0ZSgyMDIwLCAyLCAyMikpXG4gKiAvLz0+IFNhdCBNYXIgMjggMjAyMCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBuZXh0U2F0dXJkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5uZXh0RGF5KShkYXRlLCA2KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5uZXh0U3VuZGF5ID0gbmV4dFN1bmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9uZXh0RGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG5leHRTdW5kYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIG5leHQgU3VuZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgbmV4dCBTdW5kYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKlxuICogQHJldHVybnMgVGhlIG5leHQgU3VuZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIG5leHQgU3VuZGF5IGFmdGVyIE1hciwgMjIsIDIwMjA/XG4gKiBjb25zdCByZXN1bHQgPSBuZXh0U3VuZGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIyKSlcbiAqIC8vPT4gU3VuIE1hciAyOSAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG5leHRTdW5kYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5uZXh0RGF5KShkYXRlLCAwKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5uZXh0VGh1cnNkYXkgPSBuZXh0VGh1cnNkYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vbmV4dERheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBuZXh0VGh1cnNkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIG5leHQgVGh1cnNkYXk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBXaGVuIGlzIHRoZSBuZXh0IFRodXJzZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXh0IFRodXJzZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIG5leHQgVGh1cnNkYXkgYWZ0ZXIgTWFyLCAyMiwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IG5leHRUaHVyc2RheShuZXcgRGF0ZSgyMDIwLCAyLCAyMikpXG4gKiAvLz0+IFRodXIgTWFyIDI2IDIwMjAgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gbmV4dFRodXJzZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgubmV4dERheSkoZGF0ZSwgNCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubmV4dFR1ZXNkYXkgPSBuZXh0VHVlc2RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9uZXh0RGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIG5leHRUdWVzZGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBuZXh0IFR1ZXNkYXk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBXaGVuIGlzIHRoZSBuZXh0IFR1ZXNkYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKlxuICogQHJldHVybnMgVGhlIG5leHQgVHVlc2RheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBuZXh0IFR1ZXNkYXkgYWZ0ZXIgTWFyLCAyMiwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IG5leHRUdWVzZGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIyKSlcbiAqIC8vPT4gVHVlIE1hciAyNCAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIG5leHRUdWVzZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgubmV4dERheSkoZGF0ZSwgMik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMubmV4dFdlZG5lc2RheSA9IG5leHRXZWRuZXNkYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vbmV4dERheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBuZXh0V2VkbmVzZGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBuZXh0IFdlZG5lc2RheT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIG5leHQgV2VkbmVzZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXh0IFdlZG5lc2RheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBuZXh0IFdlZG5lc2RheSBhZnRlciBNYXIsIDIyLCAyMDIwP1xuICogY29uc3QgcmVzdWx0ID0gbmV4dFdlZG5lc2RheShuZXcgRGF0ZSgyMDIwLCAyLCAyMikpXG4gKiAvLz0+IFdlZCBNYXIgMjUgMjAyMCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBuZXh0V2VkbmVzZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgubmV4dERheSkoZGF0ZSwgMyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvbmdGb3JtYXR0ZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleDUubG9uZ0Zvcm1hdHRlcnM7XG4gIH0sXG59KTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Ny5wYXJzZXJzO1xuICB9LFxufSk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZ2V0RGVmYXVsdE9wdGlvbnMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdExvY2FsZS5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL19saWIvZm9ybWF0L2xvbmdGb3JtYXR0ZXJzLmpzXCIpO1xudmFyIF9pbmRleDYgPSByZXF1aXJlKFwiLi9fbGliL3Byb3RlY3RlZFRva2Vucy5qc1wiKTtcblxudmFyIF9pbmRleDcgPSByZXF1aXJlKFwiLi9wYXJzZS9fbGliL3BhcnNlcnMuanNcIik7XG5cbnZhciBfU2V0dGVyID0gcmVxdWlyZShcIi4vcGFyc2UvX2xpYi9TZXR0ZXIuanNcIik7XG5cbi8vIFJleHBvcnRzIG9mIGludGVybmFsIGZvciBsaWJyYXJpZXMgdG8gdXNlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM2MzgjaXNzdWVjb21tZW50LTE4NzcwODI4NzRcblxuLyoqXG4gKiBUaGUge0BsaW5rIHBhcnNlfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuY29uc3QgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9XG4gIC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuY29uc3QgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuY29uc3QgZXNjYXBlZFN0cmluZ1JlZ0V4cCA9IC9eJyhbXl0qPyknPyQvO1xuY29uc3QgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcblxuY29uc3Qgbm90V2hpdGVzcGFjZVJlZ0V4cCA9IC9cXFMvO1xuY29uc3QgdW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHAgPSAvW2EtekEtWl0vO1xuXG4vKipcbiAqIEBuYW1lIHBhcnNlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFBhcnNlIHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZy5cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXG4gKiA+IFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICpcbiAqIFRoZSBjaGFyYWN0ZXJzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHdyYXBwZWQgYmV0d2VlbiB0d28gc2luZ2xlIHF1b3RlcyBjaGFyYWN0ZXJzICgnKSBhcmUgZXNjYXBlZC5cbiAqIFR3byBzaW5nbGUgcXVvdGVzIGluIGEgcm93LCB3aGV0aGVyIGluc2lkZSBvciBvdXRzaWRlIGEgcXVvdGVkIHNlcXVlbmNlLCByZXByZXNlbnQgYSAncmVhbCcgc2luZ2xlIHF1b3RlLlxuICpcbiAqIEZvcm1hdCBvZiB0aGUgZm9ybWF0IHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNSBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIE5vdCBhbGwgdG9rZW5zIGFyZSBjb21wYXRpYmxlLiBDb21iaW5hdGlvbnMgdGhhdCBkb24ndCBtYWtlIHNlbnNlIG9yIGNvdWxkIGxlYWQgdG8gYnVncyBhcmUgcHJvaGliaXRlZFxuICogYW5kIHdpbGwgdGhyb3cgYFJhbmdlRXJyb3JgLiBGb3IgZXhhbXBsZSB1c2FnZSBvZiAyNC1ob3VyIGZvcm1hdCB0b2tlbiB3aXRoIEFNL1BNIHRva2VuIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHBhcnNlKCcyMyBBTScsICdISCBhJywgbmV3IERhdGUoKSlcbiAqIC8vPT4gUmFuZ2VFcnJvcjogVGhlIGZvcm1hdCBzdHJpbmcgbXVzdG4ndCBjb250YWluIGBISGAgYW5kIGBhYCBhdCB0aGUgc2FtZSB0aW1lXG4gKiBgYGBcbiAqXG4gKiBTZWUgdGhlIGNvbXBhdGliaWxpdHkgdGFibGU6IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kL2UvMlBBQ1gtMXZRT1BVM3hVaHBsbGw2ZHlvTW1WVVhIS2xfOENSRHM2X3VlTG1leDNTb3F3aHVvbGt1TjNPMDVsNHJxeDVoMWRLWDhlYjQ2VWwtQ0NTcnEvcHViaHRtbD9naWQ9MCZzaW5nbGU9dHJ1ZVxuICpcbiAqIEFjY2VwdGVkIGZvcm1hdCBzdHJpbmcgcGF0dGVybnM6XG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFByaW9yfCBQYXR0ZXJuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHwgTm90ZXMgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLXxcbiAqIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDE0MCB8IEcuLkdHRyAgfCBBRCwgQkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBHR0dHICAgIHwgQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3QgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgR0dHR0cgICB8IEEsIEIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQ2FsZW5kYXIgeWVhciAgICAgICAgICAgICAgICAgICB8IDEzMCB8IHkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNywgOTk5OSAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5byAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eSAgICAgfCAwNDQsIDAwMSwgMTIzLCA5OTkgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXl5ICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5eXkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICB8IDEzMCB8IFkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNywgOTAwMCAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZbyAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVkgICAgICB8IDQ0LCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgICB8IDQsNiAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWSAgICAgfCAwNDQsIDAwMSwgMTIzLCA5OTkgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVlZICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCw2ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZWVkgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgICB8IDEzMCB8IFIgICAgICAgfCAtNDMsIDEsIDE5MDAsIDIwMTcsIDk5OTksIC05OTk5ICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUiAgICAgIHwgLTQzLCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgIHwgNCw1ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSICAgICB8IC0wNDMsIDAwMSwgMTIzLCA5OTksIC05OTkgICAgICAgICB8IDQsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUlIgICAgfCAtMDA0MywgMDAwMSwgMjAxNywgOTk5OSwgLTk5OTkgICAgfCA0LDUgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlJSUiAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0LDUgfFxuICogfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgIHwgMTMwIHwgdSAgICAgICB8IC00MywgMSwgMTkwMCwgMjAxNywgOTk5OSwgLTk5OSAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1ICAgICAgfCAtNDMsIDAxLCA5OSwgLTk5ICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXUgICAgIHwgLTA0MywgMDAxLCAxMjMsIDk5OSwgLTk5OSAgICAgICAgIHwgNCAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1dSAgICB8IC0wMDQzLCAwMDAxLCAyMDE3LCA5OTk5LCAtOTk5OSAgICB8IDQgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dXV1ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XG4gKiB8IFF1YXJ0ZXIgKGZvcm1hdHRpbmcpICAgICAgICAgICAgfCAxMjAgfCBRICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRUSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUVFRICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XG4gKiB8IFF1YXJ0ZXIgKHN0YW5kLWFsb25lKSAgICAgICAgICAgfCAxMjAgfCBxICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcW8gICAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxcSAgICB8IDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcXFxICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IE1vbnRoIChmb3JtYXR0aW5nKSAgICAgICAgICAgICAgfCAxMTAgfCBNICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU0gICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NTSAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTU1NICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1vbnRoIChzdGFuZC1hbG9uZSkgICAgICAgICAgICAgfCAxMTAgfCBMICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTEwgICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMTCAgICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTExMICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgfCAxMDAgfCB3ICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgd28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHd3ICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICAgfCAxMDAgfCBJICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDUzdGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IElJICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBkICAgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGRkICAgICAgfCAwMSwgMDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBEICAgICAgIHwgMSwgMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDM2NXRoLCAzNjZ0aCAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEREICAgICAgfCAwMSwgMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEREQgICAgIHwgMDAxLCAwMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRERERCAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgICAgICB8ICA5MCB8IEUuLkVFRSAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRUUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUVFRSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IElTTyBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgfCAgOTAgfCBpICAgICAgIHwgMSwgMiwgMywgLi4uLCA3ICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaW8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDd0aCAgICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpICAgICAgfCAwMSwgMDIsIC4uLiwgMDcgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWkgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIsNSAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWlpICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpaWkgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgNSAgICAgfFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgIHwgIDkwIHwgZSAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZSAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlZSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZWVlICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8ICAgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKHN0YW5kLWFsb25lKSB8ICA5MCB8IGMgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2MgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjYyAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjY2MgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2NjYyAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgODAgfCBhLi5hYWEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYWFhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCAgODAgfCBiLi5iYmIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCAgODAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEtLICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNjAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNTAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCAgNDAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgICB8ICAzMCB8IFMgICAgICAgfCAwLCAxLCAuLi4sIDkgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTUyAgICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1NTICAgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTU1MgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgfCAgMjAgfCBUICAgICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8ICAxMCB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWCAgICAgIHwgLTA4MDAsICswNTMwLCBaICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFhYWCAgIHwgLTA4OjAwLCArMDU6MzAsIFosICsxMjozNDo1NiAgICAgIHwgICAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgIDEwIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHggICAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XG4gKiB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICAgfCAgTkEgfCBQICAgICAgIHwgMDUvMjkvMTQ1MyAgICAgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFAgICAgICB8IE1heSAyOSwgMTQ1MyAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUCAgICAgfCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBQICAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgIHwgMiw1LDggfFxuICogfCBMb25nIGxvY2FsaXplZCB0aW1lICAgICAgICAgICAgIHwgIE5BIHwgcCAgICAgICB8IDEyOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHBwICAgICAgfCAxMjowMDowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCAgTkEgfCBQcCAgICAgIHwgMDUvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUFBwcCAgICB8IE1heSAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFBQUHBwICAgfCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBQUFBQcHAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgIHwgMiw1LDggfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhci5cbiAqICAgIEluIGBmb3JtYXRgIGZ1bmN0aW9uLCB0aGV5IHdpbGwgcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0OlxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTExMTCcsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWQnYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTU1NTScsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWR1J2BcbiAqXG4gKiAgICBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIGJvdGggZm9ybWF0dGluZyBhbmQgc3RhbmQtYWxvbmUgdW5pdHMgaW50ZXJjaGFuZ2FibHkuXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlOlxuICogICAgLSBmb3IgbnVtZXJpY2FsIHVuaXRzIChgeXl5eXl5eXlgKSBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIGEgbnVtYmVyXG4gKiAgICAgIGFzIHdpZGUgYXMgdGhlIHNlcXVlbmNlXG4gKiAgICAtIGZvciB0ZXh0IHVuaXRzIChgTU1NTU1NTU1gKSBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIHRoZSB3aWRlc3QgdmFyaWF0aW9uIG9mIHRoZSB1bml0LlxuICogICAgICBUaGVzZSB2YXJpYXRpb25zIGFyZSBtYXJrZWQgd2l0aCBcIjJcIiBpbiB0aGUgbGFzdCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuICpcbiAqIDMuIGBRUVFRUWAgYW5kIGBxcXFxcWAgY291bGQgYmUgbm90IHN0cmljdGx5IG51bWVyaWNhbCBpbiBzb21lIGxvY2FsZXMuXG4gKiAgICBUaGVzZSB0b2tlbnMgcmVwcmVzZW50IHRoZSBzaG9ydGVzdCBmb3JtIG9mIHRoZSBxdWFydGVyLlxuICpcbiAqIDQuIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiBgeWAgYW5kIGB1YCBwYXR0ZXJucyBhcmUgQi5DLiB5ZWFyczpcbiAqXG4gKiAgICB8IFllYXIgfCBgeWAgfCBgdWAgfFxuICogICAgfC0tLS0tLXwtLS0tLXwtLS0tLXxcbiAqICAgIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gKiAgICB8IEJDIDEgfCAgIDEgfCAgIDAgfFxuICogICAgfCBCQyAyIHwgICAyIHwgIC0xIHxcbiAqXG4gKiAgICBBbHNvIGB5eWAgd2lsbCB0cnkgdG8gZ3Vlc3MgdGhlIGNlbnR1cnkgb2YgdHdvIGRpZ2l0IHllYXIgYnkgcHJveGltaXR5IHdpdGggYHJlZmVyZW5jZURhdGVgOlxuICpcbiAqICAgIGBwYXJzZSgnNTAnLCAneXknLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBTYXQgSmFuIDAxIDIwNTAgMDA6MDA6MDBgXG4gKlxuICogICAgYHBhcnNlKCc3NScsICd5eScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFdlZCBKYW4gMDEgMTk3NSAwMDowMDowMGBcbiAqXG4gKiAgICB3aGlsZSBgdXVgIHdpbGwganVzdCBhc3NpZ24gdGhlIHllYXIgYXMgaXM6XG4gKlxuICogICAgYHBhcnNlKCc1MCcsICd1dScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFNhdCBKYW4gMDEgMDA1MCAwMDowMDowMGBcbiAqXG4gKiAgICBgcGFyc2UoJzc1JywgJ3V1JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gVHVlIEphbiAwMSAwMDc1IDAwOjAwOjAwYFxuICpcbiAqICAgIFRoZSBzYW1lIGRpZmZlcmVuY2UgaXMgdHJ1ZSBmb3IgbG9jYWwgYW5kIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyAoYFlgIGFuZCBgUmApLFxuICogICAgZXhjZXB0IGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJzIGFyZSBkZXBlbmRlbnQgb24gYG9wdGlvbnMud2Vla1N0YXJ0c09uYFxuICogICAgYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKGNvbXBhcmUgW3NldElTT1dlZWtZZWFyXShodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldElTT1dlZWtZZWFyKVxuICogICAgYW5kIFtzZXRXZWVrWWVhcl0oaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9zZXRXZWVrWWVhcikpLlxuICpcbiAqIDUuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcbiAqICAgIC0gYGlgOiBJU08gZGF5IG9mIHdlZWtcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqICAgIC0gYG9gOiBvcmRpbmFsIG51bWJlciBtb2RpZmllclxuICogICAgLSBgUGA6IGxvbmcgbG9jYWxpemVkIGRhdGVcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXG4gKlxuICogNi4gYFlZYCBhbmQgYFlZWVlgIHRva2VucyByZXByZXNlbnQgd2Vlay1udW1iZXJpbmcgeWVhcnMgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggeWVhcnMuXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiA3LiBgRGAgYW5kIGBERGAgdG9rZW5zIHJlcHJlc2VudCBkYXlzIG9mIHRoZSB5ZWFyIGJ1dCB0aGV5IGFyZSBvZnRoZW4gY29uZnVzZWQgd2l0aCBkYXlzIG9mIHRoZSBtb250aC5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnNgIHRvIHVzZSB0aGVtLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiA4LiBgUCtgIHRva2VucyBkbyBub3QgaGF2ZSBhIGRlZmluZWQgcHJpb3JpdHkgc2luY2UgdGhleSBhcmUgbWVyZWx5IGFsaWFzZXMgdG8gb3RoZXIgdG9rZW5zIGJhc2VkXG4gKiAgICBvbiB0aGUgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqICAgIHVzaW5nIGBlbi1VU2AgbG9jYWxlOiBgUGAgPT4gYE1NL2RkL3l5eXlgXG4gKiAgICB1c2luZyBgZW4tVVNgIGxvY2FsZTogYHBgID0+IGBoaDptbSBhYFxuICogICAgdXNpbmcgYHB0LUJSYCBsb2NhbGU6IGBQYCA9PiBgZGQvTU0veXl5eWBcbiAqICAgIHVzaW5nIGBwdC1CUmAgbG9jYWxlOiBgcGAgPT4gYEhIOm1tYFxuICpcbiAqIFZhbHVlcyB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBkYXRlIGluIHRoZSBkZXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXG4gKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAqXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBwYXJzZWQgKGUuZy4gd2hlbiBwYXJzaW5nIHN0cmluZyAnSmFudWFyeSAxc3QnIHdpdGhvdXQgYSB5ZWFyKSxcbiAqIHRoZSB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIDNyZCBhcmd1bWVudCBgcmVmZXJlbmNlRGF0ZWAgd2hpY2ggd29ya3MgYXMgYSBjb250ZXh0IG9mIHBhcnNpbmcuXG4gKlxuICogYHJlZmVyZW5jZURhdGVgIG11c3QgYmUgcGFzc2VkIGZvciBjb3JyZWN0IHdvcmsgb2YgdGhlIGZ1bmN0aW9uLlxuICogSWYgeW91J3JlIG5vdCBzdXJlIHdoaWNoIGByZWZlcmVuY2VEYXRlYCB0byBzdXBwbHksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBEYXRlOlxuICogYHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL2RkL3l5eXknLCBuZXcgRGF0ZSgpKWBcbiAqIEluIHRoaXMgY2FzZSBwYXJzaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBkYXRlLlxuICogSWYgYHJlZmVyZW5jZURhdGVgIGlzIGBJbnZhbGlkIERhdGVgIG9yIGEgdmFsdWUgbm90IGNvbnZlcnRpYmxlIHRvIHZhbGlkIGBEYXRlYCxcbiAqIHRoZW4gYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGByZWZlcmVuY2VEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIElmIHBhcnNpbmcgZmFpbGVkLCBgSW52YWxpZCBEYXRlYCB3aWxsIGJlIHJldHVybmVkLlxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZVN0ciAtIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSBmb3JtYXRTdHIgLSBUaGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHJlZmVyZW5jZURhdGUgLSBkZWZpbmVzIHZhbHVlcyBtaXNzaW5nIGZyb20gdGhlIHBhcnNlZCBkYXRlU3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiAgIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGVcbiAqXG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBtYXRjaGAgcHJvcGVydHlcbiAqIEB0aHJvd3MgdXNlIGB5eXl5YCBpbnN0ZWFkIG9mIGBZWVlZYCBmb3IgZm9ybWF0dGluZyB5ZWFycyB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIHVzZSBgeXlgIGluc3RlYWQgb2YgYFlZYCBmb3IgZm9ybWF0dGluZyB5ZWFycyB1c2luZyBbZm9ybWF0IHByb3ZpZGVkXSB0byB0aGUgaW5wdXQgW2lucHV0IHByb3ZpZGVkXTsgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKiBAdGhyb3dzIHVzZSBgZGAgaW5zdGVhZCBvZiBgRGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyB1c2UgYGRkYCBpbnN0ZWFkIG9mIGBERGAgZm9yIGZvcm1hdHRpbmcgZGF5cyBvZiB0aGUgbW9udGggdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyBmb3JtYXQgc3RyaW5nIGNvbnRhaW5zIGFuIHVuZXNjYXBlZCBsYXRpbiBhbHBoYWJldCBjaGFyYWN0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMTEgRmVicnVhcnkgMjAxNCBmcm9tIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IHBhcnNlKCcwMi8xMS8yMDE0JywgJ01NL2RkL3l5eXknLCBuZXcgRGF0ZSgpKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUGFyc2UgMjh0aCBvZiBGZWJydWFyeSBpbiBFc3BlcmFudG8gbG9jYWxlIGluIHRoZSBjb250ZXh0IG9mIDIwMTAgeWVhcjpcbiAqIGltcG9ydCBlbyBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gKiB2YXIgcmVzdWx0ID0gcGFyc2UoJzI4LWEgZGUgZmVicnVhcm8nLCBcImRvICdkZScgTU1NTVwiLCBuZXcgRGF0ZSgyMDEwLCAwLCAxKSwge1xuICogICBsb2NhbGU6IGVvXG4gKiB9KVxuICogLy89PiBTdW4gRmViIDI4IDIwMTAgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gcGFyc2UoZGF0ZVN0ciwgZm9ybWF0U3RyLCByZWZlcmVuY2VEYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gKDAsIF9pbmRleDIuZ2V0RGVmYXVsdE9wdGlvbnMpKCk7XG4gIGNvbnN0IGxvY2FsZSA9XG4gICAgb3B0aW9ucz8ubG9jYWxlID8/IGRlZmF1bHRPcHRpb25zLmxvY2FsZSA/PyBfaW5kZXgzLmRlZmF1bHRMb2NhbGU7XG5cbiAgY29uc3QgZmlyc3RXZWVrQ29udGFpbnNEYXRlID1cbiAgICBvcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBvcHRpb25zPy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgMTtcblxuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGlmIChmb3JtYXRTdHIgPT09IFwiXCIpIHtcbiAgICBpZiAoZGF0ZVN0ciA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuICgwLCBfaW5kZXg0LnRvRGF0ZSkocmVmZXJlbmNlRGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKHJlZmVyZW5jZURhdGUsIE5hTik7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3ViRm5PcHRpb25zID0ge1xuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICB3ZWVrU3RhcnRzT24sXG4gICAgbG9jYWxlLFxuICB9O1xuXG4gIC8vIElmIHRpbWV6b25lIGlzbid0IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICBjb25zdCBzZXR0ZXJzID0gW25ldyBfU2V0dGVyLkRhdGVUb1N5c3RlbVRpbWV6b25lU2V0dGVyKCldO1xuXG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdFN0clxuICAgIC5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cClcbiAgICAubWFwKChzdWJzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hhcmFjdGVyID0gc3Vic3RyaW5nWzBdO1xuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyIGluIF9pbmRleDUubG9uZ0Zvcm1hdHRlcnMpIHtcbiAgICAgICAgY29uc3QgbG9uZ0Zvcm1hdHRlciA9IF9pbmRleDUubG9uZ0Zvcm1hdHRlcnNbZmlyc3RDaGFyYWN0ZXJdO1xuICAgICAgICByZXR1cm4gbG9uZ0Zvcm1hdHRlcihzdWJzdHJpbmcsIGxvY2FsZS5mb3JtYXRMb25nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJzdHJpbmc7XG4gICAgfSlcbiAgICAuam9pbihcIlwiKVxuICAgIC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKTtcblxuICBjb25zdCB1c2VkVG9rZW5zID0gW107XG5cbiAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgaWYgKFxuICAgICAgIW9wdGlvbnM/LnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyAmJlxuICAgICAgKDAsIF9pbmRleDYuaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKSh0b2tlbilcbiAgICApIHtcbiAgICAgICgwLCBfaW5kZXg2Lndhcm5PclRocm93UHJvdGVjdGVkRXJyb3IpKHRva2VuLCBmb3JtYXRTdHIsIGRhdGVTdHIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhb3B0aW9ucz8udXNlQWRkaXRpb25hbERheU9mWWVhclRva2VucyAmJlxuICAgICAgKDAsIF9pbmRleDYuaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbikodG9rZW4pXG4gICAgKSB7XG4gICAgICAoMCwgX2luZGV4Ni53YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKSh0b2tlbiwgZm9ybWF0U3RyLCBkYXRlU3RyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHRva2VuWzBdO1xuICAgIGNvbnN0IHBhcnNlciA9IF9pbmRleDcucGFyc2Vyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgY29uc3QgeyBpbmNvbXBhdGlibGVUb2tlbnMgfSA9IHBhcnNlcjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluY29tcGF0aWJsZVRva2VucykpIHtcbiAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9rZW4gPSB1c2VkVG9rZW5zLmZpbmQoXG4gICAgICAgICAgKHVzZWRUb2tlbikgPT5cbiAgICAgICAgICAgIGluY29tcGF0aWJsZVRva2Vucy5pbmNsdWRlcyh1c2VkVG9rZW4udG9rZW4pIHx8XG4gICAgICAgICAgICB1c2VkVG9rZW4udG9rZW4gPT09IGZpcnN0Q2hhcmFjdGVyLFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9rZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZm9ybWF0IHN0cmluZyBtdXN0bid0IGNvbnRhaW4gXFxgJHtpbmNvbXBhdGlibGVUb2tlbi5mdWxsVG9rZW59XFxgIGFuZCBcXGAke3Rva2VufVxcYCBhdCB0aGUgc2FtZSB0aW1lYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlci5pbmNvbXBhdGlibGVUb2tlbnMgPT09IFwiKlwiICYmIHVzZWRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICBgVGhlIGZvcm1hdCBzdHJpbmcgbXVzdG4ndCBjb250YWluIFxcYCR7dG9rZW59XFxgIGFuZCBhbnkgb3RoZXIgdG9rZW4gYXQgdGhlIHNhbWUgdGltZWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHVzZWRUb2tlbnMucHVzaCh7IHRva2VuOiBmaXJzdENoYXJhY3RlciwgZnVsbFRva2VuOiB0b2tlbiB9KTtcblxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBwYXJzZXIucnVuKFxuICAgICAgICBkYXRlU3RyLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgbG9jYWxlLm1hdGNoLFxuICAgICAgICBzdWJGbk9wdGlvbnMsXG4gICAgICApO1xuXG4gICAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKHJlZmVyZW5jZURhdGUsIE5hTik7XG4gICAgICB9XG5cbiAgICAgIHNldHRlcnMucHVzaChwYXJzZVJlc3VsdC5zZXR0ZXIpO1xuXG4gICAgICBkYXRlU3RyID0gcGFyc2VSZXN1bHQucmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyLm1hdGNoKHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICBcIkZvcm1hdCBzdHJpbmcgY29udGFpbnMgYW4gdW5lc2NhcGVkIGxhdGluIGFscGhhYmV0IGNoYXJhY3RlciBgXCIgK1xuICAgICAgICAgICAgZmlyc3RDaGFyYWN0ZXIgK1xuICAgICAgICAgICAgXCJgXCIsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgdHdvIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgIGlmICh0b2tlbiA9PT0gXCInJ1wiKSB7XG4gICAgICAgIHRva2VuID0gXCInXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSBcIidcIikge1xuICAgICAgICB0b2tlbiA9IGNsZWFuRXNjYXBlZFN0cmluZyh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIC8vIEN1dCB0b2tlbiBmcm9tIHN0cmluZywgb3IsIGlmIHN0cmluZyBkb2Vzbid0IG1hdGNoIHRoZSB0b2tlbiwgcmV0dXJuIEludmFsaWQgRGF0ZVxuICAgICAgaWYgKGRhdGVTdHIuaW5kZXhPZih0b2tlbikgPT09IDApIHtcbiAgICAgICAgZGF0ZVN0ciA9IGRhdGVTdHIuc2xpY2UodG9rZW4ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKHJlZmVyZW5jZURhdGUsIE5hTik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyBpbnB1dCBjb250YWlucyBzb21ldGhpbmcgb3RoZXIgdGhhbiB3aGl0ZXNwYWNlXG4gIGlmIChkYXRlU3RyLmxlbmd0aCA+IDAgJiYgbm90V2hpdGVzcGFjZVJlZ0V4cC50ZXN0KGRhdGVTdHIpKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguY29uc3RydWN0RnJvbSkocmVmZXJlbmNlRGF0ZSwgTmFOKTtcbiAgfVxuXG4gIGNvbnN0IHVuaXF1ZVByaW9yaXR5U2V0dGVycyA9IHNldHRlcnNcbiAgICAubWFwKChzZXR0ZXIpID0+IHNldHRlci5wcmlvcml0eSlcbiAgICAuc29ydCgoYSwgYikgPT4gYiAtIGEpXG4gICAgLmZpbHRlcigocHJpb3JpdHksIGluZGV4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZihwcmlvcml0eSkgPT09IGluZGV4KVxuICAgIC5tYXAoKHByaW9yaXR5KSA9PlxuICAgICAgc2V0dGVyc1xuICAgICAgICAuZmlsdGVyKChzZXR0ZXIpID0+IHNldHRlci5wcmlvcml0eSA9PT0gcHJpb3JpdHkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnN1YlByaW9yaXR5IC0gYS5zdWJQcmlvcml0eSksXG4gICAgKVxuICAgIC5tYXAoKHNldHRlckFycmF5KSA9PiBzZXR0ZXJBcnJheVswXSk7XG5cbiAgbGV0IGRhdGUgPSAoMCwgX2luZGV4NC50b0RhdGUpKHJlZmVyZW5jZURhdGUpO1xuXG4gIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShyZWZlcmVuY2VEYXRlLCBOYU4pO1xuICB9XG5cbiAgY29uc3QgZmxhZ3MgPSB7fTtcbiAgZm9yIChjb25zdCBzZXR0ZXIgb2YgdW5pcXVlUHJpb3JpdHlTZXR0ZXJzKSB7XG4gICAgaWYgKCFzZXR0ZXIudmFsaWRhdGUoZGF0ZSwgc3ViRm5PcHRpb25zKSkge1xuICAgICAgcmV0dXJuICgwLCBfaW5kZXguY29uc3RydWN0RnJvbSkocmVmZXJlbmNlRGF0ZSwgTmFOKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBzZXR0ZXIuc2V0KGRhdGUsIGZsYWdzLCBzdWJGbk9wdGlvbnMpO1xuICAgIC8vIFJlc3VsdCBpcyB0dXBsZSAoZGF0ZSwgZmxhZ3MpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgZGF0ZSA9IHJlc3VsdFswXTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZmxhZ3MsIHJlc3VsdFsxXSk7XG4gICAgICAvLyBSZXN1bHQgaXMgZGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKHJlZmVyZW5jZURhdGUsIGRhdGUpO1xufVxuXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmcoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKGVzY2FwZWRTdHJpbmdSZWdFeHApWzFdLnJlcGxhY2UoZG91YmxlUXVvdGVSZWdFeHAsIFwiJ1wiKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG52YXIgX1NldHRlciA9IHJlcXVpcmUoXCIuL1NldHRlci5qc1wiKTtcblxuY2xhc3MgUGFyc2VyIHtcbiAgcnVuKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRlcjogbmV3IF9TZXR0ZXIuVmFsdWVTZXR0ZXIoXG4gICAgICAgIHJlc3VsdC52YWx1ZSxcbiAgICAgICAgdGhpcy52YWxpZGF0ZSxcbiAgICAgICAgdGhpcy5zZXQsXG4gICAgICAgIHRoaXMucHJpb3JpdHksXG4gICAgICAgIHRoaXMuc3ViUHJpb3JpdHksXG4gICAgICApLFxuICAgICAgcmVzdDogcmVzdWx0LnJlc3QsXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlKF91dGNEYXRlLCBfdmFsdWUsIF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLlZhbHVlU2V0dGVyID1cbiAgZXhwb3J0cy5TZXR0ZXIgPVxuICBleHBvcnRzLkRhdGVUb1N5c3RlbVRpbWV6b25lU2V0dGVyID1cbiAgICB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL3RyYW5zcG9zZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0cnVjdEZyb20uanNcIik7XG5cbmNvbnN0IFRJTUVaT05FX1VOSVRfUFJJT1JJVFkgPSAxMDtcblxuY2xhc3MgU2V0dGVyIHtcbiAgc3ViUHJpb3JpdHkgPSAwO1xuXG4gIHZhbGlkYXRlKF91dGNEYXRlLCBfb3B0aW9ucykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5leHBvcnRzLlNldHRlciA9IFNldHRlcjtcblxuY2xhc3MgVmFsdWVTZXR0ZXIgZXh0ZW5kcyBTZXR0ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2YWx1ZSxcblxuICAgIHZhbGlkYXRlVmFsdWUsXG5cbiAgICBzZXRWYWx1ZSxcblxuICAgIHByaW9yaXR5LFxuICAgIHN1YlByaW9yaXR5LFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnZhbGlkYXRlVmFsdWUgPSB2YWxpZGF0ZVZhbHVlO1xuICAgIHRoaXMuc2V0VmFsdWUgPSBzZXRWYWx1ZTtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgaWYgKHN1YlByaW9yaXR5KSB7XG4gICAgICB0aGlzLnN1YlByaW9yaXR5ID0gc3ViUHJpb3JpdHk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVmFsdWUoZGF0ZSwgdGhpcy52YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzZXQoZGF0ZSwgZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWYWx1ZShkYXRlLCBmbGFncywgdGhpcy52YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydHMuVmFsdWVTZXR0ZXIgPSBWYWx1ZVNldHRlcjtcblxuY2xhc3MgRGF0ZVRvU3lzdGVtVGltZXpvbmVTZXR0ZXIgZXh0ZW5kcyBTZXR0ZXIge1xuICBwcmlvcml0eSA9IFRJTUVaT05FX1VOSVRfUFJJT1JJVFk7XG4gIHN1YlByaW9yaXR5ID0gLTE7XG4gIHNldChkYXRlLCBmbGFncykge1xuICAgIGlmIChmbGFncy50aW1lc3RhbXBJc1NldCkgcmV0dXJuIGRhdGU7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLmNvbnN0cnVjdEZyb20pKGRhdGUsICgwLCBfaW5kZXgudHJhbnNwb3NlKShkYXRlLCBEYXRlKSk7XG4gIH1cbn1cbmV4cG9ydHMuRGF0ZVRvU3lzdGVtVGltZXpvbmVTZXR0ZXIgPSBEYXRlVG9TeXN0ZW1UaW1lem9uZVNldHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy50aW1lem9uZVBhdHRlcm5zID0gZXhwb3J0cy5udW1lcmljUGF0dGVybnMgPSB2b2lkIDA7XG5jb25zdCBudW1lcmljUGF0dGVybnMgPSAoZXhwb3J0cy5udW1lcmljUGF0dGVybnMgPSB7XG4gIG1vbnRoOiAvXigxWzAtMl18MD9cXGQpLywgLy8gMCB0byAxMlxuICBkYXRlOiAvXigzWzAtMV18WzAtMl0/XFxkKS8sIC8vIDAgdG8gMzFcbiAgZGF5T2ZZZWFyOiAvXigzNlswLTZdfDNbMC01XVxcZHxbMC0yXT9cXGQ/XFxkKS8sIC8vIDAgdG8gMzY2XG4gIHdlZWs6IC9eKDVbMC0zXXxbMC00XT9cXGQpLywgLy8gMCB0byA1M1xuICBob3VyMjNoOiAvXigyWzAtM118WzAtMV0/XFxkKS8sIC8vIDAgdG8gMjNcbiAgaG91cjI0aDogL14oMlswLTRdfFswLTFdP1xcZCkvLCAvLyAwIHRvIDI0XG4gIGhvdXIxMWg6IC9eKDFbMC0xXXwwP1xcZCkvLCAvLyAwIHRvIDExXG4gIGhvdXIxMmg6IC9eKDFbMC0yXXwwP1xcZCkvLCAvLyAwIHRvIDEyXG4gIG1pbnV0ZTogL15bMC01XT9cXGQvLCAvLyAwIHRvIDU5XG4gIHNlY29uZDogL15bMC01XT9cXGQvLCAvLyAwIHRvIDU5XG5cbiAgc2luZ2xlRGlnaXQ6IC9eXFxkLywgLy8gMCB0byA5XG4gIHR3b0RpZ2l0czogL15cXGR7MSwyfS8sIC8vIDAgdG8gOTlcbiAgdGhyZWVEaWdpdHM6IC9eXFxkezEsM30vLCAvLyAwIHRvIDk5OVxuICBmb3VyRGlnaXRzOiAvXlxcZHsxLDR9LywgLy8gMCB0byA5OTk5XG5cbiAgYW55RGlnaXRzU2lnbmVkOiAvXi0/XFxkKy8sXG4gIHNpbmdsZURpZ2l0U2lnbmVkOiAvXi0/XFxkLywgLy8gMCB0byA5LCAtMCB0byAtOVxuICB0d29EaWdpdHNTaWduZWQ6IC9eLT9cXGR7MSwyfS8sIC8vIDAgdG8gOTksIC0wIHRvIC05OVxuICB0aHJlZURpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDN9LywgLy8gMCB0byA5OTksIC0wIHRvIC05OTlcbiAgZm91ckRpZ2l0c1NpZ25lZDogL14tP1xcZHsxLDR9LywgLy8gMCB0byA5OTk5LCAtMCB0byAtOTk5OVxufSk7XG5cbmNvbnN0IHRpbWV6b25lUGF0dGVybnMgPSAoZXhwb3J0cy50aW1lem9uZVBhdHRlcm5zID0ge1xuICBiYXNpY09wdGlvbmFsTWludXRlczogL14oWystXSkoXFxkezJ9KShcXGR7Mn0pP3xaLyxcbiAgYmFzaWM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KXxaLyxcbiAgYmFzaWNPcHRpb25hbFNlY29uZHM6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KSgoXFxkezJ9KSk/fFovLFxuICBleHRlbmRlZDogL14oWystXSkoXFxkezJ9KTooXFxkezJ9KXxaLyxcbiAgZXh0ZW5kZWRPcHRpb25hbFNlY29uZHM6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKT98Wi8sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wYXJzZXJzID0gdm9pZCAwO1xudmFyIF9FcmFQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0VyYVBhcnNlci5qc1wiKTtcbnZhciBfWWVhclBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvWWVhclBhcnNlci5qc1wiKTtcbnZhciBfTG9jYWxXZWVrWWVhclBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvTG9jYWxXZWVrWWVhclBhcnNlci5qc1wiKTtcbnZhciBfSVNPV2Vla1llYXJQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0lTT1dlZWtZZWFyUGFyc2VyLmpzXCIpO1xudmFyIF9FeHRlbmRlZFllYXJQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0V4dGVuZGVkWWVhclBhcnNlci5qc1wiKTtcbnZhciBfUXVhcnRlclBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvUXVhcnRlclBhcnNlci5qc1wiKTtcbnZhciBfU3RhbmRBbG9uZVF1YXJ0ZXJQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL1N0YW5kQWxvbmVRdWFydGVyUGFyc2VyLmpzXCIpO1xudmFyIF9Nb250aFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvTW9udGhQYXJzZXIuanNcIik7XG52YXIgX1N0YW5kQWxvbmVNb250aFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvU3RhbmRBbG9uZU1vbnRoUGFyc2VyLmpzXCIpO1xudmFyIF9Mb2NhbFdlZWtQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0xvY2FsV2Vla1BhcnNlci5qc1wiKTtcbnZhciBfSVNPV2Vla1BhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvSVNPV2Vla1BhcnNlci5qc1wiKTtcbnZhciBfRGF0ZVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvRGF0ZVBhcnNlci5qc1wiKTtcbnZhciBfRGF5T2ZZZWFyUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9EYXlPZlllYXJQYXJzZXIuanNcIik7XG52YXIgX0RheVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvRGF5UGFyc2VyLmpzXCIpO1xudmFyIF9Mb2NhbERheVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvTG9jYWxEYXlQYXJzZXIuanNcIik7XG52YXIgX1N0YW5kQWxvbmVMb2NhbERheVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyLmpzXCIpO1xudmFyIF9JU09EYXlQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0lTT0RheVBhcnNlci5qc1wiKTtcbnZhciBfQU1QTVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvQU1QTVBhcnNlci5qc1wiKTtcbnZhciBfQU1QTU1pZG5pZ2h0UGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9BTVBNTWlkbmlnaHRQYXJzZXIuanNcIik7XG52YXIgX0RheVBlcmlvZFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvRGF5UGVyaW9kUGFyc2VyLmpzXCIpO1xudmFyIF9Ib3VyMXRvMTJQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0hvdXIxdG8xMlBhcnNlci5qc1wiKTtcbnZhciBfSG91cjB0bzIzUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9Ib3VyMHRvMjNQYXJzZXIuanNcIik7XG52YXIgX0hvdXIwVG8xMVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvSG91cjBUbzExUGFyc2VyLmpzXCIpO1xudmFyIF9Ib3VyMVRvMjRQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL0hvdXIxVG8yNFBhcnNlci5qc1wiKTtcbnZhciBfTWludXRlUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9NaW51dGVQYXJzZXIuanNcIik7XG52YXIgX1NlY29uZFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvU2Vjb25kUGFyc2VyLmpzXCIpO1xudmFyIF9GcmFjdGlvbk9mU2Vjb25kUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9GcmFjdGlvbk9mU2Vjb25kUGFyc2VyLmpzXCIpO1xudmFyIF9JU09UaW1lem9uZVdpdGhaUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2Vycy9JU09UaW1lem9uZVdpdGhaUGFyc2VyLmpzXCIpO1xudmFyIF9JU09UaW1lem9uZVBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvSVNPVGltZXpvbmVQYXJzZXIuanNcIik7XG52YXIgX1RpbWVzdGFtcFNlY29uZHNQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXJzL1RpbWVzdGFtcFNlY29uZHNQYXJzZXIuanNcIik7XG52YXIgX1RpbWVzdGFtcE1pbGxpc2Vjb25kc1BhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvVGltZXN0YW1wTWlsbGlzZWNvbmRzUGFyc2VyLmpzXCIpO1xuXG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCBNaWxsaXNlY29uZHMgaW4gZGF5ICAgICAgICAgICAgfFxuICogfCAgYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgfCAgQiAgfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgfFxuICogfCAgYyAgfCBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlayAgfCAgQyogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZSAgfCBMb2NhbCBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgfCAgRSAgfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgRiogfCBEYXkgb2Ygd2VlayBpbiBtb250aCAgICAgICAgICAgfFxuICogfCAgZyogfCBNb2RpZmllZCBKdWxpYW4gZGF5ICAgICAgICAgICAgfCAgRyAgfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaSEgfCBJU08gZGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgfCAgSSEgfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgfFxuICogfCAgaiogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfCAgSiogfCBMb2NhbGl6ZWQgaG91ciB3L28gZGF5IHBlcmlvZCAgfFxuICogfCAgayAgfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgfCAgSyAgfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbCogfCAoZGVwcmVjYXRlZCkgICAgICAgICAgICAgICAgICAgfCAgTCAgfCBTdGFuZC1hbG9uZSBtb250aCAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbyEgfCBPcmRpbmFsIG51bWJlciBtb2RpZmllciAgICAgICAgfCAgTyogfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgfFxuICogfCAgcCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgcSAgfCBTdGFuZC1hbG9uZSBxdWFydGVyICAgICAgICAgICAgfCAgUSAgfCBRdWFydGVyICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgciogfCBSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyICAgICAgICAgfCAgUiEgfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgdCEgfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgfCAgVCEgfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgfFxuICogfCAgdSAgfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgfCAgVSogfCBDeWNsaWMgeWVhciAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgdiogfCBUaW1lem9uZSAoZ2VuZXJpYyBub24tbG9jYXQuKSAgfCAgViogfCBUaW1lem9uZSAobG9jYXRpb24pICAgICAgICAgICAgfFxuICogfCAgdyAgfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgfCAgVyogfCBXZWVrIG9mIG1vbnRoICAgICAgICAgICAgICAgICAgfFxuICogfCAgeCAgfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgfCAgWCAgfCBUaW1lem9uZSAoSVNPLTg2MDEpICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgfFxuICogfCAgeiogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgfCAgWiogfCBUaW1lem9uZSAoYWxpYXNlcykgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAhIGFyZSBub24tc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBkYXRlLWZuczpcbiAqIC0gYG9gIG1vZGlmaWVzIHRoZSBwcmV2aW91cyB0b2tlbiB0byB0dXJuIGl0IGludG8gYW4gb3JkaW5hbCAoc2VlIGBwYXJzZWAgZG9jcylcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcbiAqICAgaS5lLiA3IGZvciBTdW5kYXksIDEgZm9yIE1vbmRheSwgZXRjLlxuICogLSBgSWAgaXMgSVNPIHdlZWsgb2YgeWVhciwgYXMgb3Bwb3NlZCB0byBgd2Agd2hpY2ggaXMgbG9jYWwgd2VlayBvZiB5ZWFyLlxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXG4gKiAgIGBSYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYElgIGFuZCBgaWBcbiAqICAgZm9yIHVuaXZlcnNhbCBJU08gd2Vlay1udW1iZXJpbmcgZGF0ZSwgd2hlcmVhc1xuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXG4gKiAgIGZvciB3ZWVrLW51bWJlcmluZyBkYXRlIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEl0J3Mgb2ssIHdlIHdhbnQgYW55IGhlcmVcbmNvbnN0IHBhcnNlcnMgPSAoZXhwb3J0cy5wYXJzZXJzID0ge1xuICBHOiBuZXcgX0VyYVBhcnNlci5FcmFQYXJzZXIoKSxcbiAgeTogbmV3IF9ZZWFyUGFyc2VyLlllYXJQYXJzZXIoKSxcbiAgWTogbmV3IF9Mb2NhbFdlZWtZZWFyUGFyc2VyLkxvY2FsV2Vla1llYXJQYXJzZXIoKSxcbiAgUjogbmV3IF9JU09XZWVrWWVhclBhcnNlci5JU09XZWVrWWVhclBhcnNlcigpLFxuICB1OiBuZXcgX0V4dGVuZGVkWWVhclBhcnNlci5FeHRlbmRlZFllYXJQYXJzZXIoKSxcbiAgUTogbmV3IF9RdWFydGVyUGFyc2VyLlF1YXJ0ZXJQYXJzZXIoKSxcbiAgcTogbmV3IF9TdGFuZEFsb25lUXVhcnRlclBhcnNlci5TdGFuZEFsb25lUXVhcnRlclBhcnNlcigpLFxuICBNOiBuZXcgX01vbnRoUGFyc2VyLk1vbnRoUGFyc2VyKCksXG4gIEw6IG5ldyBfU3RhbmRBbG9uZU1vbnRoUGFyc2VyLlN0YW5kQWxvbmVNb250aFBhcnNlcigpLFxuICB3OiBuZXcgX0xvY2FsV2Vla1BhcnNlci5Mb2NhbFdlZWtQYXJzZXIoKSxcbiAgSTogbmV3IF9JU09XZWVrUGFyc2VyLklTT1dlZWtQYXJzZXIoKSxcbiAgZDogbmV3IF9EYXRlUGFyc2VyLkRhdGVQYXJzZXIoKSxcbiAgRDogbmV3IF9EYXlPZlllYXJQYXJzZXIuRGF5T2ZZZWFyUGFyc2VyKCksXG4gIEU6IG5ldyBfRGF5UGFyc2VyLkRheVBhcnNlcigpLFxuICBlOiBuZXcgX0xvY2FsRGF5UGFyc2VyLkxvY2FsRGF5UGFyc2VyKCksXG4gIGM6IG5ldyBfU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyLlN0YW5kQWxvbmVMb2NhbERheVBhcnNlcigpLFxuICBpOiBuZXcgX0lTT0RheVBhcnNlci5JU09EYXlQYXJzZXIoKSxcbiAgYTogbmV3IF9BTVBNUGFyc2VyLkFNUE1QYXJzZXIoKSxcbiAgYjogbmV3IF9BTVBNTWlkbmlnaHRQYXJzZXIuQU1QTU1pZG5pZ2h0UGFyc2VyKCksXG4gIEI6IG5ldyBfRGF5UGVyaW9kUGFyc2VyLkRheVBlcmlvZFBhcnNlcigpLFxuICBoOiBuZXcgX0hvdXIxdG8xMlBhcnNlci5Ib3VyMXRvMTJQYXJzZXIoKSxcbiAgSDogbmV3IF9Ib3VyMHRvMjNQYXJzZXIuSG91cjB0bzIzUGFyc2VyKCksXG4gIEs6IG5ldyBfSG91cjBUbzExUGFyc2VyLkhvdXIwVG8xMVBhcnNlcigpLFxuICBrOiBuZXcgX0hvdXIxVG8yNFBhcnNlci5Ib3VyMVRvMjRQYXJzZXIoKSxcbiAgbTogbmV3IF9NaW51dGVQYXJzZXIuTWludXRlUGFyc2VyKCksXG4gIHM6IG5ldyBfU2Vjb25kUGFyc2VyLlNlY29uZFBhcnNlcigpLFxuICBTOiBuZXcgX0ZyYWN0aW9uT2ZTZWNvbmRQYXJzZXIuRnJhY3Rpb25PZlNlY29uZFBhcnNlcigpLFxuICBYOiBuZXcgX0lTT1RpbWV6b25lV2l0aFpQYXJzZXIuSVNPVGltZXpvbmVXaXRoWlBhcnNlcigpLFxuICB4OiBuZXcgX0lTT1RpbWV6b25lUGFyc2VyLklTT1RpbWV6b25lUGFyc2VyKCksXG4gIHQ6IG5ldyBfVGltZXN0YW1wU2Vjb25kc1BhcnNlci5UaW1lc3RhbXBTZWNvbmRzUGFyc2VyKCksXG4gIFQ6IG5ldyBfVGltZXN0YW1wTWlsbGlzZWNvbmRzUGFyc2VyLlRpbWVzdGFtcE1pbGxpc2Vjb25kc1BhcnNlcigpLFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuQU1QTU1pZG5pZ2h0UGFyc2VyID0gdm9pZCAwO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBBTVBNTWlkbmlnaHRQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gODA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcImJcIjpcbiAgICAgIGNhc2UgXCJiYlwiOlxuICAgICAgY2FzZSBcImJiYlwiOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICBjYXNlIFwiYmJiYmJcIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImJiYmJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldEhvdXJzKCgwLCBfdXRpbHMuZGF5UGVyaW9kRW51bVRvSG91cnMpKHZhbHVlKSwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXCJhXCIsIFwiQlwiLCBcIkhcIiwgXCJrXCIsIFwidFwiLCBcIlRcIl07XG59XG5leHBvcnRzLkFNUE1NaWRuaWdodFBhcnNlciA9IEFNUE1NaWRuaWdodFBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5BTVBNUGFyc2VyID0gdm9pZCAwO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBBTVBNUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDgwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgIGNhc2UgXCJhYWFcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcImFhYWFhXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJhYWFhXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygoMCwgX3V0aWxzLmRheVBlcmlvZEVudW1Ub0hvdXJzKSh2YWx1ZSksIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiYlwiLCBcIkJcIiwgXCJIXCIsIFwia1wiLCBcInRcIiwgXCJUXCJdO1xufVxuZXhwb3J0cy5BTVBNUGFyc2VyID0gQU1QTVBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5EYXRlUGFyc2VyID0gdm9pZCAwO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jb25zdCBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgREFZU19JTl9NT05USF9MRUFQX1lFQVIgPSBbXG4gIDMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzEsXG5dO1xuXG4vLyBEYXkgb2YgdGhlIG1vbnRoXG5jbGFzcyBEYXRlUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuICBzdWJQcmlvcml0eSA9IDE7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VOdW1lcmljUGF0dGVybikoXG4gICAgICAgICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMuZGF0ZSxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcImRvXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHsgdW5pdDogXCJkYXRlXCIgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoZGF0ZSwgdmFsdWUpIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IGlzTGVhcFllYXIgPSAoMCwgX3V0aWxzLmlzTGVhcFllYXJJbmRleCkoeWVhcik7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgaWYgKGlzTGVhcFllYXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gREFZU19JTl9NT05USFttb250aF07XG4gICAgfVxuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldERhdGUodmFsdWUpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJZXCIsXG4gICAgXCJSXCIsXG4gICAgXCJxXCIsXG4gICAgXCJRXCIsXG4gICAgXCJ3XCIsXG4gICAgXCJJXCIsXG4gICAgXCJEXCIsXG4gICAgXCJpXCIsXG4gICAgXCJlXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLkRhdGVQYXJzZXIgPSBEYXRlUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkRheU9mWWVhclBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgRGF5T2ZZZWFyUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuXG4gIHN1YnByaW9yaXR5ID0gMTtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiRFwiOlxuICAgICAgY2FzZSBcIkREXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTnVtZXJpY1BhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLmRheU9mWWVhcixcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcIkRvXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHsgdW5pdDogXCJkYXRlXCIgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoZGF0ZSwgdmFsdWUpIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IGlzTGVhcFllYXIgPSAoMCwgX3V0aWxzLmlzTGVhcFllYXJJbmRleCkoeWVhcik7XG4gICAgaWYgKGlzTGVhcFllYXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMzY1O1xuICAgIH1cbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgZGF0ZS5zZXRNb250aCgwLCB2YWx1ZSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcbiAgICBcIllcIixcbiAgICBcIlJcIixcbiAgICBcInFcIixcbiAgICBcIlFcIixcbiAgICBcIk1cIixcbiAgICBcIkxcIixcbiAgICBcIndcIixcbiAgICBcIklcIixcbiAgICBcImRcIixcbiAgICBcIkVcIixcbiAgICBcImlcIixcbiAgICBcImVcIixcbiAgICBcImNcIixcbiAgICBcInRcIixcbiAgICBcIlRcIixcbiAgXTtcbn1cbmV4cG9ydHMuRGF5T2ZZZWFyUGFyc2VyID0gRGF5T2ZZZWFyUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkRheVBhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2V0RGF5LmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG4vLyBEYXkgb2Ygd2Vla1xuY2xhc3MgRGF5UGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJFRVwiOlxuICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJzaG9ydFwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJFRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJzaG9ydFwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBUdWVzZGF5XG4gICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJ3aWRlXCIsIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcInNob3J0XCIsIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHsgd2lkdGg6IFwibmFycm93XCIsIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoX2RhdGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgZGF0ZSA9ICgwLCBfaW5kZXguc2V0RGF5KShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcIkRcIiwgXCJpXCIsIFwiZVwiLCBcImNcIiwgXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuRGF5UGFyc2VyID0gRGF5UGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkRheVBlcmlvZFBhcnNlciA9IHZvaWQgMDtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuY2xhc3MgRGF5UGVyaW9kUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDgwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJCXCI6XG4gICAgICBjYXNlIFwiQkJcIjpcbiAgICAgIGNhc2UgXCJCQkJcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcIkJCQkJCXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJCQkJCXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXlQZXJpb2QoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygoMCwgX3V0aWxzLmRheVBlcmlvZEVudW1Ub0hvdXJzKSh2YWx1ZSksIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiYVwiLCBcImJcIiwgXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuRGF5UGVyaW9kUGFyc2VyID0gRGF5UGVyaW9kUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkVyYVBhcnNlciA9IHZvaWQgMDtcblxudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG5jbGFzcyBFcmFQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gMTQwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIEFELCBCQ1xuICAgICAgY2FzZSBcIkdcIjpcbiAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgY2FzZSBcIkdHR1wiOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmVyYShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcImFiYnJldmlhdGVkXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5lcmEoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJuYXJyb3dcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBBLCBCXG4gICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiIH0pO1xuICAgICAgLy8gQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3RcbiAgICAgIGNhc2UgXCJHR0dHXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmVyYShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIndpZGVcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmVyYShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcImFiYnJldmlhdGVkXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5lcmEoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJuYXJyb3dcIiB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldChkYXRlLCBmbGFncywgdmFsdWUpIHtcbiAgICBmbGFncy5lcmEgPSB2YWx1ZTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiUlwiLCBcInVcIiwgXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuRXJhUGFyc2VyID0gRXJhUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkV4dGVuZGVkWWVhclBhcnNlciA9IHZvaWQgMDtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgRXh0ZW5kZWRZZWFyUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDEzMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gXCJ1XCIpIHtcbiAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0c1NpZ25lZCkoNCwgZGF0ZVN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VORGlnaXRzU2lnbmVkKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiR1wiLCBcInlcIiwgXCJZXCIsIFwiUlwiLCBcIndcIiwgXCJJXCIsIFwiaVwiLCBcImVcIiwgXCJjXCIsIFwidFwiLCBcIlRcIl07XG59XG5leHBvcnRzLkV4dGVuZGVkWWVhclBhcnNlciA9IEV4dGVuZGVkWWVhclBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5GcmFjdGlvbk9mU2Vjb25kUGFyc2VyID0gdm9pZCAwO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBGcmFjdGlvbk9mU2Vjb25kUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDMwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuKSB7XG4gICAgY29uc3QgdmFsdWVDYWxsYmFjayA9ICh2YWx1ZSkgPT5cbiAgICAgIE1hdGgudHJ1bmModmFsdWUgKiBNYXRoLnBvdygxMCwgLXRva2VuLmxlbmd0aCArIDMpKTtcbiAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0cykodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKSxcbiAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgKTtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHModmFsdWUpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1widFwiLCBcIlRcIl07XG59XG5leHBvcnRzLkZyYWN0aW9uT2ZTZWNvbmRQYXJzZXIgPSBGcmFjdGlvbk9mU2Vjb25kUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkhvdXIwVG8xMVBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgSG91cjBUbzExUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDcwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJLXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTnVtZXJpY1BhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLmhvdXIxMWgsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJLb1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBjb25zdCBpc1BNID0gZGF0ZS5nZXRIb3VycygpID49IDEyO1xuICAgIGlmIChpc1BNICYmIHZhbHVlIDwgMTIpIHtcbiAgICAgIGRhdGUuc2V0SG91cnModmFsdWUgKyAxMiwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGUuc2V0SG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcImhcIiwgXCJIXCIsIFwia1wiLCBcInRcIiwgXCJUXCJdO1xufVxuZXhwb3J0cy5Ib3VyMFRvMTFQYXJzZXIgPSBIb3VyMFRvMTFQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuSG91cjB0bzIzUGFyc2VyID0gdm9pZCAwO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBIb3VyMHRvMjNQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gNzA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VOdW1lcmljUGF0dGVybikoXG4gICAgICAgICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMuaG91cjIzaCxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcIkhvXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoX2RhdGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMjM7XG4gIH1cblxuICBzZXQoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSkge1xuICAgIGRhdGUuc2V0SG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiYVwiLCBcImJcIiwgXCJoXCIsIFwiS1wiLCBcImtcIiwgXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuSG91cjB0bzIzUGFyc2VyID0gSG91cjB0bzIzUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkhvdXIxVG8yNFBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgSG91cjFUbzI0UGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDcwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTnVtZXJpY1BhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLmhvdXIyNGgsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJrb1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDI0O1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBjb25zdCBob3VycyA9IHZhbHVlIDw9IDI0ID8gdmFsdWUgJSAyNCA6IHZhbHVlO1xuICAgIGRhdGUuc2V0SG91cnMoaG91cnMsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1wiYVwiLCBcImJcIiwgXCJoXCIsIFwiSFwiLCBcIktcIiwgXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuSG91cjFUbzI0UGFyc2VyID0gSG91cjFUbzI0UGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkhvdXIxdG8xMlBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgSG91cjF0bzEyUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDcwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTnVtZXJpY1BhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLmhvdXIxMmgsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJob1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDEyO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBjb25zdCBpc1BNID0gZGF0ZS5nZXRIb3VycygpID49IDEyO1xuICAgIGlmIChpc1BNICYmIHZhbHVlIDwgMTIpIHtcbiAgICAgIGRhdGUuc2V0SG91cnModmFsdWUgKyAxMiwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIGlmICghaXNQTSAmJiB2YWx1ZSA9PT0gMTIpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGUuc2V0SG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcIkhcIiwgXCJLXCIsIFwia1wiLCBcInRcIiwgXCJUXCJdO1xufVxuZXhwb3J0cy5Ib3VyMXRvMTJQYXJzZXIgPSBIb3VyMXRvMTJQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuSVNPRGF5UGFyc2VyID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zZXRJU09EYXkuanNcIik7XG52YXIgX1BhcnNlciA9IHJlcXVpcmUoXCIuLi9QYXJzZXIuanNcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbi8vIElTTyBkYXkgb2Ygd2Vla1xuY2xhc3MgSVNPRGF5UGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCkge1xuICAgIGNvbnN0IHZhbHVlQ2FsbGJhY2sgPSAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gNztcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMlxuICAgICAgY2FzZSBcImlcIjpcbiAgICAgIGNhc2UgXCJpaVwiOiAvLyAwMlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgICAvLyAybmRcbiAgICAgIGNhc2UgXCJpb1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICAvLyBUdWVcbiAgICAgIGNhc2UgXCJpaWlcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgICAgfSkgfHxcbiAgICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiaWlpaWlcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImlpaWlpaVwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgdmFsdWVDYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJpaWlpXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB2YWx1ZUNhbGxiYWNrLFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDc7XG4gIH1cblxuICBzZXQoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSkge1xuICAgIGRhdGUgPSAoMCwgX2luZGV4LnNldElTT0RheSkoZGF0ZSwgdmFsdWUpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJ5XCIsXG4gICAgXCJZXCIsXG4gICAgXCJ1XCIsXG4gICAgXCJxXCIsXG4gICAgXCJRXCIsXG4gICAgXCJNXCIsXG4gICAgXCJMXCIsXG4gICAgXCJ3XCIsXG4gICAgXCJkXCIsXG4gICAgXCJEXCIsXG4gICAgXCJFXCIsXG4gICAgXCJlXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLklTT0RheVBhcnNlciA9IElTT0RheVBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5JU09UaW1lem9uZVBhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uLy4uL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy5qc1wiKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuLy8gVGltZXpvbmUgKElTTy04NjAxKVxuY2xhc3MgSVNPVGltZXpvbmVQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gMTA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwieFwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZVRpbWV6b25lUGF0dGVybikoXG4gICAgICAgICAgX2NvbnN0YW50cy50aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxNaW51dGVzLFxuICAgICAgICAgIGRhdGVTdHJpbmcsXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwieHhcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VUaW1lem9uZVBhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMudGltZXpvbmVQYXR0ZXJucy5iYXNpYyxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcInh4eHhcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VUaW1lem9uZVBhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMudGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcyxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcInh4eHh4XCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlVGltZXpvbmVQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLnRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWRPcHRpb25hbFNlY29uZHMsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJ4eHhcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlVGltZXpvbmVQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLnRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWQsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzZXQoZGF0ZSwgZmxhZ3MsIHZhbHVlKSB7XG4gICAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSByZXR1cm4gZGF0ZTtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShcbiAgICAgIGRhdGUsXG4gICAgICBkYXRlLmdldFRpbWUoKSAtXG4gICAgICAgICgwLCBfaW5kZXgyLmdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMpKGRhdGUpIC1cbiAgICAgICAgdmFsdWUsXG4gICAgKTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcInRcIiwgXCJUXCIsIFwiWFwiXTtcbn1cbmV4cG9ydHMuSVNPVGltZXpvbmVQYXJzZXIgPSBJU09UaW1lem9uZVBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5JU09UaW1lem9uZVdpdGhaUGFyc2VyID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vLi4vLi4vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzLmpzXCIpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG4vLyBUaW1lem9uZSAoSVNPLTg2MDEuICswMDowMCBpcyBgJ1onYClcbmNsYXNzIElTT1RpbWV6b25lV2l0aFpQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gMTA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiWFwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZVRpbWV6b25lUGF0dGVybikoXG4gICAgICAgICAgX2NvbnN0YW50cy50aW1lem9uZVBhdHRlcm5zLmJhc2ljT3B0aW9uYWxNaW51dGVzLFxuICAgICAgICAgIGRhdGVTdHJpbmcsXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiWFhcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VUaW1lem9uZVBhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMudGltZXpvbmVQYXR0ZXJucy5iYXNpYyxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcIlhYWFhcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VUaW1lem9uZVBhdHRlcm4pKFxuICAgICAgICAgIF9jb25zdGFudHMudGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcyxcbiAgICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcIlhYWFhYXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlVGltZXpvbmVQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLnRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWRPcHRpb25hbFNlY29uZHMsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJYWFhcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlVGltZXpvbmVQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLnRpbWV6b25lUGF0dGVybnMuZXh0ZW5kZWQsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzZXQoZGF0ZSwgZmxhZ3MsIHZhbHVlKSB7XG4gICAgaWYgKGZsYWdzLnRpbWVzdGFtcElzU2V0KSByZXR1cm4gZGF0ZTtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShcbiAgICAgIGRhdGUsXG4gICAgICBkYXRlLmdldFRpbWUoKSAtXG4gICAgICAgICgwLCBfaW5kZXgyLmdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMpKGRhdGUpIC1cbiAgICAgICAgdmFsdWUsXG4gICAgKTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcInRcIiwgXCJUXCIsIFwieFwiXTtcbn1cbmV4cG9ydHMuSVNPVGltZXpvbmVXaXRoWlBhcnNlciA9IElTT1RpbWV6b25lV2l0aFpQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuSVNPV2Vla1BhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2V0SVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0YXJ0T2ZJU09XZWVrLmpzXCIpO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG4vLyBJU08gd2VlayBvZiB5ZWFyXG5jbGFzcyBJU09XZWVrUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDEwMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiSVwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU51bWVyaWNQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLm51bWVyaWNQYXR0ZXJucy53ZWVrLFxuICAgICAgICAgIGRhdGVTdHJpbmcsXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiSW9cIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywgeyB1bml0OiBcIndlZWtcIiB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0cykodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShfZGF0ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1MztcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLnN0YXJ0T2ZJU09XZWVrKSgoMCwgX2luZGV4LnNldElTT1dlZWspKGRhdGUsIHZhbHVlKSk7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJ5XCIsXG4gICAgXCJZXCIsXG4gICAgXCJ1XCIsXG4gICAgXCJxXCIsXG4gICAgXCJRXCIsXG4gICAgXCJNXCIsXG4gICAgXCJMXCIsXG4gICAgXCJ3XCIsXG4gICAgXCJkXCIsXG4gICAgXCJEXCIsXG4gICAgXCJlXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLklTT1dlZWtQYXJzZXIgPSBJU09XZWVrUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLklTT1dlZWtZZWFyUGFyc2VyID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdGFydE9mSVNPV2Vlay5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbnN0cnVjdEZyb20uanNcIik7XG52YXIgX1BhcnNlciA9IHJlcXVpcmUoXCIuLi9QYXJzZXIuanNcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbi8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG5jbGFzcyBJU09XZWVrWWVhclBhcnNlciBleHRlbmRzIF9QYXJzZXIuUGFyc2VyIHtcbiAgcHJpb3JpdHkgPSAxMzA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4pIHtcbiAgICBpZiAodG9rZW4gPT09IFwiUlwiKSB7XG4gICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHNTaWduZWQpKDQsIGRhdGVTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0c1NpZ25lZCkodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKTtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgY29uc3QgZmlyc3RXZWVrT2ZZZWFyID0gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgMCk7XG4gICAgZmlyc3RXZWVrT2ZZZWFyLnNldEZ1bGxZZWFyKHZhbHVlLCAwLCA0KTtcbiAgICBmaXJzdFdlZWtPZlllYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguc3RhcnRPZklTT1dlZWspKGZpcnN0V2Vla09mWWVhcik7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJHXCIsXG4gICAgXCJ5XCIsXG4gICAgXCJZXCIsXG4gICAgXCJ1XCIsXG4gICAgXCJRXCIsXG4gICAgXCJxXCIsXG4gICAgXCJNXCIsXG4gICAgXCJMXCIsXG4gICAgXCJ3XCIsXG4gICAgXCJkXCIsXG4gICAgXCJEXCIsXG4gICAgXCJlXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLklTT1dlZWtZZWFyUGFyc2VyID0gSVNPV2Vla1llYXJQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTG9jYWxEYXlQYXJzZXIgPSB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uLy4uL3NldERheS5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuLy8gTG9jYWwgZGF5IG9mIHdlZWtcbmNsYXNzIExvY2FsRGF5UGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gKHZhbHVlKSA9PiB7XG4gICAgICAvLyBXZSB3YW50IGhlcmUgZmxvb3IgaW5zdGVhZCBvZiB0cnVuYywgc28gd2UgZ2V0IC03IGZvciB2YWx1ZSAwIGluc3RlYWQgb2YgMFxuICAgICAgY29uc3Qgd2hvbGVXZWVrRGF5cyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gMSkgLyA3KSAqIDc7XG4gICAgICByZXR1cm4gKCh2YWx1ZSArIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgNikgJSA3KSArIHdob2xlV2Vla0RheXM7XG4gICAgfTtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDNcbiAgICAgIGNhc2UgXCJlXCI6XG4gICAgICBjYXNlIFwiZWVcIjogLy8gMDNcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyAzcmRcbiAgICAgIGNhc2UgXCJlb1wiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB1bml0OiBcImRheVwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyBUdWVcbiAgICAgIGNhc2UgXCJlZWVcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHsgd2lkdGg6IFwic2hvcnRcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJuYXJyb3dcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSlcbiAgICAgICAgKTtcblxuICAgICAgLy8gVFxuICAgICAgY2FzZSBcImVlZWVlXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5kYXkoZGF0ZVN0cmluZywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1XG4gICAgICBjYXNlIFwiZWVlZWVlXCI6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHsgd2lkdGg6IFwic2hvcnRcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJuYXJyb3dcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSlcbiAgICAgICAgKTtcblxuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImVlZWVcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJzaG9ydFwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDY7XG4gIH1cblxuICBzZXQoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGRhdGUgPSAoMCwgX2luZGV4LnNldERheSkoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJ5XCIsXG4gICAgXCJSXCIsXG4gICAgXCJ1XCIsXG4gICAgXCJxXCIsXG4gICAgXCJRXCIsXG4gICAgXCJNXCIsXG4gICAgXCJMXCIsXG4gICAgXCJJXCIsXG4gICAgXCJkXCIsXG4gICAgXCJEXCIsXG4gICAgXCJFXCIsXG4gICAgXCJpXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLkxvY2FsRGF5UGFyc2VyID0gTG9jYWxEYXlQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTG9jYWxXZWVrUGFyc2VyID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zZXRXZWVrLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RhcnRPZldlZWsuanNcIik7XG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMuanNcIik7XG52YXIgX1BhcnNlciA9IHJlcXVpcmUoXCIuLi9QYXJzZXIuanNcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbi8vIExvY2FsIHdlZWsgb2YgeWVhclxuY2xhc3MgTG9jYWxXZWVrUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDEwMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwid1wiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU51bWVyaWNQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLm51bWVyaWNQYXR0ZXJucy53ZWVrLFxuICAgICAgICAgIGRhdGVTdHJpbmcsXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwid29cIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywgeyB1bml0OiBcIndlZWtcIiB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0cykodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShfZGF0ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1MztcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLnN0YXJ0T2ZXZWVrKShcbiAgICAgICgwLCBfaW5kZXguc2V0V2VlaykoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1xuICAgIFwieVwiLFxuICAgIFwiUlwiLFxuICAgIFwidVwiLFxuICAgIFwicVwiLFxuICAgIFwiUVwiLFxuICAgIFwiTVwiLFxuICAgIFwiTFwiLFxuICAgIFwiSVwiLFxuICAgIFwiZFwiLFxuICAgIFwiRFwiLFxuICAgIFwiaVwiLFxuICAgIFwidFwiLFxuICAgIFwiVFwiLFxuICBdO1xufVxuZXhwb3J0cy5Mb2NhbFdlZWtQYXJzZXIgPSBMb2NhbFdlZWtQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTG9jYWxXZWVrWWVhclBhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vZ2V0V2Vla1llYXIuanNcIik7XG5cbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0YXJ0T2ZXZWVrLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG4vLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG5jbGFzcyBMb2NhbFdlZWtZZWFyUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDEzMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gKHllYXIpID0+ICh7XG4gICAgICB5ZWFyLFxuICAgICAgaXNUd29EaWdpdFllYXI6IHRva2VuID09PSBcIllZXCIsXG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiWVwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKDQsIGRhdGVTdHJpbmcpLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiWW9cIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogXCJ5ZWFyXCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdmFsdWVDYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLm1hcFZhbHVlKShcbiAgICAgICAgICAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0cykodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKSxcbiAgICAgICAgICB2YWx1ZUNhbGxiYWNrLFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5pc1R3b0RpZ2l0WWVhciB8fCB2YWx1ZS55ZWFyID4gMDtcbiAgfVxuXG4gIHNldChkYXRlLCBmbGFncywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjdXJyZW50WWVhciA9ICgwLCBfaW5kZXguZ2V0V2Vla1llYXIpKGRhdGUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlLmlzVHdvRGlnaXRZZWFyKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkVHdvRGlnaXRZZWFyID0gKDAsIF91dGlscy5ub3JtYWxpemVUd29EaWdpdFllYXIpKFxuICAgICAgICB2YWx1ZS55ZWFyLFxuICAgICAgICBjdXJyZW50WWVhcixcbiAgICAgICk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKFxuICAgICAgICBub3JtYWxpemVkVHdvRGlnaXRZZWFyLFxuICAgICAgICAwLFxuICAgICAgICBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcbiAgICAgICk7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuICgwLCBfaW5kZXgyLnN0YXJ0T2ZXZWVrKShkYXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCB5ZWFyID1cbiAgICAgICEoXCJlcmFcIiBpbiBmbGFncykgfHwgZmxhZ3MuZXJhID09PSAxID8gdmFsdWUueWVhciA6IDEgLSB2YWx1ZS55ZWFyO1xuICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhciwgMCwgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLnN0YXJ0T2ZXZWVrKShkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcbiAgICBcInlcIixcbiAgICBcIlJcIixcbiAgICBcInVcIixcbiAgICBcIlFcIixcbiAgICBcInFcIixcbiAgICBcIk1cIixcbiAgICBcIkxcIixcbiAgICBcIklcIixcbiAgICBcImRcIixcbiAgICBcIkRcIixcbiAgICBcImlcIixcbiAgICBcInRcIixcbiAgICBcIlRcIixcbiAgXTtcbn1cbmV4cG9ydHMuTG9jYWxXZWVrWWVhclBhcnNlciA9IExvY2FsV2Vla1llYXJQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTWludXRlUGFyc2VyID0gdm9pZCAwO1xudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBNaW51dGVQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gNjA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VOdW1lcmljUGF0dGVybikoXG4gICAgICAgICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMubWludXRlLFxuICAgICAgICAgIGRhdGVTdHJpbmcsXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwibW9cIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywgeyB1bml0OiBcIm1pbnV0ZVwiIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSh0b2tlbi5sZW5ndGgsIGRhdGVTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDU5O1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldE1pbnV0ZXModmFsdWUsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1widFwiLCBcIlRcIl07XG59XG5leHBvcnRzLk1pbnV0ZVBhcnNlciA9IE1pbnV0ZVBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5Nb250aFBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgTW9udGhQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcbiAgICBcIllcIixcbiAgICBcIlJcIixcbiAgICBcInFcIixcbiAgICBcIlFcIixcbiAgICBcIkxcIixcbiAgICBcIndcIixcbiAgICBcIklcIixcbiAgICBcIkRcIixcbiAgICBcImlcIixcbiAgICBcImVcIixcbiAgICBcImNcIixcbiAgICBcInRcIixcbiAgICBcIlRcIixcbiAgXTtcblxuICBwcmlvcml0eSA9IDExMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gKHZhbHVlKSA9PiB2YWx1ZSAtIDE7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU51bWVyaWNQYXR0ZXJuKShcbiAgICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLm1vbnRoLFxuICAgICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgICApLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKDIsIGRhdGVTdHJpbmcpLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG4gICAgICBjYXNlIFwiTW9cIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogXCJtb250aFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcbiAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBKLCBGLCAuLi4sIERcbiAgICAgIGNhc2UgXCJNTU1NTVwiOlxuICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoZGF0ZVN0cmluZywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIndpZGVcIiwgY29udGV4dDogXCJmb3JtYXR0aW5nXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldE1vbnRoKHZhbHVlLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG59XG5leHBvcnRzLk1vbnRoUGFyc2VyID0gTW9udGhQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuUXVhcnRlclBhcnNlciA9IHZvaWQgMDtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgUXVhcnRlclBhcnNlciBleHRlbmRzIF9QYXJzZXIuUGFyc2VyIHtcbiAgcHJpb3JpdHkgPSAxMjA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSBcIlFcIjpcbiAgICAgIGNhc2UgXCJRUVwiOiAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAgIGNhc2UgXCJRb1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwicXVhcnRlclwiIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcbiAgICAgIGNhc2UgXCJRUVFcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5xdWFydGVyKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcbiAgICAgIGNhc2UgXCJRUVFRUVwiOlxuICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cbiAgICAgIGNhc2UgXCJRUVFRXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5xdWFydGVyKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDQ7XG4gIH1cblxuICBzZXQoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSkge1xuICAgIGRhdGUuc2V0TW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1xuICAgIFwiWVwiLFxuICAgIFwiUlwiLFxuICAgIFwicVwiLFxuICAgIFwiTVwiLFxuICAgIFwiTFwiLFxuICAgIFwid1wiLFxuICAgIFwiSVwiLFxuICAgIFwiZFwiLFxuICAgIFwiRFwiLFxuICAgIFwiaVwiLFxuICAgIFwiZVwiLFxuICAgIFwiY1wiLFxuICAgIFwidFwiLFxuICAgIFwiVFwiLFxuICBdO1xufVxuZXhwb3J0cy5RdWFydGVyUGFyc2VyID0gUXVhcnRlclBhcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5TZWNvbmRQYXJzZXIgPSB2b2lkIDA7XG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMuanNcIik7XG52YXIgX1BhcnNlciA9IHJlcXVpcmUoXCIuLi9QYXJzZXIuanNcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbmNsYXNzIFNlY29uZFBhcnNlciBleHRlbmRzIF9QYXJzZXIuUGFyc2VyIHtcbiAgcHJpb3JpdHkgPSA1MDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU51bWVyaWNQYXR0ZXJuKShcbiAgICAgICAgICBfY29uc3RhbnRzLm51bWVyaWNQYXR0ZXJucy5zZWNvbmQsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJzb1wiOlxuICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihkYXRlU3RyaW5nLCB7IHVuaXQ6IFwic2Vjb25kXCIgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoX2RhdGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNTk7XG4gIH1cblxuICBzZXQoZGF0ZSwgX2ZsYWdzLCB2YWx1ZSkge1xuICAgIGRhdGUuc2V0U2Vjb25kcyh2YWx1ZSwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXCJ0XCIsIFwiVFwiXTtcbn1cbmV4cG9ydHMuU2Vjb25kUGFyc2VyID0gU2Vjb25kUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLlN0YW5kQWxvbmVMb2NhbERheVBhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2V0RGF5LmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG4vLyBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2Vla1xuY2xhc3MgU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDkwO1xuXG4gIHBhcnNlKGRhdGVTdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlQ2FsbGJhY2sgPSAodmFsdWUpID0+IHtcbiAgICAgIC8vIFdlIHdhbnQgaGVyZSBmbG9vciBpbnN0ZWFkIG9mIHRydW5jLCBzbyB3ZSBnZXQgLTcgZm9yIHZhbHVlIDAgaW5zdGVhZCBvZiAwXG4gICAgICBjb25zdCB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcbiAgICAgIHJldHVybiAoKHZhbHVlICsgb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA2KSAlIDcpICsgd2hvbGVXZWVrRGF5cztcbiAgICB9O1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gM1xuICAgICAgY2FzZSBcImNcIjpcbiAgICAgIGNhc2UgXCJjY1wiOiAvLyAwM1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyksXG4gICAgICAgICAgdmFsdWVDYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIC8vIDNyZFxuICAgICAgY2FzZSBcImNvXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLm1hcFZhbHVlKShcbiAgICAgICAgICBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6IFwiZGF5XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdmFsdWVDYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJzaG9ydFwiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgcmV0dXJuIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJjY2NjY2NcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJzaG9ydFwiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBUdWVzZGF5XG4gICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5kYXkoZGF0ZVN0cmluZywgeyB3aWR0aDogXCJ3aWRlXCIsIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLmRheShkYXRlU3RyaW5nLCB7IHdpZHRoOiBcInNob3J0XCIsIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiIH0pIHx8XG4gICAgICAgICAgbWF0Y2guZGF5KGRhdGVTdHJpbmcsIHsgd2lkdGg6IFwibmFycm93XCIsIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoX2RhdGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNjtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgZGF0ZSA9ICgwLCBfaW5kZXguc2V0RGF5KShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcbiAgICBcInlcIixcbiAgICBcIlJcIixcbiAgICBcInVcIixcbiAgICBcInFcIixcbiAgICBcIlFcIixcbiAgICBcIk1cIixcbiAgICBcIkxcIixcbiAgICBcIklcIixcbiAgICBcImRcIixcbiAgICBcIkRcIixcbiAgICBcIkVcIixcbiAgICBcImlcIixcbiAgICBcImVcIixcbiAgICBcInRcIixcbiAgICBcIlRcIixcbiAgXTtcbn1cbmV4cG9ydHMuU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyID0gU3RhbmRBbG9uZUxvY2FsRGF5UGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLlN0YW5kQWxvbmVNb250aFBhcnNlciA9IHZvaWQgMDtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgU3RhbmRBbG9uZU1vbnRoUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDExMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gKHZhbHVlKSA9PiB2YWx1ZSAtIDE7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAuLi4sIDEyXG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU51bWVyaWNQYXR0ZXJuKShcbiAgICAgICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLm1vbnRoLFxuICAgICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgICApLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKDIsIGRhdGVTdHJpbmcpLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXG4gICAgICBjYXNlIFwiTG9cIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgIG1hdGNoLm9yZGluYWxOdW1iZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgdW5pdDogXCJtb250aFwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcbiAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyBKLCBGLCAuLi4sIERcbiAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoZGF0ZVN0cmluZywge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIndpZGVcIiwgY29udGV4dDogXCJzdGFuZGFsb25lXCIgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgICAgfSkgfHxcbiAgICAgICAgICBtYXRjaC5tb250aChkYXRlU3RyaW5nLCB7IHdpZHRoOiBcIm5hcnJvd1wiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKF9kYXRlLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICBkYXRlLnNldE1vbnRoKHZhbHVlLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgaW5jb21wYXRpYmxlVG9rZW5zID0gW1xuICAgIFwiWVwiLFxuICAgIFwiUlwiLFxuICAgIFwicVwiLFxuICAgIFwiUVwiLFxuICAgIFwiTVwiLFxuICAgIFwid1wiLFxuICAgIFwiSVwiLFxuICAgIFwiRFwiLFxuICAgIFwiaVwiLFxuICAgIFwiZVwiLFxuICAgIFwiY1wiLFxuICAgIFwidFwiLFxuICAgIFwiVFwiLFxuICBdO1xufVxuZXhwb3J0cy5TdGFuZEFsb25lTW9udGhQYXJzZXIgPSBTdGFuZEFsb25lTW9udGhQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuU3RhbmRBbG9uZVF1YXJ0ZXJQYXJzZXIgPSB2b2lkIDA7XG52YXIgX1BhcnNlciA9IHJlcXVpcmUoXCIuLi9QYXJzZXIuanNcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbmNsYXNzIFN0YW5kQWxvbmVRdWFydGVyUGFyc2VyIGV4dGVuZHMgX1BhcnNlci5QYXJzZXIge1xuICBwcmlvcml0eSA9IDEyMDtcblxuICBwYXJzZShkYXRlU3RyaW5nLCB0b2tlbiwgbWF0Y2gpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyAxLCAyLCAzLCA0XG4gICAgICBjYXNlIFwicVwiOlxuICAgICAgY2FzZSBcInFxXCI6IC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlTkRpZ2l0cykodG9rZW4ubGVuZ3RoLCBkYXRlU3RyaW5nKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuICAgICAgY2FzZSBcInFvXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHsgdW5pdDogXCJxdWFydGVyXCIgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuICAgICAgY2FzZSBcInFxcVwiOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2gucXVhcnRlcihkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxuICAgICAgY2FzZSBcInFxcXFxXCI6XG4gICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxuICAgICAgY2FzZSBcInFxcXFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWF0Y2gucXVhcnRlcihkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgICB9KSB8fFxuICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoZGF0ZVN0cmluZywge1xuICAgICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgbWF0Y2gucXVhcnRlcihkYXRlU3RyaW5nLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoX2RhdGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNDtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgZGF0ZS5zZXRNb250aCgodmFsdWUgLSAxKSAqIDMsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBbXG4gICAgXCJZXCIsXG4gICAgXCJSXCIsXG4gICAgXCJRXCIsXG4gICAgXCJNXCIsXG4gICAgXCJMXCIsXG4gICAgXCJ3XCIsXG4gICAgXCJJXCIsXG4gICAgXCJkXCIsXG4gICAgXCJEXCIsXG4gICAgXCJpXCIsXG4gICAgXCJlXCIsXG4gICAgXCJjXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJUXCIsXG4gIF07XG59XG5leHBvcnRzLlN0YW5kQWxvbmVRdWFydGVyUGFyc2VyID0gU3RhbmRBbG9uZVF1YXJ0ZXJQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuVGltZXN0YW1wTWlsbGlzZWNvbmRzUGFyc2VyID0gdm9pZCAwO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9QYXJzZXIgPSByZXF1aXJlKFwiLi4vUGFyc2VyLmpzXCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG5jbGFzcyBUaW1lc3RhbXBNaWxsaXNlY29uZHNQYXJzZXIgZXh0ZW5kcyBfUGFyc2VyLlBhcnNlciB7XG4gIHByaW9yaXR5ID0gMjA7XG5cbiAgcGFyc2UoZGF0ZVN0cmluZykge1xuICAgIHJldHVybiAoMCwgX3V0aWxzLnBhcnNlQW55RGlnaXRzU2lnbmVkKShkYXRlU3RyaW5nKTtcbiAgfVxuXG4gIHNldChkYXRlLCBfZmxhZ3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFsoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIHZhbHVlKSwgeyB0aW1lc3RhbXBJc1NldDogdHJ1ZSB9XTtcbiAgfVxuXG4gIGluY29tcGF0aWJsZVRva2VucyA9IFwiKlwiO1xufVxuZXhwb3J0cy5UaW1lc3RhbXBNaWxsaXNlY29uZHNQYXJzZXIgPSBUaW1lc3RhbXBNaWxsaXNlY29uZHNQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuVGltZXN0YW1wU2Vjb25kc1BhcnNlciA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vLi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuY2xhc3MgVGltZXN0YW1wU2Vjb25kc1BhcnNlciBleHRlbmRzIF9QYXJzZXIuUGFyc2VyIHtcbiAgcHJpb3JpdHkgPSA0MDtcblxuICBwYXJzZShkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbHMucGFyc2VBbnlEaWdpdHNTaWduZWQpKGRhdGVTdHJpbmcpO1xuICB9XG5cbiAgc2V0KGRhdGUsIF9mbGFncywgdmFsdWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCB2YWx1ZSAqIDEwMDApLFxuICAgICAgeyB0aW1lc3RhbXBJc1NldDogdHJ1ZSB9LFxuICAgIF07XG4gIH1cblxuICBpbmNvbXBhdGlibGVUb2tlbnMgPSBcIipcIjtcbn1cbmV4cG9ydHMuVGltZXN0YW1wU2Vjb25kc1BhcnNlciA9IFRpbWVzdGFtcFNlY29uZHNQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuWWVhclBhcnNlciA9IHZvaWQgMDtcbnZhciBfUGFyc2VyID0gcmVxdWlyZShcIi4uL1BhcnNlci5qc1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxuLy8gRnJvbSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTMxL3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxuLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxuLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxuLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxuY2xhc3MgWWVhclBhcnNlciBleHRlbmRzIF9QYXJzZXIuUGFyc2VyIHtcbiAgcHJpb3JpdHkgPSAxMzA7XG4gIGluY29tcGF0aWJsZVRva2VucyA9IFtcIllcIiwgXCJSXCIsIFwidVwiLCBcIndcIiwgXCJJXCIsIFwiaVwiLCBcImVcIiwgXCJjXCIsIFwidFwiLCBcIlRcIl07XG5cbiAgcGFyc2UoZGF0ZVN0cmluZywgdG9rZW4sIG1hdGNoKSB7XG4gICAgY29uc3QgdmFsdWVDYWxsYmFjayA9ICh5ZWFyKSA9PiAoe1xuICAgICAgeWVhcixcbiAgICAgIGlzVHdvRGlnaXRZZWFyOiB0b2tlbiA9PT0gXCJ5eVwiLFxuICAgIH0pO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubWFwVmFsdWUpKFxuICAgICAgICAgICgwLCBfdXRpbHMucGFyc2VORGlnaXRzKSg0LCBkYXRlU3RyaW5nKSxcbiAgICAgICAgICB2YWx1ZUNhbGxiYWNrLFxuICAgICAgICApO1xuICAgICAgY2FzZSBcInlvXCI6XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLm1hcFZhbHVlKShcbiAgICAgICAgICBtYXRjaC5vcmRpbmFsTnVtYmVyKGRhdGVTdHJpbmcsIHtcbiAgICAgICAgICAgIHVuaXQ6IFwieWVhclwiLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZhbHVlQ2FsbGJhY2ssXG4gICAgICAgICk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5tYXBWYWx1ZSkoXG4gICAgICAgICAgKDAsIF91dGlscy5wYXJzZU5EaWdpdHMpKHRva2VuLmxlbmd0aCwgZGF0ZVN0cmluZyksXG4gICAgICAgICAgdmFsdWVDYWxsYmFjayxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShfZGF0ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuaXNUd29EaWdpdFllYXIgfHwgdmFsdWUueWVhciA+IDA7XG4gIH1cblxuICBzZXQoZGF0ZSwgZmxhZ3MsIHZhbHVlKSB7XG4gICAgY29uc3QgY3VycmVudFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICBpZiAodmFsdWUuaXNUd29EaWdpdFllYXIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUd29EaWdpdFllYXIgPSAoMCwgX3V0aWxzLm5vcm1hbGl6ZVR3b0RpZ2l0WWVhcikoXG4gICAgICAgIHZhbHVlLnllYXIsXG4gICAgICAgIGN1cnJlbnRZZWFyLFxuICAgICAgKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIobm9ybWFsaXplZFR3b0RpZ2l0WWVhciwgMCwgMSk7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgeWVhciA9XG4gICAgICAhKFwiZXJhXCIgaW4gZmxhZ3MpIHx8IGZsYWdzLmVyYSA9PT0gMSA/IHZhbHVlLnllYXIgOiAxIC0gdmFsdWUueWVhcjtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbn1cbmV4cG9ydHMuWWVhclBhcnNlciA9IFllYXJQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZGF5UGVyaW9kRW51bVRvSG91cnMgPSBkYXlQZXJpb2RFbnVtVG9Ib3VycztcbmV4cG9ydHMuaXNMZWFwWWVhckluZGV4ID0gaXNMZWFwWWVhckluZGV4O1xuZXhwb3J0cy5tYXBWYWx1ZSA9IG1hcFZhbHVlO1xuZXhwb3J0cy5ub3JtYWxpemVUd29EaWdpdFllYXIgPSBub3JtYWxpemVUd29EaWdpdFllYXI7XG5leHBvcnRzLnBhcnNlQW55RGlnaXRzU2lnbmVkID0gcGFyc2VBbnlEaWdpdHNTaWduZWQ7XG5leHBvcnRzLnBhcnNlTkRpZ2l0cyA9IHBhcnNlTkRpZ2l0cztcbmV4cG9ydHMucGFyc2VORGlnaXRzU2lnbmVkID0gcGFyc2VORGlnaXRzU2lnbmVkO1xuZXhwb3J0cy5wYXJzZU51bWVyaWNQYXR0ZXJuID0gcGFyc2VOdW1lcmljUGF0dGVybjtcbmV4cG9ydHMucGFyc2VUaW1lem9uZVBhdHRlcm4gPSBwYXJzZVRpbWV6b25lUGF0dGVybjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzLmpzXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuZnVuY3Rpb24gbWFwVmFsdWUocGFyc2VGblJlc3VsdCwgbWFwRm4pIHtcbiAgaWYgKCFwYXJzZUZuUmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlRm5SZXN1bHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBtYXBGbihwYXJzZUZuUmVzdWx0LnZhbHVlKSxcbiAgICByZXN0OiBwYXJzZUZuUmVzdWx0LnJlc3QsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtZXJpY1BhdHRlcm4ocGF0dGVybiwgZGF0ZVN0cmluZykge1xuICBjb25zdCBtYXRjaFJlc3VsdCA9IGRhdGVTdHJpbmcubWF0Y2gocGF0dGVybik7XG5cbiAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogcGFyc2VJbnQobWF0Y2hSZXN1bHRbMF0sIDEwKSxcbiAgICByZXN0OiBkYXRlU3RyaW5nLnNsaWNlKG1hdGNoUmVzdWx0WzBdLmxlbmd0aCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHBhdHRlcm4sIGRhdGVTdHJpbmcpIHtcbiAgY29uc3QgbWF0Y2hSZXN1bHQgPSBkYXRlU3RyaW5nLm1hdGNoKHBhdHRlcm4pO1xuXG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElucHV0IGlzICdaJ1xuICBpZiAobWF0Y2hSZXN1bHRbMF0gPT09IFwiWlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgcmVzdDogZGF0ZVN0cmluZy5zbGljZSgxKSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc2lnbiA9IG1hdGNoUmVzdWx0WzFdID09PSBcIitcIiA/IDEgOiAtMTtcbiAgY29uc3QgaG91cnMgPSBtYXRjaFJlc3VsdFsyXSA/IHBhcnNlSW50KG1hdGNoUmVzdWx0WzJdLCAxMCkgOiAwO1xuICBjb25zdCBtaW51dGVzID0gbWF0Y2hSZXN1bHRbM10gPyBwYXJzZUludChtYXRjaFJlc3VsdFszXSwgMTApIDogMDtcbiAgY29uc3Qgc2Vjb25kcyA9IG1hdGNoUmVzdWx0WzVdID8gcGFyc2VJbnQobWF0Y2hSZXN1bHRbNV0sIDEwKSA6IDA7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTpcbiAgICAgIHNpZ24gKlxuICAgICAgKGhvdXJzICogX2luZGV4Lm1pbGxpc2Vjb25kc0luSG91ciArXG4gICAgICAgIG1pbnV0ZXMgKiBfaW5kZXgubWlsbGlzZWNvbmRzSW5NaW51dGUgK1xuICAgICAgICBzZWNvbmRzICogX2luZGV4Lm1pbGxpc2Vjb25kc0luU2Vjb25kKSxcbiAgICByZXN0OiBkYXRlU3RyaW5nLnNsaWNlKG1hdGNoUmVzdWx0WzBdLmxlbmd0aCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQW55RGlnaXRzU2lnbmVkKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4oXG4gICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMuYW55RGlnaXRzU2lnbmVkLFxuICAgIGRhdGVTdHJpbmcsXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTkRpZ2l0cyhuLCBkYXRlU3RyaW5nKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKFxuICAgICAgICBfY29uc3RhbnRzLm51bWVyaWNQYXR0ZXJucy5zaW5nbGVEaWdpdCxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4oXG4gICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLnR3b0RpZ2l0cyxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4oXG4gICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLnRocmVlRGlnaXRzLFxuICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihcbiAgICAgICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMuZm91ckRpZ2l0cyxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG5ldyBSZWdFeHAoXCJeXFxcXGR7MSxcIiArIG4gKyBcIn1cIiksIGRhdGVTdHJpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTkRpZ2l0c1NpZ25lZChuLCBkYXRlU3RyaW5nKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKFxuICAgICAgICBfY29uc3RhbnRzLm51bWVyaWNQYXR0ZXJucy5zaW5nbGVEaWdpdFNpZ25lZCxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4oXG4gICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLnR3b0RpZ2l0c1NpZ25lZCxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4oXG4gICAgICAgIF9jb25zdGFudHMubnVtZXJpY1BhdHRlcm5zLnRocmVlRGlnaXRzU2lnbmVkLFxuICAgICAgICBkYXRlU3RyaW5nLFxuICAgICAgKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihcbiAgICAgICAgX2NvbnN0YW50cy5udW1lcmljUGF0dGVybnMuZm91ckRpZ2l0c1NpZ25lZCxcbiAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG5ldyBSZWdFeHAoXCJeLT9cXFxcZHsxLFwiICsgbiArIFwifVwiKSwgZGF0ZVN0cmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF5UGVyaW9kRW51bVRvSG91cnMoZGF5UGVyaW9kKSB7XG4gIHN3aXRjaCAoZGF5UGVyaW9kKSB7XG4gICAgY2FzZSBcIm1vcm5pbmdcIjpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJldmVuaW5nXCI6XG4gICAgICByZXR1cm4gMTc7XG4gICAgY2FzZSBcInBtXCI6XG4gICAgY2FzZSBcIm5vb25cIjpcbiAgICBjYXNlIFwiYWZ0ZXJub29uXCI6XG4gICAgICByZXR1cm4gMTI7XG4gICAgY2FzZSBcImFtXCI6XG4gICAgY2FzZSBcIm1pZG5pZ2h0XCI6XG4gICAgY2FzZSBcIm5pZ2h0XCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih0d29EaWdpdFllYXIsIGN1cnJlbnRZZWFyKSB7XG4gIGNvbnN0IGlzQ29tbW9uRXJhID0gY3VycmVudFllYXIgPiAwO1xuICAvLyBBYnNvbHV0ZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgeWVhcjpcbiAgLy8gMSAtPiAxIEFDXG4gIC8vIDAgLT4gMSBCQ1xuICAvLyAtMSAtPiAyIEJDXG4gIGNvbnN0IGFic0N1cnJlbnRZZWFyID0gaXNDb21tb25FcmEgPyBjdXJyZW50WWVhciA6IDEgLSBjdXJyZW50WWVhcjtcblxuICBsZXQgcmVzdWx0O1xuICBpZiAoYWJzQ3VycmVudFllYXIgPD0gNTApIHtcbiAgICByZXN1bHQgPSB0d29EaWdpdFllYXIgfHwgMTAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJhbmdlRW5kID0gYWJzQ3VycmVudFllYXIgKyA1MDtcbiAgICBjb25zdCByYW5nZUVuZENlbnR1cnkgPSBNYXRoLnRydW5jKHJhbmdlRW5kIC8gMTAwKSAqIDEwMDtcbiAgICBjb25zdCBpc1ByZXZpb3VzQ2VudHVyeSA9IHR3b0RpZ2l0WWVhciA+PSByYW5nZUVuZCAlIDEwMDtcbiAgICByZXN1bHQgPSB0d29EaWdpdFllYXIgKyByYW5nZUVuZENlbnR1cnkgLSAoaXNQcmV2aW91c0NlbnR1cnkgPyAxMDAgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBpc0NvbW1vbkVyYSA/IHJlc3VsdCA6IDEgLSByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXJJbmRleCh5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8ICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wYXJzZUlTTyA9IHBhcnNlSVNPO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIHBhcnNlSVNPfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgcGFyc2VJU09cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgSVNPIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQgYW5kIHJldHVybiBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXNuJ3QgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiBjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBvclxuICogdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGFyZ3VtZW50IC0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcyMDE0LTAyLTExVDExOjMwOjMwJyB0byBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gcGFyc2VJU08oJzIwMTQtMDItMTFUMTE6MzA6MzAnKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJyswMjAxNDEwMScgdG8gZGF0ZSxcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XG4gKiBjb25zdCByZXN1bHQgPSBwYXJzZUlTTygnKzAyMDE0MTAxJywgeyBhZGRpdGlvbmFsRGlnaXRzOiAxIH0pXG4gKiAvLz0+IEZyaSBBcHIgMTEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBwYXJzZUlTTyhhcmd1bWVudCwgb3B0aW9ucykge1xuICBjb25zdCBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucz8uYWRkaXRpb25hbERpZ2l0cyA/PyAyO1xuICBjb25zdCBkYXRlU3RyaW5ncyA9IHNwbGl0RGF0ZVN0cmluZyhhcmd1bWVudCk7XG5cbiAgbGV0IGRhdGU7XG4gIGlmIChkYXRlU3RyaW5ncy5kYXRlKSB7XG4gICAgY29uc3QgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpO1xuICAgIGRhdGUgPSBwYXJzZURhdGUocGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nLCBwYXJzZVllYXJSZXN1bHQueWVhcik7XG4gIH1cblxuICBpZiAoIWRhdGUgfHwgaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgbGV0IHRpbWUgPSAwO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lKSB7XG4gICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcbiAgICBpZiAoaXNOYU4odGltZSkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lem9uZSkge1xuICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGlydHlEYXRlID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSk7XG4gICAgLy8gSlMgcGFyc2VkIHN0cmluZyBhc3N1bWluZyBpdCdzIGluIFVUQyB0aW1lem9uZVxuICAgIC8vIGJ1dCB3ZSBuZWVkIGl0IHRvIGJlIHBhcnNlZCBpbiBvdXIgdGltZXpvbmVcbiAgICAvLyBzbyB3ZSB1c2UgdXRjIHZhbHVlcyB0byBidWlsZCBkYXRlIGluIG91ciB0aW1lem9uZS5cbiAgICAvLyBZZWFyIHZhbHVlcyBmcm9tIDAgdG8gOTkgbWFwIHRvIHRoZSB5ZWFycyAxOTAwIHRvIDE5OTlcbiAgICAvLyBzbyBzZXQgeWVhciBleHBsaWNpdGx5IHdpdGggc2V0RnVsbFllYXIuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoMCk7XG4gICAgcmVzdWx0LnNldEZ1bGxZZWFyKFxuICAgICAgZGlydHlEYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICBkaXJ0eURhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgIGRpcnR5RGF0ZS5nZXRVVENEYXRlKCksXG4gICAgKTtcbiAgICByZXN1bHQuc2V0SG91cnMoXG4gICAgICBkaXJ0eURhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIGRpcnR5RGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICBkaXJ0eURhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgZGlydHlEYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0KTtcbn1cblxuY29uc3QgcGF0dGVybnMgPSB7XG4gIGRhdGVUaW1lRGVsaW1pdGVyOiAvW1QgXS8sXG4gIHRpbWVab25lRGVsaW1pdGVyOiAvW1ogXS9pLFxuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxufTtcblxuY29uc3QgZGF0ZVJlZ2V4ID1cbiAgL14tPyg/OihcXGR7M30pfChcXGR7Mn0pKD86LT8oXFxkezJ9KSk/fFcoXFxkezJ9KSg/Oi0/KFxcZHsxfSkpP3wpJC87XG5jb25zdCB0aW1lUmVnZXggPVxuICAvXihcXGR7Mn0oPzpbLixdXFxkKik/KSg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8oPzo6PyhcXGR7Mn0oPzpbLixdXFxkKik/KSk/JC87XG5jb25zdCB0aW1lem9uZVJlZ2V4ID0gL14oWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyQvO1xuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xuICBjb25zdCBkYXRlU3RyaW5ncyA9IHt9O1xuICBjb25zdCBhcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMuZGF0ZVRpbWVEZWxpbWl0ZXIpO1xuICBsZXQgdGltZVN0cmluZztcblxuICAvLyBUaGUgcmVnZXggbWF0Y2ggc2hvdWxkIG9ubHkgcmV0dXJuIGF0IG1heGltdW0gdHdvIGFycmF5IGVsZW1lbnRzLlxuICAvLyBbZGF0ZV0sIFt0aW1lXSwgb3IgW2RhdGUsIHRpbWVdLlxuICBpZiAoYXJyYXkubGVuZ3RoID4gMikge1xuICAgIHJldHVybiBkYXRlU3RyaW5ncztcbiAgfVxuXG4gIGlmICgvOi8udGVzdChhcnJheVswXSkpIHtcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMF07XG4gIH0gZWxzZSB7XG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGFycmF5WzBdO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXTtcbiAgICBpZiAocGF0dGVybnMudGltZVpvbmVEZWxpbWl0ZXIudGVzdChkYXRlU3RyaW5ncy5kYXRlKSkge1xuICAgICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMudGltZVpvbmVEZWxpbWl0ZXIpWzBdO1xuICAgICAgdGltZVN0cmluZyA9IGRhdGVTdHJpbmcuc3Vic3RyKFxuICAgICAgICBkYXRlU3RyaW5ncy5kYXRlLmxlbmd0aCxcbiAgICAgICAgZGF0ZVN0cmluZy5sZW5ndGgsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lU3RyaW5nKSB7XG4gICAgY29uc3QgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgXCJcIik7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lem9uZSA9IHRva2VuWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0ZVN0cmluZ3M7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkYXRlU3RyaW5nLCBhZGRpdGlvbmFsRGlnaXRzKSB7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBcIl4oPzooXFxcXGR7NH18WystXVxcXFxke1wiICtcbiAgICAgICg0ICsgYWRkaXRpb25hbERpZ2l0cykgK1xuICAgICAgXCJ9KXwoXFxcXGR7Mn18WystXVxcXFxke1wiICtcbiAgICAgICgyICsgYWRkaXRpb25hbERpZ2l0cykgK1xuICAgICAgXCJ9KSQpXCIsXG4gICk7XG5cbiAgY29uc3QgY2FwdHVyZXMgPSBkYXRlU3RyaW5nLm1hdGNoKHJlZ2V4KTtcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIHsgeWVhcjogTmFOLCByZXN0RGF0ZVN0cmluZzogXCJcIiB9O1xuXG4gIGNvbnN0IHllYXIgPSBjYXB0dXJlc1sxXSA/IHBhcnNlSW50KGNhcHR1cmVzWzFdKSA6IG51bGw7XG4gIGNvbnN0IGNlbnR1cnkgPSBjYXB0dXJlc1syXSA/IHBhcnNlSW50KGNhcHR1cmVzWzJdKSA6IG51bGw7XG5cbiAgLy8gZWl0aGVyIHllYXIgb3IgY2VudHVyeSBpcyBudWxsLCBub3QgYm90aFxuICByZXR1cm4ge1xuICAgIHllYXI6IGNlbnR1cnkgPT09IG51bGwgPyB5ZWFyIDogY2VudHVyeSAqIDEwMCxcbiAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZSgoY2FwdHVyZXNbMV0gfHwgY2FwdHVyZXNbMl0pLmxlbmd0aCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nLCB5ZWFyKSB7XG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIGlmICh5ZWFyID09PSBudWxsKSByZXR1cm4gbmV3IERhdGUoTmFOKTtcblxuICBjb25zdCBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2goZGF0ZVJlZ2V4KTtcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHN0cmluZ1xuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gbmV3IERhdGUoTmFOKTtcblxuICBjb25zdCBpc1dlZWtEYXRlID0gISFjYXB0dXJlc1s0XTtcbiAgY29uc3QgZGF5T2ZZZWFyID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1sxXSk7XG4gIGNvbnN0IG1vbnRoID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1syXSkgLSAxO1xuICBjb25zdCBkYXkgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzNdKTtcbiAgY29uc3Qgd2VlayA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbNF0pO1xuICBjb25zdCBkYXlPZldlZWsgPSBwYXJzZURhdGVVbml0KGNhcHR1cmVzWzVdKSAtIDE7XG5cbiAgaWYgKGlzV2Vla0RhdGUpIHtcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWssIGRheU9mV2Vlayk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgIGlmIChcbiAgICAgICF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkgfHxcbiAgICAgICF2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIE1hdGgubWF4KGRheU9mWWVhciwgZGF5KSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlVW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyBwYXJzZUludCh2YWx1ZSkgOiAxO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWUodGltZVN0cmluZykge1xuICBjb25zdCBjYXB0dXJlcyA9IHRpbWVTdHJpbmcubWF0Y2godGltZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIE5hTjsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcblxuICBjb25zdCBob3VycyA9IHBhcnNlVGltZVVuaXQoY2FwdHVyZXNbMV0pO1xuICBjb25zdCBtaW51dGVzID0gcGFyc2VUaW1lVW5pdChjYXB0dXJlc1syXSk7XG4gIGNvbnN0IHNlY29uZHMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzNdKTtcblxuICBpZiAoIXZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBob3VycyAqIF9pbmRleC5taWxsaXNlY29uZHNJbkhvdXIgK1xuICAgIG1pbnV0ZXMgKiBfaW5kZXgubWlsbGlzZWNvbmRzSW5NaW51dGUgK1xuICAgIHNlY29uZHMgKiAxMDAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiBwYXJzZUZsb2F0KHZhbHVlLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmUodGltZXpvbmVTdHJpbmcpIHtcbiAgaWYgKHRpbWV6b25lU3RyaW5nID09PSBcIlpcIikgcmV0dXJuIDA7XG5cbiAgY29uc3QgY2FwdHVyZXMgPSB0aW1lem9uZVN0cmluZy5tYXRjaCh0aW1lem9uZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIDA7XG5cbiAgY29uc3Qgc2lnbiA9IGNhcHR1cmVzWzFdID09PSBcIitcIiA/IC0xIDogMTtcbiAgY29uc3QgaG91cnMgPSBwYXJzZUludChjYXB0dXJlc1syXSk7XG4gIGNvbnN0IG1pbnV0ZXMgPSAoY2FwdHVyZXNbM10gJiYgcGFyc2VJbnQoY2FwdHVyZXNbM10pKSB8fCAwO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBzaWduICpcbiAgICAoaG91cnMgKiBfaW5kZXgubWlsbGlzZWNvbmRzSW5Ib3VyICsgbWludXRlcyAqIF9pbmRleC5taWxsaXNlY29uZHNJbk1pbnV0ZSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZJU09XZWVrWWVhcihpc29XZWVrWWVhciwgd2VlaywgZGF5KSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29XZWVrWWVhciwgMCwgNCk7XG4gIGNvbnN0IGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgY29uc3QgZGlmZiA9ICh3ZWVrIC0gMSkgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheTtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkYXRlO1xufVxuXG4vLyBWYWxpZGF0aW9uIGZ1bmN0aW9uc1xuXG4vLyBGZWJydWFyeSBpcyBudWxsIHRvIGhhbmRsZSB0aGUgbGVhcCB5ZWFyICh1c2luZyB8fClcbmNvbnN0IGRheXNJbk1vbnRocyA9IFszMSwgbnVsbCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICByZXR1cm4gKFxuICAgIG1vbnRoID49IDAgJiZcbiAgICBtb250aCA8PSAxMSAmJlxuICAgIGRhdGUgPj0gMSAmJlxuICAgIGRhdGUgPD0gKGRheXNJbk1vbnRoc1ttb250aF0gfHwgKGlzTGVhcFllYXJJbmRleCh5ZWFyKSA/IDI5IDogMjgpKVxuICApO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSB7XG4gIHJldHVybiBkYXlPZlllYXIgPj0gMSAmJiBkYXlPZlllYXIgPD0gKGlzTGVhcFllYXJJbmRleCh5ZWFyKSA/IDM2NiA6IDM2NSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2Vla0RhdGUoX3llYXIsIHdlZWssIGRheSkge1xuICByZXR1cm4gd2VlayA+PSAxICYmIHdlZWsgPD0gNTMgJiYgZGF5ID49IDAgJiYgZGF5IDw9IDY7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICBpZiAoaG91cnMgPT09IDI0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgJiYgc2Vjb25kcyA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgc2Vjb25kcyA+PSAwICYmXG4gICAgc2Vjb25kcyA8IDYwICYmXG4gICAgbWludXRlcyA+PSAwICYmXG4gICAgbWludXRlcyA8IDYwICYmXG4gICAgaG91cnMgPj0gMCAmJlxuICAgIGhvdXJzIDwgMjVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lem9uZShfaG91cnMsIG1pbnV0ZXMpIHtcbiAgcmV0dXJuIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDw9IDU5O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnBhcnNlSlNPTiA9IHBhcnNlSlNPTjsgLyoqXG4gKiBAbmFtZSBwYXJzZUpTT05cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgYSBKU09OIGRhdGUgc3RyaW5nXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0cyBhIGNvbXBsZXRlIElTTyBkYXRlIHN0cmluZyBpbiBVVEMgdGltZSwgdGhlIHR5cGljYWwgZm9ybWF0IGZvciB0cmFuc21pdHRpbmdcbiAqIGEgZGF0ZSBpbiBKU09OLCB0byBhIEphdmFTY3JpcHQgYERhdGVgIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgaXMgYSBtaW5pbWFsIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nIGRhdGVzIHJldHJpZXZlZCBmcm9tIGEgSlNPTiBBUEkgdG9cbiAqIGEgYERhdGVgIGluc3RhbmNlIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggb3RoZXIgZnVuY3Rpb25zIGluIHRoZSBgZGF0ZS1mbnNgIGxpYnJhcnkuXG4gKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGAyMDAwLTAzLTE1VDA1OjIwOjEwLjEyM1pgOiBUaGUgb3V0cHV0IG9mIGAudG9JU09TdHJpbmcoKWAgYW5kIGBKU09OLnN0cmluZ2lmeShuZXcgRGF0ZSgpKWBcbiAqIC0gYDIwMDAtMDMtMTVUMDU6MjA6MTBaYDogV2l0aG91dCBtaWxsaXNlY29uZHNcbiAqIC0gYDIwMDAtMDMtMTVUMDU6MjA6MTArMDA6MDBgOiBXaXRoIGEgemVybyBvZmZzZXQsIHRoZSBkZWZhdWx0IEpTT04gZW5jb2RlZCBmb3JtYXQgaW4gc29tZSBvdGhlciBsYW5ndWFnZXNcbiAqIC0gYDIwMDAtMDMtMTVUMDU6MjA6MTArMDU6NDVgOiBXaXRoIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgb2Zmc2V0LCB0aGUgZGVmYXVsdCBKU09OIGVuY29kZWQgZm9ybWF0IGluIHNvbWUgb3RoZXIgbGFuZ3VhZ2VzXG4gKiAtIGAyMDAwLTAzLTE1VDA1OjIwOjEwKzAwMDBgOiBXaXRoIGEgemVybyBvZmZzZXQgd2l0aG91dCBhIGNvbG9uXG4gKiAtIGAyMDAwLTAzLTE1VDA1OjIwOjEwYDogV2l0aG91dCBhIHRyYWlsaW5nICdaJyBzeW1ib2xcbiAqIC0gYDIwMDAtMDMtMTVUMDU6MjA6MTAuMTIzNDU2N2A6IFVwIHRvIDcgZGlnaXRzIGluIG1pbGxpc2Vjb25kcyBmaWVsZC4gT25seSBmaXJzdCAzIGFyZSB0YWtlbiBpbnRvIGFjY291bnQgc2luY2UgSlMgZG9lcyBub3QgYWxsb3cgZnJhY3Rpb25hbCBtaWxsaXNlY29uZHNcbiAqIC0gYDIwMDAtMDMtMTUgMDU6MjA6MTBgOiBXaXRoIGEgc3BhY2UgaW5zdGVhZCBvZiBhICdUJyBzZXBhcmF0b3IgZm9yIEFQSXMgcmV0dXJuaW5nIGEgU1FMIGRhdGUgd2l0aG91dCByZWZvcm1hdHRpbmdcbiAqXG4gKiBGb3IgY29udmVuaWVuY2UgYW5kIGVhc2Ugb2YgdXNlIHRoZXNlIG90aGVyIGlucHV0IHR5cGVzIGFyZSBhbHNvIHN1cHBvcnRlZFxuICogdmlhIFt0b0RhdGVdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlKTpcbiAqXG4gKiAtIEEgYERhdGVgIGluc3RhbmNlIHdpbGwgYmUgY2xvbmVkXG4gKiAtIEEgYG51bWJlcmAgd2lsbCBiZSB0cmVhdGVkIGFzIGEgdGltZXN0YW1wXG4gKlxuICogQW55IG90aGVyIGlucHV0IHR5cGUgb3IgaW52YWxpZCBkYXRlIHN0cmluZ3Mgd2lsbCByZXR1cm4gYW4gYEludmFsaWQgRGF0ZWAuXG4gKlxuICogQHBhcmFtIGRhdGVTdHIgLSBBIGZ1bGx5IGZvcm1lZCBJU084NjAxIGRhdGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICovXG5mdW5jdGlvbiBwYXJzZUpTT04oZGF0ZVN0cikge1xuICBjb25zdCBwYXJ0cyA9IGRhdGVTdHIubWF0Y2goXG4gICAgLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pW1QgXShcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pKD86XFwuKFxcZHswLDd9KSk/KD86WnwoLikoXFxkezJ9KTo/KFxcZHsyfSk/KT8vLFxuICApO1xuICBpZiAocGFydHMpIHtcbiAgICAvLyBHcm91cCA4IG1hdGNoZXMgdGhlIHNpZ25cbiAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICBEYXRlLlVUQyhcbiAgICAgICAgK3BhcnRzWzFdLFxuICAgICAgICArcGFydHNbMl0gLSAxLFxuICAgICAgICArcGFydHNbM10sXG4gICAgICAgICtwYXJ0c1s0XSAtICgrcGFydHNbOV0gfHwgMCkgKiAocGFydHNbOF0gPT0gXCItXCIgPyAtMSA6IDEpLFxuICAgICAgICArcGFydHNbNV0gLSAoK3BhcnRzWzEwXSB8fCAwKSAqIChwYXJ0c1s4XSA9PSBcIi1cIiA/IC0xIDogMSksXG4gICAgICAgICtwYXJ0c1s2XSxcbiAgICAgICAgKygocGFydHNbN10gfHwgXCIwXCIpICsgXCIwMFwiKS5zdWJzdHJpbmcoMCwgMyksXG4gICAgICApLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucHJldmlvdXNEYXkgPSBwcmV2aW91c0RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZXREYXkuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N1YkRheXMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgcHJldmlvdXNEYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIHByZXZpb3VzIGRheSBvZiB0aGUgd2Vlaz9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIHByZXZpb3VzIGRheSBvZiB0aGUgd2Vlaz8gMC02IHRoZSBkYXkgb2YgdGhlIHdlZWssIDAgcmVwcmVzZW50cyBTdW5kYXkuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRheSAtIFRoZSBkYXkgb2YgdGhlIHdlZWtcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyB0aGUgcHJldmlvdXMgZGF5IG9mIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgcHJldmlvdXMgTW9uZGF5IGJlZm9yZSBNYXIsIDIwLCAyMDIwP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNEYXkobmV3IERhdGUoMjAyMCwgMiwgMjApLCAxKVxuICogLy89PiBNb24gTWFyIDE2IDIwMjAgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgcHJldmlvdXMgVHVlc2RheSBiZWZvcmUgTWFyLCAyMSwgMjAyMD9cbiAqIGNvbnN0IHJlc3VsdCA9IHByZXZpb3VzRGF5KG5ldyBEYXRlKDIwMjAsIDIsIDIxKSwgMilcbiAqIC8vPT4gVHVlIE1hciAxNyAyMDIwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzRGF5KGRhdGUsIGRheSkge1xuICBsZXQgZGVsdGEgPSAoMCwgX2luZGV4LmdldERheSkoZGF0ZSkgLSBkYXk7XG4gIGlmIChkZWx0YSA8PSAwKSBkZWx0YSArPSA3O1xuXG4gIHJldHVybiAoMCwgX2luZGV4Mi5zdWJEYXlzKShkYXRlLCBkZWx0YSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucHJldmlvdXNGcmlkYXkgPSBwcmV2aW91c0ZyaWRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wcmV2aW91c0RheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBwcmV2aW91c0ZyaWRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgV2hlbiBpcyB0aGUgcHJldmlvdXMgRnJpZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgcHJldmlvdXMgRnJpZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBGcmlkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgcHJldmlvdXMgRnJpZGF5IGJlZm9yZSBKdW4sIDE5LCAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNGcmlkYXkobmV3IERhdGUoMjAyMSwgNSwgMTkpKVxuICogLy89PiBGcmkgSnVuZSAxOCAyMDIxIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzRnJpZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgucHJldmlvdXNEYXkpKGRhdGUsIDUpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnByZXZpb3VzTW9uZGF5ID0gcHJldmlvdXNNb25kYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vcHJldmlvdXNEYXkuanNcIik7XG5cbi8qKlxuICogQG5hbWUgcHJldmlvdXNNb25kYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIHByZXZpb3VzIE1vbmRheT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIHByZXZpb3VzIE1vbmRheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIHN0YXJ0IGNvdW50aW5nIGZyb21cbiAqXG4gKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgTW9uZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIHByZXZpb3VzIE1vbmRheSBiZWZvcmUgSnVuLCAxOCwgMjAyMT9cbiAqIGNvbnN0IHJlc3VsdCA9IHByZXZpb3VzTW9uZGF5KG5ldyBEYXRlKDIwMjEsIDUsIDE4KSlcbiAqIC8vPT4gTW9uIEp1bmUgMTQgMjAyMSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBwcmV2aW91c01vbmRheShkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnByZXZpb3VzRGF5KShkYXRlLCAxKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wcmV2aW91c1NhdHVyZGF5ID0gcHJldmlvdXNTYXR1cmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wcmV2aW91c0RheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBwcmV2aW91c1NhdHVyZGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBwcmV2aW91cyBTYXR1cmRheT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdoZW4gaXMgdGhlIHByZXZpb3VzIFNhdHVyZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBTYXR1cmRheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBwcmV2aW91cyBTYXR1cmRheSBiZWZvcmUgSnVuLCAyMCwgMjAyMT9cbiAqIGNvbnN0IHJlc3VsdCA9IHByZXZpb3VzU2F0dXJkYXkobmV3IERhdGUoMjAyMSwgNSwgMjApKVxuICogLy89PiBTYXQgSnVuZSAxOSAyMDIxIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzU2F0dXJkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5wcmV2aW91c0RheSkoZGF0ZSwgNik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucHJldmlvdXNTdW5kYXkgPSBwcmV2aW91c1N1bmRheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wcmV2aW91c0RheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBwcmV2aW91c1N1bmRheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgV2hlbiBpcyB0aGUgcHJldmlvdXMgU3VuZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgcHJldmlvdXMgU3VuZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBTdW5kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgcHJldmlvdXMgU3VuZGF5IGJlZm9yZSBKdW4sIDIxLCAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNTdW5kYXkobmV3IERhdGUoMjAyMSwgNSwgMjEpKVxuICogLy89PiBTdW4gSnVuZSAyMCAyMDIxIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzU3VuZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgucHJldmlvdXNEYXkpKGRhdGUsIDApO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnByZXZpb3VzVGh1cnNkYXkgPSBwcmV2aW91c1RodXJzZGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3ByZXZpb3VzRGF5LmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHByZXZpb3VzVGh1cnNkYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFdoZW4gaXMgdGhlIHByZXZpb3VzIFRodXJzZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgcHJldmlvdXMgVGh1cnNkYXk/XG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKlxuICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRodXJzZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoZW4gaXMgdGhlIHByZXZpb3VzIFRodXJzZGF5IGJlZm9yZSBKdW4sIDE4LCAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNUaHVyc2RheShuZXcgRGF0ZSgyMDIxLCA1LCAxOCkpXG4gKiAvLz0+IFRodSBKdW5lIDE3IDIwMjEgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gcHJldmlvdXNUaHVyc2RheShkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnByZXZpb3VzRGF5KShkYXRlLCA0KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5wcmV2aW91c1R1ZXNkYXkgPSBwcmV2aW91c1R1ZXNkYXk7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vcHJldmlvdXNEYXkuanNcIik7XG5cbi8qKlxuICogQG5hbWUgcHJldmlvdXNUdWVzZGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBXaGVuIGlzIHRoZSBwcmV2aW91cyBUdWVzZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgcHJldmlvdXMgVHVlc2RheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIHN0YXJ0IGNvdW50aW5nIGZyb21cbiAqXG4gKiBAcmV0dXJucyBUaGUgcHJldmlvdXMgVHVlc2RheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGVuIGlzIHRoZSBwcmV2aW91cyBUdWVzZGF5IGJlZm9yZSBKdW4sIDE4LCAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNUdWVzZGF5KG5ldyBEYXRlKDIwMjEsIDUsIDE4KSlcbiAqIC8vPT4gVHVlIEp1bmUgMTUgMjAyMSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBwcmV2aW91c1R1ZXNkYXkoZGF0ZSkge1xuICByZXR1cm4gKDAsIF9pbmRleC5wcmV2aW91c0RheSkoZGF0ZSwgMik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucHJldmlvdXNXZWRuZXNkYXkgPSBwcmV2aW91c1dlZG5lc2RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9wcmV2aW91c0RheS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBwcmV2aW91c1dlZG5lc2RheVxuICogQGNhdGVnb3J5IFdlZWtkYXkgSGVscGVyc1xuICogQHN1bW1hcnkgV2hlbiBpcyB0aGUgcHJldmlvdXMgV2VkbmVzZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpcyB0aGUgcHJldmlvdXMgV2VkbmVzZGF5P1xuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBXZWRuZXNkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hlbiBpcyB0aGUgcHJldmlvdXMgV2VkbmVzZGF5IGJlZm9yZSBKdW4sIDE4LCAyMDIxP1xuICogY29uc3QgcmVzdWx0ID0gcHJldmlvdXNXZWRuZXNkYXkobmV3IERhdGUoMjAyMSwgNSwgMTgpKVxuICogLy89PiBXZWQgSnVuZSAxNiAyMDIxIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzV2VkbmVzZGF5KGRhdGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgucHJldmlvdXNEYXkpKGRhdGUsIDMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnF1YXJ0ZXJzVG9Nb250aHMgPSBxdWFydGVyc1RvTW9udGhzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBxdWFydGVyc1RvTW9udGhzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IG51bWJlciBvZiBxdWFydGVycyB0byBtb250aHMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIHF1YXJ0ZXJzIHRvIGEgZnVsbCBudW1iZXIgb2YgbW9udGhzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBxdWFydGVycyAtIFRoZSBudW1iZXIgb2YgcXVhcnRlcnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBxdWFydGVycyBjb252ZXJ0ZWQgaW4gbW9udGhzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMiBxdWFydGVycyB0byBtb250aHNcbiAqIGNvbnN0IHJlc3VsdCA9IHF1YXJ0ZXJzVG9Nb250aHMoMilcbiAqIC8vPT4gNlxuICovXG5mdW5jdGlvbiBxdWFydGVyc1RvTW9udGhzKHF1YXJ0ZXJzKSB7XG4gIHJldHVybiBNYXRoLnRydW5jKHF1YXJ0ZXJzICogX2luZGV4Lm1vbnRoc0luUXVhcnRlcik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucXVhcnRlcnNUb1llYXJzID0gcXVhcnRlcnNUb1llYXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBxdWFydGVyc1RvWWVhcnNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgbnVtYmVyIG9mIHF1YXJ0ZXJzIHRvIHllYXJzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiBxdWFydGVycyB0byBhIGZ1bGwgbnVtYmVyIG9mIHllYXJzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBxdWFydGVycyAtIFRoZSBudW1iZXIgb2YgcXVhcnRlcnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBxdWFydGVycyBjb252ZXJ0ZWQgaW4geWVhcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCA4IHF1YXJ0ZXJzIHRvIHllYXJzXG4gKiBjb25zdCByZXN1bHQgPSBxdWFydGVyc1RvWWVhcnMoOClcbiAqIC8vPT4gMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJdCB1c2VzIGZsb29yIHJvdW5kaW5nOlxuICogY29uc3QgcmVzdWx0ID0gcXVhcnRlcnNUb1llYXJzKDExKVxuICogLy89PiAyXG4gKi9cbmZ1bmN0aW9uIHF1YXJ0ZXJzVG9ZZWFycyhxdWFydGVycykge1xuICBjb25zdCB5ZWFycyA9IHF1YXJ0ZXJzIC8gX2luZGV4LnF1YXJ0ZXJzSW5ZZWFyO1xuICByZXR1cm4gTWF0aC50cnVuYyh5ZWFycyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucm91bmRUb05lYXJlc3RIb3VycyA9IHJvdW5kVG9OZWFyZXN0SG91cnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9nZXRSb3VuZGluZ01ldGhvZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgcm91bmRUb05lYXJlc3RIb3Vyc30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIHJvdW5kVG9OZWFyZXN0SG91cnNcbiAqIEBjYXRlZ29yeSBIb3VyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJvdW5kcyB0aGUgZ2l2ZW4gZGF0ZSB0byB0aGUgbmVhcmVzdCBob3VyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSb3VuZHMgdGhlIGdpdmVuIGRhdGUgdG8gdGhlIG5lYXJlc3QgaG91ciAob3IgbnVtYmVyIG9mIGhvdXJzKS5cbiAqIFJvdW5kcyB1cCB3aGVuIHRoZSBnaXZlbiBkYXRlIGlzIGV4YWN0bHkgYmV0d2VlbiB0aGUgbmVhcmVzdCByb3VuZCBob3Vycy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIHJvdW5kXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgaG91clxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSb3VuZCAxMCBKdWx5IDIwMTQgMTI6MzQ6NTYgdG8gbmVhcmVzdCBob3VyOlxuICogY29uc3QgcmVzdWx0ID0gcm91bmRUb05lYXJlc3RIb3VycyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDM0LCA1NikpXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMzowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSb3VuZCAxMCBKdWx5IDIwMTQgMTI6MzQ6NTYgdG8gbmVhcmVzdCBoYWxmIGhvdXI6XG4gKiBjb25zdCByZXN1bHQgPSByb3VuZFRvTmVhcmVzdEhvdXJzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMzQsIDU2KSwgeyBuZWFyZXN0VG86IDYgfSlcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjAwOjAwXG5cbiAqIEBleGFtcGxlXG4gKiAvLyBSb3VuZCAxMCBKdWx5IDIwMTQgMTI6MzQ6NTYgdG8gbmVhcmVzdCBoYWxmIGhvdXI6XG4gKiBjb25zdCByZXN1bHQgPSByb3VuZFRvTmVhcmVzdEhvdXJzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMzQsIDU2KSwgeyBuZWFyZXN0VG86IDggfSlcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDE2OjAwOjAwXG5cbiogQGV4YW1wbGVcbiAqIC8vIEZsb29yIChyb3VuZHMgZG93bikgMTAgSnVseSAyMDE0IDEyOjM0OjU2IHRvIG5lYXJlc3QgaG91cjpcbiAqIGNvbnN0IHJlc3VsdCA9IHJvdW5kVG9OZWFyZXN0SG91cnMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEsIDIzLCA0NSksIHsgcm91bmRpbmdNZXRob2Q6ICdjZWlsJyB9KVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMDI6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2VpbCAocm91bmRzIHVwKSAxMCBKdWx5IDIwMTQgMTI6MzQ6NTYgdG8gbmVhcmVzdCBxdWFydGVyIGhvdXI6XG4gKiBjb25zdCByZXN1bHQgPSByb3VuZFRvTmVhcmVzdEhvdXJzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMzQsIDU2KSwgeyByb3VuZGluZ01ldGhvZDogJ2Zsb29yJywgbmVhcmVzdFRvOiA4IH0pXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAwODowMDowMFxuICovXG5mdW5jdGlvbiByb3VuZFRvTmVhcmVzdEhvdXJzKGRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmVhcmVzdFRvID0gb3B0aW9ucz8ubmVhcmVzdFRvID8/IDE7XG5cbiAgaWYgKG5lYXJlc3RUbyA8IDEgfHwgbmVhcmVzdFRvID4gMTIpXG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLmNvbnN0cnVjdEZyb20pKGRhdGUsIE5hTik7XG5cbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBmcmFjdGlvbmFsTWludXRlcyA9IF9kYXRlLmdldE1pbnV0ZXMoKSAvIDYwO1xuICBjb25zdCBmcmFjdGlvbmFsU2Vjb25kcyA9IF9kYXRlLmdldFNlY29uZHMoKSAvIDYwIC8gNjA7XG4gIGNvbnN0IGZyYWN0aW9uYWxNaWxsaXNlY29uZHMgPSBfZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAvIDEwMDAgLyA2MCAvIDYwO1xuICBjb25zdCBob3VycyA9XG4gICAgX2RhdGUuZ2V0SG91cnMoKSArXG4gICAgZnJhY3Rpb25hbE1pbnV0ZXMgK1xuICAgIGZyYWN0aW9uYWxTZWNvbmRzICtcbiAgICBmcmFjdGlvbmFsTWlsbGlzZWNvbmRzO1xuXG4gIC8vIFVubGlrZSB0aGUgYGRpZmZlcmVuY2VJbipgIGZ1bmN0aW9ucywgdGhlIGRlZmF1bHQgcm91bmRpbmcgYmVoYXZpb3IgaXMgYHJvdW5kYCBhbmQgbm90ICd0cnVuYydcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucz8ucm91bmRpbmdNZXRob2QgPz8gXCJyb3VuZFwiO1xuICBjb25zdCByb3VuZGluZ01ldGhvZCA9ICgwLCBfaW5kZXguZ2V0Um91bmRpbmdNZXRob2QpKG1ldGhvZCk7XG5cbiAgLy8gbmVhcmVzdFRvIG9wdGlvbiBkb2VzIG5vdCBjYXJlIGRheWxpZ2h0IHNhdmluZ3MgdGltZVxuICBjb25zdCByb3VuZGVkSG91cnMgPSByb3VuZGluZ01ldGhvZChob3VycyAvIG5lYXJlc3RUbykgKiBuZWFyZXN0VG87XG5cbiAgY29uc3QgcmVzdWx0ID0gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgX2RhdGUpO1xuICByZXN1bHQuc2V0SG91cnMocm91bmRlZEhvdXJzLCAwLCAwLCAwKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5yb3VuZFRvTmVhcmVzdE1pbnV0ZXMgPSByb3VuZFRvTmVhcmVzdE1pbnV0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9nZXRSb3VuZGluZ01ldGhvZC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgcm91bmRUb05lYXJlc3RNaW51dGVzfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgcm91bmRUb05lYXJlc3RNaW51dGVzXG4gKiBAY2F0ZWdvcnkgTWludXRlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJvdW5kcyB0aGUgZ2l2ZW4gZGF0ZSB0byB0aGUgbmVhcmVzdCBtaW51dGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJvdW5kcyB0aGUgZ2l2ZW4gZGF0ZSB0byB0aGUgbmVhcmVzdCBtaW51dGUgKG9yIG51bWJlciBvZiBtaW51dGVzKS5cbiAqIFJvdW5kcyB1cCB3aGVuIHRoZSBnaXZlbiBkYXRlIGlzIGV4YWN0bHkgYmV0d2VlbiB0aGUgbmVhcmVzdCByb3VuZCBtaW51dGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gcm91bmRcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBtaW51dGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUm91bmQgMTAgSnVseSAyMDE0IDEyOjEyOjM0IHRvIG5lYXJlc3QgbWludXRlOlxuICogY29uc3QgcmVzdWx0ID0gcm91bmRUb05lYXJlc3RNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMTIsIDM0KSlcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjEzOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJvdW5kIDEwIEp1bHkgMjAxNCAxMjoxMjozNCB0byBuZWFyZXN0IHF1YXJ0ZXIgaG91cjpcbiAqIGNvbnN0IHJlc3VsdCA9IHJvdW5kVG9OZWFyZXN0TWludXRlcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDEyLCAzNCksIHsgbmVhcmVzdFRvOiAxNSB9KVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6MTU6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRmxvb3IgKHJvdW5kcyBkb3duKSAxMCBKdWx5IDIwMTQgMTI6MTI6MzQgdG8gbmVhcmVzdCBtaW51dGU6XG4gKiBjb25zdCByZXN1bHQgPSByb3VuZFRvTmVhcmVzdE1pbnV0ZXMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCAxMiwgMzQpLCB7IHJvdW5kaW5nTWV0aG9kOiAnZmxvb3InIH0pXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjoxMjowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDZWlsIChyb3VuZHMgdXApIDEwIEp1bHkgMjAxNCAxMjoxMjozNCB0byBuZWFyZXN0IGhhbGYgaG91cjpcbiAqIGNvbnN0IHJlc3VsdCA9IHJvdW5kVG9OZWFyZXN0TWludXRlcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDEyLCAzNCksIHsgcm91bmRpbmdNZXRob2Q6ICdjZWlsJywgbmVhcmVzdFRvOiAzMCB9KVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6MzA6MDBcbiAqL1xuZnVuY3Rpb24gcm91bmRUb05lYXJlc3RNaW51dGVzKGRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmVhcmVzdFRvID0gb3B0aW9ucz8ubmVhcmVzdFRvID8/IDE7XG5cbiAgaWYgKG5lYXJlc3RUbyA8IDEgfHwgbmVhcmVzdFRvID4gMzApXG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLmNvbnN0cnVjdEZyb20pKGRhdGUsIE5hTik7XG5cbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4My50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBmcmFjdGlvbmFsU2Vjb25kcyA9IF9kYXRlLmdldFNlY29uZHMoKSAvIDYwO1xuICBjb25zdCBmcmFjdGlvbmFsTWlsbGlzZWNvbmRzID0gX2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMDAwIC8gNjA7XG4gIGNvbnN0IG1pbnV0ZXMgPVxuICAgIF9kYXRlLmdldE1pbnV0ZXMoKSArIGZyYWN0aW9uYWxTZWNvbmRzICsgZnJhY3Rpb25hbE1pbGxpc2Vjb25kcztcblxuICAvLyBVbmxpa2UgdGhlIGBkaWZmZXJlbmNlSW4qYCBmdW5jdGlvbnMsIHRoZSBkZWZhdWx0IHJvdW5kaW5nIGJlaGF2aW9yIGlzIGByb3VuZGAgYW5kIG5vdCAndHJ1bmMnXG4gIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/LnJvdW5kaW5nTWV0aG9kID8/IFwicm91bmRcIjtcbiAgY29uc3Qgcm91bmRpbmdNZXRob2QgPSAoMCwgX2luZGV4LmdldFJvdW5kaW5nTWV0aG9kKShtZXRob2QpO1xuXG4gIGNvbnN0IHJvdW5kZWRNaW51dGVzID0gcm91bmRpbmdNZXRob2QobWludXRlcyAvIG5lYXJlc3RUbykgKiBuZWFyZXN0VG87XG5cbiAgY29uc3QgcmVzdWx0ID0gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgX2RhdGUpO1xuICByZXN1bHQuc2V0TWludXRlcyhyb3VuZGVkTWludXRlcywgMCwgMCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2Vjb25kc1RvSG91cnMgPSBzZWNvbmRzVG9Ib3VycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc2Vjb25kc1RvSG91cnNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgc2Vjb25kcyB0byBob3Vycy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgYSBudW1iZXIgb2Ygc2Vjb25kcyB0byBhIGZ1bGwgbnVtYmVyIG9mIGhvdXJzLlxuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBjb252ZXJ0ZWQgaW4gaG91cnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCA3MjAwIHNlY29uZHMgaW50byBob3Vyc1xuICogY29uc3QgcmVzdWx0ID0gc2Vjb25kc1RvSG91cnMoNzIwMClcbiAqIC8vPT4gMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJdCB1c2VzIGZsb29yIHJvdW5kaW5nOlxuICogY29uc3QgcmVzdWx0ID0gc2Vjb25kc1RvSG91cnMoNzE5OSlcbiAqIC8vPT4gMVxuICovXG5mdW5jdGlvbiBzZWNvbmRzVG9Ib3VycyhzZWNvbmRzKSB7XG4gIGNvbnN0IGhvdXJzID0gc2Vjb25kcyAvIF9pbmRleC5zZWNvbmRzSW5Ib3VyO1xuICByZXR1cm4gTWF0aC50cnVuYyhob3Vycyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZWNvbmRzVG9NaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIHNlY29uZHMgdG8gYSBmdWxsIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBzZWNvbmRzIGNvbnZlcnRlZCBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCAyIHNlY29uZHMgaW50byBtaWxsaXNlY29uZHNcbiAqIGNvbnN0IHJlc3VsdCA9IHNlY29uZHNUb01pbGxpc2Vjb25kcygyKVxuICogLy89PiAyMDAwXG4gKi9cbmZ1bmN0aW9uIHNlY29uZHNUb01pbGxpc2Vjb25kcyhzZWNvbmRzKSB7XG4gIHJldHVybiBzZWNvbmRzICogX2luZGV4Lm1pbGxpc2Vjb25kc0luU2Vjb25kO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNlY29uZHNUb01pbnV0ZXMgPSBzZWNvbmRzVG9NaW51dGVzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZWNvbmRzVG9NaW51dGVzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHNlY29uZHMgdG8gbWludXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgYSBudW1iZXIgb2Ygc2Vjb25kcyB0byBhIGZ1bGwgbnVtYmVyIG9mIG1pbnV0ZXMuXG4gKlxuICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBzZWNvbmRzIGNvbnZlcnRlZCBpbiBtaW51dGVzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgMTIwIHNlY29uZHMgaW50byBtaW51dGVzXG4gKiBjb25zdCByZXN1bHQgPSBzZWNvbmRzVG9NaW51dGVzKDEyMClcbiAqIC8vPT4gMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJdCB1c2VzIGZsb29yIHJvdW5kaW5nOlxuICogY29uc3QgcmVzdWx0ID0gc2Vjb25kc1RvTWludXRlcygxMTkpXG4gKiAvLz0+IDFcbiAqL1xuZnVuY3Rpb24gc2Vjb25kc1RvTWludXRlcyhzZWNvbmRzKSB7XG4gIGNvbnN0IG1pbnV0ZXMgPSBzZWNvbmRzIC8gX2luZGV4LnNlY29uZHNJbk1pbnV0ZTtcbiAgcmV0dXJuIE1hdGgudHJ1bmMobWludXRlcyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2V0ID0gc2V0O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdEZyb20uanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3NldE1vbnRoLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc2V0XG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCBkYXRlIHZhbHVlcyB0byBhIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgZGF0ZSB2YWx1ZXMgdG8gYSBnaXZlbiBkYXRlLlxuICpcbiAqIFNldHMgdGltZSB2YWx1ZXMgdG8gZGF0ZSBmcm9tIG9iamVjdCBgdmFsdWVzYC5cbiAqIEEgdmFsdWUgaXMgbm90IHNldCBpZiBpdCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciBkb2Vzbid0IGV4aXN0IGluIGB2YWx1ZXNgLlxuICpcbiAqIE5vdGUgYWJvdXQgYnVuZGxlIHNpemU6IGBzZXRgIGRvZXMgbm90IGludGVybmFsbHkgdXNlIGBzZXRYYCBmdW5jdGlvbnMgZnJvbSBkYXRlLWZucyBidXQgaW5zdGVhZCBvcHRzXG4gKiB0byB1c2UgbmF0aXZlIGBEYXRlI3NldFhgIG1ldGhvZHMuIElmIHlvdSB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IG1heSBub3Qgd2FudCB0byBpbmNsdWRlIHRoZVxuICogb3RoZXIgYHNldFhgIGZ1bmN0aW9ucyB0aGF0IGRhdGUtZm5zIHByb3ZpZGVzIGlmIHlvdSBhcmUgY29uY2VybmVkIGFib3V0IHRoZSBidW5kbGUgc2l6ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgZGF0ZSB2YWx1ZXMgdG8gYmUgc2V0XG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggb3B0aW9ucyBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVHJhbnNmb3JtIDEgU2VwdGVtYmVyIDIwMTQgaW50byAyMCBPY3RvYmVyIDIwMTUgaW4gYSBzaW5nbGUgbGluZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHNldChuZXcgRGF0ZSgyMDE0LCA4LCAyMCksIHsgeWVhcjogMjAxNSwgbW9udGg6IDksIGRhdGU6IDIwIH0pXG4gKiAvLz0+IFR1ZSBPY3QgMjAgMjAxNSAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXQgMTIgUE0gdG8gMSBTZXB0ZW1iZXIgMjAxNCAwMToyMzo0NSB0byAxIFNlcHRlbWJlciAyMDE0IDEyOjAwOjAwOlxuICogY29uc3QgcmVzdWx0ID0gc2V0KG5ldyBEYXRlKDIwMTQsIDgsIDEsIDEsIDIzLCA0NSksIHsgaG91cnM6IDEyIH0pXG4gKiAvLz0+IE1vbiBTZXAgMDEgMjAxNCAxMjoyMzo0NVxuICovXG5cbmZ1bmN0aW9uIHNldChkYXRlLCB2YWx1ZXMpIHtcbiAgbGV0IF9kYXRlID0gKDAsIF9pbmRleDMudG9EYXRlKShkYXRlKTtcblxuICAvLyBDaGVjayBpZiBkYXRlIGlzIEludmFsaWQgRGF0ZSBiZWNhdXNlIERhdGUucHJvdG90eXBlLnNldEZ1bGxZZWFyIGlnbm9yZXMgdGhlIHZhbHVlIG9mIEludmFsaWQgRGF0ZVxuICBpZiAoaXNOYU4oK19kYXRlKSkge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIE5hTik7XG4gIH1cblxuICBpZiAodmFsdWVzLnllYXIgIT0gbnVsbCkge1xuICAgIF9kYXRlLnNldEZ1bGxZZWFyKHZhbHVlcy55ZWFyKTtcbiAgfVxuXG4gIGlmICh2YWx1ZXMubW9udGggIT0gbnVsbCkge1xuICAgIF9kYXRlID0gKDAsIF9pbmRleDIuc2V0TW9udGgpKF9kYXRlLCB2YWx1ZXMubW9udGgpO1xuICB9XG5cbiAgaWYgKHZhbHVlcy5kYXRlICE9IG51bGwpIHtcbiAgICBfZGF0ZS5zZXREYXRlKHZhbHVlcy5kYXRlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZXMuaG91cnMgIT0gbnVsbCkge1xuICAgIF9kYXRlLnNldEhvdXJzKHZhbHVlcy5ob3Vycyk7XG4gIH1cblxuICBpZiAodmFsdWVzLm1pbnV0ZXMgIT0gbnVsbCkge1xuICAgIF9kYXRlLnNldE1pbnV0ZXModmFsdWVzLm1pbnV0ZXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlcy5zZWNvbmRzICE9IG51bGwpIHtcbiAgICBfZGF0ZS5zZXRTZWNvbmRzKHZhbHVlcy5zZWNvbmRzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZXMubWlsbGlzZWNvbmRzICE9IG51bGwpIHtcbiAgICBfZGF0ZS5zZXRNaWxsaXNlY29uZHModmFsdWVzLm1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2V0RGF0ZSA9IHNldERhdGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHNldERhdGVcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgU2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGRheU9mTW9udGggLSBUaGUgZGF5IG9mIHRoZSBtb250aCBvZiB0aGUgbmV3IGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgZGF5IG9mIHRoZSBtb250aCBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHRoZSAzMHRoIGRheSBvZiB0aGUgbW9udGggdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IHNldERhdGUobmV3IERhdGUoMjAxNCwgOCwgMSksIDMwKVxuICogLy89PiBUdWUgU2VwIDMwIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0RGF0ZShkYXRlLCBkYXlPZk1vbnRoKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXREYXRlKGRheU9mTW9udGgpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2V0RGF5ID0gc2V0RGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZERheXMuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgc2V0RGF5fSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgc2V0RGF5XG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIGRheSBvZiB0aGUgd2VlayB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNldCB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGRheSAtIFRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIG5ldyBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIGRheSBvZiB0aGUgd2VlayBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHdlZWsgZGF5IHRvIFN1bmRheSwgd2l0aCB0aGUgZGVmYXVsdCB3ZWVrU3RhcnRzT24gb2YgU3VuZGF5OlxuICogY29uc3QgcmVzdWx0ID0gc2V0RGF5KG5ldyBEYXRlKDIwMTQsIDgsIDEpLCAwKVxuICogLy89PiBTdW4gQXVnIDMxIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHdlZWsgZGF5IHRvIFN1bmRheSwgd2l0aCBhIHdlZWtTdGFydHNPbiBvZiBNb25kYXk6XG4gKiBjb25zdCByZXN1bHQgPSBzZXREYXkobmV3IERhdGUoMjAxNCwgOCwgMSksIDAsIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gKiAvLz0+IFN1biBTZXAgMDcgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzZXREYXkoZGF0ZSwgZGF5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gKDAsIF9pbmRleDMuZ2V0RGVmYXVsdE9wdGlvbnMpKCk7XG4gIGNvbnN0IHdlZWtTdGFydHNPbiA9XG4gICAgb3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIDA7XG5cbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBjdXJyZW50RGF5ID0gX2RhdGUuZ2V0RGF5KCk7XG5cbiAgY29uc3QgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgY29uc3QgZGF5SW5kZXggPSAocmVtYWluZGVyICsgNykgJSA3O1xuXG4gIGNvbnN0IGRlbHRhID0gNyAtIHdlZWtTdGFydHNPbjtcbiAgY29uc3QgZGlmZiA9XG4gICAgZGF5IDwgMCB8fCBkYXkgPiA2XG4gICAgICA/IGRheSAtICgoY3VycmVudERheSArIGRlbHRhKSAlIDcpXG4gICAgICA6ICgoZGF5SW5kZXggKyBkZWx0YSkgJSA3KSAtICgoY3VycmVudERheSArIGRlbHRhKSAlIDcpO1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGREYXlzKShfZGF0ZSwgZGlmZik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2V0RGF5T2ZZZWFyID0gc2V0RGF5T2ZZZWFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXREYXlPZlllYXJcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgU2V0IHRoZSBkYXkgb2YgdGhlIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIGRheSBvZiB0aGUgeWVhciB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBkYXlPZlllYXIgLSBUaGUgZGF5IG9mIHRoZSB5ZWFyIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBkYXkgb2YgdGhlIHllYXIgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCB0aGUgMm5kIGRheSBvZiB0aGUgeWVhciB0byAyIEp1bHkgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IHNldERheU9mWWVhcihuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgMilcbiAqIC8vPT4gVGh1IEphbiAwMiAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHNldERheU9mWWVhcihkYXRlLCBkYXlPZlllYXIpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIF9kYXRlLnNldE1vbnRoKDApO1xuICBfZGF0ZS5zZXREYXRlKGRheU9mWWVhcik7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zZXREZWZhdWx0T3B0aW9ucyA9IHNldERlZmF1bHRPcHRpb25zO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vX2xpYi9kZWZhdWx0T3B0aW9ucy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXREZWZhdWx0T3B0aW9uc1xuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgZGVmYXVsdCBvcHRpb25zIGluY2x1ZGluZyBsb2NhbGUuXG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0cyB0aGUgZGVmYXVsdHMgZm9yXG4gKiBgb3B0aW9ucy5sb2NhbGVgLCBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgXG4gKiBhcmd1bWVudHMgZm9yIGFsbCBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCBnbG9iYWwgbG9jYWxlOlxuICogaW1wb3J0IHsgZXMgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUnXG4gKiBzZXREZWZhdWx0T3B0aW9ucyh7IGxvY2FsZTogZXMgfSlcbiAqIGNvbnN0IHJlc3VsdCA9IGZvcm1hdChuZXcgRGF0ZSgyMDE0LCA4LCAyKSwgJ1BQUFAnKVxuICogLy89PiAnbWFydGVzLCAyIGRlIHNlcHRpZW1icmUgZGUgMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3RhcnQgb2YgdGhlIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyKSlcbiAqIC8vPT4gU3VuIEF1ZyAzMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0YXJ0IG9mIHRoZSB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0LFxuICogLy8gd2hlbiB3ZSBzZXQgdGhhdCB3ZWVrIHN0YXJ0cyBvbiBNb25kYXkgYnkgZGVmYXVsdDpcbiAqIHNldERlZmF1bHRPcHRpb25zKHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyKSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE1hbnVhbGx5IHNldCBvcHRpb25zIHRha2UgcHJpb3JpdHkgb3ZlciBkZWZhdWx0IG9wdGlvbnM6XG4gKiBzZXREZWZhdWx0T3B0aW9ucyh7IHdlZWtTdGFydHNPbjogMSB9KVxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiksIHsgd2Vla1N0YXJ0c09uOiAwIH0pXG4gKiAvLz0+IFN1biBBdWcgMzEgMjAxNCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZW1vdmUgdGhlIG9wdGlvbiBieSBzZXR0aW5nIGl0IHRvIGB1bmRlZmluZWRgOlxuICogc2V0RGVmYXVsdE9wdGlvbnMoeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAqIHNldERlZmF1bHRPcHRpb25zKHsgd2Vla1N0YXJ0c09uOiB1bmRlZmluZWQgfSlcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIpKVxuICogLy89PiBTdW4gQXVnIDMxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoMCwgX2luZGV4LmdldERlZmF1bHRPcHRpb25zKSgpO1xuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRPcHRpb25zLCBwcm9wZXJ0eSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEkgY2hhbGxhbmdlIHlvdSB0byBmaXggdGhlIHR5cGVcbiAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBkZWZhdWx0T3B0aW9uc1twcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBwcm9wZXJ0eSkpIHtcbiAgICAgIGlmIChvcHRpb25zW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEkgY2hhbGxhbmdlIHlvdSB0byBmaXggdGhlIHR5cGVcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtwcm9wZXJ0eV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAoMCwgX2luZGV4LnNldERlZmF1bHRPcHRpb25zKShyZXN1bHQpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldEhvdXJzID0gc2V0SG91cnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHNldEhvdXJzXG4gKiBAY2F0ZWdvcnkgSG91ciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIGhvdXJzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0IHRoZSBob3VycyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBob3VycyAtIFRoZSBob3VycyBvZiB0aGUgbmV3IGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgaG91cnMgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCA0IGhvdXJzIHRvIDEgU2VwdGVtYmVyIDIwMTQgMTE6MzA6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRIb3VycyhuZXcgRGF0ZSgyMDE0LCA4LCAxLCAxMSwgMzApLCA0KVxuICogLy89PiBNb24gU2VwIDAxIDIwMTQgMDQ6MzA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0SG91cnMoZGF0ZSwgaG91cnMpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIF9kYXRlLnNldEhvdXJzKGhvdXJzKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldElTT0RheSA9IHNldElTT0RheTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGREYXlzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9nZXRJU09EYXkuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXRJU09EYXlcbiAqIEBjYXRlZ29yeSBXZWVrZGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgZGF5IG9mIHRoZSBJU08gd2VlayB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNldCB0aGUgZGF5IG9mIHRoZSBJU08gd2VlayB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIElTTyB3ZWVrIHN0YXJ0cyB3aXRoIE1vbmRheS5cbiAqIDcgaXMgdGhlIGluZGV4IG9mIFN1bmRheSwgMSBpcyB0aGUgaW5kZXggb2YgTW9uZGF5IGV0Yy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBkYXkgLSBUaGUgZGF5IG9mIHRoZSBJU08gd2VlayBvZiB0aGUgbmV3IGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgZGF5IG9mIHRoZSBJU08gd2VlayBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IFN1bmRheSB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc2V0SVNPRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDEpLCA3KVxuICogLy89PiBTdW4gU2VwIDA3IDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0SVNPRGF5KGRhdGUsIGRheSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgzLnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGN1cnJlbnREYXkgPSAoMCwgX2luZGV4Mi5nZXRJU09EYXkpKF9kYXRlKTtcbiAgY29uc3QgZGlmZiA9IGRheSAtIGN1cnJlbnREYXk7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZERheXMpKF9kYXRlLCBkaWZmKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zZXRJU09XZWVrID0gc2V0SVNPV2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZXRJU09XZWVrLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc2V0SVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgSVNPIHdlZWsgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIElTTyB3ZWVrIHRvIHRoZSBnaXZlbiBkYXRlLCBzYXZpbmcgdGhlIHdlZWtkYXkgbnVtYmVyLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB3ZWVrIC0gVGhlIElTTyB3ZWVrIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBJU08gd2VlayBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHRoZSA1M3JkIElTTyB3ZWVrIHRvIDcgQXVndXN0IDIwMDQ6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRJU09XZWVrKG5ldyBEYXRlKDIwMDQsIDcsIDcpLCA1MylcbiAqIC8vPT4gU2F0IEphbiAwMSAyMDA1IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHNldElTT1dlZWsoZGF0ZSwgd2Vlaykge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGRpZmYgPSAoMCwgX2luZGV4LmdldElTT1dlZWspKF9kYXRlKSAtIHdlZWs7XG4gIF9kYXRlLnNldERhdGUoX2RhdGUuZ2V0RGF0ZSgpIC0gZGlmZiAqIDcpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc2V0SVNPV2Vla1llYXIgPSBzZXRJU09XZWVrWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrWWVhci5qc1wiKTtcbnZhciBfaW5kZXg0ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHNldElTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgU2V0IHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhciB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNldCB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUsXG4gKiBzYXZpbmcgdGhlIHdlZWsgbnVtYmVyIGFuZCB0aGUgd2Vla2RheSBudW1iZXIuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHdlZWtZZWFyIC0gVGhlIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIDIwMDcgdG8gMjkgRGVjZW1iZXIgMjAwODpcbiAqIGNvbnN0IHJlc3VsdCA9IHNldElTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDgsIDExLCAyOSksIDIwMDcpXG4gKiAvLz0+IE1vbiBKYW4gMDEgMjAwNyAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzZXRJU09XZWVrWWVhcihkYXRlLCB3ZWVrWWVhcikge1xuICBsZXQgX2RhdGUgPSAoMCwgX2luZGV4NC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkaWZmID0gKDAsIF9pbmRleDIuZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKShcbiAgICBfZGF0ZSxcbiAgICAoMCwgX2luZGV4My5zdGFydE9mSVNPV2Vla1llYXIpKF9kYXRlKSxcbiAgKTtcbiAgY29uc3QgZm91cnRoT2ZKYW51YXJ5ID0gKDAsIF9pbmRleC5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldEZ1bGxZZWFyKHdlZWtZZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBfZGF0ZSA9ICgwLCBfaW5kZXgzLnN0YXJ0T2ZJU09XZWVrWWVhcikoZm91cnRoT2ZKYW51YXJ5KTtcbiAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldE1pbGxpc2Vjb25kcyA9IHNldE1pbGxpc2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc2V0TWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU2V0IHRoZSBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBUaGUgbWlsbGlzZWNvbmRzIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCAzMDAgbWlsbGlzZWNvbmRzIHRvIDEgU2VwdGVtYmVyIDIwMTQgMTE6MzA6NDAuNTAwOlxuICogY29uc3QgcmVzdWx0ID0gc2V0TWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDgsIDEsIDExLCAzMCwgNDAsIDUwMCksIDMwMClcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDExOjMwOjQwLjMwMFxuICovXG5mdW5jdGlvbiBzZXRNaWxsaXNlY29uZHMoZGF0ZSwgbWlsbGlzZWNvbmRzKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXRNaWxsaXNlY29uZHMobWlsbGlzZWNvbmRzKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldE1pbnV0ZXMgPSBzZXRNaW51dGVzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXRNaW51dGVzXG4gKiBAY2F0ZWdvcnkgTWludXRlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNldCB0aGUgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBtaW51dGVzIC0gVGhlIG1pbnV0ZXMgb2YgdGhlIG5ldyBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbnV0ZXMgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCA0NSBtaW51dGVzIHRvIDEgU2VwdGVtYmVyIDIwMTQgMTE6MzA6NDA6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDgsIDEsIDExLCAzMCwgNDApLCA0NSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDExOjQ1OjQwXG4gKi9cbmZ1bmN0aW9uIHNldE1pbnV0ZXMoZGF0ZSwgbWludXRlcykge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgX2RhdGUuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldE1vbnRoID0gc2V0TW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZ2V0RGF5c0luTW9udGguanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXRNb250aFxuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgbW9udGggdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIG1vbnRoIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIG1vbnRoIC0gVGhlIG1vbnRoIGluZGV4IHRvIHNldCAoMC0xMSlcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgbW9udGggc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCBGZWJydWFyeSB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc2V0TW9udGgobmV3IERhdGUoMjAxNCwgOCwgMSksIDEpXG4gKiAvLz0+IFNhdCBGZWIgMDEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzZXRNb250aChkYXRlLCBtb250aCkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgzLnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXRlKCk7XG5cbiAgY29uc3QgZGF0ZVdpdGhEZXNpcmVkTW9udGggPSAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIDApO1xuICBkYXRlV2l0aERlc2lyZWRNb250aC5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMTUpO1xuICBkYXRlV2l0aERlc2lyZWRNb250aC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3QgZGF5c0luTW9udGggPSAoMCwgX2luZGV4Mi5nZXREYXlzSW5Nb250aCkoZGF0ZVdpdGhEZXNpcmVkTW9udGgpO1xuICAvLyBTZXQgdGhlIGxhc3QgZGF5IG9mIHRoZSBuZXcgbW9udGhcbiAgLy8gaWYgdGhlIG9yaWdpbmFsIGRhdGUgd2FzIHRoZSBsYXN0IGRheSBvZiB0aGUgbG9uZ2VyIG1vbnRoXG4gIF9kYXRlLnNldE1vbnRoKG1vbnRoLCBNYXRoLm1pbihkYXksIGRheXNJbk1vbnRoKSk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zZXRRdWFydGVyID0gc2V0UXVhcnRlcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zZXRNb250aC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHNldFF1YXJ0ZXJcbiAqIEBjYXRlZ29yeSBRdWFydGVyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgeWVhciBxdWFydGVyIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0IHRoZSB5ZWFyIHF1YXJ0ZXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gcXVhcnRlciAtIFRoZSBxdWFydGVyIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBxdWFydGVyIHNldFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXQgdGhlIDJuZCBxdWFydGVyIHRvIDIgSnVseSAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc2V0UXVhcnRlcihuZXcgRGF0ZSgyMDE0LCA2LCAyKSwgMilcbiAqIC8vPT4gV2VkIEFwciAwMiAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHNldFF1YXJ0ZXIoZGF0ZSwgcXVhcnRlcikge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgyLnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IG9sZFF1YXJ0ZXIgPSBNYXRoLnRydW5jKF9kYXRlLmdldE1vbnRoKCkgLyAzKSArIDE7XG4gIGNvbnN0IGRpZmYgPSBxdWFydGVyIC0gb2xkUXVhcnRlcjtcbiAgcmV0dXJuICgwLCBfaW5kZXguc2V0TW9udGgpKF9kYXRlLCBfZGF0ZS5nZXRNb250aCgpICsgZGlmZiAqIDMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldFNlY29uZHMgPSBzZXRTZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXRTZWNvbmRzXG4gKiBAY2F0ZWdvcnkgU2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNldCB0aGUgc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIHNlY29uZHMgb2YgdGhlIG5ldyBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIHNlY29uZHMgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCA0NSBzZWNvbmRzIHRvIDEgU2VwdGVtYmVyIDIwMTQgMTE6MzA6NDA6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRTZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDgsIDEsIDExLCAzMCwgNDApLCA0NSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDExOjMwOjQ1XG4gKi9cbmZ1bmN0aW9uIHNldFNlY29uZHMoZGF0ZSwgc2Vjb25kcykge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgX2RhdGUuc2V0U2Vjb25kcyhzZWNvbmRzKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldFdlZWsgPSBzZXRXZWVrO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dldFdlZWsuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIHNldFdlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzZXRXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIGxvY2FsIHdlZWsgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIGxvY2FsIHdlZWsgdG8gdGhlIGdpdmVuIGRhdGUsIHNhdmluZyB0aGUgd2Vla2RheSBudW1iZXIuXG4gKiBUaGUgZXhhY3QgY2FsY3VsYXRpb24gZGVwZW5kcyBvbiB0aGUgdmFsdWVzIG9mXG4gKiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gICh3aGljaCBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaylcbiAqIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgICh3aGljaCBpcyB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzIGFsd2F5cyBpblxuICogdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIpXG4gKlxuICogV2VlayBudW1iZXJpbmc6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlZWsjVGhlX0lTT193ZWVrX2RhdGVfc3lzdGVtXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gd2VlayAtIFRoZSB3ZWVrIG9mIHRoZSBuZXcgZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIGxvY2FsIHdlZWsgc2V0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCB0aGUgMXN0IHdlZWsgdG8gMiBKYW51YXJ5IDIwMDUgd2l0aCBkZWZhdWx0IG9wdGlvbnM6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRXZWVrKG5ldyBEYXRlKDIwMDUsIDAsIDIpLCAxKVxuICogLy89PiBTdW4gRGVjIDI2IDIwMDQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHRoZSAxc3Qgd2VlayB0byAyIEphbnVhcnkgMjAwNSxcbiAqIC8vIGlmIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLFxuICogLy8gYW5kIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGFsd2F5cyBjb250YWlucyA0IEphbnVhcnk6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRXZWVrKG5ldyBEYXRlKDIwMDUsIDAsIDIpLCAxLCB7XG4gKiAgIHdlZWtTdGFydHNPbjogMSxcbiAqICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0XG4gKiB9KVxuICogLy89PiBTdW4gSmFuIDQgMjAwNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzZXRXZWVrKGRhdGUsIHdlZWssIG9wdGlvbnMpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4Mi50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkaWZmID0gKDAsIF9pbmRleC5nZXRXZWVrKShfZGF0ZSwgb3B0aW9ucykgLSB3ZWVrO1xuICBfZGF0ZS5zZXREYXRlKF9kYXRlLmdldERhdGUoKSAtIGRpZmYgKiA3KTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldFdlZWtZZWFyID0gc2V0V2Vla1llYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9zdGFydE9mV2Vla1llYXIuanNcIik7XG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxudmFyIF9pbmRleDUgPSByZXF1aXJlKFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLmpzXCIpO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgc2V0V2Vla1llYXJ9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzZXRXZWVrWWVhclxuICogQGNhdGVnb3J5IFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgU2V0IHRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0IHRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIHRvIHRoZSBnaXZlbiBkYXRlLFxuICogc2F2aW5nIHRoZSB3ZWVrIG51bWJlciBhbmQgdGhlIHdlZWtkYXkgbnVtYmVyLlxuICogVGhlIGV4YWN0IGNhbGN1bGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlcyBvZlxuICogYG9wdGlvbnMud2Vla1N0YXJ0c09uYCAod2hpY2ggaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWspXG4gKiBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAod2hpY2ggaXMgdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW5cbiAqIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyKVxuICpcbiAqIFdlZWsgbnVtYmVyaW5nOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWVrI1RoZV9JU09fd2Vla19kYXRlX3N5c3RlbVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHdlZWtZZWFyIC0gVGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIG5ldyBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciBzZXRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IHRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIDIwMDQgdG8gMiBKYW51YXJ5IDIwMTAgd2l0aCBkZWZhdWx0IG9wdGlvbnM6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDEwLCAwLCAyKSwgMjAwNClcbiAqIC8vPT4gU2F0IEphbiAwMyAyMDA0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNldCB0aGUgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAyMDA0IHRvIDIgSmFudWFyeSAyMDEwLFxuICogLy8gaWYgTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2Ygd2Vla1xuICogLy8gYW5kIDQgSmFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXI6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDEwLCAwLCAyKSwgMjAwNCwge1xuICogICB3ZWVrU3RhcnRzT246IDEsXG4gKiAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICogfSlcbiAqIC8vPT4gU2F0IEphbiAwMSAyMDA1IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHNldFdlZWtZZWFyKGRhdGUsIHdlZWtZZWFyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gKDAsIF9pbmRleDUuZ2V0RGVmYXVsdE9wdGlvbnMpKCk7XG4gIGNvbnN0IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XG4gICAgb3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIDE7XG5cbiAgbGV0IF9kYXRlID0gKDAsIF9pbmRleDQudG9EYXRlKShkYXRlKTtcbiAgY29uc3QgZGlmZiA9ICgwLCBfaW5kZXgyLmRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cykoXG4gICAgX2RhdGUsXG4gICAgKDAsIF9pbmRleDMuc3RhcnRPZldlZWtZZWFyKShfZGF0ZSwgb3B0aW9ucyksXG4gICk7XG4gIGNvbnN0IGZpcnN0V2VlayA9ICgwLCBfaW5kZXguY29uc3RydWN0RnJvbSkoZGF0ZSwgMCk7XG4gIGZpcnN0V2Vlay5zZXRGdWxsWWVhcih3ZWVrWWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBfZGF0ZSA9ICgwLCBfaW5kZXgzLnN0YXJ0T2ZXZWVrWWVhcikoZmlyc3RXZWVrLCBvcHRpb25zKTtcbiAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnNldFllYXIgPSBzZXRZZWFyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdEZyb20uanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzZXRZZWFyXG4gKiBAY2F0ZWdvcnkgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0geWVhciAtIFRoZSB5ZWFyIG9mIHRoZSBuZXcgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSB5ZWFyIHNldFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXQgeWVhciAyMDEzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzZXRZZWFyKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCAyMDEzKVxuICogLy89PiBTdW4gU2VwIDAxIDIwMTMgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0WWVhcihkYXRlLCB5ZWFyKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDIudG9EYXRlKShkYXRlKTtcblxuICAvLyBDaGVjayBpZiBkYXRlIGlzIEludmFsaWQgRGF0ZSBiZWNhdXNlIERhdGUucHJvdG90eXBlLnNldEZ1bGxZZWFyIGlnbm9yZXMgdGhlIHZhbHVlIG9mIEludmFsaWQgRGF0ZVxuICBpZiAoaXNOYU4oK19kYXRlKSkge1xuICAgIHJldHVybiAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIE5hTik7XG4gIH1cblxuICBfZGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mRGF5XG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBkYXkgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYSBkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgZGF5IGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZkRheShkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN0YXJ0T2ZEZWNhZGUgPSBzdGFydE9mRGVjYWRlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mRGVjYWRlXG4gKiBAY2F0ZWdvcnkgRGVjYWRlIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBkZWNhZGUgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRlY2FkZSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIGRlY2FkZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBkZWNhZGUgZm9yIDIxIE9jdG9iZXIgMjAxNSAwMDowMDowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZEZWNhZGUobmV3IERhdGUoMjAxNSwgOSwgMjEsIDAwLCAwMCwgMDApKVxuICogLy89PiBKYW4gMDEgMjAxMCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mRGVjYWRlKGRhdGUpIHtcbiAgLy8gVE9ETzogU3dpdGNoIHRvIG1vcmUgdGVjaG5pY2FsIGRlZmluaXRpb24gaW4gb2YgZGVjYWRlcyB0aGF0IHN0YXJ0IHdpdGggMVxuICAvLyBlbmQgd2l0aCAwLiBJLmUuIDIwMDEtMjAxMCBpbnN0ZWFkIG9mIGN1cnJlbnQgMjAwMC0yMDA5LiBJdCdzIGEgYnJlYWtpbmdcbiAgLy8gY2hhbmdlLCBzbyBpdCBjYW4gb25seSBiZSBkb25lIGluIDQuMC5cbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IHllYXIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBkZWNhZGUgPSBNYXRoLmZsb29yKHllYXIgLyAxMCkgKiAxMDtcbiAgX2RhdGUuc2V0RnVsbFllYXIoZGVjYWRlLCAwLCAxKTtcbiAgX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mSG91ciA9IHN0YXJ0T2ZIb3VyO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3RvRGF0ZS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mSG91clxuICogQGNhdGVnb3J5IEhvdXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBob3VyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYW4gaG91ciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYW4gaG91clxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYW4gaG91ciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZIb3VyKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSkpXG4gKiAvLz0+IFR1ZSBTZXAgMDIgMjAxNCAxMTowMDowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mSG91cihkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXRNaW51dGVzKDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3RhcnRPZklTT1dlZWsgPSBzdGFydE9mSVNPV2VlaztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zdGFydE9mV2Vlay5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mSVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYW4gSVNPIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZJU09XZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCkpXG4gKiAvLz0+IE1vbiBTZXAgMDEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mSVNPV2VlayhkYXRlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnN0YXJ0T2ZXZWVrKShkYXRlLCB7IHdlZWtTdGFydHNPbjogMSB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mSVNPV2Vla1llYXIgPSBzdGFydE9mSVNPV2Vla1llYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2V0SVNPV2Vla1llYXIuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZJU09XZWVrLmpzXCIpO1xudmFyIF9pbmRleDMgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZJU09XZWVrWWVhclxuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcixcbiAqIHdoaWNoIGFsd2F5cyBzdGFydHMgMyBkYXlzIGJlZm9yZSB0aGUgeWVhcidzIGZpcnN0IFRodXJzZGF5LlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYW4gSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1OlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZklTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDYsIDIpKVxuICogLy89PiBNb24gSmFuIDAzIDIwMDUgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZklTT1dlZWtZZWFyKGRhdGUpIHtcbiAgY29uc3QgeWVhciA9ICgwLCBfaW5kZXguZ2V0SVNPV2Vla1llYXIpKGRhdGUpO1xuICBjb25zdCBmb3VydGhPZkphbnVhcnkgPSAoMCwgX2luZGV4My5jb25zdHJ1Y3RGcm9tKShkYXRlLCAwKTtcbiAgZm91cnRoT2ZKYW51YXJ5LnNldEZ1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiAoMCwgX2luZGV4Mi5zdGFydE9mSVNPV2VlaykoZm91cnRoT2ZKYW51YXJ5KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mTWludXRlID0gc3RhcnRPZk1pbnV0ZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZk1pbnV0ZVxuICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbWludXRlIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSBtaW51dGUgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGEgbWludXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIG1pbnV0ZSBmb3IgMSBEZWNlbWJlciAyMDE0IDIyOjE1OjQ1LjQwMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZNaW51dGUobmV3IERhdGUoMjAxNCwgMTEsIDEsIDIyLCAxNSwgNDUsIDQwMCkpXG4gKiAvLz0+IE1vbiBEZWMgMDEgMjAxNCAyMjoxNTowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mTWludXRlKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIF9kYXRlLnNldFNlY29uZHMoMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mTW9udGggPSBzdGFydE9mTW9udGg7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZNb250aFxuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBtb250aCBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGEgbW9udGhcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgbW9udGggZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZNb250aChkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBfZGF0ZS5zZXREYXRlKDEpO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN0YXJ0T2ZRdWFydGVyID0gc3RhcnRPZlF1YXJ0ZXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZRdWFydGVyXG4gKiBAY2F0ZWdvcnkgUXVhcnRlciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgeWVhciBxdWFydGVyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSB5ZWFyIHF1YXJ0ZXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGEgcXVhcnRlclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBxdWFydGVyIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZlF1YXJ0ZXIobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gVHVlIEp1bCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZRdWFydGVyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IGN1cnJlbnRNb250aCA9IF9kYXRlLmdldE1vbnRoKCk7XG4gIGNvbnN0IG1vbnRoID0gY3VycmVudE1vbnRoIC0gKGN1cnJlbnRNb250aCAlIDMpO1xuICBfZGF0ZS5zZXRNb250aChtb250aCwgMSk7XG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3RhcnRPZlNlY29uZCA9IHN0YXJ0T2ZTZWNvbmQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZTZWNvbmRcbiAqIEBjYXRlZ29yeSBTZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIHNlY29uZCBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgc2Vjb25kIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIHNlY29uZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBzZWNvbmQgZm9yIDEgRGVjZW1iZXIgMjAxNCAyMjoxNTo0NS40MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mU2Vjb25kKG5ldyBEYXRlKDIwMTQsIDExLCAxLCAyMiwgMTUsIDQ1LCA0MDApKVxuICogLy89PiBNb24gRGVjIDAxIDIwMTQgMjI6MTU6NDUuMDAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgudG9EYXRlKShkYXRlKTtcbiAgX2RhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3RhcnRPZlRvZGF5ID0gc3RhcnRPZlRvZGF5O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZEYXkuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZlRvZGF5XG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgdG9kYXkuXG4gKiBAcHVyZSBmYWxzZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiB0b2RheS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgdG9kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mVG9kYXkoKVxuICogLy89PiBNb24gT2N0IDYgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mVG9kYXkoKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LnN0YXJ0T2ZEYXkpKERhdGUubm93KCkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN0YXJ0T2ZUb21vcnJvdyA9IHN0YXJ0T2ZUb21vcnJvdzsgLyoqXG4gKiBAbmFtZSBzdGFydE9mVG9tb3Jyb3dcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiB0b21vcnJvdy5cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIHRvbW9ycm93LlxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiB0b21vcnJvd1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyA2IE9jdG9iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZUb21vcnJvdygpXG4gKiAvLz0+IFR1ZSBPY3QgNyAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZUb21vcnJvdygpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgeWVhciA9IG5vdy5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBtb250aCA9IG5vdy5nZXRNb250aCgpO1xuICBjb25zdCBkYXkgPSBub3cuZ2V0RGF0ZSgpO1xuXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgZGF5ICsgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN0YXJ0T2ZXZWVrID0gc3RhcnRPZldlZWs7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vdG9EYXRlLmpzXCIpO1xuXG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBzdGFydE9mV2Vla30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCkpXG4gKiAvLz0+IFN1biBBdWcgMzEgMjAxNCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0aGUgd2VlayBzdGFydHMgb24gTW9uZGF5LCB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApLCB7IHdlZWtTdGFydHNPbjogMSB9KVxuICogLy89PiBNb24gU2VwIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZldlZWsoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9ICgwLCBfaW5kZXgyLmdldERlZmF1bHRPcHRpb25zKSgpO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleC50b0RhdGUpKGRhdGUpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG5cbiAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgLSBkaWZmKTtcbiAgX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mV2Vla1llYXIgPSBzdGFydE9mV2Vla1llYXI7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vZ2V0V2Vla1llYXIuanNcIik7XG52YXIgX2luZGV4MyA9IHJlcXVpcmUoXCIuL3N0YXJ0T2ZXZWVrLmpzXCIpO1xuXG52YXIgX2luZGV4NCA9IHJlcXVpcmUoXCIuL19saWIvZGVmYXVsdE9wdGlvbnMuanNcIik7XG5cbi8qKlxuICogVGhlIHtAbGluayBzdGFydE9mV2Vla1llYXJ9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mV2Vla1llYXJcbiAqIEBjYXRlZ29yeSBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyLlxuICogVGhlIGV4YWN0IGNhbGN1bGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlcyBvZlxuICogYG9wdGlvbnMud2Vla1N0YXJ0c09uYCAod2hpY2ggaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWspXG4gKiBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAod2hpY2ggaXMgdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW5cbiAqIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyKVxuICpcbiAqIFdlZWsgbnVtYmVyaW5nOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWVrI1RoZV9JU09fd2Vla19kYXRlX3N5c3RlbVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGFuIGEgd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgMiBKdWx5IDIwMDUgd2l0aCBkZWZhdWx0IHNldHRpbmdzOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDYsIDIpKVxuICogLy89PiBTdW4gRGVjIDI2IDIwMDQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgMiBKdWx5IDIwMDVcbiAqIC8vIGlmIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHdlZWtcbiAqIC8vIGFuZCA0IEphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDYsIDIpLCB7XG4gKiAgIHdlZWtTdGFydHNPbjogMSxcbiAqICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiA0XG4gKiB9KVxuICogLy89PiBNb24gSmFuIDAzIDIwMDUgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZldlZWtZZWFyKGRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoMCwgX2luZGV4NC5nZXREZWZhdWx0T3B0aW9ucykoKTtcbiAgY29uc3QgZmlyc3RXZWVrQ29udGFpbnNEYXRlID1cbiAgICBvcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBvcHRpb25zPy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgMTtcblxuICBjb25zdCB5ZWFyID0gKDAsIF9pbmRleDIuZ2V0V2Vla1llYXIpKGRhdGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdFdlZWsgPSAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGRhdGUsIDApO1xuICBmaXJzdFdlZWsuc2V0RnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBfZGF0ZSA9ICgwLCBfaW5kZXgzLnN0YXJ0T2ZXZWVrKShmaXJzdFdlZWssIG9wdGlvbnMpO1xuICByZXR1cm4gX2RhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3RhcnRPZlllYXIgPSBzdGFydE9mWWVhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi90b0RhdGUuanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdEZyb20uanNcIik7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZlllYXJcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgeWVhciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZZZWFyKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMDApKVxuICogLy89PiBXZWQgSmFuIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZlllYXIoZGF0ZSkge1xuICBjb25zdCBjbGVhbkRhdGUgPSAoMCwgX2luZGV4LnRvRGF0ZSkoZGF0ZSk7XG4gIGNvbnN0IF9kYXRlID0gKDAsIF9pbmRleDIuY29uc3RydWN0RnJvbSkoZGF0ZSwgMCk7XG4gIF9kYXRlLnNldEZ1bGxZZWFyKGNsZWFuRGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdGFydE9mWWVzdGVyZGF5ID0gc3RhcnRPZlllc3RlcmRheTsgLyoqXG4gKiBAbmFtZSBzdGFydE9mWWVzdGVyZGF5XG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgeWVzdGVyZGF5LlxuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgeWVzdGVyZGF5LlxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiB5ZXN0ZXJkYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mWWVzdGVyZGF5KClcbiAqIC8vPT4gU3VuIE9jdCA1IDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZlllc3RlcmRheSgpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgeWVhciA9IG5vdy5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBtb250aCA9IG5vdy5nZXRNb250aCgpO1xuICBjb25zdCBkYXkgPSBub3cuZ2V0RGF0ZSgpO1xuXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgZGF5IC0gMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN1YiA9IHN1YjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9zdWJEYXlzLmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi9zdWJNb250aHMuanNcIik7XG5cbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vY29uc3RydWN0RnJvbS5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCB5ZWFycywgbW9udGhzLCB3ZWVrcywgZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgb2JqZWN0IHdpdGggeWVhcnMsIG1vbnRocywgd2Vla3MsIGRheXMsIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWRcbiAqXG4gKiB8IEtleSAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCB5ZWFycyAgIHwgQW1vdW50IG9mIHllYXJzIHRvIGJlIHN1YnRyYWN0ZWQgICB8XG4gKiB8IG1vbnRocyAgfCBBbW91bnQgb2YgbW9udGhzIHRvIGJlIHN1YnRyYWN0ZWQgIHxcbiAqIHwgd2Vla3MgICB8IEFtb3VudCBvZiB3ZWVrcyB0byBiZSBzdWJ0cmFjdGVkICAgfFxuICogfCBkYXlzICAgIHwgQW1vdW50IG9mIGRheXMgdG8gYmUgc3VidHJhY3RlZCAgICB8XG4gKiB8IGhvdXJzICAgfCBBbW91bnQgb2YgaG91cnMgdG8gYmUgc3VidHJhY3RlZCAgIHxcbiAqIHwgbWludXRlcyB8IEFtb3VudCBvZiBtaW51dGVzIHRvIGJlIHN1YnRyYWN0ZWQgfFxuICogfCBzZWNvbmRzIHwgQW1vdW50IG9mIHNlY29uZHMgdG8gYmUgc3VidHJhY3RlZCB8XG4gKlxuICogQWxsIHZhbHVlcyBkZWZhdWx0IHRvIDBcbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgc2Vjb25kcyBzdWJ0cmFjdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IHRoZSBmb2xsb3dpbmcgZHVyYXRpb24gZnJvbSAxNSBKdW5lIDIwMTcgMTU6Mjk6MjBcbiAqIGNvbnN0IHJlc3VsdCA9IHN1YihuZXcgRGF0ZSgyMDE3LCA1LCAxNSwgMTUsIDI5LCAyMCksIHtcbiAqICAgeWVhcnM6IDIsXG4gKiAgIG1vbnRoczogOSxcbiAqICAgd2Vla3M6IDEsXG4gKiAgIGRheXM6IDcsXG4gKiAgIGhvdXJzOiA1LFxuICogICBtaW51dGVzOiA5LFxuICogICBzZWNvbmRzOiAzMFxuICogfSlcbiAqIC8vPT4gTW9uIFNlcCAxIDIwMTQgMTA6MTk6NTBcbiAqL1xuZnVuY3Rpb24gc3ViKGRhdGUsIGR1cmF0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICB5ZWFycyA9IDAsXG4gICAgbW9udGhzID0gMCxcbiAgICB3ZWVrcyA9IDAsXG4gICAgZGF5cyA9IDAsXG4gICAgaG91cnMgPSAwLFxuICAgIG1pbnV0ZXMgPSAwLFxuICAgIHNlY29uZHMgPSAwLFxuICB9ID0gZHVyYXRpb247XG5cbiAgLy8gU3VidHJhY3QgeWVhcnMgYW5kIG1vbnRoc1xuICBjb25zdCBkYXRlV2l0aG91dE1vbnRocyA9ICgwLCBfaW5kZXgyLnN1Yk1vbnRocykoZGF0ZSwgbW9udGhzICsgeWVhcnMgKiAxMik7XG5cbiAgLy8gU3VidHJhY3Qgd2Vla3MgYW5kIGRheXNcbiAgY29uc3QgZGF0ZVdpdGhvdXREYXlzID0gKDAsIF9pbmRleC5zdWJEYXlzKShcbiAgICBkYXRlV2l0aG91dE1vbnRocyxcbiAgICBkYXlzICsgd2Vla3MgKiA3LFxuICApO1xuXG4gIC8vIFN1YnRyYWN0IGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzXG4gIGNvbnN0IG1pbnV0ZXN0b1N1YiA9IG1pbnV0ZXMgKyBob3VycyAqIDYwO1xuICBjb25zdCBzZWNvbmRzdG9TdWIgPSBzZWNvbmRzICsgbWludXRlc3RvU3ViICogNjA7XG4gIGNvbnN0IG1zdG9TdWIgPSBzZWNvbmRzdG9TdWIgKiAxMDAwO1xuICBjb25zdCBmaW5hbERhdGUgPSAoMCwgX2luZGV4My5jb25zdHJ1Y3RGcm9tKShcbiAgICBkYXRlLFxuICAgIGRhdGVXaXRob3V0RGF5cy5nZXRUaW1lKCkgLSBtc3RvU3ViLFxuICApO1xuXG4gIHJldHVybiBmaW5hbERhdGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViQnVzaW5lc3NEYXlzID0gc3ViQnVzaW5lc3NEYXlzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZEJ1c2luZXNzRGF5cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJCdXNpbmVzc0RheXNcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgU3Vic3RyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ1c2luZXNzIGRheXMgKG1vbiAtIGZyaSkgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJzdHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnVzaW5lc3MgZGF5cyAobW9uIC0gZnJpKSB0byB0aGUgZ2l2ZW4gZGF0ZSwgaWdub3Jpbmcgd2Vla2VuZHMuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBidXNpbmVzcyBkYXlzIHRvIGJlIHN1YnRyYWN0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIGJ1c2luZXNzIGRheXMgc3VidHJhY3RlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJzdHJhY3QgMTAgYnVzaW5lc3MgZGF5cyBmcm9tIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzdWJCdXNpbmVzc0RheXMobmV3IERhdGUoMjAxNCwgOCwgMSksIDEwKVxuICogLy89PiBNb24gQXVnIDE4IDIwMTQgMDA6MDA6MDAgKHNraXBwZWQgd2Vla2VuZCBkYXlzKVxuICovXG5mdW5jdGlvbiBzdWJCdXNpbmVzc0RheXMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZEJ1c2luZXNzRGF5cykoZGF0ZSwgLWFtb3VudCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViRGF5cyA9IHN1YkRheXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkRGF5cy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJEYXlzXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIGRheXMgdG8gYmUgc3VidHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgZGF5cyBzdWJ0cmFjdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDEwIGRheXMgZnJvbSAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc3ViRGF5cyhuZXcgRGF0ZSgyMDE0LCA4LCAxKSwgMTApXG4gKiAvLz0+IEZyaSBBdWcgMjIgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdWJEYXlzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGREYXlzKShkYXRlLCAtYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdWJIb3VycyA9IHN1YkhvdXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZEhvdXJzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN1YkhvdXJzXG4gKiBAY2F0ZWdvcnkgSG91ciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBob3VycyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaG91cnMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIGhvdXJzIHRvIGJlIHN1YnRyYWN0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIGhvdXJzIHN1YnRyYWN0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgMiBob3VycyBmcm9tIDExIEp1bHkgMjAxNCAwMTowMDowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1YkhvdXJzKG5ldyBEYXRlKDIwMTQsIDYsIDExLCAxLCAwKSwgMilcbiAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDIzOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN1YkhvdXJzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGRIb3VycykoZGF0ZSwgLWFtb3VudCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViSVNPV2Vla1llYXJzID0gc3ViSVNPV2Vla1llYXJzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZElTT1dlZWtZZWFycy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJJU09XZWVrWWVhcnNcbiAqIEBjYXRlZ29yeSBJU08gV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyB0byBiZSBzdWJ0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgc3VidHJhY3RlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA1IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFycyBmcm9tIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiBjb25zdCByZXN1bHQgPSBzdWJJU09XZWVrWWVhcnMobmV3IERhdGUoMjAxNCwgOCwgMSksIDUpXG4gKiAvLz0+IE1vbiBBdWcgMzEgMjAwOSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdWJJU09XZWVrWWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZElTT1dlZWtZZWFycykoZGF0ZSwgLWFtb3VudCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViTWlsbGlzZWNvbmRzID0gc3ViTWlsbGlzZWNvbmRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2FkZE1pbGxpc2Vjb25kcy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBzdWJ0cmFjdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDc1MCBtaWxsaXNlY29uZHMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxuICogY29uc3QgcmVzdWx0ID0gc3ViTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MjkuMjUwXG4gKi9cbmZ1bmN0aW9uIHN1Yk1pbGxpc2Vjb25kcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguYWRkTWlsbGlzZWNvbmRzKShkYXRlLCAtYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdWJNaW51dGVzID0gc3ViTWludXRlcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRNaW51dGVzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN1Yk1pbnV0ZXNcbiAqIEBjYXRlZ29yeSBNaW51dGUgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWludXRlcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWludXRlcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgbWludXRlcyB0byBiZSBzdWJ0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaW51dGVzIHN1YnRyYWN0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgMzAgbWludXRlcyBmcm9tIDEwIEp1bHkgMjAxNCAxMjowMDowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1Yk1pbnV0ZXMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCAwKSwgMzApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMTozMDowMFxuICovXG5mdW5jdGlvbiBzdWJNaW51dGVzKGRhdGUsIGFtb3VudCkge1xuICByZXR1cm4gKDAsIF9pbmRleC5hZGRNaW51dGVzKShkYXRlLCAtYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdWJNb250aHMgPSBzdWJNb250aHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkTW9udGhzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN1Yk1vbnRoc1xuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1vbnRocyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbW9udGhzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiBtb250aHMgdG8gYmUgc3VidHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgbW9udGhzIHN1YnRyYWN0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgNSBtb250aHMgZnJvbSAxIEZlYnJ1YXJ5IDIwMTU6XG4gKiBjb25zdCByZXN1bHQgPSBzdWJNb250aHMobmV3IERhdGUoMjAxNSwgMSwgMSksIDUpXG4gKiAvLz0+IE1vbiBTZXAgMDEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdWJNb250aHMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZE1vbnRocykoZGF0ZSwgLWFtb3VudCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViUXVhcnRlcnMgPSBzdWJRdWFydGVycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRRdWFydGVycy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJRdWFydGVyc1xuICogQGNhdGVnb3J5IFF1YXJ0ZXIgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhciBxdWFydGVycyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhciBxdWFydGVycyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgcXVhcnRlcnMgdG8gYmUgc3VidHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgcXVhcnRlcnMgc3VidHJhY3RlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCAzIHF1YXJ0ZXJzIGZyb20gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1YlF1YXJ0ZXJzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCAzKVxuICogLy89PiBTdW4gRGVjIDAxIDIwMTMgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3ViUXVhcnRlcnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZFF1YXJ0ZXJzKShkYXRlLCAtYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5zdWJTZWNvbmRzID0gc3ViU2Vjb25kcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRTZWNvbmRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHN1YlNlY29uZHNcbiAqIEBjYXRlZ29yeSBTZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2Ygc2Vjb25kcyB0byBiZSBzdWJ0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBzZWNvbmRzIHN1YnRyYWN0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgMzAgc2Vjb25kcyBmcm9tIDEwIEp1bHkgMjAxNCAxMjo0NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1YlNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMCksIDMwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDQ6MzBcbiAqL1xuZnVuY3Rpb24gc3ViU2Vjb25kcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguYWRkU2Vjb25kcykoZGF0ZSwgLWFtb3VudCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuc3ViV2Vla3MgPSBzdWJXZWVrcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9hZGRXZWVrcy5qc1wiKTtcblxuLyoqXG4gKiBAbmFtZSBzdWJXZWVrc1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygd2Vla3MgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHdlZWtzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB3ZWVrcyB0byBiZSBzdWJ0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZSB3aXRoIHRoZSB3ZWVrcyBzdWJ0cmFjdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN1YnRyYWN0IDQgd2Vla3MgZnJvbSAxIFNlcHRlbWJlciAyMDE0OlxuICogY29uc3QgcmVzdWx0ID0gc3ViV2Vla3MobmV3IERhdGUoMjAxNCwgOCwgMSksIDQpXG4gKiAvLz0+IE1vbiBBdWcgMDQgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdWJXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguYWRkV2Vla3MpKGRhdGUsIC1hbW91bnQpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnN1YlllYXJzID0gc3ViWWVhcnM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYWRkWWVhcnMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgc3ViWWVhcnNcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHllYXJzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB5ZWFycyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgeWVhcnMgdG8gYmUgc3VidHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRhdGUgd2l0aCB0aGUgeWVhcnMgc3VidHJhY3RlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA1IHllYXJzIGZyb20gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN1YlllYXJzKG5ldyBEYXRlKDIwMTQsIDgsIDEpLCA1KVxuICogLy89PiBUdWUgU2VwIDAxIDIwMDkgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3ViWWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmFkZFllYXJzKShkYXRlLCAtYW1vdW50KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy50b0RhdGUgPSB0b0RhdGU7XG5cbi8qKlxuICogQG5hbWUgdG9EYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqICoqTm90ZSoqOiAqYWxsKiBEYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYW55ICpkYXRlLWZucyogZnVuY3Rpb24gaXMgcHJvY2Vzc2VkIGJ5IGB0b0RhdGVgLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBhcmd1bWVudCAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCB0aGUgdGltZXN0YW1wIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKi9cbmZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCkge1xuICBjb25zdCBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpO1xuXG4gIC8vIENsb25lIHRoZSBkYXRlXG4gIGlmIChcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAodHlwZW9mIGFyZ3VtZW50ID09PSBcIm9iamVjdFwiICYmIGFyZ1N0ciA9PT0gXCJbb2JqZWN0IERhdGVdXCIpXG4gICkge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgYXJndW1lbnQuY29uc3RydWN0b3IoK2FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09IFwibnVtYmVyXCIgfHxcbiAgICBhcmdTdHIgPT09IFwiW29iamVjdCBOdW1iZXJdXCIgfHxcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBhcmdTdHIgPT09IFwiW29iamVjdCBTdHJpbmddXCJcbiAgKSB7XG4gICAgLy8gVE9ETzogQ2FuIHdlIGdldCByaWQgb2YgYXM/XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBDYW4gd2UgZ2V0IHJpZCBvZiBhcz9cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RGcm9tLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHRyYW5zcG9zZVxuICogQGNhdGVnb3J5IEdlbmVyaWMgSGVscGVyc1xuICogQHN1bW1hcnkgVHJhbnNwb3NlIHRoZSBkYXRlIHRvIHRoZSBnaXZlbiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBmdW5jdGlvbiB0cmFuc3Bvc2VzIHRoZSBkYXRlIHRvIHRoZSBnaXZlbiBjb25zdHJ1Y3Rvci4gSXQgaGVscHMgeW91XG4gKiB0byB0cmFuc3Bvc2UgdGhlIGRhdGUgaW4gdGhlIHN5c3RlbSB0aW1lIHpvbmUgdG8gc2F5IGBVVENEYXRlYCBvciBhbnkgb3RoZXJcbiAqIGRhdGUgZXh0ZW5zaW9uLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZUlucHV0VHlwZSAtIFRoZSBpbnB1dCBgRGF0ZWAgdHlwZSBkZXJpdmVkIGZyb20gdGhlIHBhc3NlZCBhcmd1bWVudC5cbiAqIEB0eXBlUGFyYW0gRGF0ZU91dHB1dFR5cGUgLSBUaGUgb3V0cHV0IGBEYXRlYCB0eXBlIGRlcml2ZWQgZnJvbSB0aGUgcGFzc2VkIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSBmcm9tRGF0ZSAtIFRoZSBkYXRlIHRvIHVzZSB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIGNvbnN0cnVjdG9yIC0gVGhlIGRhdGUgY29uc3RydWN0b3IgdG8gdXNlXG4gKlxuICogQHJldHVybnMgRGF0ZSB0cmFuc3Bvc2VkIHRvIHRoZSBnaXZlbiBjb25zdHJ1Y3RvclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgSnVseSAxMCwgMjAyMiAwMDowMCBpbiBsb2NhbGUgdGltZSB6b25lXG4gKiBjb25zdCBkYXRlID0gbmV3IERhdGUoMjAyMiwgNiwgMTApXG4gKiAvLz0+ICdTdW4gSnVsIDEwIDIwMjIgMDA6MDA6MDAgR01UKzA4MDAgKFNpbmdhcG9yZSBTdGFuZGFyZCBUaW1lKSdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVHJhbnNwb3NlIHRoZSBkYXRlIHRvIEp1bHkgMTAsIDIwMjIgMDA6MDAgaW4gVVRDXG4gKiB0cmFuc3Bvc2UoZGF0ZSwgVVRDRGF0ZSlcbiAqIC8vPT4gJ1N1biBKdWwgMTAgMjAyMiAwMDowMDowMCBHTVQrMDAwMCAoQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUpJ1xuICovXG5mdW5jdGlvbiB0cmFuc3Bvc2UoZnJvbURhdGUsIGNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IGRhdGUgPVxuICAgIGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgPyAoMCwgX2luZGV4LmNvbnN0cnVjdEZyb20pKGNvbnN0cnVjdG9yLCAwKVxuICAgICAgOiBuZXcgY29uc3RydWN0b3IoMCk7XG4gIGRhdGUuc2V0RnVsbFllYXIoXG4gICAgZnJvbURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICBmcm9tRGF0ZS5nZXRNb250aCgpLFxuICAgIGZyb21EYXRlLmdldERhdGUoKSxcbiAgKTtcbiAgZGF0ZS5zZXRIb3VycyhcbiAgICBmcm9tRGF0ZS5nZXRIb3VycygpLFxuICAgIGZyb21EYXRlLmdldE1pbnV0ZXMoKSxcbiAgICBmcm9tRGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgZnJvbURhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICk7XG4gIHJldHVybiBkYXRlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLndlZWtzVG9EYXlzID0gd2Vla3NUb0RheXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHdlZWtzVG9EYXlzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHdlZWtzIHRvIGRheXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IGEgbnVtYmVyIG9mIHdlZWtzIHRvIGEgZnVsbCBudW1iZXIgb2YgZGF5cy5cbiAqXG4gKiBAcGFyYW0gd2Vla3MgLSBUaGUgbnVtYmVyIG9mIHdlZWtzIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygd2Vla3MgY29udmVydGVkIGluIGRheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCAyIHdlZWtzIGludG8gZGF5c1xuICogY29uc3QgcmVzdWx0ID0gd2Vla3NUb0RheXMoMilcbiAqIC8vPT4gMTRcbiAqL1xuZnVuY3Rpb24gd2Vla3NUb0RheXMod2Vla3MpIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMod2Vla3MgKiBfaW5kZXguZGF5c0luV2Vlayk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMueWVhcnNUb0RheXMgPSB5ZWFyc1RvRGF5cztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgeWVhcnNUb0RheXNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgeWVhcnMgdG8gZGF5cy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgYSBudW1iZXIgb2YgeWVhcnMgdG8gYSBmdWxsIG51bWJlciBvZiBkYXlzLlxuICpcbiAqIEBwYXJhbSB5ZWFycyAtIFRoZSBudW1iZXIgb2YgeWVhcnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiB5ZWFycyBjb252ZXJ0ZWQgaW4gZGF5c1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDIgeWVhcnMgaW50byBkYXlzXG4gKiBjb25zdCByZXN1bHQgPSB5ZWFyc1RvRGF5cygyKVxuICogLy89PiA3MzBcbiAqL1xuZnVuY3Rpb24geWVhcnNUb0RheXMoeWVhcnMpIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeWVhcnMgKiBfaW5kZXguZGF5c0luWWVhcik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMueWVhcnNUb01vbnRocyA9IHllYXJzVG9Nb250aHM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBuYW1lIHllYXJzVG9Nb250aHNcbiAqIEBjYXRlZ29yeSBDb252ZXJzaW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgeWVhcnMgdG8gbW9udGhzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiB5ZWFycyB0byBhIGZ1bGwgbnVtYmVyIG9mIG1vbnRocy5cbiAqXG4gKiBAcGFyYW0geWVhcnMgLSBUaGUgbnVtYmVyIG9mIHllYXJzIHRvIGJlIGNvbnZlcnRlZFxuICpcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgeWVhcnMgY29udmVydGVkIGluIG1vbnRoc1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IDIgeWVhcnMgaW50byBtb250aHNcbiAqIGNvbnN0IHJlc3VsdCA9IHllYXJzVG9Nb250aHMoMilcbiAqIC8vPT4gMjRcbiAqL1xuZnVuY3Rpb24geWVhcnNUb01vbnRocyh5ZWFycykge1xuICByZXR1cm4gTWF0aC50cnVuYyh5ZWFycyAqIF9pbmRleC5tb250aHNJblllYXIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLnllYXJzVG9RdWFydGVycyA9IHllYXJzVG9RdWFydGVycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICogQG5hbWUgeWVhcnNUb1F1YXJ0ZXJzXG4gKiBAY2F0ZWdvcnkgQ29udmVyc2lvbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHllYXJzIHRvIHF1YXJ0ZXJzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCBhIG51bWJlciBvZiB5ZWFycyB0byBhIGZ1bGwgbnVtYmVyIG9mIHF1YXJ0ZXJzLlxuICpcbiAqIEBwYXJhbSB5ZWFycyAtIFRoZSBudW1iZXIgb2YgeWVhcnMgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiB5ZWFycyBjb252ZXJ0ZWQgaW4gcXVhcnRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCAyIHllYXJzIHRvIHF1YXJ0ZXJzXG4gKiBjb25zdCByZXN1bHQgPSB5ZWFyc1RvUXVhcnRlcnMoMilcbiAqIC8vPT4gOFxuICovXG5mdW5jdGlvbiB5ZWFyc1RvUXVhcnRlcnMoeWVhcnMpIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeWVhcnMgKiBfaW5kZXgucXVhcnRlcnNJblllYXIpO1xufVxuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21haW4uY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGlkPVxcXCJfMDE0Nl80MDRfcGFnZV9ub3RfZm91bmRfMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTAwIDUwMFxcXCIgZGF0YS1pbWFnZWlkPVxcXCI0MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgaW1hZ2VOYW1lPVxcXCI0MDQgUGFnZSBOb3QgRm91bmQgMVxcXCIgY2xhc3M9XFxcImlsbHVzdHJhdGlvbnNfaW1hZ2VcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMjE2cHg7XFxcIj48ZGVmcz48c3R5bGU+LmNscy0xXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2e2ZpbGw6I2ZmZjt9LmNscy0yXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2e29wYWNpdHk6LjM5O30uY2xzLTJfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYsLmNscy0zXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2LC5jbHMtNF80MDQtcGFnZS1ub3QtZm91bmQtMS02NiwuY2xzLTVfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYsLmNscy02XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2LC5jbHMtN180MDQtcGFnZS1ub3QtZm91bmQtMS02NiwuY2xzLThfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYsLmNscy05XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2e2ZpbGw6bm9uZTt9LmNscy0xMF80MDQtcGFnZS1ub3QtZm91bmQtMS02NntmaWxsOiNmNGEyOGM7fS5jbHMtM180MDQtcGFnZS1ub3QtZm91bmQtMS02NntvcGFjaXR5Oi41ODt9LmNscy0xMV80MDQtcGFnZS1ub3QtZm91bmQtMS02NntmaWxsOiNjZTgxNzI7fS5jbHMtMTJfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZ7ZmlsbDojZTZlNmU2O30uY2xzLTRfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZ7b3BhY2l0eTouMDM7fS5jbHMtNV80MDQtcGFnZS1ub3QtZm91bmQtMS02NntvcGFjaXR5Oi43Mzt9LmNscy02XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2e29wYWNpdHk6LjA4O30uY2xzLTdfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZ7b3BhY2l0eTouMzE7fS5jbHMtOF80MDQtcGFnZS1ub3QtZm91bmQtMS02NntvcGFjaXR5Oi4zO30uY2xzLTEzXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2e2ZpbGw6IzI0Mjg1Yjt9LmNscy0xNF80MDQtcGFnZS1ub3QtZm91bmQtMS02NntmaWxsOiMwMDAwMDE7fS5jbHMtOV80MDQtcGFnZS1ub3QtZm91bmQtMS02NntvcGFjaXR5Oi4xNTt9LmNscy0xNV80MDQtcGFnZS1ub3QtZm91bmQtMS02NntmaWxsOiNmZmQyMDA7fS5jbHMtMTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZ7ZmlsbDojNjhlMWZkO308L3N0eWxlPjwvZGVmcz48ZyBpZD1cXFwiYmdfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxnIGNsYXNzPVxcXCJjbHMtOF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCI+PHBhdGggY2xhc3M9XFxcImNscy0xMl80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgZD1cXFwibTk2Ljg0LDIwOS42MWMtMzkuMjksNy42My02Ny4wNiw0NC45My02Mi40OCw4NiwyLjQzLDIxLjc5LDEyLjI4LDQxLjAxLDM3LjYsNDYuNTcsNjcuMiwxNC43NSwzMjAuODQsNzAuMjksMzcwLjY4LTI1Ljk0LDM4Ljg1LTc1LjAxLDE1LjctMTI2LjkzLTIwLjM5LTE1OS40My0zNi4wOS0zMi41LTExMC44NS0yNS43NS0xNzIuNjQtMy41MS00Ni4wNSwxNi41Ny04MC4yMSw0Mi4yNC0xNTIuNzcsNTYuMzJaXFxcIj48L3BhdGg+PC9nPjxnIGNsYXNzPVxcXCJjbHMtNF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCI+PGVsbGlwc2UgY2xhc3M9XFxcImNscy0xNF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgY3g9XFxcIjI1Mi43NVxcXCIgY3k9XFxcIjM5OC40MVxcXCIgcng9XFxcIjIyOC43NFxcXCIgcnk9XFxcIjE2LjkxXFxcIj48L2VsbGlwc2U+PC9nPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTJfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGQ9XFxcIm00MzguOTQsMTU0Ljk3YzAtNS4zLTQuMy05LjYxLTkuNjEtOS42MS0uNTMsMC0xLjA0LjA1LTEuNTQuMTQtMi4xOS00LjA2LTYuNDctNi44Mi0xMS40LTYuODItLjE2LDAtLjMyLjAyLS40Ny4wMi4zLTEuMTkuNDctMi40NC40Ny0zLjczLDAtOC40OS02Ljg4LTE1LjM3LTE1LjM3LTE1LjM3cy0xNS4zNyw2Ljg4LTE1LjM3LDE1LjM3YzAsMS4yOS4xOCwyLjUzLjQ3LDMuNzMtLjE2LDAtLjMxLS4wMi0uNDctLjAyLTcuMTUsMC0xMi45NSw1LjgtMTIuOTUsMTIuOTVzNS44LDEyLjk1LDEyLjk1LDEyLjk1aDQ0Ljk0di0uMDljNC43MS0uNjEsOC4zNS00LjYzLDguMzUtOS41MlpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTEyXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIiBkPVxcXCJtMjg0LjY0LDc5LjJjMC00LjU1LTMuNjktOC4yNC04LjI0LTguMjQtLjQ1LDAtLjg5LjA1LTEuMzIuMTItMS44Ny0zLjQ4LTUuNTUtNS44NS05Ljc4LTUuODUtLjE0LDAtLjI3LjAyLS40MS4wMi4yNi0xLjAyLjQxLTIuMDkuNDEtMy4xOSwwLTcuMjgtNS45LTEzLjE4LTEzLjE4LTEzLjE4cy0xMy4xOCw1LjktMTMuMTgsMTMuMThjMCwxLjEuMTUsMi4xNy40MSwzLjE5LS4xNCwwLS4yNy0uMDItLjQxLS4wMi02LjEzLDAtMTEuMSw0Ljk3LTExLjEsMTEuMXM0Ljk3LDExLjEsMTEuMSwxMS4xaDM4LjU0di0uMDhjNC4wNC0uNTIsNy4xNi0zLjk3LDcuMTYtOC4xNlpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTEyXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIiBkPVxcXCJtOTAuOTQsMjM3Ljc0YzAtNC41NS0zLjY5LTguMjQtOC4yNC04LjI0LS40NSwwLS44OS4wNS0xLjMyLjEyLTEuODctMy40OC01LjU1LTUuODUtOS43OC01Ljg1LS4xNCwwLS4yNy4wMi0uNDEuMDIuMjYtMS4wMi40MS0yLjA5LjQxLTMuMTksMC03LjI4LTUuOS0xMy4xOC0xMy4xOC0xMy4xOHMtMTMuMTgsNS45LTEzLjE4LDEzLjE4YzAsMS4xLjE1LDIuMTcuNDEsMy4xOS0uMTQsMC0uMjctLjAyLS40MS0uMDItNi4xMywwLTExLjEsNC45Ny0xMS4xLDExLjFzNC45NywxMS4xLDExLjEsMTEuMWgzOC41NHYtLjA4YzQuMDQtLjUyLDcuMTYtMy45Nyw3LjE2LTguMTZaXFxcIj48L3BhdGg+PC9nPjxnIGlkPVxcXCJzdW5fNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxjaXJjbGUgY2xhc3M9XFxcImNscy0xNV80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgY3g9XFxcIjEzMi42XFxcIiBjeT1cXFwiMTAzLjk3XFxcIiByPVxcXCIzMi4zNlxcXCI+PC9jaXJjbGU+PGcgY2xhc3M9XFxcImNscy05XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIj48Y2lyY2xlIGNsYXNzPVxcXCJjbHMtMTVfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGN4PVxcXCIxMzIuNlxcXCIgY3k9XFxcIjEwMy45N1xcXCIgcj1cXFwiNjEuN1xcXCI+PC9jaXJjbGU+PC9nPjwvZz48ZyBpZD1cXFwiXzQwNF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCI+PGNpcmNsZSBjbGFzcz1cXFwiY2xzLTEzXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIiBjeD1cXFwiMjQ5Ljk3XFxcIiBjeT1cXFwiMzE1LjIzXFxcIiByPVxcXCI4Mi40MVxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjbGFzcz1cXFwiY2xzLTFfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGN4PVxcXCIyNDkuOTdcXFwiIGN5PVxcXCIzMTUuMjNcXFwiIHI9XFxcIjUxLjg4XFxcIj48L2NpcmNsZT48cGF0aCBjbGFzcz1cXFwiY2xzLTE2XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2IHRhcmdldENvbG9yXFxcIiBkPVxcXCJtMTUwLjQ4LDMzNC44OGM1LjQ2LDAsNy40MiwxLjk2LDcuNDIsNy40MnY5LjM4YzAsNS40Ni0xLjUzLDcuNDItNy40Miw3LjQyaC0xNS4wNnYyOC41OWMwLDUuNDYtMS45Niw3LjQyLTcuNDIsNy40MmgtMTAuNjljLTUuNDYsMC03LjQyLTEuOTYtNy40Mi03LjQydi0yOC41OUgzNy44OGMtNS40NiwwLTcuNDItMS45Ni03LjQyLTcuNDJ2LTcuODZjMC0zLjcxLjg3LTYuNTUsMi42Mi04Ljk1bDcyLjQ1LTg5LjkxYzIuODQtMy40OSw2LjMzLTUuMjQsMTAuNDctNS4yNGgxMmM1LjQ1LDAsNy40MiwxLjUzLDcuNDIsNy40MnY4Ny43MmgxNS4wNlptLTQwLjU5LTU4LjQ4bC00Ny4zNSw1OC40OGg0Ny4zNXYtNTguNDhaXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy0xNl80MDQtcGFnZS1ub3QtZm91bmQtMS02NiB0YXJnZXRDb2xvclxcXCIgZD1cXFwibTQ2Mi4xMywzMzQuODhjNS40NiwwLDcuNDIsMS45Niw3LjQyLDcuNDJ2OS4zOGMwLDUuNDYtMS41Myw3LjQyLTcuNDIsNy40MmgtMTUuMDZ2MjguNTljMCw1LjQ2LTEuOTYsNy40Mi03LjQyLDcuNDJoLTEwLjY5Yy01LjQ2LDAtNy40Mi0xLjk2LTcuNDItNy40MnYtMjguNTloLTcyLjAxYy01LjQ2LDAtNy40Mi0xLjk2LTcuNDItNy40MnYtNy44NmMwLTMuNzEuODctNi41NSwyLjYyLTguOTVsNzIuNDUtODkuOTFjMi44NC0zLjQ5LDYuMzMtNS4yNCwxMC40Ny01LjI0aDEyYzUuNDUsMCw3LjQyLDEuNTMsNy40Miw3LjQydjg3LjcyaDE1LjA2Wm0tNDAuNTktNTguNDhsLTQ3LjM1LDU4LjQ4aDQ3LjM1di01OC40OFpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48ZyBjbGFzcz1cXFwiY2xzLTNfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIm00MjkuODEsMjIyLjE5cy0xMy43MS0zLjc1LTE2LjctMTYuNTFjMCwwLDIxLjI1LTQuMjksMjEuODUsMTcuNjRsLTUuMTYtMS4xM1pcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48L2c+PGcgY2xhc3M9XFxcImNscy01XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIj48cGF0aCBjbGFzcz1cXFwiY2xzLTE2XzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2IHRhcmdldENvbG9yXFxcIiBkPVxcXCJtNDMxLjQ5LDIyMC44M3MtOS41OC0xNS4xNS0xLjE1LTI5LjMxYzAsMCwxNi4xNiwxMC4yNiw4Ljk4LDI5LjM0bC03LjgzLS4wM1pcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48L2c+PHBhdGggY2xhc3M9XFxcImNscy0xNl80MDQtcGFnZS1ub3QtZm91bmQtMS02NiB0YXJnZXRDb2xvclxcXCIgZD1cXFwibTQzMy45NiwyMjAuODRzNS4wNi0xNiwyMC4zNi0xOS4wM2MwLDAsMi44NywxMC4zOS05LjkxLDE5LjA3bC0xMC40Ni0uMDRaXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcImNscy0xM180MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgcG9pbnRzPVxcXCI0MjQuMDIgMjIwLjQ4IDQyNi43OSAyMzkuNSA0NDQuMyAyMzkuNTcgNDQ2Ljg4IDIyMC41NyA0MjQuMDIgMjIwLjQ4XFxcIj48L3BvbHlnb24+PHBhdGggY2xhc3M9XFxcImNscy0xMF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgZD1cXFwibTI1OS45NCwyMDdzMi4yNiwxMC44OSwxLjI4LDE4LjQyYy0uNCwzLjA2LTMuMjUsNS4yNC02LjMsNC44LTMuNzktLjU1LTguNzUtMi4zOS0xMC42Ny04LjA4bC00LjQ0LTkuMjVzLTIuNTgtNS44OSwzLjExLTExLjExYzUuNjktNS4yMSwxNS45Ny0xLjQ4LDE3LjAyLDUuMjJaXFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcImNscy0xMF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgcG9pbnRzPVxcXCIyNDAuNjEgMjE0LjU3IDIzOS4xNyAyNTAuOTcgMjU5LjI5IDI1MC4zMyAyNTIuMjYgMjI0LjEgMjQwLjYxIDIxNC41N1xcXCI+PC9wb2x5Z29uPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTNfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGQ9XFxcIm0yNTcuMjYsMjA3Ljc5Yy0xLjkyLjMzLTUuNDYuNzQtMTAuMjcuNDIsMCwwLDQuMDIsNC40LDEuMiwxMC4xLTIuODIsNS43LTguNyw0LjA2LTguNyw0LjA2bC0xLjUtMTQuMmMtLjU3LTQuMTMsMS4xNS04LjI0LDQuNTEtMTAuNywxLjM3LTEsMi45LTIuMDIsNC40Ni0yLjg3LDMuODktMi4xMiwxMC4xOS0uMTEsMTMuNTMtMy4zLDEuNDYtMS40LDMuOS0uNzEsNC40MywxLjI0LDEuMTUsNC4yNCwxLjE4LDExLjEyLTQuMzcsMTQuMTctMS4wMi41Ni0yLjE0Ljg4LTMuMjgsMS4wN1pcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTEwXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIiBkPVxcXCJtMjQ5LjMzLDIxNy44NHMtLjU5LTQuMjQtMy43NC0zLjUzYy0zLjE1LjcxLTIuMzQsNi44NCwyLjA2LDYuOWwxLjY4LTMuMzZaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy0xMF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgZD1cXFwibTI2MS4wMSwyMTMuOTNsMy41OCwzLjg5Yy44OC45Ni40NywyLjUxLS43OCwyLjlsLTQuMTMsMS4zLDEuMzItOC4wOVpcXFwiPjwvcGF0aD48ZyBjbGFzcz1cXFwiY2xzLTdfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTFfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGQ9XFxcIm0yNTQuMDQsMjI5Ljc4cy0zLjc3LS4zMS02LjkyLTMuMDljMCwwLDEuMDcsNi41OCw5LjExLDEyLjI1bC0yLjE5LTkuMTdaXFxcIj48L3BhdGg+PC9nPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIm0yMzkuMTcsMjUwLjk3bDIwLjEyLS42NHMzMS41OS01LjM3LDQyLjU2LDIwLjRjMTAuOTcsMjUuNzctMy4xLDYyLjE5LTMuMSw2Mi4xOSwwLDAtMTEuMzksMzguNDUtNTkuNTIsMzQuMTgsMCwwLTQwLjA1LTIuMzItNDQuNTctNTcuMjEtLjItMi4zOS0uNTktNC43Ny0xLjEtNy4xMS0xLjg2LTguNTktMi45My0zNC42NCw0NS42MS01MS44MVpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48ZyBjbGFzcz1cXFwiY2xzLTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTRfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIGQ9XFxcIm0yMTIuMjUsMjg1LjE5czEwLjczLDEuMTYsMjUuNjIsMjYuMTFjMTQuOSwyNC45NSw0NC4xNCwxNS44MSw2MC42My0yLjY1bC0zMC42Niw0MC40OC0zNC4yNy0yLjc0LTE4LjY0LTQ5LjYyLTIuNjktMTEuNThaXFxcIj48L3BhdGg+PC9nPjxyZWN0IGNsYXNzPVxcXCJjbHMtMTVfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIHg9XFxcIjMyNC45NFxcXCIgeT1cXFwiMjI3Ljc4XFxcIiB3aWR0aD1cXFwiNS45NFxcXCIgaGVpZ2h0PVxcXCIxNy4yOVxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTI4LjQyIDQ1LjUpIHJvdGF0ZSgtNy42MSlcXFwiPjwvcmVjdD48ZyBjbGFzcz1cXFwiY2xzLTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiPjxyZWN0IGNsYXNzPVxcXCJjbHMtMTRfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjZcXFwiIHg9XFxcIjMyNC45NFxcXCIgeT1cXFwiMjI3Ljc4XFxcIiB3aWR0aD1cXFwiNS45NFxcXCIgaGVpZ2h0PVxcXCIxNy4yOVxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTI4LjQyIDQ1LjUpIHJvdGF0ZSgtNy42MSlcXFwiPjwvcmVjdD48L2c+PHJlY3QgY2xhc3M9XFxcImNscy0xM180MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgeD1cXFwiMzI1LjRcXFwiIHk9XFxcIjI0MC4xM1xcXCIgd2lkdGg9XFxcIjkuMTRcXFwiIGhlaWdodD1cXFwiMjIuMjJcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKC0zMC4zNiA0NS45KSByb3RhdGUoLTcuNjEpXFxcIj48L3JlY3Q+PHBhdGggY2xhc3M9XFxcImNscy0xNV80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgZD1cXFwibTMyMS40LDE5MS45NmMtMTAuNjcsMS40Mi0xOC4xNiwxMS4yMy0xNi43MywyMS44OSwxLjQyLDEwLjY3LDExLjIzLDE4LjE2LDIxLjg5LDE2LjczLDEwLjY3LTEuNDIsMTguMTYtMTEuMjMsMTYuNzMtMjEuODktMS40Mi0xMC42Ny0xMS4yMy0xOC4xNi0yMS44OS0xNi43M1ptNC40LDMyLjk1Yy03LjUzLDEuMDEtMTQuNDYtNC4yOS0xNS40Ni0xMS44Mi0xLjAxLTcuNTMsNC4yOS0xNC40NiwxMS44Mi0xNS40Niw3LjUzLTEuMDEsMTQuNDYsNC4yOSwxNS40NiwxMS44MiwxLjAxLDcuNTMtNC4yOSwxNC40Ni0xMS44MiwxNS40NlpcXFwiPjwvcGF0aD48Y2lyY2xlIGNsYXNzPVxcXCJjbHMtMV80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgY3g9XFxcIjMyNC4wMlxcXCIgY3k9XFxcIjIxMS4zNFxcXCIgcj1cXFwiMTMuODRcXFwiPjwvY2lyY2xlPjxwYXRoIGNsYXNzPVxcXCJjbHMtMTZfNDA0LXBhZ2Utbm90LWZvdW5kLTEtNjYgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIm0xOTQuMTQsMjg3Ljg4YzIuMTUtOC41LDEzLjQ5LTEwLjE1LDE4LjExLTIuNjksNS43Niw5LjMxLDEzLjMyLDIzLjAyLDE5LjQxLDM5LjI3LDExLjUxLDMwLjcsNjcuOTgsMTAuNDYsODguODItNjEuMTFsMTEuODksNy4zOHMtMTYuNDEsOTIuOTYtODIuNDEsOTYuMzdjMCwwLTQxLjE5LDguMzYtNTMuNy00Mi4yLDAsMC0zLjE0LTkuNTMtMy40Mi0xNC45MWwtLjg4LTYuMDZzLS40OC02LjU5LDIuMTMtMTUuODljMCwwLC4wMS0uMDYuMDQtLjE3WlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxnIGNsYXNzPVxcXCJjbHMtMl80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCI+PHBhdGggY2xhc3M9XFxcImNscy0xXzQwNC1wYWdlLW5vdC1mb3VuZC0xLTY2XFxcIiBkPVxcXCJtMTk0LjE0LDI4Ny44OGMyLjE1LTguNSwxMy40OS0xMC4xNSwxOC4xMS0yLjY5LDUuNzYsOS4zMSwxMy4zMiwyMy4wMiwxOS40MSwzOS4yNywxMS41MSwzMC43LDY3Ljk4LDEwLjQ2LDg4LjgyLTYxLjExbDExLjg5LDcuMzhzLTE2LjQxLDkyLjk2LTgyLjQxLDk2LjM3YzAsMC00MS4xOSw4LjM2LTUzLjctNDIuMiwwLDAtMy4xNC05LjUzLTMuNDItMTQuOTFsLS44OC02LjA2cy0uNDgtNi41OSwyLjEzLTE1Ljg5YzAsMCwuMDEtLjA2LjA0LS4xN1pcXFwiPjwvcGF0aD48L2c+PHBhdGggY2xhc3M9XFxcImNscy0xMF80MDQtcGFnZS1ub3QtZm91bmQtMS02NlxcXCIgZD1cXFwibTMyMy4zOSwyNjUuMTVzMS4yMS0xNS4zMSw3LjUxLTE1LjI5YzYuMy4wMywyMS4xNSwxMS4zNy0xLjc2LDE4Ljg2bC01Ljc1LTMuNTdaXFxcIj48L3BhdGg+PC9nPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiXzAwMjBfY2hlY2tsaXN0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDUwMCA1MDBcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMjEzcHg7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIiBkYXRhLWltYWdlaWQ9XFxcImNoZWNrbGlzdC03MVxcXCIgaW1hZ2VOYW1lPVxcXCJDaGVja2xpc3RcXFwiIGNsYXNzPVxcXCJpbGx1c3RyYXRpb25zX2ltYWdlXFxcIj48c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPiAuc3QwX2NoZWNrbGlzdC03MXtmaWxsOiNGRkZGRkY7fSAuc3QxX2NoZWNrbGlzdC03MXtmaWxsOiMyMzFGMjA7fSAuc3QyX2NoZWNrbGlzdC03MXtmaWxsOiM2OEUxRkQ7fSAuc3QzX2NoZWNrbGlzdC03MXtmaWxsOm5vbmU7fSA8L3N0eWxlPjxnIGlkPVxcXCJDaGFyYWN0ZXJfY2hlY2tsaXN0LTcxXFxcIj48cGF0aCBjbGFzcz1cXFwic3QwX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTMwNy4xLDM2NS44Yy0xOC4yLTEzLjQtMjUuMi0zNy43LTI0LjktNjAuMmMwLjEtMTEuNCwyLjItMjMuNSwxMC4xLTMxLjdjMy44LTMuOSw4LjctNi42LDEzLjgtOC44XFxuXFx0XFx0YzE2LjEtNywzNy42LTguMSw0OC45LDUuNGMzLjMsNCw1LjMsOC44LDcuMiwxMy42YzYuNywxNi43LDEyLjgsMzMuNiwxOC4yLDUwLjhjNS4zLDE2LjksMTEsNDMuNS0xMi45LDQ1XFxuXFx0XFx0QzM0OCwzODEuMSwzMjMuMSwzNzcuNSwzMDcuMSwzNjUuOHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTM2MC4yLDM4MC44Yy0xNy41LDAtMzktMy43LTUzLjUtMTQuNGwwLDBjLTE2LjQtMTItMjUuNS0zNC4yLTI1LjItNjAuOWMwLjItMTQuNywzLjYtMjUuMiwxMC40LTMyLjJcXG5cXHRcXHRjNC40LTQuNSwxMC4xLTcuMiwxNC05YzE2LjUtNy4yLDM4LjMtOC4yLDQ5LjcsNS42YzMuMiwzLjksNS4yLDguNiw3LjQsMTMuOGM2LjcsMTYuNiwxMi44LDMzLjcsMTguMiw1MC44XFxuXFx0XFx0YzUuOSwxOC43LDYuMiwzMS40LDEuMSwzOC44Yy0zLDQuNC04LDYuOC0xNC43LDcuMkMzNjUuMiwzODAuOCwzNjIuNywzODAuOCwzNjAuMiwzODAuOHogTTMwNy41LDM2NS4yXFxuXFx0XFx0YzE2LjQsMTIsNDEuNywxNS4xLDU5LjksMTMuOWM2LjItMC40LDEwLjgtMi42LDEzLjUtNi42YzQuOC03LDQuNC0xOS4yLTEuNC0zNy41Yy01LjMtMTcuMS0xMS40LTM0LjEtMTguMS01MC43XFxuXFx0XFx0Yy0yLjEtNS4xLTQtOS42LTcuMS0xMy40Yy0xMC45LTEzLjItMzItMTIuMi00OC01LjJjLTMuOCwxLjYtOS40LDQuNC0xMy41LDguNmMtNi41LDYuNy05LjgsMTYuOS05LjksMzEuMlxcblxcdFxcdEMyODIuNiwzMzEuNywyOTEuNiwzNTMuNCwzMDcuNSwzNjUuMkwzMDcuNSwzNjUuMnpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QyX2NoZWNrbGlzdC03MSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTExNi43LDI4MC41bC01Mi42LTIxLjdjMTguNy0zOS45LDM5LjctNjMuNiw1NC4zLTcyLjljMTguNi0xNS40LDY0LjYtMTYuNSwxMDYuNy0xOC4xYzAsMCwyMC0xLjcsNDAuMSwzLjlcXG5cXHRcXHRjNDkuMiwxMy42LDk1LDg0LjksOTUsODQuOWwtNTkuNiw4LjFjMCwwLDcuNyw3Mi4xLDE0LjUsMTU5LjljMCwwLTc3LjIsMTcuNC0xOTcuOSwxMC42QzExNy4xLDQzNS4yLDExNy44LDI5MywxMTYuNywyODAuNXpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QwX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIzMC42LDE2MC43bDYuNiwzMS43YzAsMC03LDIxLTI4LjMsMTguOHMtMzEuMS0xOS4zLTMxLjEtMTkuM2wtNy42LTU4LjJjMCwwLDE0LjItMTAuMiw1LjItNDIuOFxcblxcdFxcdGMwLDAsMjQuNCw4LjMsNTQuNiwwLjNjMCwwLDE0LjIsMzQuNywxMy44LDUxUzIzMC42LDE2MC43LDIzMC42LDE2MC43elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMjEyLDIxMmMtMSwwLTIuMS0wLjEtMy4xLTAuMmMtMjEuNC0yLjItMzEuNS0xOS41LTMxLjYtMTkuN2MtMC4xLTAuMS0wLjEtMC4yLTAuMS0wLjNsLTcuNi01OC4yXFxuXFx0XFx0YzAtMC4zLDAuMS0wLjUsMC4zLTAuN2MwLjEtMC4xLDEzLjYtMTAuNCw1LTQyYy0wLjEtMC4zLDAtMC42LDAuMi0wLjdjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjJjMC4yLDAuMSwyNC42LDguMSw1NC4xLDAuM1xcblxcdFxcdGMwLjQtMC4xLDAuOCwwLjEsMC45LDAuNGMwLjYsMS40LDE0LjIsMzUuMSwxMy45LDUxLjNjLTAuMywxNC40LTEwLjMsMTguMy0xMy4yLDE5LjFsNi40LDMxYzAsMC4xLDAsMC4zLDAsMC40XFxuXFx0XFx0QzIzNy45LDE5Mi44LDIzMS4yLDIxMiwyMTIsMjEyeiBNMTc4LjYsMTkxLjVjMC45LDEuNSwxMC43LDE2LjgsMzAuNCwxOC44czI2LjctMTUuOSwyNy40LTE4LjFsLTYuNS0zMS41YzAtMC4yLDAtMC40LDAuMS0wLjZcXG5cXHRcXHRjMC4xLTAuMiwwLjMtMC4zLDAuNS0wLjNjMC41LTAuMSwxMi40LTIuNCwxMi43LTE3LjhjMC4zLTE0LjgtMTEuNy00NS40LTEzLjUtNTAuMWMtMTcuNCw0LjUtMzUuNiw0LjUtNTMsMFxcblxcdFxcdGM3LjYsMjkuMi0zLjMsNDAuMS01LjUsNDJMMTc4LjYsMTkxLjV6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MF9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0xODIuMywxMzFjLTEuMS0yLjctMy01LTUuNS02LjZjLTIuNC0xLjMtNS0yLjItNy43LTIuN2MtMS40LTAuNC0zLTAuNS00LjQtMC4yYy0xLDAuMy0yLDAuOC0yLjgsMS41XFxuXFx0XFx0Yy0yLjEsMS40LTMuNiwzLjUtNC4zLDUuOWMtMC4zLDItMC4xLDQsMC41LDUuOWMwLjUsMi4xLDEuMyw0LjIsMi40LDYuMWM0LjcsNy44LDE0LjgsMTAuNCwyMi42LDUuN2MwLjEsMCwwLjEtMC4xLDAuMi0wLjFcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTE3NC42LDE0OS42Yy02LjEsMC0xMS43LTMuMi0xNC44LTguNGMtMS4xLTItMi00LTIuNS02LjJjLTAuNy0yLTAuOS00LjItMC41LTYuM2MwLjctMi42LDIuMy00LjgsNC42LTYuM1xcblxcdFxcdGMwLjktMC43LDEuOS0xLjMsMy4xLTEuNmMxLjYtMC4zLDMuMi0wLjIsNC44LDAuMmMyLjgsMC40LDUuNSwxLjQsOCwyLjhjMi43LDEuNiw0LjcsNC4xLDUuOSw3YzAuMSwwLjQsMCwwLjgtMC40LDFcXG5cXHRcXHRjLTAuNCwwLjEtMC44LDAtMS0wLjRjLTEtMi42LTIuOS00LjgtNS4yLTYuMmMtMi4zLTEuMy00LjktMi4xLTcuNS0yLjZjLTEuMy0wLjQtMi43LTAuNC00LjEtMC4yYy0wLjksMC4zLTEuOCwwLjctMi41LDEuM1xcblxcdFxcdGMtMS45LDEuMy0zLjMsMy4yLTQsNS40Yy0wLjMsMS45LTAuMSwzLjgsMC41LDUuNmMwLjUsMi4xLDEuMyw0LDIuNCw1LjljNC40LDcuNSwxNC4xLDkuOSwyMS42LDUuNWMwLjEsMCwwLjEtMC4xLDAuMi0wLjFcXG5cXHRcXHRjMC4zLTAuMiwwLjgtMC4xLDEsMC4yYzAuMiwwLjMsMC4xLDAuOC0wLjIsMUMxODAuOSwxNDguOCwxNzcuOCwxNDkuNiwxNzQuNiwxNDkuNnpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIzMy4yLDE3Ni41YzAsMC0xMS44LDMuNS0yMi00UzIwMSwxNTkuNywyMDEsMTU5LjdzMTUuNyw2LjEsMjguOSwxLjVMMjMzLjIsMTc2LjV6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yMjYuNSwxNzguMWMtNS43LDAuMS0xMS4yLTEuNy0xNS44LTVjLTEwLjQtNy43LTEwLjUtMTMuMS0xMC41LTEzLjRjMC0wLjIsMC4xLTAuNSwwLjMtMC42XFxuXFx0XFx0YzAuMi0wLjEsMC41LTAuMiwwLjctMC4xYzAuMiwwLjEsMTUuNiw1LjksMjguNCwxLjVjMC4yLTAuMSwwLjQsMCwwLjYsMC4xYzAuMiwwLjEsMC4zLDAuMywwLjQsMC41bDMuMywxNS4yXFxuXFx0XFx0YzAuMSwwLjQtMC4xLDAuOC0wLjUsMC45QzIzMS4xLDE3Ny44LDIyOC44LDE3OC4xLDIyNi41LDE3OC4xeiBNMjAyLDE2MC45YzAuNiwxLjksMi42LDUuOCw5LjYsMTFjOC40LDYuMiwxOC4xLDQuNywyMC43LDQuMVxcblxcdFxcdGwtMy0xMy43QzIxOC4zLDE2NS43LDIwNS45LDE2Mi4yLDIwMiwxNjAuOXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QwX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIxMS43LDExMy4zYzAsMCwxMy41LDE0LjIsMTEuNCwxNy40Yy0yLjEsMy4yLTkuNSwyLjYtOS41LDIuNlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMjE1LDEzNC4xYy0wLjksMC0xLjQtMC4xLTEuNS0wLjFjLTAuNCwwLTAuNy0wLjQtMC43LTAuOHMwLjQtMC43LDAuOC0wLjdjMS45LDAuMiw3LjMsMC4xLDguOC0yLjJcXG5cXHRcXHRjMS4xLTEuNy01LTkuOS0xMS4zLTE2LjVjLTAuMy0wLjMtMC4zLTAuOCwwLTEuMWMwLjMtMC4zLDAuOC0wLjMsMS4xLDBjMy4zLDMuNCwxMy43LDE0LjksMTEuNSwxOC4zXFxuXFx0XFx0QzIyMiwxMzMuNywyMTcuNCwxMzQuMSwyMTUsMTM0LjF6XFxcIj48L3BhdGg+PGVsbGlwc2UgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMC45Mjc3IC0wLjM3MzMgMC4zNzMzIDAuOTI3NyAtMjkuMzA2MiA4MC41NzA3KVxcXCIgY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGN4PVxcXCIxOTMuNFxcXCIgY3k9XFxcIjExNlxcXCIgcng9XFxcIjIuN1xcXCIgcnk9XFxcIjMuOFxcXCI+PC9lbGxpcHNlPjxlbGxpcHNlIHRyYW5zZm9ybT1cXFwibWF0cml4KDAuOTI3NyAtMC4zNzMzIDAuMzczMyAwLjkyNzcgLTI1LjU3OTQgOTAuNjg0KVxcXCIgY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGN4PVxcXCIyMjEuM1xcXCIgY3k9XFxcIjExMS40XFxcIiByeD1cXFwiMi43XFxcIiByeT1cXFwiMy44XFxcIj48L2VsbGlwc2U+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yMTMuNiwxNTIuOGMtNS4yLDAtMTAtMy4xLTE0LTguOWMtMi4zLTMuNC00LjEtNy01LjQtMTAuOWMtMC4xLTAuNCwwLjEtMC44LDAuNS0wLjljMC40LTAuMSwwLjgsMC4xLDAuOSwwLjVcXG5cXHRcXHRjMS4yLDMuNywzLDcuMiw1LjEsMTAuNGM0LjUsNi41LDEwLDkuMywxNS43LDcuOWMxMy44LTMuMywxMy42LTE5LjcsMTMuNi0xOS45YzAtMC40LDAuMy0wLjgsMC43LTAuOGMwLDAsMCwwLDAsMFxcblxcdFxcdGMwLjQsMCwwLjcsMC4zLDAuOCwwLjdjMCwwLjIsMC4zLDE3LjctMTQuNywyMS40QzIxNS44LDE1Mi43LDIxNC43LDE1Mi44LDIxMy42LDE1Mi44elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDBfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMTM1LjQsMjY3LjdMMTEwLDMyOC4xbDU2LjYtNDguOWwzNi4xLDEyLjJjMCwwLTguMSw1My44LTU3LjMsOTkuMXMtMTAwLjEsMzYuNy0xMDMtNS44czI3LTEyNC45LDI3LTEyNC45XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk04MS40LDQyMS42Yy01LjgsMC4xLTExLjYtMS0xNy0zLjFjLTEzLjYtNS40LTIxLjctMTcuNC0yMi44LTMzLjdjLTIuOS00Mi4yLDI2LjgtMTI0LjQsMjcuMS0xMjUuMlxcblxcdFxcdGMwLjEtMC40LDAuNi0wLjYsMS0wLjVjMCwwLDAsMCwwLDBjMC40LDAuMSwwLjYsMC42LDAuNSwwLjljMCwwLDAsMCwwLDAuMWMtMC4zLDAuOC0yOS44LDgyLjctMjcsMTI0LjZcXG5cXHRcXHRjMS4xLDE1LjcsOC44LDI3LjIsMjEuOCwzMi40YzIxLjcsOC42LDUyLjMtMS44LDc5LjktMjcuMWM0NS42LTQyLjEsNTUuOS05Miw1Ny05OC4xbC0zNS0xMS45bC01Ni4zLDQ4LjZcXG5cXHRcXHRjLTAuMywwLjMtMC44LDAuMi0xLjEtMC4xYy0wLjItMC4yLTAuMi0wLjUtMC4xLTAuOGwyNS40LTYwLjNjMC4yLTAuNCwwLjYtMC42LDEtMC40YzAsMCwwLDAsMCwwYzAuNCwwLjIsMC42LDAuNiwwLjQsMVxcblxcdFxcdGMwLDAsMCwwLDAsMGwtMjQuMyw1Ny40bDU0LjItNDYuOGMwLjItMC4yLDAuNS0wLjIsMC43LTAuMWwzNi4xLDEyLjJjMC4zLDAuMSwwLjYsMC41LDAuNSwwLjhjLTAuMSwwLjUtOC42LDU0LjUtNTcuNSw5OS42XFxuXFx0XFx0QzEyNC41LDQxMC44LDEwMS4yLDQyMS42LDgxLjQsNDIxLjZ6XFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIHBvaW50cz1cXFwiMTgxLjEsMTkxLjIgMjQ1LjUsMjQyLjMgMjQ3LjMsMjQ1LjQgMjU1LjgsMjYwLjMgMjM5LjQsMjU1LjMgMjM2LDI1NC4zIDE3MS42LDIwMy4xIFxcdFxcXCI+PC9wb2x5Z29uPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMjU1LjgsMjYxaC0wLjJsLTE5LjgtNmMtMC4xLDAtMC4yLTAuMS0wLjItMC4xbC02NC40LTUxLjJjLTAuMi0wLjEtMC4yLTAuMy0wLjMtMC41YzAtMC4yLDAtMC40LDAuMS0wLjZcXG5cXHRcXHRsOS41LTExLjljMC4zLTAuMywwLjctMC4zLDEtMC4xbDY0LjQsNTEuMmMwLjEsMC4xLDAuMSwwLjEsMC4yLDAuMmwxMC4zLDE3LjljMC4yLDAuNCwwLjEsMC44LTAuMywxQzI1Ni4xLDI2MSwyNTYsMjYxLDI1NS44LDI2MVxcblxcdFxcdEwyNTUuOCwyNjF6IE0yMzYuNCwyNTMuNmwxNy44LDUuNGwtOS4yLTE2LjJsLTYzLjctNTAuNmwtOC42LDEwLjhMMjM2LjQsMjUzLjZ6XFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcInN0Ml9jaGVja2xpc3QtNzEgdGFyZ2V0Q29sb3JcXFwiIHBvaW50cz1cXFwiMjQ3LjMsMjQ1LjQgMjU1LjgsMjYwLjMgMjM5LjQsMjU1LjMgXFx0XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yNTUuOCwyNjFoLTAuMmwtMTYuNC01Yy0wLjQtMC4xLTAuNi0wLjUtMC41LTAuOWMwLTAuMSwwLjEtMC4yLDAuMS0wLjNsNy45LTkuOWMwLjItMC4yLDAuNC0wLjMsMC42LTAuM1xcblxcdFxcdGMwLjIsMCwwLjUsMC4yLDAuNiwwLjRsOC42LDE0LjljMC4yLDAuNCwwLjEsMC44LTAuMywxQzI1Ni4xLDI2MSwyNTYsMjYxLDI1NS44LDI2MXogTTI0MC43LDI1NC45bDEzLjYsNC4xbC03LjEtMTIuM0wyNDAuNywyNTQuOVxcblxcdFxcdHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTE1Ni4xLDE5MGw4LjgtMTEuMWMwLjgtMSwyLjItMS4yLDMuMi0wLjRsMCwwbDMxLjgsMjUuMmwwLDBsLTExLjcsMTQuN2wwLDBsLTMxLjgtMjUuMlxcblxcdFxcdEMxNTUuNSwxOTIuNSwxNTUuMywxOTEsMTU2LjEsMTkwTDE1Ni4xLDE5MHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTE4OC4yLDIxOS4zYy0wLjIsMC0wLjMtMC4xLTAuNS0wLjJMMTU2LDE5My45Yy0xLjMtMS0xLjYtMi45LTAuNS00LjJjMCwwLDAsMCwwLjEtMC4xbDguOC0xMS4xXFxuXFx0XFx0YzEuMS0xLjMsMy0xLjUsNC4zLTAuNWwzMS44LDI1LjJjMC4zLDAuMywwLjQsMC43LDAuMSwxLjFjMCwwLDAsMCwwLDBMMTg4LjgsMjE5QzE4OC43LDIxOS4yLDE4OC41LDIxOS4zLDE4OC4yLDIxOS4zTDE4OC4yLDIxOS4zXFxuXFx0XFx0eiBNMTY2LjcsMTc4LjhoLTAuMmMtMC40LDAuMS0wLjgsMC4zLTEsMC42bC04LjgsMTEuMWwwLDBjLTAuMywwLjMtMC40LDAuNy0wLjMsMS4xYzAuMSwwLjQsMC4zLDAuOCwwLjYsMWwzMS4yLDI0LjhsMTAuNy0xMy40XFxuXFx0XFx0bC0zMS4yLTI0LjhDMTY3LjQsMTc5LDE2Ny4xLDE3OC45LDE2Ni43LDE3OC44eiBNMTU2LjEsMTkwLjFMMTU2LjEsMTkwLjF6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0xNzUuOSwyMTYuNGMtMC4yLDAtMC4zLTAuMS0wLjUtMC4yYy0wLjEtMC4xLTE1LjktMTIuNS0xOC0xNC41Yy0yLjYtMi40LTEuNS03LjMtMS40LTcuOVxcblxcdFxcdGMwLjEtMC40LDAuNS0wLjYsMC45LTAuNmMwLjQsMC4xLDAuNiwwLjUsMC41LDAuOWMwLDAtMS4xLDQuNSwwLjksNi40YzEuOSwxLjcsMTUuOSwxMi44LDE3LjksMTQuNGMwLjMsMC4zLDAuNCwwLjcsMC4xLDEuMVxcblxcdFxcdEMxNzYuNCwyMTYuMiwxNzYuMiwyMTYuMywxNzUuOSwyMTYuNEwxNzUuOSwyMTYuNHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QwX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIwMS44LDI5NS45YzAuOC0zLjQsMi4yLTEwLjQsMi4yLTEwLjRzMTQuMSwxLjEsMTcuMS0zLjJzMTEuOS0zNS4xLDguOS00MC40cy0xNC4zLTEyLjUtMTcuOC0xMy45XFxuXFx0XFx0cy0xNy4zLDEuNC0xNy4zLDEuNGwxMC45LTExYzAsMCwxNy44LDEwLjUsMjUuOCw5LjhzMTAuMy0zLjYsNi4yLTguNHMtMzQtMTguMi0zOS0xNy42cy0yNy4xLDIxLjQtMjcuNiwyNC40cy0xNy41LDYwLjYtMTMuOSw2N1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMjAxLjgsMjk2LjZoLTAuMmMtMC40LTAuMS0wLjYtMC41LTAuNS0wLjljMC44LTMuMywyLjItMTAuMywyLjItMTAuNGMwLjEtMC40LDAuNC0wLjYsMC44LTAuNlxcblxcdFxcdGMzLjgsMC4zLDE0LjIsMC40LDE2LjQtMi45YzEuNC0yLjEsNC40LTEwLjksNi42LTE5LjZjMi42LTEwLjMsMy41LTE3LjksMi4zLTIwYy0yLjktNS4xLTE0LjMtMTIuMy0xNy40LTEzLjZcXG5cXHRcXHRjLTIuNi0xLjEtMTMuMSwwLjYtMTYuOSwxLjRjLTAuNCwwLjEtMC44LTAuMi0wLjktMC42YzAtMC4yLDAtMC41LDAuMi0wLjdsMTAuOS0xMWMwLjItMC4yLDAuNi0wLjMsMC45LTAuMVxcblxcdFxcdGMwLjIsMC4xLDE3LjcsMTAuNCwyNS4zLDkuN2M0LjEtMC40LDYuNy0xLjQsNy4zLTIuOHMtMC42LTMuMS0xLjctNC40Yy0zLjktNC41LTMzLjYtMTcuOS0zOC4zLTE3LjNzLTI2LjUsMjAuOS0yNywyMy44XFxuXFx0XFx0Yy0wLjEsMC42LTAuNywzLTIsNy44Yy00LDE0LjgtMTQuNyw1My45LTExLjksNTguN2MwLjIsMC40LDAuMSwwLjgtMC4zLDFjLTAuNCwwLjItMC44LDAuMS0xLTAuM2wwLDBjLTIuNy00LjcsNC40LTMyLjksMTEuOC01OS45XFxuXFx0XFx0YzEuMS0zLjksMS45LTcuMSwyLTcuNmMwLjUtMy41LDIzLTI0LjMsMjguMi0yNXMzNS4zLDEyLjgsMzkuNywxNy44YzEuOSwyLjMsMi42LDQuMywxLjksNS45Yy0wLjksMi4xLTMuNywzLjMtOC42LDMuOFxcblxcdFxcdGMtNy40LDAuNi0yMi43LTcuOS0yNS43LTkuNmwtOC44LDguOGM0LjItMC43LDEyLjYtMiwxNS40LTAuOWMzLjQsMS40LDE1LjEsOC44LDE4LjIsMTQuMmMxLjksMy4zLTAuNSwxNC42LTIuMSwyMS4xXFxuXFx0XFx0Yy0yLjIsOS01LjIsMTcuOC02LjgsMjAuMWMtMi44LDQuMS0xNCwzLjgtMTcuMSwzLjZjLTAuNCwxLjgtMS40LDcuMS0yLjEsOS44QzIwMi41LDI5Ni40LDIwMi4yLDI5Ni42LDIwMS44LDI5Ni42elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDBfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMTkwLjQsMjQzYzAsMCwxOC43LTMuMiwyMi44LTJzMTYsMTMuOSwxNiwxMy45XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yMjkuMSwyNTUuNmMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0zLjItMy41LTEyLjQtMTIuOC0xNS42LTEzLjdzLTE3LjMsMS4yLTIyLjUsMi4xXFxuXFx0XFx0Yy0wLjQsMC4xLTAuOC0wLjItMC45LTAuNmMtMC4xLTAuNCwwLjItMC44LDAuNi0wLjljMC44LTAuMSwxOC45LTMuMiwyMy4xLTJzMTUuOCwxMy42LDE2LjMsMTQuMWMwLjMsMC4zLDAuMywwLjgsMCwxLjFcXG5cXHRcXHRDMjI5LjUsMjU1LjYsMjI5LjMsMjU1LjcsMjI5LjEsMjU1LjZMMjI5LjEsMjU1LjZ6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MF9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yMDQsMjg1LjVjMCwwLDIuOC04LjksMi4xLTE1LjJcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIwNCwyODYuMmMtMC4xLDAtMC4xLDAtMC4yLDBjLTAuNC0wLjEtMC42LTAuNS0wLjUtMC45YzAtMC4xLDIuNy04LjgsMi4xLTE1YzAtMC40LDAuMi0wLjgsMC43LTAuOFxcblxcdFxcdGMwLDAsMCwwLDAsMGMwLjQsMCwwLjgsMC4yLDAuOCwwLjdjMC43LDYuNS0yLDE1LjItMi4xLDE1LjZDMjA0LjYsMjg2LDIwNC4zLDI4Ni4yLDIwNCwyODYuMnpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QwX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTE5My44LDI3MGMwLjktMC4yLDE2LjYsMC4yLDE3LjYsMFxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMjA5LjEsMjcwLjhjLTEuNCwwLTMuNiwwLTYuNS0wLjFjLTMuNiwwLTguMS0wLjEtOC42LDBjLTAuNCwwLjEtMC44LTAuMi0wLjktMC42Yy0wLjEtMC40LDAuMi0wLjgsMC41LTAuOVxcblxcdFxcdGMwLjUtMC4xLDMuMS0wLjEsOSwwYzMuNiwwLDguMSwwLjEsOC42LDBjMC40LTAuMSwwLjgsMC4yLDAuOSwwLjZjMC4xLDAuNC0wLjEsMC44LTAuNSwwLjljMCwwLDAsMCwwLDBcXG5cXHRcXHRDMjEwLjcsMjcwLjgsMjA5LjksMjcwLjgsMjA5LjEsMjcwLjh6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MF9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0xODcuNCwyNTUuNmMwLDAsMTMuNS0zLDE5LjgtMS42czE3LjQsMTQuNSwxOC42LDE1LjdcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTIyNS44LDI3MC40Yy0wLjIsMC0wLjQtMC4xLTAuNS0wLjJjLTAuMi0wLjItMC41LTAuNS0wLjktMWMtMy0zLjMtMTEuOS0xMy4zLTE3LjMtMTQuNFxcblxcdFxcdGMtNi4xLTEuMy0xOS40LDEuNi0xOS41LDEuNmMtMC40LDAuMS0wLjgtMC4xLTAuOS0wLjVjLTAuMS0wLjQsMC4xLTAuOCwwLjUtMC45YzAsMCwwLjEsMCwwLjEsMGMwLjYtMC4xLDEzLjctMywyMC4yLTEuNlxcblxcdFxcdGM1LjIsMS4xLDEyLjgsOSwxOC4xLDE0LjljMC40LDAuNSwwLjcsMC44LDAuOSwxYzAuMywwLjMsMC4zLDAuOCwwLDEuMUMyMjYuMiwyNzAuNCwyMjYsMjcwLjQsMjI1LjgsMjcwLjR6XFxcIj48L3BhdGg+PGxpbmUgY2xhc3M9XFxcInN0M19jaGVja2xpc3QtNzFcXFwiIHgxPVxcXCIxMTBcXFwiIHkxPVxcXCIzMjguMVxcXCIgeDI9XFxcIjgyLjNcXFwiIHkyPVxcXCIzNDkuM1xcXCI+PC9saW5lPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNODIuMywzNTBjLTAuNCwwLTAuNy0wLjMtMC43LTAuOGMwLTAuMiwwLjEtMC40LDAuMy0wLjZsMjcuNy0yMS4yYzAuMy0wLjIsMC44LTAuMiwxLDAuMVxcblxcdFxcdGMwLjMsMC4zLDAuMiwwLjgtMC4xLDFjMCwwLDAsMCwwLDBsLTI3LjYsMjEuMkM4Mi42LDM1MCw4Mi41LDM1MCw4Mi4zLDM1MHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTE1Ny43LDExOC41Yy0wLjMsMC0wLjYtMC4yLTAuNy0wLjZjLTIuNS0xMC42LTUtMjEuMy03LjItMzEuN2wtMC4yLTEuMWMtMS00LjUtMi4xLTkuNi0xLjgtMTQuM1xcblxcdFxcdGMwLjMtNS43LDQuOC02LjEsNy42LTZjMC43LTQuOSwzLjMtOS4zLDcuNC0xMi4xYzEwLjQtNy4yLDIxLjQtNCwzMi0wLjljNi45LDIsMTQsNC4xLDIwLjYsMy4xYzQuNC0wLjYsOC41LTIuNywxMi41LTQuN2gwLjFcXG5cXHRcXHRjMS40LTAuNywyLjktMS40LDQuMy0yLjFjMi45LTEuMywxNy4zLTcuMywyMS4yLDAuNmMxLjIsMi40LDAuMyw0LjktMC44LDdjLTEuNCwyLjktMyw1LjctNC44LDguNGMwLjktMC41LDEuOS0wLjksMi45LTEuM1xcblxcdFxcdGMzLjktMS43LDguMy0xLjgsMTIuMy0wLjNjMS43LDAuNywzLjIsMS44LDQuMiwzLjRjMiwzLjIsMS4yLDcuNC0yLjQsMTIuNGMtMiwyLjgtNC4xLDUuNi02LjQsOC4yYzIuOC0xLjcsNS45LTMuMiw5LjMtMi4zXFxuXFx0XFx0YzEuNiwwLjMsMi45LDEuNCwzLjcsMi44YzEuNCwyLjktMC45LDUuOS0xLjcsNi45Yy02LDcuOS0xMy43LDE0LjQtMjIuNCwxOS4yYy0wLjQsMC4yLTAuOCwwLjEtMS0wLjNzLTAuMS0wLjgsMC4zLTFcXG5cXHRcXHRjMCwwLDAsMCwwLjEsMGM4LjUtNC42LDE2LTExLDIxLjktMTguOGMwLjYtMC44LDIuNS0zLjMsMS41LTUuNGMtMC42LTEtMS41LTEuOC0yLjctMmMtMy40LTAuOS02LjUsMS4xLTkuNSwzXFxuXFx0XFx0Yy0xLDAuNi0xLjksMS4yLTIuOSwxLjhjLTAuNCwwLjItMC44LDAtMS0wLjNjLTAuMS0wLjMtMC4xLTAuNiwwLjEtMC44YzMuNS0zLjcsNi43LTcuNiw5LjYtMTEuOGMzLjEtNC41LDMuOS04LjEsMi4zLTEwLjdcXG5cXHRcXHRjLTAuOC0xLjMtMi4xLTIuMi0zLjUtMi44Yy0zLjItMS4zLTcuMi0xLjItMTEuMiwwLjNjLTEuOSwwLjgtMy44LDEuNy01LjUsMi45Yy0wLjMsMC4yLTAuNywwLjItMS0wLjFjLTAuMi0wLjMtMC4zLTAuNy0wLjEtMC45XFxuXFx0XFx0YzIuNC0zLjUsNC42LTcuMiw2LjUtMTFjMC45LTEuOCwxLjYtMy45LDAuOC01LjdjLTMuNC02LjgtMTcuNi0wLjYtMTkuMywwLjFjLTEuNCwwLjYtMi45LDEuMy00LjIsMmgtMC4xYy00LjEsMi04LjQsNC4yLTEzLDQuOFxcblxcdFxcdGMtNi45LDEtMTQuMi0xLjEtMjEuMi0zLjFjLTEwLjMtMy0yMS02LjEtMzAuOCwwLjdjLTMuOSwyLjctNi40LDctNi44LDExLjdjLTAuMSwwLjQtMC40LDAuNy0wLjgsMC43Yy0zLjQtMC4xLTYuNCwwLjItNi43LDQuNlxcblxcdFxcdHMwLjksOS42LDEuOSwxNGwwLjIsMS4xYzIuMywxMC41LDQuNywyMS4xLDcuMiwzMS43YzAuMSwwLjQtMC4xLDAuOC0wLjUsMC45YzAsMCwwLDAsMCwwQzE1Ny44LDExOC41LDE1Ny44LDExOC41LDE1Ny43LDExOC41elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDBfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMTYzLjIsMTk3LjRjLTAuNCwwLTAuOC0wLjQtMC43LTAuOGMwLTAuMiwwLjEtMC4zLDAuMi0wLjVsMTAuMS0xMi4yYzAuMy0wLjMsMC44LTAuNCwxLjEtMC4xXFxuXFx0XFx0czAuNCwwLjgsMC4xLDEuMWwwLDBsLTEwLjEsMTIuMkMxNjMuNywxOTcuMywxNjMuNSwxOTcuNCwxNjMuMiwxOTcuNHpcXFwiPjwvcGF0aD48bGluZSBjbGFzcz1cXFwic3QzX2NoZWNrbGlzdC03MVxcXCIgeDE9XFxcIjI1NS40XFxcIiB5MT1cXFwiMjU5LjhcXFwiIHgyPVxcXCIyNTcuNVxcXCIgeTI9XFxcIjI2MS41XFxcIj48L2xpbmU+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yNTcuNSwyNjIuMmMtMC4yLDAtMC4zLTAuMS0wLjUtMC4ybC0yLjEtMS42Yy0wLjMtMC4yLTAuNC0wLjctMC4yLTFjMC4yLTAuMywwLjctMC40LDEtMC4yXFxuXFx0XFx0YzAsMCwwLjEsMCwwLjEsMC4xbDIuMSwxLjZjMC4zLDAuMywwLjQsMC43LDAuMSwxLjFDMjU4LDI2Mi4xLDI1Ny44LDI2Mi4yLDI1Ny41LDI2Mi4yTDI1Ny41LDI2Mi4yelxcXCI+PC9wYXRoPjwvZz48ZyBpZD1cXFwiQ2hlY2tsaXN0X2NoZWNrbGlzdC03MVxcXCI+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0yNzAuOSwxMTAuM2gxNzUuM2MyLjksMCw1LjIsMi4zLDUuMiw1LjJ2MjI5LjljMCwyLjktMi4zLDUuMi01LjIsNS4ySDI3MC45Yy0yLjksMC01LjItMi4zLTUuMi01LjJWMTE1LjVcXG5cXHRcXHRDMjY1LjcsMTEyLjYsMjY4LjEsMTEwLjMsMjcwLjksMTEwLjN6XFxcIj48L3BhdGg+PHJlY3QgeD1cXFwiMjc3LjFcXFwiIHk9XFxcIjEyNVxcXCIgY2xhc3M9XFxcInN0MF9jaGVja2xpc3QtNzFcXFwiIHdpZHRoPVxcXCIxNjIuOVxcXCIgaGVpZ2h0PVxcXCIyMTAuOFxcXCI+PC9yZWN0PjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNNDQwLjEsMzM2LjZIMjc3LjFjLTAuNCwwLTAuOC0wLjMtMC44LTAuOFYxMjVjMC0wLjQsMC4zLTAuNywwLjctMC44YzAsMCwwLDAsMCwwaDE2Mi45XFxuXFx0XFx0YzAuNCwwLDAuNywwLjMsMC44LDAuN2MwLDAsMCwwLDAsMHYyMTAuOUM0NDAuOCwzMzYuMyw0NDAuNSwzMzYuNiw0NDAuMSwzMzYuNnogTTI3Ny45LDMzNS4xaDE2MS40VjEyNS44SDI3Ny45VjMzNS4xelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDJfY2hlY2tsaXN0LTcxIHRhcmdldENvbG9yXFxcIiBkPVxcXCJNNDAxLjIsMTAxLjhoLTIzLjRjLTIuMS0xMC42LTEyLjMtMTcuNS0yMi45LTE1LjRjLTcuOCwxLjUtMTMuOSw3LjYtMTUuNCwxNS40SDMxNmMtMy4xLDAtNS42LDIuNS01LjYsNS42XFxuXFx0XFx0YzAsMCwwLDAsMCwwVjEyN2MwLDMuMSwyLjUsNS42LDUuNiw1LjZoODUuMmMzLjEsMCw1LjYtMi41LDUuNi01LjZ2LTE5LjZDNDA2LjgsMTA0LjMsNDA0LjMsMTAxLjgsNDAxLjIsMTAxLjh6IE0zNTguNiwxMDQuNFxcblxcdFxcdGMtMi44LDAtNS0yLjItNS01czIuMi01LDUtNXM1LDIuMiw1LDVDMzYzLjYsMTAyLjEsMzYxLjQsMTA0LjQsMzU4LjYsMTA0LjRMMzU4LjYsMTA0LjR6XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0zMzkuOSwxOTMuNGgtMzkuNGMtMC44LDAtMS41LTAuNy0xLjUtMS41di00Mi4xYzAtMC44LDAuNy0xLjUsMS41LTEuNWgzOS40YzAuOCwwLDEuNSwwLjcsMS41LDEuNXY0Mi4xXFxuXFx0XFx0QzM0MS40LDE5Mi43LDM0MC43LDE5My40LDMzOS45LDE5My40eiBNMzAwLjUsMTQ5Ljh2NDIuMWgzOS40di00MkwzMDAuNSwxNDkuOHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QyX2NoZWNrbGlzdC03MSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTM0OS4xLDE2MC4xYy0wLjIsMC40LTAuNCwwLjctMC43LDFjLTguNSw4LjUtMTYuOSwxNi45LTI1LjQsMjUuNGMtMC40LDAuNy0xLjMsMC45LTIsMC41XFxuXFx0XFx0Yy0wLjItMC4xLTAuMy0wLjMtMC41LTAuNWwtMTQuMy0xNC44Yy0wLjYtMC41LTAuNy0xLjQtMC4zLTJjMC4xLTAuMSwwLjItMC4yLDAuMy0wLjNsMy42LTMuMmMwLjUtMC42LDEuMy0wLjcsMS45LTAuMlxcblxcdFxcdGMwLjEsMC4xLDAuMiwwLjEsMC4yLDAuMmw4LjUsOC42YzAuOSwwLjksMS41LDAuOSwyLjQsMGwxOS44LTE5LjdjMC40LTAuNywxLjMtMC44LDItMC40YzAuMiwwLjEsMC4zLDAuMiwwLjQsMC40XFxuXFx0XFx0YzEuMSwxLjEsMi4yLDIuMiwzLjMsMy40YzAuMiwwLjMsMC41LDAuNiwwLjcsMC45TDM0OS4xLDE2MC4xelxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMzM5LjksMjUwLjhoLTM5LjRjLTAuOCwwLTEuNS0wLjctMS41LTEuNWMwLDAsMCwwLDAsMHYtNDIuMWMwLTAuOCwwLjctMS41LDEuNS0xLjVoMzkuNFxcblxcdFxcdGMwLjgsMCwxLjUsMC43LDEuNSwxLjV2NDIuMUMzNDEuNCwyNTAuMSwzNDAuNywyNTAuOCwzMzkuOSwyNTAuOHogTTMwMC41LDIwNy4ydjQyLjFoMzkuNHYtNDIuMUwzMDAuNSwyMDcuMnpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QyX2NoZWNrbGlzdC03MSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTM0OS4xLDIxNy41Yy0wLjIsMC40LTAuNCwwLjctMC43LDFjLTguNSw4LjUtMTYuOSwxNi45LTI1LjQsMjUuNGMtMC40LDAuNy0xLjMsMC45LTIsMC41XFxuXFx0XFx0Yy0wLjItMC4xLTAuMy0wLjMtMC41LTAuNWwtMTQuMy0xNC44Yy0wLjYtMC41LTAuNy0xLjQtMC4zLTJjMC4xLTAuMSwwLjItMC4yLDAuMy0wLjNsMy42LTMuMmMwLjUtMC42LDEuMy0wLjcsMS45LTAuMlxcblxcdFxcdGMwLjEsMC4xLDAuMiwwLjEsMC4yLDAuMmw4LjUsOC42YzAuOSwwLjksMS41LDAuOSwyLjQsMGwxOS44LTE5LjdjMC40LTAuNywxLjMtMC44LDItMC40YzAuMiwwLjEsMC4zLDAuMiwwLjQsMC40XFxuXFx0XFx0YzEuMSwxLjEsMi4yLDIuMiwzLjMsMy40YzAuMiwwLjMsMC41LDAuNiwwLjcsMC45TDM0OS4xLDIxNy41elxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNMzM5LjksMzA4LjJoLTM5LjRjLTAuOCwwLTEuNS0wLjctMS41LTEuNXYtNDJjMC0wLjgsMC43LTEuNSwxLjUtMS41aDM5LjRjMC44LDAsMS41LDAuNywxLjUsMS41djQyXFxuXFx0XFx0QzM0MS40LDMwNy42LDM0MC43LDMwOC4yLDMzOS45LDMwOC4yeiBNMzAwLjUsMjY0Ljd2NDIuMWgzOS40di00MkwzMDAuNSwyNjQuN3pcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTQyMC40LDE2NWgtNThjLTAuNCwwLTAuOC0wLjMtMC44LTAuOHMwLjMtMC44LDAuOC0wLjhoNThjMC40LDAsMC44LDAuMywwLjgsMC44UzQyMC44LDE2NSw0MjAuNCwxNjV6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk00MDUuMywxNzguMmgtNDNjLTAuNCwwLTAuOC0wLjMtMC44LTAuOHMwLjMtMC44LDAuOC0wLjhoNDNjMC40LDAsMC44LDAuMywwLjgsMC44UzQwNS43LDE3OC4yLDQwNS4zLDE3OC4yelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNNDIwLjQsMjIyLjNoLTU4Yy0wLjQsMC0wLjgtMC4zLTAuOC0wLjhzMC4zLTAuOCwwLjgtMC44aDU4YzAuNCwwLDAuOCwwLjMsMC44LDAuOFM0MjAuOCwyMjIuMyw0MjAuNCwyMjIuM3pcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxX2NoZWNrbGlzdC03MVxcXCIgZD1cXFwiTTQwNS4zLDIzNS41aC00M2MtMC40LDAtMC44LTAuMy0wLjgtMC44czAuMy0wLjgsMC44LTAuOGg0M2MwLjQsMCwwLjgsMC4zLDAuOCwwLjhTNDA1LjcsMjM1LjUsNDA1LjMsMjM1LjV6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk00MjAuNCwyNzkuOGgtNThjLTAuNCwwLTAuOC0wLjMtMC44LTAuOHMwLjMtMC44LDAuOC0wLjhoNThjMC40LDAsMC44LDAuMywwLjgsMC44UzQyMC44LDI3OS44LDQyMC40LDI3OS44elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDFfY2hlY2tsaXN0LTcxXFxcIiBkPVxcXCJNNDA1LjMsMjkzaC00M2MtMC40LDAtMC44LTAuMy0wLjgtMC44czAuMy0wLjgsMC44LTAuOGg0M2MwLjQsMCwwLjgsMC4zLDAuOCwwLjhTNDA1LjcsMjkzLDQwNS4zLDI5M3pcXFwiPjwvcGF0aD48L2c+PHBhdGggaWQ9XFxcIkNoYXJhY3Rlcl9oYW5kX2NoZWNrbGlzdC03MVxcXCIgY2xhc3M9XFxcInN0MF9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk00MTUuNiwzNTBjMC40LTIuNiwwLjYtNS4zLDAuOC03LjljMC40LTUuMy0wLjktMTEuMi0yLjUtMTYuMWMtMC43LTIuMi0xLjctNC41LTMuNi02XFxuXFx0cy01LTEuNS02LjMsMC41Yy0xLjIsMS43LTAuNyw0LTAuMiw2YzEuMiw1LjUsMS41LDExLjEsMC44LDE2LjdjLTAuOS03LjUtMS45LTE1LjMtNi0yMS43Yy0wLjktMS41LTIuMS0yLjctMy41LTMuNlxcblxcdGMtMS41LTAuOS0zLjQtMC44LTQuOCwwLjFjLTIuMSwxLjUtMS45LDQuNi0xLjcsNy4yYzAuNyw2LjYsMC42LDEzLjMtMC4zLDE5LjljMC41LTUuOCwwLjEtMTEuNi0xLjItMTcuM2MtMC45LTMuNy0yLjUtNy44LTYuMS05XFxuXFx0Yy0wLjgtMC4zLTEuNi0wLjMtMi41LTAuMmMtMS43LDAuNi0yLjksMi0zLjIsMy43Yy0wLjMsMS43LTAuMywzLjQsMCw1LjFjMC43LDYuNywwLjUsMTMuNC0wLjYsMjBjMC44LTUuOCwwLjYtMTEuNy0wLjYtMTcuNFxcblxcdGMtMC4zLTIuMy0xLjItNC41LTIuNi02LjNjLTEuNS0xLjctNC4xLTIuOC02LjItMS44Yy0xLjYsMC45LTIuNywyLjQtMyw0LjJjLTAuMywxLjgtMC4zLDMuNi0wLjIsNS4zYzAuMiw2LjctMS4xLDEzLjQtMy43LDE5LjdcXG5cXHRjLTIuMSw1LjItNC45LDEwLjktNC40LDE2LjdjMC41LDYsNS4zLDExLjIsMTAuOSwxMy40czEyLDIsMTcuOSwwLjljMTkuNS0zLjksMzUuNy0xMy4yLDQyLjYtMzEuOVxcXCI+PC9wYXRoPjxwYXRoIGlkPVxcXCJoYW5kX2NoZWNrbGlzdC03MVxcXCIgY2xhc3M9XFxcInN0MV9jaGVja2xpc3QtNzFcXFwiIGQ9XFxcIk0zNzQuNCwzODMuOGMtMy40LDAuMS02LjgtMC41LTEwLTEuOGMtNi4zLTIuNS0xMC45LTguMS0xMS40LTE0Yy0wLjUtNS40LDEuOC0xMC43LDMuOC0xNS40bDAuNy0xLjdcXG5cXHRjMi41LTYuMSwzLjgtMTIuNywzLjYtMTkuNHYtMC44Yy0wLjEtMS42LDAtMy4xLDAuMi00LjdjMC4zLTIsMS42LTMuOCwzLjQtNC43YzIuNS0xLjEsNS41LDAuMSw3LjEsMmMxLjUsMS45LDIuNCw0LjEsMi44LDYuNVxcblxcdGMtMC4xLTAuNy0wLjEtMS41LTAuMi0yLjJ2LTAuNGMtMC4zLTEuNi0wLjMtMy4zLDAtNC45YzAuMy0yLDEuOC0zLjcsMy43LTQuM2MwLjktMC4yLDEuOS0wLjIsMi45LDAuMmMzLjIsMSw1LjQsNC4yLDYuNiw5LjVcXG5cXHRjMC4xLDAuNiwwLjMsMS4zLDAuNCwxLjljLTAuMS0xLjQtMC4yLTIuOC0wLjMtNC4yYy0wLjMtMi45LTAuNC02LjIsMi03LjljMS43LTEuMSwzLjktMS4yLDUuNi0wLjFjMS42LDAuOSwyLjksMi4zLDMuOCwzLjlcXG5cXHRjMi41LDQuMSw0LjEsOC43LDQuOCwxMy41Yy0wLjEtMi43LTAuNS01LjQtMS4xLThjLTAuNS0yLjEtMS00LjcsMC40LTYuNmMwLjctMC45LDEuOC0xLjYsMi45LTEuN2MxLjYtMC4yLDMuMiwwLjEsNC41LDEuMVxcblxcdGMyLjEsMS41LDMuMSw0LjEsMy45LDYuM2MyLjEsNi4zLDIuOSwxMS44LDIuNiwxNi40Yy0wLjEsMC44LTAuMSwxLjUtMC4xLDIuMmMtMC4xLDEuOS0wLjMsMy45LTAuNiw1LjhjLTAuMSwwLjQtMC41LDAuNy0wLjksMC42XFxuXFx0Yy0wLjQtMC4xLTAuNy0wLjUtMC42LTAuOWMwLDAsMCwwLDAsMGMwLjMtMS45LDAuNS0zLjcsMC42LTUuNmMwLTAuNywwLjEtMS40LDAuMS0yLjJjMC4zLTQuNC0wLjUtOS43LTIuNS0xNS45XFxuXFx0Yy0wLjctMi0xLjYtNC4zLTMuMy01LjZjLTEtMC43LTIuMi0xLTMuNC0wLjhjLTAuOCwwLjEtMS41LDAuNS0xLjksMS4xYy0xLDEuNC0wLjUsMy41LTAuMSw1LjRjMS4zLDUuNiwxLjUsMTEuMywwLjgsMTdcXG5cXHRjMCwwLjQtMC40LDAuNy0wLjgsMC43bDAsMGMtMC40LDAtMC43LTAuMy0wLjctMC43Yy0wLjgtNy0xLjgtMTUtNS45LTIxLjNjLTAuOC0xLjQtMS45LTIuNS0zLjMtMy40Yy0xLjMtMC43LTIuOC0wLjctNCwwXFxuXFx0Yy0xLjcsMS4zLTEuNiw0LTEuNCw2LjVjMC43LDYuNywwLjYsMTMuNC0wLjMsMjAuMWMtMC4xLDAuNC0wLjQsMC43LTAuOSwwLjZjLTAuNC0wLjEtMC43LTAuNC0wLjYtMC44YzAuNS01LjcsMC0xMS40LTEuMy0xN1xcblxcdGMtMS4xLTQuNy0zLTcuNi01LjYtOC40Yy0wLjYtMC4yLTEuMy0wLjMtMi0wLjFjLTEuNCwwLjUtMi40LDEuNy0yLjYsMy4yYy0wLjIsMS41LTAuMiwzLDAsNC41djAuNGMwLjcsNi43LDAuNSwxMy41LTAuNiwyMC4yXFxuXFx0Yy0wLjEsMC40LTAuNSwwLjctMC45LDAuNmMtMC40LTAuMS0wLjYtMC40LTAuNi0wLjhjMC44LTUuNywwLjYtMTEuNS0wLjYtMTcuMWMtMC4zLTIuMi0xLjItNC4yLTIuNS02Yy0xLjItMS40LTMuNS0yLjQtNS4zLTEuNlxcblxcdGMtMS40LDAuNy0yLjMsMi4xLTIuNiwzLjdjLTAuMiwxLjQtMC4zLDIuOS0wLjIsNC4zdjAuOGMwLjIsNi45LTEuMSwxMy43LTMuNywyMGMtMC4yLDAuNS0wLjUsMS4xLTAuNywxLjdjLTIsNC44LTQuMSw5LjctMy42LDE0LjdcXG5cXHRjMC41LDUuMyw0LjYsMTAuNSwxMC40LDEyLjhjNC44LDEuOSwxMC42LDIuMiwxNy41LDAuOGMyMS44LTQuMywzNi0xNC45LDQyLjEtMzEuNGMwLjEtMC40LDAuNS0wLjYsMC45LTAuNVxcblxcdGMwLjQsMC4xLDAuNiwwLjUsMC41LDAuOWMwLDAsMCwwLjEsMCwwLjFjLTYuMywxNy0yMC44LDI3LjktNDMuMiwzMi40QzM4MCwzODMuNSwzNzcuMiwzODMuOCwzNzQuNCwzODMuOHpcXFwiPjwvcGF0aD48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIGlkPVxcXCJMYXllcl8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTAwIDUwMFxcXCIgZGF0YS1pbWFnZWlkPVxcXCJjb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgaW1hZ2VOYW1lPVxcXCJDb25zdHJ1Y3Rpb24gU2l0ZVxcXCIgY2xhc3M9XFxcImlsbHVzdHJhdGlvbnNfaW1hZ2VcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMjEzcHg7XFxcIj48ZGVmcz48c3R5bGU+LmNscy0xX2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQpO30uY2xzLTFfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0yX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtM19jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTRfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy01X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTdfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy04X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTEwX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMTFfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0xMl9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTEzX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMTRfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0xNV9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTE2X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMTdfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0xOF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTE5X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMjBfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0yMV9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTIyX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMjNfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0yNF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTI1X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMjZfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0yN19jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTI4X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMjlfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0zMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTMxX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMzJfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0zM19jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTM0X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMzVfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0zNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTM3X2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtMzhfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy0zOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTQwX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtNDFfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy00Ml9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTQzX2NvbnN0cnVjdGlvbi1zaXRlLTU5LC5jbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTksLmNscy00NV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtzdHJva2Utd2lkdGg6MHB4O30uY2xzLTJfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDp1cmwoI2xpbmVhci1ncmFkaWVudC0zOC1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtM19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTMzLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy00X2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMjktY29uc3RydWN0aW9uLXNpdGUtNTkpO30uY2xzLTVfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDp1cmwoI2xpbmVhci1ncmFkaWVudC0zMi1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTMwLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy03X2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMzEtY29uc3RydWN0aW9uLXNpdGUtNTkpO30uY2xzLThfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDp1cmwoI2xpbmVhci1ncmFkaWVudC0zNi1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTM5LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTM0LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xMV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTM3LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xMl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTM1LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xM19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTI4LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xNF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTI1LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xNV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTExLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTEyLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xN19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTEzLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xOF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTEwLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0xOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE3LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE2LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yMV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE5LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yMl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE1LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yM19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTIzLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yNF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTIxLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yNV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE4LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTE0LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yN19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTIyLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yOF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTIwLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0yOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTI3LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0zMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTI0LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0zMV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTI2LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0zMl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTQwLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0zM19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTQxLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy00Nl9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtvcGFjaXR5Oi4yNDt9LmNscy0zNF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTQtY29uc3RydWN0aW9uLXNpdGUtNTkpO30uY2xzLTM1X2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtMi1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtMzZfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDp1cmwoI2xpbmVhci1ncmFkaWVudC0zLWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy0zN19jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTgtY29uc3RydWN0aW9uLXNpdGUtNTkpO30uY2xzLTM4X2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtOS1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtMzlfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDp1cmwoI2xpbmVhci1ncmFkaWVudC03LWNvbnN0cnVjdGlvbi1zaXRlLTU5KTt9LmNscy00MF9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50LTUtY29uc3RydWN0aW9uLXNpdGUtNTkpO30uY2xzLTQxX2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6dXJsKCNsaW5lYXItZ3JhZGllbnQtNi1jb25zdHJ1Y3Rpb24tc2l0ZS01OSk7fS5jbHMtNDJfY29uc3RydWN0aW9uLXNpdGUtNTl7ZmlsbDojMjMxZjIwO30uY2xzLTQzX2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6I2ZmYjRhMzt9LmNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSwuY2xzLTQ1X2NvbnN0cnVjdGlvbi1zaXRlLTU5e2ZpbGw6IzY4ZTFmZDt9LmNscy00NV9jb25zdHJ1Y3Rpb24tc2l0ZS01OXtpc29sYXRpb246aXNvbGF0ZTtvcGFjaXR5Oi4yNTt9PC9zdHlsZT48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zMzk4Ljk1XFxcIiB5MT1cXFwiLTYzMTQuNjZcXFwiIHgyPVxcXCItMzUyMi4yOVxcXCIgeTI9XFxcIi02MzEwLjU0XFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDM4MjMuMDQgNjU4MC41NClcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjBcXFwiIHN0b3AtY29sb3I9XFxcIiMyMzFmMjBcXFwiIHN0b3Atb3BhY2l0eT1cXFwiMFxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiMVxcXCIgc3RvcC1jb2xvcj1cXFwiIzIzMWYyMFxcXCI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMi1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zMzg2Ljg4XFxcIiB5MT1cXFwiLTYzMTYuMDZcXFwiIHgyPVxcXCItMzM5MS42XFxcIiB5Mj1cXFwiLTYyMzIuM1xcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgzODIzLjA0IDY1MTQuODMpXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTMtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzM3MC42NlxcXCIgeTE9XFxcIi02MzEzLjgzXFxcIiB4Mj1cXFwiLTM0NDQuNTFcXFwiIHkyPVxcXCItNjIzMC4zOVxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgzODIzLjA0IDY1MTQuODMpXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzM1My45M1xcXCIgeTE9XFxcIi02MjkxLjk4XFxcIiB4Mj1cXFwiLTMzOTUuMjhcXFwiIHkyPVxcXCItNjI5MC40NlxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC01LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM0MjEuMjFcXFwiIHkxPVxcXCItNjI4NS4yMVxcXCIgeDI9XFxcIi0zMzYzLjk1XFxcIiB5Mj1cXFwiLTYyODUuMjFcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtNi1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTc1LjczXFxcIiB5MT1cXFwiLTYzMTYuNTVcXFwiIHgyPVxcXCItMzYxNi45NFxcXCIgeTI9XFxcIi02MzE1LjAzXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTctY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzQ5OC44M1xcXCIgeTE9XFxcIi02MjgzLjQ5XFxcIiB4Mj1cXFwiLTM1MzMuNlxcXCIgeTI9XFxcIi02MzUxLjM4XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTgtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzUwMy4zNVxcXCIgeTE9XFxcIi02MzEwLjA4XFxcIiB4Mj1cXFwiLTM1MDQuNDNcXFwiIHkyPVxcXCItNjI5Ni41NFxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC05LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1MDUuNzlcXFwiIHkxPVxcXCItNjM4Ny45OVxcXCIgeDI9XFxcIi0zNTA1Ljc5XFxcIiB5Mj1cXFwiLTYzNDIuNDRcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMTAtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzUwNS43OVxcXCIgeTE9XFxcIi02Mzg3LjU0XFxcIiB4Mj1cXFwiLTM1MDUuNzlcXFwiIHkyPVxcXCItNjMzNS42NlxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0xMS1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTUyLjE0XFxcIiB5MT1cXFwiLTYzNzAuNDdcXFwiIHgyPVxcXCItMzU1Ni44MVxcXCIgeTI9XFxcIi02MzQyLjY2XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTEyLWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1ODcuMTJcXFwiIHkxPVxcXCItNjMxNi4yNFxcXCIgeDI9XFxcIi0zNTYyLjM2XFxcIiB5Mj1cXFwiLTYzMTYuNTJcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMTMtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzQ0MC41N1xcXCIgeTE9XFxcIi02Mjg3LjU2XFxcIiB4Mj1cXFwiLTM0MzkuOTVcXFwiIHkyPVxcXCItNjIzMi42N1xcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0xNC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTUwLjE1XFxcIiB5MT1cXFwiLTYzMDQuNzRcXFwiIHgyPVxcXCItMzU1NC43MVxcXCIgeTI9XFxcIi02MjQ4LjAxXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTE1LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1NTAuMjZcXFwiIHkxPVxcXCItNjMwMi40M1xcXCIgeDI9XFxcIi0zNTU0LjUyXFxcIiB5Mj1cXFwiLTYyNDkuMzFcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMTYtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzQzOS45NFxcXCIgeTE9XFxcIi02MzY0LjY1XFxcIiB4Mj1cXFwiLTM0NDEuODVcXFwiIHkyPVxcXCItNjI5Ni43M1xcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0xNy1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNDM5Ljg4XFxcIiB5MT1cXFwiLTYzNjEuNjNcXFwiIHgyPVxcXCItMzQ0Mi4wMlxcXCIgeTI9XFxcIi02Mjg1LjYzXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTE4LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1NTcuMTJcXFwiIHkxPVxcXCItNjMwNC4zMlxcXCIgeDI9XFxcIi0zNTU5LjA1XFxcIiB5Mj1cXFwiLTYyODAuMjRcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMTktY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzUxNC4wOVxcXCIgeTE9XFxcIi02MjkyLjE5XFxcIiB4Mj1cXFwiLTM1NTUuNDRcXFwiIHkyPVxcXCItNjI5MC42N1xcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0yMC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTU0LjU3XFxcIiB5MT1cXFwiLTYzNjguOTRcXFwiIHgyPVxcXCItMzU2MS43N1xcXCIgeTI9XFxcIi02MzE3LjhcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMjEtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzM5OC45NVxcXCIgeTE9XFxcIi02NDE0LjA0XFxcIiB4Mj1cXFwiLTM1MjIuMjlcXFwiIHkyPVxcXCItNjQwOS45M1xcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0yMi1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zMzg2Ljg4XFxcIiB5MT1cXFwiLTY0MTUuNDVcXFwiIHgyPVxcXCItMzM5MS42XFxcIiB5Mj1cXFwiLTYzMzEuNjlcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMzgyMy4wNCA2NTE0LjgzKVxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0yMy1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zMzcwLjY0XFxcIiB5MT1cXFwiLTY0MTMuMjFcXFwiIHgyPVxcXCItMzQ0NC41XFxcIiB5Mj1cXFwiLTYzMjkuNzZcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMzgyMy4wNCA2NTE0LjgzKVxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0yNC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zMzUzLjkzXFxcIiB5MT1cXFwiLTYzOTEuMzZcXFwiIHgyPVxcXCItMzM5NS4yOFxcXCIgeTI9XFxcIi02Mzg5Ljg0XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTI1LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1NzUuNzNcXFwiIHkxPVxcXCItNjQxNS45M1xcXCIgeDI9XFxcIi0zNjE2Ljk0XFxcIiB5Mj1cXFwiLTY0MTQuNDFcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMjYtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzUwNS43OVxcXCIgeTE9XFxcIi02NDg3LjM3XFxcIiB4Mj1cXFwiLTM1MDUuNzlcXFwiIHkyPVxcXCItNjQ0MS44M1xcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0yNy1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTA1Ljc5XFxcIiB5MT1cXFwiLTY0ODYuOTJcXFwiIHgyPVxcXCItMzUwNS43OVxcXCIgeTI9XFxcIi02NDM1LjA1XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTI4LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1NTIuMTRcXFwiIHkxPVxcXCItNjQ2OS44NVxcXCIgeDI9XFxcIi0zNTU2LjgxXFxcIiB5Mj1cXFwiLTY0NDIuMDRcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMjktY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzU4Ny4xMlxcXCIgeTE9XFxcIi02NDE1LjYyXFxcIiB4Mj1cXFwiLTM1NjIuMzZcXFwiIHkyPVxcXCItNjQxNS45XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTMwLWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM0MzkuOTRcXFwiIHkxPVxcXCItNjQ2NC4wNFxcXCIgeDI9XFxcIi0zNDQxLjg1XFxcIiB5Mj1cXFwiLTYzOTYuMTFcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMzEtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzQzOS44OFxcXCIgeTE9XFxcIi02NDYxLjAyXFxcIiB4Mj1cXFwiLTM0NDIuMDJcXFwiIHkyPVxcXCItNjM4NS4wMlxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0zMi1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNTE0LjA5XFxcIiB5MT1cXFwiLTYzOTEuNTdcXFwiIHgyPVxcXCItMzU1NS40NFxcXCIgeTI9XFxcIi02MzkwLjA1XFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTMzLWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM1NTQuNTdcXFwiIHkxPVxcXCItNjQ2OC4zM1xcXCIgeDI9XFxcIi0zNTYxLjc3XFxcIiB5Mj1cXFwiLTY0MTcuMThcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMzQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzY5Ny4yNFxcXCIgeTE9XFxcIi02MzY3LjA5XFxcIiB4Mj1cXFwiLTM2OTMuNzVcXFwiIHkyPVxcXCItNjM2MS41OFxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0zNS1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNzA0Ljc3XFxcIiB5MT1cXFwiLTYzMTYuNFxcXCIgeDI9XFxcIi0zNzA0LjA3XFxcIiB5Mj1cXFwiLTYyNzMuMDNcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMzgyMy4wNCA2NTE0LjgzKVxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC0zNi1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNzA5LjExXFxcIiB5MT1cXFwiLTYzMDEuMTNcXFwiIHgyPVxcXCItMzcwOC43MVxcXCIgeTI9XFxcIi02Mjc2LjY1XFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDM4MjMuMDQgNjUxNC44MylcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtMzctY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzY5Ny4xM1xcXCIgeTE9XFxcIi02MjIxLjcxXFxcIiB4Mj1cXFwiLTM3ODQuODRcXFwiIHkyPVxcXCItNjIwOC42NFxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgzODIzLjA0IDY1MTQuODMpXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTM4LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM3MDYuOTRcXFwiIHkxPVxcXCItNjI2NC45MlxcXCIgeDI9XFxcIi0zNjk2LjdcXFwiIHkyPVxcXCItNjIxOC4zMlxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgzODIzLjA0IDY1MTQuODMpXFxcIiB4bGluazpocmVmPVxcXCIjbGluZWFyLWdyYWRpZW50LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwibGluZWFyLWdyYWRpZW50LTM5LWNvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4MT1cXFwiLTM3MDkuNzFcXFwiIHkxPVxcXCItNjI3NC4zOVxcXCIgeDI9XFxcIi0zNzA2LjgzXFxcIiB5Mj1cXFwiLTYyNDQuNjJcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMzgyMy4wNCA2NTE0LjgzKVxcXCIgeGxpbms6aHJlZj1cXFwiI2xpbmVhci1ncmFkaWVudC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcImxpbmVhci1ncmFkaWVudC00MC1jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeDE9XFxcIi0zNzA5LjcxXFxcIiB5MT1cXFwiLTYyNjguNTVcXFwiIHgyPVxcXCItMzcwNi44MlxcXCIgeTI9XFxcIi02MjM4Ljc5XFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDM4MjMuMDQgNjUxNC44MylcXFwiIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXItZ3JhZGllbnQtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJsaW5lYXItZ3JhZGllbnQtNDEtY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHgxPVxcXCItMzY3MC45N1xcXCIgeTE9XFxcIi02MjU4LjFcXFwiIHgyPVxcXCItMzY2Ny4yNlxcXCIgeTI9XFxcIi02MTgzLjA2XFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDM4MjMuMDQgNjUxNC44MylcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjBcXFwiIHN0b3AtY29sb3I9XFxcIiMwMDBcXFwiIHN0b3Atb3BhY2l0eT1cXFwiMFxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiLjQ5XFxcIiBzdG9wLWNvbG9yPVxcXCIjMDAwXFxcIiBzdG9wLW9wYWNpdHk9XFxcIi40OVxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiLjk3XFxcIiBzdG9wLWNvbG9yPVxcXCIjMDAwXFxcIj48L3N0b3A+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHBhdGggaWQ9XFxcImJhY2tncm91bmRfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGNsYXNzPVxcXCJjbHMtNDVfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIk0xMTMuMzQsMTg5LjIyYy0zMy4yNCw2LjQ5LTEwNC44MiwyMi4zNC04MC41MSwxMDEuNDMsMy4zOSwxMS4wNSwyNS4yOCw0OC44MSwyNy43MSw2MC4xMSwyLjcsMTIuNjItMi45MSwyNS45My0uMTcsMzguNTUsNC45NCwyMi42OCwzMi4zOCwzMS4xMSw1NS4zMywzNC42MywyNi41NCw0LjA3LDUzLjksNy4xNCw4MC4wMiwxLjA2LDE0LjQxLTMuMzUsMjguMDYtOS4zOSw0Mi40LTEzLjA0LDU4Ljg1LTE0LjgzLDEyMi45MywxMi4xMiwxODAuNzYtNi4yLDE3LjEyLTUuNDEsMzQuMjMtMTYuMiwzOS42My0zMy4zMywzLjQ4LTExLjE1LDEuNS0yMy4xOSwxLjQ0LTM0Ljg5LS4xNy0yOS43MiwzLjY4LTY5LjI0LDEzLjExLTk3LjQyczUyLjg4LTEzOS4xLTM4LjI1LTE1Ny4yN2MtMTMyLjQtMjYuNC05MC41NCw2MS4yOS0zMjEuNDYsMTA2LjM3aC0uMDFaXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBhdGggaWQ9XFxcImZsb29yX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBjbGFzcz1cXFwiY2xzLTQ1X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNMTExLjY4LDM4OS40NGMtMjEuMjksNC42LTQzLjgsMTAuNjgtNTguMjUsMjYuOTUtMi45OCwzLjM1LTUuNjYsNy4zNi01LjczLDExLjg0LS4xOCwxMC42NiwxMi45OSwxNS42NSwyMy41NiwxNy4wOCwzMi42NCw0LjM1LDY1LjcyLDIuOTgsOTguNjIsMS42MywyMC44MS0uODcsNDEuNjgtMS43NCw2Mi4yNy00Ljc5LDQwLjQ2LTYuMDksODAuNTktMjAuNzgsMTIxLjMxLTE2LjM0LDEzLjQxLDEuNDYsMjYuNTIsNC45OSwzOS45NCw2LjM0LDIxLjU3LDIuMTMsNDMuMzItMS40MSw2My4xLTEwLjI2LDYuOTUtMy4xMywxNC4zLTcuNzIsMTYuMTMtMTUuMTQsMS44My03LjQyLTIuNjYtMTUuMDEtOC44My0xOS4zMS02LjE3LTQuMy0xMy43Ny01Ljk1LTIxLjEzLTcuNS0xNy43My0zLjczLTMzLjA0LTEwLjM1LTUxLjItMTEuNS0yMi45Ny0xLjQ0LTQ1Ljk5LTIuMTEtNjkuMDQtMi00NS42NC4yMy05MS4yMiwzLjUxLTEzNi40Myw5LjgyLTI0LjkzLDMuNDgtNDkuNyw3Ljg3LTc0LjMxLDEzLjE4aC0uMDFaXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PGcgaWQ9XFxcInNoYWRvd19jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgY2xhc3M9XFxcImNscy00Nl9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PHBhdGggY2xhc3M9XFxcImNscy00Ml9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTkzLjQzLDQzOS4zMWMxMi43NSwxLjE2LDI1LjU2LDEuNjYsMzguMzYsMS43NCwxMS4wOC4wNSwyMi41MS0uMjksMzIuNTgtNC44OSw1LjUyLTIuNTIsMTAuNS02LjI4LDE2LjMtOC4wNyw1LjQ2LTEuNjksMTEuMy0xLjU0LDE2Ljk0LTIuMyw1LjY0LS43NiwxMS42MS0yLjc0LDE0LjkyLTcuMzlsLTIxLjYzLTcuMTljLTIuNzQtMS01LjU2LTEuNzYtOC40My0yLjI2LTMuNjctLjQtNy4zNy0uMzYtMTEuMDMuMTEtMTMuODgsMS4zNC0yNy42NiwzLjU2LTQxLjI1LDYuNjQtNy42MiwxLjc0LTExLjU3LDYuMjYtMTguMTgsOS4xNi01LjMyLDIuMzQtOC41MS41LTEzLjkxLjM1LTEyLjU2LS4zNC0yMS41MywxMi41NC00LjY3LDE0LjA4di4wMlpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTQyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMjEyLjI0LDM4Mi43NGMtMy4xOC4wNS03LjQ2LDEuMDQtNy40Miw0LjIzLDExLjQ4LDMuNTYsMjMuODMtLjM3LDM1Ljg0LjA1LDE2LjE1LjU3LDMwLjg2LDguOTYsNDQuODIsMTcuMTMtNS41LS4xMy0xMC42NSwyLjcxLTEzLjQ2LDcuNDQsMzEuNDYsMy4zMiw2Mi45OC00LjcsOTQuNi01LjIyLDMzLjEtLjUsNjYuMjcsNy4yNyw5OS4xMSwzLjE5LS41Ny0yLjY3LTMuNzktMy42OS02LjQ5LTQuMDktMTMuODEtMi4wOS0yNy44OS0xLjE0LTQxLjgyLTIuMDMtMTMuOTQtLjktMjguMzctMy45Mi0zOS4yMy0xMi42OSwxMS4yOC0yLjY4LDIyLjE4LTYuNzcsMzIuNDQtMTIuMTctNi41Mi0zLjA3LTE0LjEzLTIuMTMtMjEuMjgtMS4yNy00Ny40OCw1Ljc0LTk1LjUyLDUuMDktMTQyLjgzLTEuOTEtMS42MywzLjI2LDMuMzUsNS42OSw2Ljk1LDUuOTdsNzkuMjgsNi4yOWM5LjA4LjcyLDE4LjkxLDEuNzQsMjUuNTksNy45NS0zNS4wNiw2LjczLTgzLjI0LS4yMy0xMTYuMjctMTMuODYtNS40Mi0yLjI0LDMuMzktOC41Ni0yLjQ2LTcuOTUtNi43OS43MS0xOS4yMyw4Ljc5LTI3LjM5LDguOTRoLjAyWlxcXCI+PC9wYXRoPjwvZz48ZyBpZD1cXFwiY29uc3RydWN0aW9uX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIj48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIzOTEuNzVcXFwiIHk9XFxcIjE1NS44M1xcXCIgd2lkdGg9XFxcIjE1LjQxXFxcIiBoZWlnaHQ9XFxcIjIyMS41MlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtMV9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMzk4LjI5XFxcIiB5PVxcXCIxNTUuODNcXFwiIHdpZHRoPVxcXCI4Ljg3XFxcIiBoZWlnaHQ9XFxcIjIyMS41MlxcXCI+PC9yZWN0PjxwYXRoIGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIk00MDcuMTYsMjAyLjk5YzAtLjQ5LDU1LjQsMTguOTMsNTUuNCwxOC45M2wxLjMyLDE5LjAzLTU3Ljk0LTIwLjk3LS4xNS0xN2gxLjM3WlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtMzVfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk00MDUuNzgsMjA0LjYyYzAtLjQ5LDU2Ljc4LDE5Ljk1LDU2Ljc4LDE5Ljk1bDEuMzIsMTUuNTctNTcuOTQtMjAuOTctLjE2LTE0LjU1aDBaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTQwMi44MiwyMDYuNzhjMC0uNDksNTUuMzksMTguOTMsNTUuMzksMTguOTNsMS4zMiwxNy44MS01Ny45NC0yMC45Ny0uMTctMTUuODEsMS40MS4wNGgwWlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtMzZfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk00MDEuNDQsMjA3Ljk5YzAtLjQ5LDU2Ljc3LDE5Ljk1LDU2Ljc3LDE5Ljk1bDEuMzIsMTUuNTctNTcuOTQtMjAuOTctLjE1LTE0LjU1WlxcXCI+PC9wYXRoPjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjQ1My4wOFxcXCIgeT1cXFwiMTc0LjY3XFxcIiB3aWR0aD1cXFwiMTUuNDFcXFwiIGhlaWdodD1cXFwiMjI4LjI3XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0zNF9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiNDU0Ljg0XFxcIiB5PVxcXCIxNzQuNjdcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjguMjdcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCI0NTkuMjNcXFwiIHk9XFxcIjE3NC42N1xcXCIgd2lkdGg9XFxcIjIuMTdcXFwiIGhlaWdodD1cXFwiMjI4LjI3XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHBvbHlnb24gY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgcG9pbnRzPVxcXCI0NTkuMzUgMjk1LjEgNDU5LjM1IDI5Ny45NiA0NTkuMDkgMzEwLjY2IDQwMS44MyAyOTEuNDcgNDAxLjczIDI5MS40MyA0MDIuNDcgMjc2LjQ2IDQ1OS4zNSAyOTUuMVxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wb2x5Z29uPjxwb2x5Z29uIGNsYXNzPVxcXCJjbHMtNDBfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHBvaW50cz1cXFwiNDU5LjA5IDI5Ny4zMSA0NTkuMDkgMzEyLjAyIDQwMS44MyAyOTEuNDcgNDAyLjQ3IDI3OC42NCA0NTkuMDkgMjk3LjMxXFxcIj48L3BvbHlnb24+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjMxLjMxXFxcIiB5PVxcXCIxNTEuMTJcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjYuMjNcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQxX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIyMzMuMDdcXFwiIHk9XFxcIjE1MS4xMlxcXCIgd2lkdGg9XFxcIjE1LjQxXFxcIiBoZWlnaHQ9XFxcIjIyNi4yM1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjI0MC43OFxcXCIgeT1cXFwiMjc2LjI0XFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjE0LjQxXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0zOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMjQwLjc4XFxcIiB5PVxcXCIyNzYuMjRcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTQuNDFcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTM3X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIyNDYuNTdcXFwiIHk9XFxcIjI3Ni4yNFxcXCIgd2lkdGg9XFxcIjE0NS4xN1xcXCIgaGVpZ2h0PVxcXCIxLjk3XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjQwLjc4XFxcIiB5PVxcXCIyMDIuMjFcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTQuNDFcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTM4X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIyNDAuNzhcXFwiIHk9XFxcIjIwMi4yMVxcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxNC40MVxcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjI0Mi43OFxcXCIgeT1cXFwiMjA2LjAxXFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjE0LjQxXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0xOF9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMjQwLjc4XFxcIiB5PVxcXCIyMDQuMDFcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTYuNDFcXFwiPjwvcmVjdD48cG9seWdvbiBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBwb2ludHM9XFxcIjI5Mi45MyAyMjMuMjIgMjQ2LjcyIDIwNi4wMSAyNDYuNzIgMjA5Ljc3IDI5Mi45MyAyMjYuOTYgMjkyLjkzIDIyMy4yMlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wb2x5Z29uPjxwb2x5Z29uIGNsYXNzPVxcXCJjbHMtMTVfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHBvaW50cz1cXFwiMjkyLjkzIDIyMy4yMiAyNDYuNzIgMjA2LjAxIDI0Ni43MiAyMDkuNzcgMjkyLjkzIDIyNi45NiAyOTIuOTMgMjIzLjIyXFxcIj48L3BvbHlnb24+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjQ2LjcyXFxcIiB5PVxcXCIyMDYuMDFcXFwiIHdpZHRoPVxcXCIxNDUuMDNcXFwiIGhlaWdodD1cXFwiMS41XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjQ2LjcyXFxcIiB5PVxcXCIyMDEuMlxcXCIgd2lkdGg9XFxcIjE0NS4wM1xcXCIgaGVpZ2h0PVxcXCIxLjVcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyMzcuNDZcXFwiIHk9XFxcIjE1MS4xMlxcXCIgd2lkdGg9XFxcIjkuMjZcXFwiIGhlaWdodD1cXFwiMjI2LjIzXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0xNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMjM3LjQ2XFxcIiB5PVxcXCIxNTEuMTJcXFwiIHdpZHRoPVxcXCI5LjI2XFxcIiBoZWlnaHQ9XFxcIjIyNi4yM1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjMwNi4xNlxcXCIgeT1cXFwiMjk4Ljk0XFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjE0LjQxXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0xN19jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMzA2LjE2XFxcIiB5PVxcXCIzMDAuOTNcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTIuNDFcXFwiPjwvcmVjdD48cG9seWdvbiBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBwb2ludHM9XFxcIjIzNy40NiAyOTQuMDkgMzA1LjExIDMxNC44IDMwNS4wNiAyOTcuNTUgMjM3LjQ2IDI3Ni43OSAyMzcuNDYgMjk0LjA5XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy0yNl9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIzMDUuMTEgMzE0LjggMzA1LjEgMzE0LjggMjM3LjQ2IDI5NC4wOSAyMzcuNDYgMjc2Ljc5IDMwNS4wNiAyOTcuNTUgMzA1LjExIDMxNC44XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy0yMl9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIzMDUuMSAzMTQuOCAyMzcuNDYgMjk0LjA5IDIzNy40NiAyNzguODYgMzA1LjA2IDI5OS42MiAzMDUuMSAzMTQuOFxcXCI+PC9wb2x5Z29uPjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjMwNi4xNlxcXCIgeT1cXFwiMjI0LjkxXFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjEzLjk2XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy0yMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgeD1cXFwiMzA2LjE2XFxcIiB5PVxcXCIyMjYuOTZcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTEuOTFcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIzMDYuMTZcXFwiIHk9XFxcIjIyOVxcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxNS45NlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtMTlfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjMwNi4xNlxcXCIgeT1cXFwiMjMxLjA1XFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjEzLjg0XFxcIj48L3JlY3Q+PHBvbHlnb24gY2xhc3M9XFxcImNscy0yNV9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIyMzcuNDYgMjc2Ljc5IDI1Mi44OCAyNzYuNzkgMjkyLjkzIDI4Ny43IDI5Mi45MyAyOTMuODMgMjM3LjQ2IDI3Ni43OVxcXCI+PC9wb2x5Z29uPjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjIzNy40NlxcXCIgeT1cXFwiMTUxLjEyXFxcIiB3aWR0aD1cXFwiMi4xN1xcXCIgaGVpZ2h0PVxcXCIyMjYuMjNcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyOTIuOTNcXFwiIHk9XFxcIjE3NC40NlxcXCIgd2lkdGg9XFxcIjE1LjQxXFxcIiBoZWlnaHQ9XFxcIjIyOC4yN1xcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtMjFfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjI5NC42OVxcXCIgeT1cXFwiMTc0LjQ2XFxcIiB3aWR0aD1cXFwiMTUuNDFcXFwiIGhlaWdodD1cXFwiMjI4LjI3XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjk5LjA4XFxcIiB5PVxcXCIxNzQuNDZcXFwiIHdpZHRoPVxcXCIyLjE3XFxcIiBoZWlnaHQ9XFxcIjIyOC4yN1xcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0Pjxwb2x5Z29uIGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHBvaW50cz1cXFwiMjM5LjYzIDIwNy4xMiAyOTIuOTMgMjI2Ljk2IDI5Mi45MyAyNDQuODkgMjM5LjYzIDIyMS43NSAyMzkuNjMgMjA3LjEyXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy0yOF9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIyMzkuNjMgMjA5LjQyIDI5Mi45MyAyMjkuMjcgMjkyLjkzIDI0NC44OSAyMzkuNjMgMjIxLjc1IDIzOS42MyAyMDkuNDJcXFwiPjwvcG9seWdvbj48cG9seWdvbiBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBwb2ludHM9XFxcIjI0Ni43MiAyMDYuMDEgMjkyLjkzIDIyMy4yMiAyOTIuOTMgMjI1LjI3IDI0Ni43MiAyMDguMTIgMjQ2LjcyIDIwNi4wMVxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wb2x5Z29uPjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjM5MS43NVxcXCIgeT1cXFwiNTYuNDVcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIxMzUuNDZcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTI0X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIzOTguMjlcXFwiIHk9XFxcIjU2LjQ1XFxcIiB3aWR0aD1cXFwiOC44N1xcXCIgaGVpZ2h0PVxcXCIyMjEuNTJcXFwiPjwvcmVjdD48cGF0aCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNNDA3LjE2LDEwMy41OWMwLS40OCw1NS40LDE4LjkzLDU1LjQsMTguOTNsMS4zMiwxOS01Ny45NC0yMC45Ny0uMTUtMTcsMS4zNy4wM2gwWlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtMjdfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk00MDUuNzgsMTA1LjIzYzAtLjQ4LDU2Ljc4LDIwLDU2Ljc4LDIwbDEuMzIsMTUuNTQtNTcuOTctMjAuOTYtLjEzLTE0LjU3aDBaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTQwMi44MiwxMDcuMzljMC0uNDksNTUuMzksMTguOTMsNTUuMzksMTguOTNsMS4zMiwxNy44Mi01Ny45NC0yMC45Ny0uMTUtMTUuNzhoMS4zOFpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTIzX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNNDAxLjQ0LDEwOC42MWMwLS40OSw1Ni43NywyMCw1Ni43NywyMGwxLjMyLDE1LjU0LTU3Ljk0LTIwLjk3LS4xNS0xNC41NmgwWlxcXCI+PC9wYXRoPjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjQ1My4wOFxcXCIgeT1cXFwiNzUuMjlcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjguMjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTMwX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCI0NTQuODRcXFwiIHk9XFxcIjc1LjI5XFxcIiB3aWR0aD1cXFwiMTUuNDFcXFwiIGhlaWdodD1cXFwiMjI4LjI3XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiNDU5LjIzXFxcIiB5PVxcXCI3NS4yOVxcXCIgd2lkdGg9XFxcIjIuMTdcXFwiIGhlaWdodD1cXFwiMjI4LjI3XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjMxLjMxXFxcIiB5PVxcXCI1MS43NFxcXCIgd2lkdGg9XFxcIjE1LjQxXFxcIiBoZWlnaHQ9XFxcIjIyNi4yM1xcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtMTRfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjIzMy4wN1xcXCIgeT1cXFwiNTEuNzRcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjYuMjNcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyNDAuNzhcXFwiIHk9XFxcIjEwMi44M1xcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxNC40MVxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtMzFfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjI0MC43OFxcXCIgeT1cXFwiMTAyLjgzXFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjE0LjQxXFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgeD1cXFwiMjQyLjc4XFxcIiB5PVxcXCIxMDYuNjNcXFwiIHdpZHRoPVxcXCIxNTIuOTNcXFwiIGhlaWdodD1cXFwiMTQuNDFcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTI5X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIyNDAuNzhcXFwiIHk9XFxcIjEwNC42M1xcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxNi40MVxcXCI+PC9yZWN0Pjxwb2x5Z29uIGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHBvaW50cz1cXFwiMjkyLjkzIDEyMy44MyAyNDYuNzIgMTA2LjYzIDI0Ni43MiAxMTAuMzcgMjkyLjkzIDEyNy41OCAyOTIuOTMgMTIzLjgzXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy0xM19jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIyOTIuOTMgMTIzLjgzIDI0Ni43MiAxMDYuNjMgMjQ2LjcyIDExMC4zNyAyOTIuOTMgMTI3LjU4IDI5Mi45MyAxMjMuODNcXFwiPjwvcG9seWdvbj48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyNDYuNzJcXFwiIHk9XFxcIjEwNi42M1xcXCIgd2lkdGg9XFxcIjE0NS4wM1xcXCIgaGVpZ2h0PVxcXCIxLjVcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyNDYuNzJcXFwiIHk9XFxcIjEwMS44MlxcXCIgd2lkdGg9XFxcIjE0NS4wM1xcXCIgaGVpZ2h0PVxcXCIxLjVcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyMzcuNDZcXFwiIHk9XFxcIjUxLjc0XFxcIiB3aWR0aD1cXFwiOS4yNlxcXCIgaGVpZ2h0PVxcXCIyMjYuMjNcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTRfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjIzNy40NlxcXCIgeT1cXFwiNTEuNzRcXFwiIHdpZHRoPVxcXCI5LjI2XFxcIiBoZWlnaHQ9XFxcIjIyNi4yM1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjMwNi4xNlxcXCIgeT1cXFwiMTI1LjUzXFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjEzLjk2XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy02X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIzMDYuMTZcXFwiIHk9XFxcIjEyNy41OFxcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxMS45MVxcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjMwNi4xNlxcXCIgeT1cXFwiMTI5LjYxXFxcIiB3aWR0aD1cXFwiMTUyLjkzXFxcIiBoZWlnaHQ9XFxcIjE1Ljk2XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3JlY3Q+PHJlY3QgY2xhc3M9XFxcImNscy03X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiB4PVxcXCIzMDYuMTZcXFwiIHk9XFxcIjEzMS42NlxcXCIgd2lkdGg9XFxcIjE1Mi45M1xcXCIgaGVpZ2h0PVxcXCIxMy44NFxcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjIzNy40NlxcXCIgeT1cXFwiNTEuNzRcXFwiIHdpZHRoPVxcXCIyLjE3XFxcIiBoZWlnaHQ9XFxcIjIyNi4yM1xcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9yZWN0PjxyZWN0IGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIHg9XFxcIjI5Mi45M1xcXCIgeT1cXFwiNzUuMDhcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjguMjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTVfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIHg9XFxcIjI5NC42OVxcXCIgeT1cXFwiNzUuMDhcXFwiIHdpZHRoPVxcXCIxNS40MVxcXCIgaGVpZ2h0PVxcXCIyMjguMjdcXFwiPjwvcmVjdD48cmVjdCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiB4PVxcXCIyOTkuMDhcXFwiIHk9XFxcIjc1LjA4XFxcIiB3aWR0aD1cXFwiMi4xN1xcXCIgaGVpZ2h0PVxcXCIyMjguMjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcmVjdD48cG9seWdvbiBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBwb2ludHM9XFxcIjIzOS42MyAxMDcuNzQgMjkyLjkzIDEyNy41OCAyOTIuOTMgMTQ1LjUgMjM5LjYzIDEyMi4zNiAyMzkuNjMgMTA3Ljc0XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy0zX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBwb2ludHM9XFxcIjIzOS42MyAxMTAuMDQgMjkyLjkzIDEyOS44OCAyOTIuOTMgMTQ1LjUgMjM5LjYzIDEyMi4zNiAyMzkuNjMgMTEwLjA0XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgcG9pbnRzPVxcXCIyNDYuNzIgMTA2LjYzIDI5Mi45MyAxMjMuODMgMjkyLjkzIDEyNS44NyAyNDYuNzIgMTA4LjcyIDI0Ni43MiAxMDYuNjNcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcG9seWdvbj48L2c+PGcgaWQ9XFxcImNoYXJhY3Rlcl9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCI+PHBhdGggY2xhc3M9XFxcImNscy00M19jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTEzMC41NSwyMTYuMTZjMS4xMywxLjQzLDEuNjYsMy4yNCwxLjQ4LDUuMDUtLjA5Ljc5LS4zLDEuNTctLjM0LDIuMzYtLjA4LjguMTcsMS42LjcsMi4yMS40Ny40NSwxLjIxLjc0LDEuMzIsMS4zNy4xNy44Ny0uOTEsMS4zOC0xLjU1LDIuMDEtLjU2LjctLjk1LDEuNTItMS4xMywyLjQtLjM5LDEuMjgtLjkzLDIuNTItMS42LDMuNjktLjU4LDEuMjMtMS41OCwyLjIxLTIuODIsMi43Ni0uODcuMzEtMS45My4yMy0yLjc2LjcxLTEuOTUsMS4xMi0xLjQ5LDQuMzUtMy4yOSw1LjczLS41Mi4zNS0xLjEyLjU2LTEuNzQuNjMtMS40My4yMi0yLjg5LjAyLTQuMjEtLjU3LS41OS0uMjMtMS4xMS0uNjMtMS40OC0xLjE1LS4zNS0uNy0uNDctMS40OS0uMzYtMi4yNy4xNS0yLjYxLjUtNS4yNy40Mi03LjktLjA0LTEuNDEtLjIxLTIuODItLjE5LTQuMjMuMDQtNC4yMywxLjk1LTguMjIsNS4yMi0xMC45MSwzLjM0LTIuNjQsNy44Mi0zLjM1LDExLjgxLTEuODhsLS43Ny0uODdcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTQyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTE2LjYyLDIyMy4zM2MtMS4yMi4zMi0xLjk4LDEuNTMtMS43NCwyLjc2LjMxLDEuMiwxLjM3LDIuMDUsMi42MSwyLjFsLTIuNzcsNS4zM2MtLjIzLjQ1LS42My45OS0xLjEyLjg3cy0uNjItLjgtLjcxLTEuMzNjLS4zLTEuNjgtMS42Mi0yLjk2LTIuMzYtNC40OS0xLjEtMi4yMy0uODctNC44Ni0uNjgtNy4zNC4yLTIuMjEuNDMtNC41MiwxLjYzLTYuMzkuNy0xLjAxLDEuNTctMS44OSwyLjU2LTIuNjEsMS42Ni0xLjQxLDMuNjYtMi4zNCw1LjgtMi43LDEuODEtLjEzLDMuNjIuMSw1LjM0LjY2LDEuNzMuMzcsMy4zNSwxLjEyLDQuNzUsMi4yLDEuNCwxLjEyLDIuMDMsMi45NiwxLjYsNC43LTIuNjEuMzUtNy42OCwwLTkuNzIsMS45LTEuNzQsMS42NC0uNTYsNS4yMi0yLjgxLDYuMzQtLjA5LTEuNS0xLjExLTEuODItMi4zNi0yLjAxaC0uMDJaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTEzOC44OSwyMTRjLS44LS40OC00LjM1LTEuOTYtNS4xNi0yLjQ0LS4xNi0yLjgyLTMuMTktNi40OS03LjM1LTguMDUtMy4xMS0xLjEyLTkuNTEtMS4xMi0xNC41OSwyLjY5LTUuNzYsNC4zNS00Ljk2LDExLjYzLTUuMDIsMTMuNTQtLjAzLDEuMzQsMS4wMiwyLjQ1LDIuMzYsMi40OS4zNSwwLC43LS4wNiwxLjAzLS4yLDEuNTQtLjcsMy4xMi0xLjMsNC43My0xLjgxbDYuOTUtMS43NGM0LjkxLTEuMywxMi4xMS0zLjIsMTcuMDQtNC40N2guMDFaXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcImNscy0xMF9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgcG9pbnRzPVxcXCIxMzcuODIgMjEzLjU0IDExNy4yNiAyMTguODYgMTI0LjA1IDIxNS4yNSAxMjUuOTEgMjE0LjI3IDEyOS4wNSAyMTMuMTggMTMyLjU5IDIxMS45NiAxMzMuNzMgMjExLjU2IDEzNy44MiAyMTMuNTRcXFwiPjwvcG9seWdvbj48cG9seWdvbiBjbGFzcz1cXFwiY2xzLTQyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBwb2ludHM9XFxcIjExNy4yNiAyMTkuNTUgMTExLjEyIDIzMC44NSAxMDkuNzEgMjI3LjQxIDExMS42NSAyMjQuMDEgMTA5LjQxIDIyMi4zOSAxMTEuNzkgMjIxLjMxIDExMy4zNCAyMjIuNTUgMTEzLjk3IDIyMC41IDExNy4yNiAyMTkuNTVcXFwiPjwvcG9seWdvbj48cGF0aCBjbGFzcz1cXFwiY2xzLTQ0X2NvbnN0cnVjdGlvbi1zaXRlLTU5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNMTA3LjYzLDIyMS42M3MuOTcuMjUsMy40OC0uODdjMi4wMS0uODEsNC4wOC0xLjQ2LDYuMTktMS45M2w4LjY0LTQuNTlzLTEwLjk5LTUuNTMtMTcuNDcuNzRjLS4wMy4wMi0yLjU2LDMuNDktLjgzLDYuNjVoLS4wMVpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTEyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTA3LjUsMjEyLjUyczQuNy04LjA4LDEyLjI0LTguMDVjMy41Ni4wMyw2Ljk4LDEuMzIsOS42OCwzLjY0LDAsMC0xMi45NS04LjE1LTIxLjkyLDQuNDFaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy04X2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTA3LjMzLDIyMC45NXMuMDksMS4yNCwyLjE2LjQzYzIuMDgtLjgxLDguMzQtMi42MSw4LjM0LTIuNjFsMi44OS0xLjc0cy0xMi4yNSw0LjctMTMuNCwzLjkxaC4wMVpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTQyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTEwLjY3LDQxNS42N2MxNC4xOS0yNy4xOCwyMi43MS01Ni45NiwyNS4wMy04Ny41My4yMS0yLjc4LjMyLTUuNzctMS4xNS04LjE1LTIuODEtNC41Ni05LjQyLTQuMjktMTQuNy0zLjQ4LTIuNC4zOC01LjExLjk4LTYuMzEsMy4wOS0uODcsMS41Ni0xMC4wMiw3LjE5LTkuMTksOC43Nyw2LjA5LDExLjQ4LDguNTUsMjYuMjEsNS41MSw0MS41Mi0yLjk5LDE1LjA3LTguMzYsMjYuMi0xMC41Miw0MS4yNCwxLjIzLjEsMTAuODYsNS40MiwxMS4zMyw0LjUzaDBaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTE3MC4xNCwyNjEuMTdjLS44Nyw1Ljg5LTMuMjksMTEuNzQtNy43NSwxNS42NXMtMTEuMTIsNS42NS0xNi42MSwzLjMzYy01Ljc1LTIuNDMtOS4wMi04LjQtMTEuODYtMTMuOTEtLjA2LDEzLjk3LDUuNTUsMjcuODIsMy42LDQxLjYyLS4xNCwyLjAyLS44NywzLjk1LTIuMDgsNS41Ny0xLjUsMS43NC0zLjgxLDIuNDYtNi4wMSwzLjA3LTcuNjgsMi4wOS0xNS41NCwzLjQ4LTIzLjQ3LDQuMTUtLjc3LjA2LTEuNTIuMTMtMi4yOS4xNy0uOTItNC41Ni0xLjMtMTAuNDktMS4zNy0xNy43M3YtMi4xOWMwLTUuODEuMTQtMTIuMzguMzYtMTkuNjZ2LTIuMTFjMC0uNDEsMC0xLjA0LjA1LTEuNzR2LTQuMjNjLjE1LTQuNTIuMy05LjI4LjQzLTE0LjI3LDAtLjY0LDAtMS4yOC4wNC0xLjkzLjAyLTEuNzcuMjMtMy41NC42My01LjI3LjYyLTIuODgsMi4zMy01LjQsNC43Ny03LjA0aDBjMS44My0xLjIsMy44LTIuMTUsNS44OC0yLjgzLDguMzEtMi45MSwxOC4yLTEuMTcsMjQuMTQsNS4wOSwxLjAyLDEuMDksMS45NCwyLjI3LDIuNzQsMy41NCwxLjMyLDIuMDIsMi40Miw0LjE3LDMuNTYsNi4zMSwxLjE1LDIuMjgsMi40OSw0LjQ1LDQuMDEsNi40OSwxLjM3LDEuNzQsMy4zNywzLjQsNS41NCwzLjAyLDMuMTEtLjU2LDMuOTYtNC41Niw0LTcuNjkuMDYtNS4yLS4yMy0xMC40MS0uODctMTUuNTcsMy45OC0uMzYsNy45OC0uMjIsMTEuOTIuNDMuNDksMy4xOS44Miw2LjQuOTgsOS42Mi4xMywyLjcxLjAyLDUuNDMtLjM0LDguMTN2LS4wMlpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTExX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTIwLjMyLDI4Ni40M2MtMi4zMywzLjgtNS41LDcuMDEtOC42OSwxMC4wOC0xLjUsMS40My0uNjMsMTguNzMtMi4xOCwyMC4xMy0uNTcuNS0xLjk1LDIuMjEtMy40OCw0LS43Ny4wNi0xLjUyLjEzLTIuMjkuMTctLjkyLTQuNTYtMS4zLTEwLjQ5LTEuMzctMTcuNzN2LTIuMTljMC01LjgxLjE0LTEyLjM4LjM2LTE5LjY2di0yLjExYzAtLjQxLDAtMS4wNC4wNS0xLjc0di00LjIzYzEuMDktLjk1LDEuODgsMy4wMywyLjA4LDMuNTUuMDcuMTcuMTYuMzMuMjkuNDcuMTguMTQuNC4yMS42My4xOCwxLjAzLS4xNywxLjk3LS43MiwyLjYxLTEuNTUsMS43LTEuNywzLjMyLTMuNDgsNC44Ni01LjM0bDEwLjI4LDMuMjdjLjY3LDQuNDItLjc5LDguODktMy4xMywxMi42OWgtLjAyWlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtNDRfY29uc3RydWN0aW9uLXNpdGUtNTkgdGFyZ2V0Q29sb3JcXFwiIGQ9XFxcIk0xMjIuMjIsMjczLjQ2Yy0zLjAyLDEyLjM4LTEyLDI0LjM0LTE5LjkyLDI3LjQ0LTMuMjQsMS4yNi02LjMsMS4wNC04LjY5LTEuMjQtNC4zNS0zLjg5LTUuMjItMTguMjYtMy44OS0zNC4zNi4xNS0xLjk5LjU1LTMuOTUsMS4yLTUuODMuOTItMi41NywyLjMzLTQuOTUsNC4xMy03LjAxLDMuNzEtNCw4LjUtNi44NCwxMy43OS04LjE5bC0uMDguMzUtMS40MSw2Ljg1LTEuNDksNy4yLTIuOTgsMTQuNDctMS43NCw4LjM0YzAsLjk1LjU4LjcsMS40Ny0uMjQsMi40OC0yLjYxLDcuNDItMTAuNTgsOS41LTEyLjI0LjA2LS4wNS4xMi0uMS4xNy0uMTZsOS45Myw0LjYyaC4wMVpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTJfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0xNDQuOSwyNTYuNzVjLS4yOS4wNi0uNTkuMS0uODcuMTQtNi4zOC43Ni0xMi44Mi41LTE5LjI0LjY0cy0xMi42Mi42Ni0xOC45MywxLjEzbC0yLjU1LjJjLTQuMTIuMjgtOC4yNi41Mi0xMi40LjYuOTItMi41NywyLjMzLTQuOTUsNC4xMy03LjAxLjYxLS4xNCwxLjIzLS4yMywxLjg1LS4yOCwyLjM2LS4xOSw0LjcyLS4zNyw3LjA5LS41MSwxLjEyLS4wOCwyLjI0LS4xNCwzLjM2LS4yLDcuNTEtLjQzLDE1LjAxLS43LDIyLjUyLS45NywzLjgzLS4xMyw3LjY1LS4yNiwxMS40Ny0uMDVoMGMxLjMzLDIuMDIsMi40Myw0LjE3LDMuNTcsNi4zMWgwWlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtNDJfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0xMjcuNjQsMzYzLjQ2YzkuNDEsMTIuMjgsMTguMywyNi4wOCwxOS4xMyw0MS40OS4xNiwyLjc3LjQ3LDYuMjIsMy4wNiw3LjIyLDEuMjQuMzQsMi41Ni4zMiwzLjc5LS4wNmw5LjU2LTEuOTctNS45Ni0yNi42NmMtMS41LTYuNzMtMy4wMi0xMy41Mi01Ljg1LTE5LjgtMS45OS00LjQxLTQuNi04LjUxLTYuNzUtMTIuODYtNS40Mi0xMC45Ny03LjczLTIzLjE3LTkuOTktMzUuMi0xMS4xOS43My0zNi42LTQuMjUtMzAuMjcsMTIuODEsNS4wMiwxMy42MSwxNi4xMiwyMi44NiwyMy4yNywzNS4wNGguMDFaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00Ml9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTE1My4xMyw0MTUuOGMuMTcuNjIuNDcsMS4xOS44NywxLjcuODQuODEsMi4wMywxLjE0LDMuMTYuODcsMS4xMS0uMjcsMi4xNy0uNzQsMy4xMy0xLjM2LjU0LS4yNSwxLS42NCwxLjMzLTEuMTMuMzItLjg1LjI5LTEuNzgtLjA5LTIuNjFsLTEuNTctNC45OGMtLjA1LS4zLS4yMy0uNTctLjQ5LS43My0uMzQtLjA3LS43LjAzLS45Ni4yNy0xLjc0LDEuMTYtNC4zNSwxLjMtNS45NSwyLjQ1cy0uMDYsMy44LjU2LDUuNTNoLjAxWlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtNDJfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0xMDAuMDEsNDE4LjE2YzEuNTYsMS4wMywzLjI5LDEuNzgsNS4xLDIuMjMuMjguMDkuNTkuMDkuODcsMCwuNDItLjE1LjYxLS42Mi43NS0xLjAzbDIuMjUtNi40NWMtLjI3Ljc4LTQuODItMy4xNi01LjktMi43Ni0yLjAxLjc5LTIuNjgsNi4yMS0zLjA3LDguMDJoMFpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwiY2xzLTQyX2NvbnN0cnVjdGlvbi1zaXRlLTU5XFxcIiBkPVxcXCJNMTU5LjU0LDQxMy41NWMuOTctLjM1LDEuOTktLjU2LDMuMDMtLjYzLDIuODktLjA3LDUuNjYsMi4wNiw4LjQ4LDEuNC43My0uMjUsMS40Ny0uNDcsMi4yMy0uNjMsMS44NS0uMDcsMy40OCwxLjIzLDMuODIsMy4wNS4yNywxLjgtLjMxLDMuNjItMS41Nyw0LjkyLTEuMjYsMS4yNy0yLjc2LDIuMjktNC40MSwzLTMuMzksMS42Ni03LjAyLDIuNzgtMTAuNzUsMy4zLS45NC4xOS0xLjkxLjEzLTIuODMtLjE2LS43NS0uMzQtMS40LS44NS0xLjktMS41LTEuODEtMi4wNy0zLjg2LTUuNy0zLjU0LTguNTkuMzQtMy4wNSw1LjAzLTMuNDIsNy40Ni00LjE2aC0uMDJaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00Ml9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTEwNy44Niw0MTkuMDRjLjQxLjEyLjc5LjMxLDEuMTMuNTcuMzguNDIuNjUuOTMuOCwxLjQ4Ljk4LDIuNiwyLjY4LDQuODcsNC44OSw2LjU1LjkyLjU3LDEuNzMsMS4zLDIuMzgsMi4xNi42NS45MS41MiwyLjE2LS4zMSwyLjktLjUuMjgtMS4wNy40LTEuNjQuMzUtMS44OS0uMDUtMy43Ni0uMjQtNS42Mi0uNTUtNS4wNS0uNzMtMTAuNDMtMS42MS0xNC4yMi01LjAyLTEuMDQtLjgxLTEuNzQtMS45Ny0xLjk2LTMuMjctLjE2LTEuNjUuODctMi45NiwxLjc0LTQuMjQuNjMtLjk0LDEuNDMtMy4wMywyLjQyLTMuNjUsMi4yMi0xLjM2LDguMTUsMS45NSwxMC40MSwyLjczaC0uMDJaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTIxOC45MSwyMzQuMjhzLS4wNi45NS0uMTQsMi40Yy0uMjYsNC41NC0uODEsMTMuOTYtLjg3LDE0LjEzcy0yMDguNDgsOS4yMy0yMDguNDgsOS4yM2wtLjg3LTEyLjE3LS4yMi0yLjM2LDEyLjE3LS4xMSwxOTguNC0xMS4xMmgwWlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtOV9jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTIxOC43NywyMzYuNjhjLS4yNiw0LjU0LS44MSwxMy45Ni0uODcsMTQuMTNzLTIwOC40OCw5LjIzLTIwOC40OCw5LjIzbC0uODctMTIuMTcsMTEuOTUtLjEsMTk4LjI2LTExLjA5aDBaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy00NF9jb25zdHJ1Y3Rpb24tc2l0ZS01OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTIxOC45MSwyNDAuMTJzLS4wNi45NS0uMTQsMi40Yy0uMjYsNC41NS0uODEsMTMuOTctLjg3LDE0LjEzcy0yMDguNDgsOS4yMS0yMDguNDgsOS4yMWwtLjg3LTEyLjE3LS4yMi0yLjMzLDEyLjE3LS4xMSwxOTguNC0xMS4xMmgwWlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtMzJfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0yMTguNzcsMjQyLjUyYy0uMjYsNC41NS0uODEsMTMuOTctLjg3LDE0LjEzcy0yMDguNDgsOS4yMS0yMDguNDgsOS4yMWwtLjg3LTEyLjE3LDExLjk1LS4wNiwxOTguMjYtMTEuMWgwWlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtNDNfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0xMTkuOTUsMjcxLjkzYzIuMi0yLjY2LDMuMDYtNS4zMyw0LjA4LTguNjMuMy0uOTktLjY2LTEuMDMtMS44LDEuNjguMjktMS45Mi44Ny01LjAyLjg3LTUuNzYtMS4wMi0uOTQtMS4yNC43Ny0xLjUzLDEuNDctLjQ1LjkyLS44NSwxLjg2LTEuMjEsMi44My4xNy0xLjY1LjE2LTIuNDMuMzMtNC4wOCwwLS4zLDAtLjcyLS4zLS43OS0xLjU2LjMxLS45NSwzLjk2LTIuMzQsNS4zNS4yMy0xLjUyLjQ2LTUuMTIsMC00Ljg5LS44NywwLTEuMjksMS4xMS0xLjQ0LDEuOTlsLS44Nyw0LjkzYy0uNDktLjE1LS41OC0uNzctLjctMS4yN3MtLjY1LTEuMDQtMS4wNi0uNzRjLS4xMy4xMi0uMjIuMjgtLjI0LjQ1LS4wNC42MiwwLDEuMjUuMTQsMS44Ni4xMSwxLjItLjMxLDIuNC0xLjE1LDMuMjcsMi4zLDEuMDgsNC43MywxLjg3LDcuMjMsMi4zNGgtLjAxWlxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJjbHMtNDNfY29uc3RydWN0aW9uLXNpdGUtNTlcXFwiIGQ9XFxcIk0xNjAuNDEsMjM1LjgxYy0uNDYuNTYtLjgxLDEuMi0xLjAzLDEuODktLjI1LjUzLS4zOCwxLjEtLjM3LDEuNjksMCwuNi4zOSwxLjEyLjk2LDEuMzIuMTUuMDUuMzEuMDQuNDQtLjA0LjA5LS4wNy4xNi0uMTcuMjEtLjI4LjQ3LS44OS44Ny0xLjgyLDEuMi0yLjc3LS43Mi45LS44NywyLjE0LS4zNywzLjE5LjE3LjM2LjUxLjcuODcuNjJzLjUtLjQ3LjU5LS44MWMuMjMtLjguNDEtMS42MS41Ni0yLjQyLS4xMi41Mi0uMiwxLjA1LS4yMywxLjU4LS4wMy4yNywwLC41NS4xLjgxLjExLjI2LjM3LjQzLjY1LjQxLjIzLS4wNy40My0uMjIuNTYtLjQzLjYyLS44LDEuMTMtMS42OCwxLjUyLTIuNjEtLjE5Ljg2LS4xNSwxLjc2LjEsMi42MS4wNC4xMy4xMS4yNS4yMi4zMy4zNi4yNy44Ny0uMTMsMS4wOC0uNTEuNDYtLjcyLjgtMS41MiwxLjAxLTIuMzUuMTQtLjQ0LjE3LS45LjA5LTEuMzYtLjA5LS40Ny0uNDItLjg1LS44Ny0xLS40Ni0uMTItLjkyLjE1LTEuMDUuNjEuMDgtLjU4LS41Ny0xLjA1LTEuMTYtLjk5LS41OC4xMi0xLjA5LjQ2LTEuNDIuOTUtLjA1LS41Ni0uNDktMS0xLjA1LTEuMDQtMS4wMi0uMS0xLjc2LS4zMi0yLjU5LjYxaC0uMDJaXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcImNscy0zM19jb25zdHJ1Y3Rpb24tc2l0ZS01OVxcXCIgZD1cXFwiTTE3MC4xNCwyNjEuMTdjLS44Nyw1Ljg5LTMuMjksMTEuNzQtNy43NSwxNS42NXMtMTEuMTIsNS42NS0xNi42MSwzLjMzYy01Ljc1LTIuNDMtOS4wMi04LjQtMTEuODYtMTMuOTEsMCwwLC4zNC00LjkzLDMuOTEtMS45OXM4Ljg3LDIwLjc1LDE5LjgxLDEwLjM1YzEwLjk1LTEwLjQxLDEwLjk5LTIxLjUxLDEwLjk5LTIxLjUxbDEuODctLjA4Yy4xMywyLjczLDAsNS40Ni0uMzYsOC4xNlpcXFwiPjwvcGF0aD48L2c+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJMYXllcl8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDUwMCA1MDBcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMTQ0cHg7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIiBkYXRhLWltYWdlaWQ9XFxcInJlc3RpbmctNDlcXFwiIGltYWdlTmFtZT1cXFwiUmVzdGluZ1xcXCIgY2xhc3M9XFxcImlsbHVzdHJhdGlvbnNfaW1hZ2VcXFwiPjxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+IC5zdDBfcmVzdGluZy00OXtmaWxsOiNGRkQ1Qjg7fSAuc3QxX3Jlc3RpbmctNDl7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9IC5zdDJfcmVzdGluZy00OXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwMzEyMDUyMDIzMjY0MjY3ODM1MjAwMDAwMTUxMDM2MjQzNTYwMDczOTU1MTFfKTt9IC5zdDNfcmVzdGluZy00OXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwMTYwNjQ2NDY1Mzg2NDIyODAzOTAwMDAwMDY4NzQwNzQzMjE5Mjc2MjM1NzFfKTt9IC5zdDRfcmVzdGluZy00OXtmaWxsOiNFRjhBM0Y7fSAuc3Q1X3Jlc3RpbmctNDl7b3BhY2l0eTowLjM7ZmlsbDojMDkxMTE0O2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyA7fSAuc3Q2X3Jlc3RpbmctNDl7ZmlsbDojRkY5QTU1O30gLnN0N19yZXN0aW5nLTQ5e2ZpbGw6IzA5MTExNDt9IC5zdDhfcmVzdGluZy00OXtmaWxsOiM2OEUxRkQ7fSAuc3Q5X3Jlc3RpbmctNDl7b3BhY2l0eTowLjQ2O2ZpbGw6IzA5MTExNDtlbmFibGUtYmFja2dyb3VuZDpuZXcgO30gLnN0MTBfcmVzdGluZy00OXtvcGFjaXR5OjAuMjI7ZmlsbDojMDkxMTE0O2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyA7fSAuc3QxMV9yZXN0aW5nLTQ5e2ZpbGw6Izk4MUU2MTt9IC5zdDEyX3Jlc3RpbmctNDl7b3BhY2l0eTowLjU7ZmlsbDojMDkxMTE0O2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyA7fSAuc3QxM19yZXN0aW5nLTQ5e2ZpbGw6IzlCQzYzNDt9IC5zdDE0X3Jlc3RpbmctNDl7ZmlsbDojODVBQTFEO30gLnN0MTVfcmVzdGluZy00OXtmaWxsOiM5MzU1NDI7fSA8L3N0eWxlPjxwYXRoIGlkPVxcXCJCYXNlX3Jlc3RpbmctNDlcXFwiIGNsYXNzPVxcXCJzdDBfcmVzdGluZy00OVxcXCIgZD1cXFwiTTMyLjYsMjgzLjRMMjA1LDE4My4yYzIuNS0xLjUsNS42LTEuNSw4LjEsMGwyNTcuOCwxNDcuNWMzLjksMi4yLDUuMiw3LjIsMywxMS4xXFxuXFx0Yy0wLjcsMS4yLTEuOCwyLjMtMywzTDMwNi4xLDQ0MGMtOC4yLDQuOC0xOC40LDQuOC0yNi42LDBMMzIuNiwyOTcuNWMtMy45LTIuMi01LjItNy4yLTMtMTEuMUMzMC40LDI4NS4yLDMxLjQsMjg0LjEsMzIuNiwyODMuNHpcXFwiPjwvcGF0aD48ZyBpZD1cXFwiU2hhZG93X3Jlc3RpbmctNDlcXFwiPjxsaW5lYXJHcmFkaWVudCBpZD1cXFwiU1ZHSURfMV8tcmVzdGluZy00OVxcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHgxPVxcXCIxMDQuNjE1MlxcXCIgeTE9XFxcIjc3NC40NTkyXFxcIiB4Mj1cXFwiNjkuODI1MlxcXCIgeTI9XFxcIjgyMi4yMDkyXFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwibWF0cml4KDEgMCAwIDEgMCAtNDk4KVxcXCI+PHN0b3Agb2Zmc2V0PVxcXCIwXFxcIiBzdHlsZT1cXFwic3RvcC1jb2xvcjojOTM1NTQyXFxcIj48L3N0b3A+PHN0b3Agb2Zmc2V0PVxcXCIxXFxcIiBzdHlsZT1cXFwic3RvcC1jb2xvcjojRkZGRkZGO3N0b3Atb3BhY2l0eTowXFxcIj48L3N0b3A+PC9saW5lYXJHcmFkaWVudD48cGF0aCBjbGFzcz1cXFwic3QxX3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk04NC41LDMyOC4zYzkuNy04LjMsMTYuOC0xNi4xLDI2LjgtMjRMNzYsMzAwLjdsLTIyLjUsOC45QzYzLjcsMzE2LjEsNzQuMSwzMjIuMiw4NC41LDMyOC4zelxcXCI+PC9wYXRoPjxsaW5lYXJHcmFkaWVudCBpZD1cXFwiU1ZHSURfMDAwMDAxMTkwNzk3Mzk1ODg2MzMwODk4MjAwMDAwMDM2Mjc3NjUyMzcyOTAxNjU5MjBfLXJlc3RpbmctNDlcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIiB4MT1cXFwiMjgyLjc2ODdcXFwiIHkxPVxcXCI3NzQuMTQ0NVxcXCIgeDI9XFxcIjI0Ni4yMTg2XFxcIiB5Mj1cXFwiODI0LjMyNDVcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJtYXRyaXgoMSAwIDAgMSAwIC00OTgpXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjBcXFwiIHN0eWxlPVxcXCJzdG9wLWNvbG9yOiM5MzU1NDJcXFwiPjwvc3RvcD48c3RvcCBvZmZzZXQ9XFxcIjFcXFwiIHN0eWxlPVxcXCJzdG9wLWNvbG9yOiNGRkZGRkY7c3RvcC1vcGFjaXR5OjBcXFwiPjwvc3RvcD48L2xpbmVhckdyYWRpZW50PjxwYXRoIHN0eWxlPVxcXCJmaWxsOnVybCgjU1ZHSURfMDAwMDAxMTkwNzk3Mzk1ODg2MzMwODk4MjAwMDAwMDM2Mjc3NjUyMzcyOTAxNjU5MjBfKTtcXFwiIGQ9XFxcIk0zMDAuOCwzOTEuNGw2Ni41LTQzLjFMMjA0LjgsMjQ3LjZcXG5cXHRcXHRMMTMxLDI5Ni4zQzE0MCwzMDIuNSwyOTEuOSwzODUsMzAwLjgsMzkxLjR6XFxcIj48L3BhdGg+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJTVkdJRF8wMDAwMDE2NzM1NzQ2NDk5NjAxMzQzNzU1MDAwMDAxNTE5NjUyODI5MDM5ODUwNjQxOF8tcmVzdGluZy00OVxcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHgxPVxcXCIxOTkuNzYwMVxcXCIgeTE9XFxcIjg2MC43NzM1XFxcIiB4Mj1cXFwiMTg0LjUyMDFcXFwiIHkyPVxcXCI4ODMuNzkzNVxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcIm1hdHJpeCgxIDAgMCAxIDAgLTQ5OClcXFwiPjxzdG9wIG9mZnNldD1cXFwiMFxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6IzkzNTU0MlxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiMVxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6I0ZGRkZGRjtzdG9wLW9wYWNpdHk6MFxcXCI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggc3R5bGU9XFxcImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NzM1NzQ2NDk5NjAxMzQzNzU1MDAwMDAxNTE5NjUyODI5MDM5ODUwNjQxOF8pO1xcXCIgZD1cXFwiTTIzMi43LDQxMy40bDQyLjYtMjMuOEwxNDMsMzI1LjRcXG5cXHRcXHRsLTI1LjcsMjFDMTIyLjksMzUwLjIsMjI3LjEsNDA5LjQsMjMyLjcsNDEzLjR6XFxcIj48L3BhdGg+PC9nPjxnIGlkPVxcXCJEZXNrX3Jlc3RpbmctNDlcXFwiPjxwb2x5Z29uIGNsYXNzPVxcXCJzdDRfcmVzdGluZy00OVxcXCIgcG9pbnRzPVxcXCIyNDQuMSw0MDYuNyAyNzUuMywzODkuNiAyNzUuMywzNTQuNSAyMzguMSwzNzAuMiBcXHRcXFwiPjwvcG9seWdvbj48cG9seWdvbiBjbGFzcz1cXFwic3Q1X3Jlc3RpbmctNDlcXFwiIHBvaW50cz1cXFwiMjQ0LjEsNDA2LjcgMjc1LjMsMzg5LjYgMjc1LjMsMzU0LjUgMjM4LjEsMzcwLjIgXFx0XFxcIj48L3BvbHlnb24+PHBvbHlnb24gY2xhc3M9XFxcInN0NF9yZXN0aW5nLTQ5XFxcIiBwb2ludHM9XFxcIjEyNi4yLDMwMy41IDEyNi4yLDMzOC43IDI0NC4xLDQwNi43IDI0NC45LDM3MiBcXHRcXFwiPjwvcG9seWdvbj48cG9seWdvbiBjbGFzcz1cXFwic3Q2X3Jlc3RpbmctNDlcXFwiIHBvaW50cz1cXFwiMTI2LjIsMzAzLjUgMTU3LjYsMjg1LjUgMjc1LjMsMzU0LjUgMjQ0LjksMzcyIFxcdFxcXCI+PC9wb2x5Z29uPjwvZz48ZyBpZD1cXFwiVFZfcmVzdGluZy00OVxcXCI+PHBhdGggY2xhc3M9XFxcInN0N19yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMTYwLjYsMjQ5LjRsOTQuMSw1NC4zYzAuOSwwLjUsMS40LDEuNSwxLjQsMi41djQwLjljMCwxLjYtMS4zLDIuOS0yLjksMi45Yy0wLjUsMC0xLTAuMS0xLjQtMC40bC05NC4xLTU0LjNcXG5cXHRcXHRjLTAuOS0wLjUtMS40LTEuNS0xLjQtMi41di00MC45YzAtMS42LDEuMy0yLjksMi45LTIuOUMxNTkuNywyNDkuMSwxNjAuMiwyNDkuMiwxNjAuNiwyNDkuNHpcXFwiPjwvcGF0aD48cG9seWxpbmUgY2xhc3M9XFxcInN0N19yZXN0aW5nLTQ5XFxcIiBwb2ludHM9XFxcIjE5Mi42LDMxMy4xIDE5MSwzMjcgMjEwLjUsMzM3LjggMjA4LjQsMzIyLjIgXFx0XFxcIj48L3BvbHlsaW5lPjxlbGxpcHNlIHRyYW5zZm9ybT1cXFwibWF0cml4KDAuNDM0NiAtMC45MDA2IDAuOTAwNiAwLjQzNDYgLTE4My44Mjg2IDM2Ny41MDkyKVxcXCIgY2xhc3M9XFxcInN0N19yZXN0aW5nLTQ5XFxcIiBjeD1cXFwiMjAwLjhcXFwiIGN5PVxcXCIzMzAuMlxcXCIgcng9XFxcIjMuN1xcXCIgcnk9XFxcIjIwLjFcXFwiPjwvZWxsaXBzZT48L2c+PGcgaWQ9XFxcIkxhbXBfcmVzdGluZy00OVxcXCI+PHBhdGggY2xhc3M9XFxcInN0NF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNNzkuNSwyODUuM2MtMC42LDAtMS4zLTAuMS0xLjgtMC40bC0wLjMsMS45bDI5LjksMC44di0yLjJMNzkuNSwyODUuM3pcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q0X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk03Ny43LDI4NWwtMC4zLDEuOGwxNi41LDkuNVYyOTRDODguMywyOTEuMyw4MywyODguMiw3Ny43LDI4NXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q0X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk05NC4zLDE1Ni4yYy0xLDAuMi0yLDAtMi45LTAuNGwtMTguOSwxNDZjMS4yLDAuNywyLjMsMS4zLDMuNSwybDE5LjEtMTQ3LjdDOTQuOSwxNTYuMSw5NC42LDE1Ni4yLDk0LjMsMTU2LjJcXG5cXHRcXHR6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0NF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNOTguNywxNTZjLTAuNywwLjEtMS40LDAuMS0yLjEsMGMtMC42LDAtMS4xLDAtMS43LDAuMWwxMi44LDE0OS44YzEtMC41LDItMC45LDMtMS4zbDAuNS0wLjJoMC4xTDk4LjcsMTU2elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDRfcmVzdGluZy00OVxcXCIgZD1cXFwiTTk2LjYsMTU2LjFjLTAuOCwwLTEuNSwwLTIuMywwLjFjLTAuMywwLTAuNiwwLjEtMC45LDAuMWwtMS4yLDE1OC4zbDAsMGMwLjYtMC4yLDEuMy0wLjMsMi0wLjJoMS4xbDAuNi0wLjFcXG5cXHRcXHRsMS4yLTE1OC4yTDk2LjYsMTU2LjF6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0OF9yZXN0aW5nLTQ5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNNzUuOSwxNTguNnYzMi43YzAsMCwzNy42LDEuMSwzNy42LDB2LTMyLjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48ZWxsaXBzZSBjbGFzcz1cXFwic3Q4X3Jlc3RpbmctNDkgdGFyZ2V0Q29sb3JcXFwiIGN4PVxcXCI5NC44XFxcIiBjeT1cXFwiMTU4LjVcXFwiIHJ4PVxcXCIxOC44XFxcIiByeT1cXFwiOC43XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L2VsbGlwc2U+PGVsbGlwc2UgY2xhc3M9XFxcInN0OV9yZXN0aW5nLTQ5XFxcIiBjeD1cXFwiOTQuOFxcXCIgY3k9XFxcIjE1OC41XFxcIiByeD1cXFwiMTguOFxcXCIgcnk9XFxcIjguN1xcXCI+PC9lbGxpcHNlPjxlbGxpcHNlIGNsYXNzPVxcXCJzdDhfcmVzdGluZy00OSB0YXJnZXRDb2xvclxcXCIgY3g9XFxcIjk0LjhcXFwiIGN5PVxcXCIxOTEuOFxcXCIgcng9XFxcIjE4LjhcXFwiIHJ5PVxcXCI4LjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvZWxsaXBzZT48L2c+PGcgaWQ9XFxcIlNvZmFfcmVzdGluZy00OVxcXCI+PHBhdGggY2xhc3M9XFxcInN0OF9yZXN0aW5nLTQ5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNMzU0LjUsMzU0LjRjMCwwLDYtMC43LDEyLjktNnMtMTIuOS00LjUtMTIuOS00LjVWMzU0LjR6XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTBfcmVzdGluZy00OVxcXCIgZD1cXFwiTTM1NC41LDM1NC40YzAsMCw2LTAuNywxMi45LTZzLTEyLjktNC41LTEyLjktNC41VjM1NC40elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDdfcmVzdGluZy00OVxcXCIgZD1cXFwiTTIwOS41LDI1Ni40djE3LjdjMCwwLDAuOSwyLjUsNSwyLjJzNC43LTIuOCw0LjctMi44di0yMS4yTDIwOS41LDI1Ni40elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDdfcmVzdGluZy00OVxcXCIgZD1cXFwiTTMzOSwzMzUuN3YxNy43YzAsMCwwLjksMi41LDUsMi4yczQuNy0yLjgsNC43LTIuOHYtMjEuMkwzMzksMzM1Ljd6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0OF9yZXN0aW5nLTQ5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNMzY3LjYsMjYwLjFjOC44LTUuOCwxNy45LTExLjIsMjYuNy0xNy4xbC0xNDIuOS04MS43Yy01LjctMy4zLTEyLjgtMy4yLTE4LjUsMC4xbC0zOS41LDIzLjJcXG5cXHRcXHRjLTYuNSwzLjgtNS41LDkuNi01LjUsOS42cy0xLjgsNTQuMiwwLDU3LjhzNy4yLDYsNy4yLDZsMTU5LjQsOTYuM0MzNjcuNSwzNDQuNCwzNTYuOSwyNjcuMiwzNjcuNiwyNjAuMXpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q5X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0zNjcuNiwyNjAuMWM4LjgtNS44LDE3LjktMTEuMiwyNi43LTE3LjFsLTE0Mi45LTgxLjdjLTUuNy0zLjMtMTIuOC0zLjItMTguNSwwLjFsLTM5LjUsMjMuMlxcblxcdFxcdGMtNi41LDMuOC01LjUsOS42LTUuNSw5LjZzLTEuOCw1NC4yLDAsNTcuOHM3LjIsNiw3LjIsNmwxNTkuNCw5Ni4zQzM2Ny41LDM0NC40LDM1Ni45LDI2Ny4yLDM2Ny42LDI2MC4xelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDhfcmVzdGluZy00OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTM3NSwyNzIuNmMwLDAtMTMyLjktNzYuMi0xMzIuNi03N3MwLTI4LjYsMC0yOC42bDE1Ni44LDkwLjNMMzc1LDI3Mi42elxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDhfcmVzdGluZy00OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTQxMi40LDI1NS4ybC0xLjgtMC4yYy0yLjgsMi4xLTUuOCwzLjgtOSw1LjFjLTEzLjIsOS45LTI4LDE4LjItNDIuOCwyNS43djYzLjhjMS45LDAuNCwzLjgsMC41LDUuOCwwLjNcXG5cXHRcXHRsNDAuOS0yNC4yYzUuMy0zLjIsOC42LTguOSw4LjYtMTUuMXYtNTMuN0M0MTMuNSwyNTYuMyw0MTIuOSwyNTUuOCw0MTIuNCwyNTUuMnpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMzc1LDI3Mi42YzAsMC0xMzIuOS03Ni4yLTEzMi42LTc3czAtMjguNiwwLTI4LjZsMTU2LjgsOTAuM0wzNzUsMjcyLjZ6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0OF9yZXN0aW5nLTQ5IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNMjAyLjYsMjE3LjlsNDAuMS0yMi40bDE1MS44LDg3LjFsLTQ1LjYsMjQuOWMtMi4yLDEuMi00LjgsMS4yLTYuOSwwbC0xMzkuNC03OC4zYy0zLjEtMS44LTQuMy01LjctMi41LTguOVxcblxcdFxcdEMyMDAuNywyMTkuMywyMDEuNSwyMTguNSwyMDIuNiwyMTcuOXpcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNNDEyLjQsMjU1LjJsLTEuOC0wLjJjLTIuOCwyLjEtNS44LDMuOC05LDUuMWMtMTMuMiw5LjktMjgsMTguMi00Mi44LDI1Ljd2NjMuOGMxLjksMC40LDMuOCwwLjUsNS44LDAuM1xcblxcdFxcdGw0MC45LTI0LjJjNS4zLTMuMiw4LjYtOC45LDguNi0xNS4xdi01My43QzQxMy41LDI1Ni4zLDQxMi45LDI1NS44LDQxMi40LDI1NS4yelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDhfcmVzdGluZy00OSB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTE4OS4yLDE4Ni40YzAsMC0zLjksMS4zLDAsNi4xczE4LTUuMywxOC01LjNsMzUuMS0yMC4ybDE1Ni44LDkwLjNsLTQwLjksMjMuM2MwLDAtMy4yLDIuNS0wLjgsNS4zXFxuXFx0XFx0czUuNywxLjUsMTIuNC0xLjhzNDMtMjMuOSw0My0yMy45czMuNi0yLjUtMS45LTcuMXMtMTYxLjItOTIuMy0xNjEuMi05Mi4zcy01LjgtNS4zLTEyLjktMS43UzE4OS4yLDE4Ni40LDE4OS4yLDE4Ni40elxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wYXRoPjwvZz48ZyBpZD1cXFwiV2FsbF9QaG90b19yZXN0aW5nLTQ5XFxcIj48cGF0aCBjbGFzcz1cXFwic3Q2X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0zNzMuMSwxMjEuNmwtMS4xLDYyLjVjMCwyLjItMS44LDMuOS00LDMuOWMtMC42LDAtMS4yLTAuMi0xLjctMC40bC01My4xLTI2LjVjLTEuOC0wLjktMi45LTIuNy0yLjktNC44XFxuXFx0XFx0bDEuMS02Mi42YzAuMS0yLjQsMi00LjIsNC40LTQuMmMwLjYsMCwxLjMsMC4yLDEuOCwwLjVsNTIuNywyNi44QzM3Mi4xLDExNy44LDM3My4yLDExOS42LDM3My4xLDEyMS42elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0zNDAuMywxNTIuNmMtMy44LTYuNi03LjMtMTMuNC0xMC42LTIwLjJjLTIuMS00LjMtOC41LTAuNS02LjQsMy44YzMuMyw2LjksNi45LDEzLjYsMTAuNiwyMC4yXFxuXFx0XFx0QzMzNi4yLDE2MC41LDM0Mi42LDE1Ni44LDM0MC4zLDE1Mi42elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0zNTUuNiwxNTEuMWMtNy43LTExLjktMTQuNy0yNC4yLTIxLTM2LjljLTIuMS00LjMtOC42LTAuNS02LjQsMy44YzYuMywxMi43LDEzLjMsMjUsMjEsMzYuOVxcblxcdFxcdEMzNTEuOCwxNTguOSwzNTguMiwxNTUuMSwzNTUuNiwxNTEuMXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMV9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMzUzLjIsMTI0LjFjLTQuOCwwLTQuOCw3LjUsMCw3LjVTMzU4LDEyNC4xLDM1My4yLDEyNC4xelxcXCI+PC9wYXRoPjwvZz48ZyBpZD1cXFwiQ2hhcmFjdGVyX3Jlc3RpbmctNDlcXFwiPjxwb2x5Z29uIGNsYXNzPVxcXCJzdDExX3Jlc3RpbmctNDlcXFwiIHBvaW50cz1cXFwiMzc0LjIsMjgwLjcgMzY1LjQsMjc3LjIgMzY4LjEsMjYzLjEgMzc2LjQsMjYxLjMgXFx0XFxcIj48L3BvbHlnb24+PHBhdGggY2xhc3M9XFxcInN0MTFfcmVzdGluZy00OVxcXCIgZD1cXFwiTTM3NC4yLDI4MC43YzAsMC0wLjgtNi43LTEuMy05LjhzLTIuNS0yMC4yLDUuNC0xOS43czIuOSwxNy4zLDMuMSwxOS4xczEsNy4xLTAuMSw4LjdcXG5cXHRcXHRTMzc2LjgsMjgyLjUsMzc0LjIsMjgwLjd6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTJfcmVzdGluZy00OVxcXCIgZD1cXFwiTTM3OC4zLDI1MS4zYy00LjYtMC4zLTUuOSw1LjUtNiwxMC45bC00LjIsMC45bC0yLjcsMTQuMmw4LjksMy41YzIuNSwxLjcsNS45LDAsNy4xLTEuNnMwLjQtNi44LDAuMS04LjdcXG5cXHRcXHRTMzg2LjIsMjUxLjksMzc4LjMsMjUxLjN6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0NF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMjQzLjksMTUxLjRjMCwwLTQuNywxLjYtNS4yLDEuNnMtOC44LTAuMS04LjMsNC43czEzLjUsMy42LDEzLjUsMy42bDYtNi4yXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0NF9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMjI3LjIsMTU3LjJsNi42LTIuMmMwLDAsOC4xLTEuNyw4LjksMHMtMS41LDcuNC0yLjIsNy42bC02LjEsMS40bC02LDAuN1xcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDZfcmVzdGluZy00OVxcXCIgZD1cXFwiTTI3OS43LDIyMS4xYzAsMCw0MS4yLDI2LjcsNDUuMiwyNy4xczQ0LjcsMTYsNDQuNywxNnMtMiwxMC4xLTAuOSwxNC44YzAsMC03NC4zLTE4LjUtODMuNi0yMS42XFxuXFx0XFx0cy0zMC44LTI0LjItMjUuNC0yOS44QzI2NS4xLDIyMiwyNzkuNywyMjEuMSwyNzkuNywyMjEuMXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q1X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0yNzkuNywyMjEuMWMwLDAsNDEuMiwyNi43LDQ1LjIsMjcuMXM0NC43LDE2LDQ0LjcsMTZzLTIsMTAuMS0wLjksMTQuOGMwLDAtNzQuMy0xOC41LTgzLjYtMjEuNlxcblxcdFxcdHMtMzAuOC0yNC4yLTI1LjQtMjkuOEMyNjUuMSwyMjIsMjc5LjcsMjIxLjEsMjc5LjcsMjIxLjF6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTNfcmVzdGluZy00OVxcXCIgZD1cXFwiTTI1NS44LDE3OC45YzMuNC0zLjEsOS0xNy4yLDcuNi0yMC41cy0xMC41LDIuMS0xMC41LDIuMWwtOS4xLTkuMmMwLDAsMTIuNy0xMC4zLDE4LjctMTEuOVxcblxcdFxcdHMxMC43LDAuMywxMi43LDcuNHMtNC40LDMyLjQtMy42LDM3LjhzOCwzNi4zLDgsMzYuM2MtNS44LDkuOC0yOS40LDE0LjktMzIuNywxNC4xcy0yMC4xLTM3LjktMjAuMS0zNy45cy0zMS40LTIwLjItMjcuMi0yOS42XFxuXFx0XFx0czIyLjMtMTIuMSwyNi0xMi41czYuNSwxMS40LDYuNSwxMS40cy0xMS45LDMuMy0xMyw0LjhzNC4xLDUuNCwxNCw3LjVzMTIuMSwwLjksMTIuMSwwLjlcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMV9yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMzg0LjIsMjY3LjRjMCwwLDIuOSwxLjksNC44LTAuNHMzLTIwLjksNC41LTI0LjZzMS42LTEwLjMtMy0xMC44cy01LjIsMS44LTYuMiw0LjhzLTQuNywxMi4zLTguMSwxMy40XFxuXFx0XFx0Yy0yLjksMC45LTUuOCwxLjYtOC44LDIuMmwwLjgsMTFMMzg0LjIsMjY3LjR6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0N19yZXN0aW5nLTQ5XFxcIiBkPVxcXCJNMjUyLjQsMTgzLjljMCwwLDguMSwzNi4yLDguNCwzNy4xczcuNyw1LjIsNy43LDUuMmwxLjYtNi41bC0xNS41LTM2LjVMMjUyLjQsMTgzLjl6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTRfcmVzdGluZy00OVxcXCIgZD1cXFwiTTI0MS43LDE4MC4yYzAsMCwxMC42LDksMTAuMSw4LjRzMi4zLTQuMiwyLjMtNC4ybDQuNywxLjRsLTUuNC05LjRcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q0X3Jlc3RpbmctNDlcXFwiIGQ9XFxcIk0yNTguNSwxNjMuNGMwLDAsNCwxNC42LTIuNiwxNy44cy0xMS4yLTEuNi0xMy4yLTUuOXMtMS4yLTE0LjYsNy4zLTE1LjZDMjU3LjQsMTU4LjcsMjU4LjUsMTYzLjQsMjU4LjUsMTYzLjRcXG5cXHRcXHR6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTVfcmVzdGluZy00OVxcXCIgZD1cXFwiTTI1OS44LDE2MC42YzAuNy0xLjgsMS01LTEuMS02Yy0xLjYtMC42LTMuNC0wLjMtNC43LDAuOWMtMC43LTAuNi0xLjYtMS0yLjUtMS4yYy0zLjQtMS03LTAuMi05LjcsMi4xXFxuXFx0XFx0Yy0wLjEsMC4xLTAuMywwLjItMC40LDAuM2MtMC4yLDAuMS0wLjQsMC4xLTAuNiwwLjFjLTUuMiwwLjEtNi4zLDYtNS40LDEwYzAuOSw0LjIsMy4xLDcuOSw2LjMsMTAuOGMxLjQsMS4xLDMsMS45LDQuNywyLjRcXG5cXHRcXHRjMC4yLDAuMSwwLjQtMC4xLDAuNS0wLjN2LTAuMWMwLjItMC4xLDAuMy0wLjQsMC4yLTAuN2wwLDBjLTAuNC0wLjktMC42LTEuOS0wLjQtMi44YzAtMC4xLDAtMC4zLTAuMS0wLjRjMC4yLTAuMiwwLjItMC41LDAtMC43XFxuXFx0XFx0Yy0wLjEtMC4xLTAuMi0wLjEtMC4zLTAuMWMtMS4xLDAuMS0yLjItMC4zLTMtMS4xYy0wLjUtMC41LTAuOS0xLjUsMC4xLTEuN2MwLjQtMC4xLDAuNywwLDEsMC4zYzAuMSwwLjIsMC4zLDAuNSwwLjUsMC43XFxuXFx0XFx0YzAuMSwwLjEsMC4yLDAuMSwwLjMsMC4xYzAuNCwwLjEsMC44LTAuMiwwLjYtMC42Yy0wLjItMC4zLTAuNC0wLjUtMC42LTAuOGMtMC43LTEuMS0wLjQtMi41LDAuNS0zLjRjMS4yLTEuMSwyLjMtMC41LDMuNy0wLjRcXG5cXHRcXHRjMC45LDAuMSwxLjgtMC40LDItMS4zYzAtMC42LTAuMS0xLjItMC4yLTEuN2MwLTAuOSwwLjUtMS43LDEuMy0yYzEuNS0wLjYsMi40LDAuNywzLjUsMS40YzAuOSwwLjcsMi4xLDAuOSwzLjIsMC42XFxuXFx0XFx0YzEuNC0wLjQsMi4zLTEuOCwxLjktMy4yYy0wLjEtMC40LTAuMy0wLjctMC41LTFDMjYwLjIsMTYwLjYsMjYwLDE2MC41LDI1OS44LDE2MC42eiBNMjUwLjgsMTYyLjdjMC4yLTAuMywwLjQtMC41LDAuNy0wLjZcXG5cXHRcXHRjMC4xLDAsMC4yLTAuMSwwLjMtMC4yaDAuMWwwLjEsMC4xQzI1MS41LDE2Mi4xLDI1MS4xLDE2Mi40LDI1MC44LDE2Mi43TDI1MC44LDE2Mi43eiBNMjU5LjEsMTU5LjZMMjU5LjEsMTU5LjZcXG5cXHRcXHRjMC0wLjIsMC4xLTAuMywwLjEtMC41QzI1OS4yLDE1OS4yLDI1OS4yLDE1OS40LDI1OS4xLDE1OS42TDI1OS4xLDE1OS42elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDZfcmVzdGluZy00OVxcXCIgZD1cXFwiTTI0NywyMzUuMmMwLDAsNi44LDIxLDIwLjQsMjUuNGMxMy42LDQuMywyNC41LTQsMzAuOC0yLjFzNTgsOC4yLDcxLjUsNS44YzAsMCwyLjMtMTQuNC0wLjktMTcuNVxcblxcdFxcdHMtNTkuNy0xNC40LTY1LjMtMTUuMnMtMzAuMi00LjUtMzAuMi00LjVcXFwiPjwvcGF0aD48L2c+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJMYXllcl8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDUwMCA1MDBcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMjEzcHg7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIiBkYXRhLWltYWdlaWQ9XFxcInNjcnVtLWJvYXJkLTI3XFxcIiBpbWFnZU5hbWU9XFxcIlNjcnVtIEJvYXJkXFxcIiBjbGFzcz1cXFwiaWxsdXN0cmF0aW9uc19pbWFnZVxcXCI+PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj4gLnN0MF9zY3J1bS1ib2FyZC0yN3tmaWxsOiNGRkU5MjI7fSAuc3QxX3NjcnVtLWJvYXJkLTI3e29wYWNpdHk6MC4zMjtmaWxsOnVybCgjU1ZHSURfMV8pO2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyA7fSAuc3QyX3NjcnVtLWJvYXJkLTI3e2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDA3MDgzOTYyMjY0NTIzMTU5MjMzMDAwMDAwNjIxNjEwNDYwNjI0NjE2NDEzNF8pO30gLnN0M19zY3J1bS1ib2FyZC0yN3tvcGFjaXR5OjAuMzI7ZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDc5NDYxOTI4MjEzMDYzNjEyMzIwMDAwMDA1OTk1MDM1NDkwMjkzOTg0OTUxXyk7ZW5hYmxlLWJhY2tncm91bmQ6bmV3IDt9IC5zdDRfc2NydW0tYm9hcmQtMjd7ZmlsbDojRkZDNjVBO30gLnN0NV9zY3J1bS1ib2FyZC0yN3tmaWxsOiM2OEUxRkQ7fSAuc3Q2X3NjcnVtLWJvYXJkLTI3e29wYWNpdHk6MC41MjtmaWxsOiMwOTExMTQ7ZW5hYmxlLWJhY2tncm91bmQ6bmV3IDt9IC5zdDdfc2NydW0tYm9hcmQtMjd7ZmlsbDojQUE2ODAwO30gLnN0OF9zY3J1bS1ib2FyZC0yN3tmaWxsOiMwOTExMTQ7fSAuc3Q5X3NjcnVtLWJvYXJkLTI3e2ZpbGw6I0YxNUEyNDt9IC5zdDEwX3NjcnVtLWJvYXJkLTI3e2ZpbGw6I0FEM0MwNDt9IC5zdDExX3NjcnVtLWJvYXJkLTI3e2ZpbGw6I0UyODEzMzt9IC5zdDEyX3NjcnVtLWJvYXJkLTI3e29wYWNpdHk6MC40NjtmaWxsOiMwOTExMTQ7ZW5hYmxlLWJhY2tncm91bmQ6bmV3IDt9IC5zdDEzX3NjcnVtLWJvYXJkLTI3e2ZpbGw6I0ZGQUM5OTt9IDwvc3R5bGU+PHBhdGggaWQ9XFxcIkJhc2Vfc2NydW0tYm9hcmQtMjdcXFwiIGNsYXNzPVxcXCJzdDBfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk01NCwzMDkuOGwyNDUuMSwxMzYuN2M0LjcsMi42LDEwLjYsMi40LDE1LjEtMC42bDEyNC4yLTgzLjJjNi42LTQuNCw4LjQtMTMuNCw0LTIwXFxuXFx0Yy0xLjMtMS45LTMtMy41LTUtNC42TDIwNC4yLDIwOS41Yy00LjMtMi40LTkuNi0yLjQtMTMuOSwwTDU0LDI4NC41Yy03LDMuOS05LjUsMTIuNy01LjYsMTkuN0M0OS43LDMwNi42LDUxLjYsMzA4LjUsNTQsMzA5Ljh6XFxcIj48L3BhdGg+PGcgaWQ9XFxcIlNoYWRvd19zY3J1bS1ib2FyZC0yN1xcXCI+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJTVkdJRF8xXy1zY3J1bS1ib2FyZC0yN1xcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHgxPVxcXCIyNjguNjAwNVxcXCIgeTE9XFxcIjc1LjU3OTRcXFwiIHgyPVxcXCIyODYuMTYwNVxcXCIgeTI9XFxcIjg5LjQwOTRcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJtYXRyaXgoMSAwIDAgLTEgMCA1MDIpXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjBcXFwiIHN0eWxlPVxcXCJzdG9wLWNvbG9yOiNGRkZGRkY7c3RvcC1vcGFjaXR5OjBcXFwiPjwvc3RvcD48c3RvcCBvZmZzZXQ9XFxcIjAuOThcXFwiIHN0eWxlPVxcXCJzdG9wLWNvbG9yOiNBQTY4MDBcXFwiPjwvc3RvcD48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPVxcXCJzdDFfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk0zMzQuNiwzNjkuMmwtODIuMyw0OC4zbDE5LjIsMTAuNmw4MS4zLTQ2LjJDMzQxLjcsMzc0LjUsMzQ0LjEsMzc4LjQsMzM0LjYsMzY5LjJ6XFxcIj48L3BhdGg+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJTVkdJRF8wMDAwMDE0NTc1NzIwMDU3NjQ4Mzg3MDkyMDAwMDAxNzY2OTA2NDIwNTc3NjM4MDA4M18tc2NydW0tYm9hcmQtMjdcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIiB4MT1cXFwiMTEzLjM4OTRcXFwiIHkxPVxcXCIyMzIuMzYwNFxcXCIgeDI9XFxcIjc4Ljc1OTRcXFwiIHkyPVxcXCIxODQuODMwNFxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcIm1hdHJpeCgxIDAgMCAtMSAwIDUwMilcXFwiPjxzdG9wIG9mZnNldD1cXFwiMFxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6I0YxNUEyNFxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiMVxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6I0ZGRkZGRlxcXCI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggc3R5bGU9XFxcImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE0NTc1NzIwMDU3NjQ4Mzg3MDkyMDAwMDAxNzY2OTA2NDIwNTc3NjM4MDA4M18pO1xcXCIgZD1cXFwiTTkzLjQsMzIxLjNjOS43LTguMywxNi43LTE2LDI2LjctMjMuOVxcblxcdFxcdGwtMzUuMi0zLjZsLTIyLjQsOC44QzcyLjYsMzA5LjEsODMsMzE1LjIsOTMuNCwzMjEuM3pcXFwiPjwvcGF0aD48bGluZWFyR3JhZGllbnQgaWQ9XFxcIlNWR0lEXzAwMDAwMDYyODk5NTAwMTExMzIzNDUzNjkwMDAwMDE0ODQzNTkwOTAzNDMzNDM1ODM4Xy1zY3J1bS1ib2FyZC0yN1xcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiIHgxPVxcXCIxNDAuNDkwOFxcXCIgeTE9XFxcIjExMy4xMzg4XFxcIiB4Mj1cXFwiMjIyLjQ0MDhcXFwiIHkyPVxcXCIxNjYuODU4OFxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcIm1hdHJpeCgxIDAgMCAtMSAwIDUwMilcXFwiPjxzdG9wIG9mZnNldD1cXFwiMFxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6I0ZGRkZGRjtzdG9wLW9wYWNpdHk6MFxcXCI+PC9zdG9wPjxzdG9wIG9mZnNldD1cXFwiMC45OFxcXCIgc3R5bGU9XFxcInN0b3AtY29sb3I6I0FBNjgwMFxcXCI+PC9zdG9wPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggc3R5bGU9XFxcIm9wYWNpdHk6MC4zMjtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNjI4OTk1MDAxMTEzMjM0NTM2OTAwMDAwMTQ4NDM1OTA5MDM0MzM0MzU4MzhfKTtlbmFibGUtYmFja2dyb3VuZDpuZXcgO1xcXCIgZD1cXFwiXFxuXFx0XFx0TTIxMi4yLDMyMy4xbC0xMDUuNyw1OS4zbDM4LjcsMjMuMWwxMDMuNC01OC43QzIzNC42LDMzNy4zLDIyNC4zLDMzNC44LDIxMi4yLDMyMy4xelxcXCI+PC9wYXRoPjwvZz48ZyBpZD1cXFwiUGVuY2lsX3NjcnVtLWJvYXJkLTI3XFxcIj48cG9seWxpbmUgY2xhc3M9XFxcInN0NF9zY3J1bS1ib2FyZC0yN1xcXCIgcG9pbnRzPVxcXCIzODUsMzQxLjUgNDExLjUsMzM3LjQgMzg4LjQsMzYxIFxcdFxcXCI+PC9wb2x5bGluZT48ZWxsaXBzZSBjbGFzcz1cXFwic3Q1X3NjcnVtLWJvYXJkLTI3IHRhcmdldENvbG9yXFxcIiBjeD1cXFwiMzg1XFxcIiBjeT1cXFwiMzUxLjhcXFwiIHJ4PVxcXCI3LjlcXFwiIHJ5PVxcXCIxMC4yXFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L2VsbGlwc2U+PHBvbHlnb24gY2xhc3M9XFxcInN0NV9zY3J1bS1ib2FyZC0yNyB0YXJnZXRDb2xvclxcXCIgcG9pbnRzPVxcXCIyOTQuNiw0MTQuOSAzODguNCwzNjEgMzgyLDM0Mi4zIDI4Ny45LDM5Ni40IFxcdFxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9wb2x5Z29uPjxlbGxpcHNlIGNsYXNzPVxcXCJzdDVfc2NydW0tYm9hcmQtMjcgdGFyZ2V0Q29sb3JcXFwiIGN4PVxcXCIyOTEuNlxcXCIgY3k9XFxcIjQwNS41XFxcIiByeD1cXFwiNy45XFxcIiByeT1cXFwiMTAuMlxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYigwLCA0OSwgODMpO1xcXCI+PC9lbGxpcHNlPjxlbGxpcHNlIGNsYXNzPVxcXCJzdDZfc2NydW0tYm9hcmQtMjdcXFwiIGN4PVxcXCIyOTEuNlxcXCIgY3k9XFxcIjQwNS41XFxcIiByeD1cXFwiNy45XFxcIiByeT1cXFwiMTAuMlxcXCI+PC9lbGxpcHNlPjxwYXRoIGNsYXNzPVxcXCJzdDdfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk00MTEuNSwzMzcuNGwtMTAsMS42YzAsMCwzLjgsMS4zLDIuNyw1LjlMNDExLjUsMzM3LjR6XFxcIj48L3BhdGg+PC9nPjxnIGlkPVxcXCJCb2FyZF9zY3J1bS1ib2FyZC0yN1xcXCI+PHBhdGggY2xhc3M9XFxcInN0OF9zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTM0OC41LDI0OC4xYzAtNi44LTEwLjYtNi44LTEwLjYsMGMwLjIsMjkuMywxLjQsNTguNSwzLjUsODcuN2MwLjUsNi44LDExLjEsNi44LDEwLjYsMFxcblxcdFxcdEMzNDkuOSwzMDYuNiwzNDguNywyNzcuNCwzNDguNSwyNDguMXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q4X3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjgyLjcsMjIzLjdMMjQ1LDI3NS40Yy00LDUuNSw1LjIsMTAuOCw5LjIsNS40bDM3LjctNTEuN0MyOTUuOSwyMjMuNiwyODYuNywyMTguMywyODIuNywyMjMuN3pcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q5X3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNNDI4LjgsMTYzLjJMMjMwLjUsNDkuMWMtMi45LTEuNi02LjYtMC42LTguMiwyLjNjLTAuNCwwLjgtMC43LDEuNi0wLjgsMi40TDIwOC43LDIxMmMtMC4yLDIuMywxLDQuNiwzLDUuOFxcblxcdFxcdGwxOTQsMTA5LjljMi45LDEuNiw2LjYsMC42LDguMy0yLjNjMC40LTAuNywwLjctMS41LDAuNy0yLjNsMTctMTUzLjlDNDMyLDE2Ni44LDQzMC45LDE2NC40LDQyOC44LDE2My4yelxcXCI+PC9wYXRoPjxwb2x5Z29uIGNsYXNzPVxcXCJzdDVfc2NydW0tYm9hcmQtMjcgdGFyZ2V0Q29sb3JcXFwiIHBvaW50cz1cXFwiNDA4LjksMjAxLjMgMzI0LjksMTU0LjMgMzEzLjIsMjUyLjUgMzk3LjUsMjk5LjggXFx0XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BvbHlnb24+PHBhdGggY2xhc3M9XFxcInN0NV9zY3J1bS1ib2FyZC0yNyB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTI0OS45LDk3YzAsMCwwLjEsMzQuNC02LjEsNDEuM2wyNi4xLDE1LjJjMi43LTMuNSw0LjUtNy41LDUuMy0xMS45YzAuNi0zLjksMi41LTI5LjUsMi41LTI5LjVMMjQ5LjksOTd6XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0NV9zY3J1bS1ib2FyZC0yNyB0YXJnZXRDb2xvclxcXCIgZD1cXFwiTTI4MS43LDExNS40YzAsMCwwLjEsMzQuNC02LjEsNDEuM2wyNi4xLDE1LjJjMi43LTMuNSw0LjUtNy41LDUuMy0xMS45YzAuNi0zLjksMi41LTI5LjUsMi41LTI5LjVcXG5cXHRcXHRMMjgxLjcsMTE1LjR6XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L3BhdGg+PHBvbHlnb24gY2xhc3M9XFxcInN0OF9zY3J1bS1ib2FyZC0yN1xcXCIgcG9pbnRzPVxcXCIzNDcuOCwxNjAuOSAzNDUsMTcxLjkgMzkyLjIsMTk3LjYgMzk1LjUsMTg4IFxcdFxcXCI+PC9wb2x5Z29uPjxjaXJjbGUgY2xhc3M9XFxcInN0MTBfc2NydW0tYm9hcmQtMjdcXFwiIGN4PVxcXCIyOTYuMlxcXCIgY3k9XFxcIjEyMi43XFxcIiByPVxcXCI0LjRcXFwiPjwvY2lyY2xlPjxwb2x5Z29uIGNsYXNzPVxcXCJzdDEwX3NjcnVtLWJvYXJkLTI3XFxcIiBwb2ludHM9XFxcIjI5MS41LDI0Mi42IDI5OS41LDE4MS4xIDI0NS45LDE0OC45IFxcdFxcXCI+PC9wb2x5Z29uPjxwb2x5Z29uIGNsYXNzPVxcXCJzdDRfc2NydW0tYm9hcmQtMjdcXFwiIHBvaW50cz1cXFwiMjQ0LjQsMTQ5LjggMjkxLjUsMTc3LjMgMjkxLjUsMjQyLjYgMjQ0LjQsMjE0LjMgXFx0XFxcIj48L3BvbHlnb24+PGNpcmNsZSBjbGFzcz1cXFwic3QxMF9zY3J1bS1ib2FyZC0yN1xcXCIgY3g9XFxcIjI2Ni40XFxcIiBjeT1cXFwiMTA0XFxcIiByPVxcXCI0LjNcXFwiPjwvY2lyY2xlPjwvZz48ZyBpZD1cXFwiTGFtcF9zY3J1bS1ib2FyZC0yN1xcXCI+PHBhdGggY2xhc3M9XFxcInN0MTFfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk04OC40LDI3OC41Yy0wLjYsMC0xLjMtMC4xLTEuOC0wLjRsLTAuMywxLjlsMjkuNywwLjh2LTIuMkg4OC40elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNODYuNSwyNzguMWwtMC4zLDEuOGwxNi40LDkuNXYtMi4zQzk3LjIsMjg0LjQsOTEuOCwyODEuMyw4Ni41LDI3OC4xelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMTAzLjEsMTQ5LjljLTEsMC4yLTIsMC0yLjgtMC40TDgxLjQsMjk0LjljMS4xLDAuNywyLjMsMS4zLDMuNSwybDE5LjEtMTQ3XFxuXFx0XFx0QzEwMy43LDE0OS45LDEwMy40LDE0OS45LDEwMy4xLDE0OS45elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMTA3LjQsMTQ5LjhjLTAuNywwLjEtMS40LDAuMS0yLjEsMGMtMC42LDAtMS4xLDAtMS43LDAuMWwxMi43LDE0OS4xYzEtMC41LDItMC45LDMtMS4zbDAuNS0wLjNoMC4xXFxuXFx0XFx0TDEwNy40LDE0OS44elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDExX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMTA1LjQsMTQ5LjhjLTAuOCwwLTEuNSwwLjEtMi4zLDAuMmMtMC4zLDAtMC42LDAuMS0wLjksMC4xTDEwMSwzMDcuNWwwLDBjMC42LTAuMiwxLjMtMC4zLDItMC4yaDEuMVxcblxcdFxcdGwwLjYtMC4xbDEuMi0xNTcuNUwxMDUuNCwxNDkuOHpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q1X3NjcnVtLWJvYXJkLTI3IHRhcmdldENvbG9yXFxcIiBkPVxcXCJNODQuOCwxNTIuM3YzMi42YzAsMCwzNy41LDEuMSwzNy41LDB2LTMyLjZcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvcGF0aD48ZWxsaXBzZSBjbGFzcz1cXFwic3Q1X3NjcnVtLWJvYXJkLTI3IHRhcmdldENvbG9yXFxcIiBjeD1cXFwiMTAzLjZcXFwiIGN5PVxcXCIxNTIuMlxcXCIgcng9XFxcIjE4LjdcXFwiIHJ5PVxcXCI4LjdcXFwiIHN0eWxlPVxcXCJmaWxsOiByZ2IoMCwgNDksIDgzKTtcXFwiPjwvZWxsaXBzZT48ZWxsaXBzZSBjbGFzcz1cXFwic3QxMl9zY3J1bS1ib2FyZC0yN1xcXCIgY3g9XFxcIjEwMy42XFxcIiBjeT1cXFwiMTUyLjJcXFwiIHJ4PVxcXCIxOC43XFxcIiByeT1cXFwiOC43XFxcIj48L2VsbGlwc2U+PGVsbGlwc2UgY2xhc3M9XFxcInN0NV9zY3J1bS1ib2FyZC0yNyB0YXJnZXRDb2xvclxcXCIgY3g9XFxcIjEwMy42XFxcIiBjeT1cXFwiMTg1LjNcXFwiIHJ4PVxcXCIxOC43XFxcIiByeT1cXFwiOC43XFxcIiBzdHlsZT1cXFwiZmlsbDogcmdiKDAsIDQ5LCA4Myk7XFxcIj48L2VsbGlwc2U+PC9nPjxnIGlkPVxcXCJDaGFyYWN0ZXJfc2NydW0tYm9hcmQtMjdcXFwiPjxwYXRoIGNsYXNzPVxcXCJzdDEzX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjQ0LjUsMTY1LjdjMCwwLTAuOS01LjksMC04LjFzMS40LTguNiwxLjQtOC42YzEuMi0wLjMsMi4zLDAuNCwyLjgsMS41YzAuOCwyLTAuOSw2LjgtMC45LDYuOFxcblxcdFxcdHM0LjksMTAuMSwwLDE0LjdTMjQ0LjUsMTY1LjcsMjQ0LjUsMTY1Ljd6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0OF9zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTIxMi4xLDE5Ny4ybDMyLjQtMzEuNmMwLDAsNy4zLDE1LjksMCwyMy4ybC0yOS43LDI5LjVcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMF9zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTIwNi4xLDMyNy44YzAsMC00LjUsNi4yLTQuMSw5LjhzNi4xLDkuNyw3LjQsMTIuM3MxLjYsMy43LDAsNS42cy0xNS42LTEwLjItMTUuOS0xMi4yczEuOS05LjQsMS45LTkuNFxcblxcdFxcdGwtNi4yLDcuOGwtNC41LTIuNmw5LjYtMTYuMVxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDhfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk0yMDcuOSwzNTUuOGMtMC40LTAuNC0xMS40LTQuMi0xMS40LTQuMnMtNS4yLTUuNC01LTcuNXMyLTEwLjIsNC0xMC4xczIuMSwxMC45LDIuMSwxMC45TDIwNy45LDM1NS44elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDEwX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjIxLDMzOC4xbDEuNCwxNi41YzAsMCwzLjYsMi42LDQuNCwyLjRzMy41LTAuOSwzLjUtMS4zcy0xLjMtMTEuNy0wLjktMTJzNS44LDguNiw3LjYsOC44XFxuXFx0XFx0czE0LjgtNy40LDEzLjUtMTAuM3MtNy42LTEuNC0xMC43LTEuNHMtNy40LTEuOC05LjgtNy4yXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0NF9zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTIyOS4zLDI5My40bDgsNDIuM2MwLDAtNC42LDYtMjEuMSw1LjNsLTEyLjMtMzBcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Q0X3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjMyLjgsMjI3YzAsMCwxMi4zLDE4LDguNSw0Ny4xYy0zLjQsMjUuOC0yOS4xLDU2LjItMjkuMSw1Ni4ycy03LjcsMy40LTIzLjctMTEuOGwxNy43LTI4LjFcXG5cXHRcXHRjMCwwLTE3LjItNDAsMy4xLTY1LjNcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxM19zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTI2Ny41LDE5Mi41YzAtMi4zLDMuNS0yLjMsMy42LDBjMCwxLjIsMCwyLjQsMCwzLjZjMC4xLTAuMywwLjMtMC41LDAuNC0wLjhjMS40LTMuMywyLjUtNi44LDMuMi0xMC40XFxuXFx0XFx0YzAuNC0yLjMsMy44LTEuMywzLjUsMWMtMC4yLDEuNy0wLjYsMy41LTEuMSw1LjJsMC40LTAuMWMxLjItMC40LDIuNiwwLjMsMywxLjZjMCwwLDAsMC4xLDAsMC4xYzAuMiwwLjUsMC4yLDEuMSwwLjEsMS43aDAuM1xcblxcdFxcdGMxLDAuMywxLjgsMS4yLDEuOCwyLjNjMCwwLjYtMC4xLDEuMi0wLjUsMS43YzAuNCwwLjQsMC43LDAuOCwwLjksMS40YzAuMSwxLjMtMC40LDIuNi0xLjUsMy4zYy0xLjIsMS0yLjYsMi40LTMuNywzLjVcXG5cXHRcXHRjLTEuNSwxLjQtMy4yLDIuOS00LjUsNHMtMy43LTIuNy0zLjctMy45Yy0wLjksMC4zLTEuOC0wLjItMi4xLTFjLTAuMS0wLjItMC4xLTAuNC0wLjEtMC42QzI2Ny41LDIwMC44LDI2Ny42LDE5Ni43LDI2Ny41LDE5Mi41elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDEwX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjc0LjcsMTk2LjNjMC45LTEuOCwxLjYtMy42LDIuNC01LjRjMC4xLTAuNCwwLjgtMC4yLDAuNiwwLjJjLTAuNywxLjktMS41LDMuNy0yLjQsNS42XFxuXFx0XFx0QzI3NS4xLDE5Ny4xLDI3NC41LDE5Ni43LDI3NC43LDE5Ni4zelxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDhfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk0yMzEsMTg3LjNjMCwwLDYsNS40LDguMyw5LjJzMTEuNiwxNCwxNS41LDEwLjljMy44LTMuMSwxMC42LTksMTAuNi05czkuNyw2LjcsOC43LDEzLjZjMCwwLTguNiwxNy42LTIyLDEzLjdcXG5cXHRcXHRzLTE2LjgtOS0xNi44LTlsLTIsMTEuNGMwLDAtMTYuNyw1LjItMjQuNC0yLjVjMCwwLTUuMS0zMi45LTEuMy0zNy44XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTNfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk0yMzIuOCwxNjcuNGMwLjEsMC40LDAuNCwxMi4zLTMuNiwxMy40cy0xMS0xLjctMTIuOC01LjVzMC44LTE1LjgsNy4yLTE2LjVTMjMxLjcsMTYzLjksMjMyLjgsMTY3LjR6XFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInN0MTFfc2NydW0tYm9hcmQtMjdcXFwiIGQ9XFxcIk0yMjcuOSwxNjkuNmMtMi43LDEuOC0xLDUuMiwwLjEsNy40YzAuOCwxLjcsMS4yLDMuNiwxLjIsNS40YzAsMS44LDAuNiwzLjUsMS43LDQuOGMwLjksMS4xLDEuNywyLjMsMi4zLDMuNlxcblxcdFxcdGMtNS44LDEuMy0xMiwwLjktMTcuOSwwLjJjLTQuOS0wLjQtOS44LTEtMTQuNi0xLjljMC4xLTEsMC4zLTIsMC43LTNjMS4xLTIuNiwzLTQsMi42LTcuMWMtMC40LTIuNC0xLTQuNy0wLjEtNy4xczIuOS0zLjYsNC45LTVcXG5cXHRcXHRjMC42LTAuNCwxLjEtMC45LDEuNi0xLjRsMC40LTAuN2MxLjItMiwyLTQuNCwzLjYtNi4xYzEuNi0xLjYsMy42LTIuNiw1LjgtM2M0LjYtMC44LDkuNCwwLjIsMTMuMiwzYzAsMCwzLjUsMy40LDIuNCw2LjlcXG5cXHRcXHRTMjMwLjMsMTY4LDIyNy45LDE2OS42elxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzdDEwX3NjcnVtLWJvYXJkLTI3XFxcIiBkPVxcXCJNMjMwLjksMzAyLjFjMCwwLTE0LjEsMjQuNC0xOC43LDI4LjFsMy45LDEwLjhDMjE2LjIsMzQxLDIzMi41LDMxOCwyMzAuOSwzMDIuMXpcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3QxMF9zY3J1bS1ib2FyZC0yN1xcXCIgZD1cXFwiTTIwNi41LDI4OWM0LjUtOS41LDctMTkuOCw3LjQtMzAuM2MwLTAuNCwwLjQtMC42LDAuNy0wLjZjMC4zLDAsMC41LDAuMywwLjYsMC42Yy0wLjQsMTAuNy0yLjksMjEuMy03LjUsMzFcXG5cXHRcXHRDMjA3LjIsMjkwLjUsMjA2LjEsMjg5LjgsMjA2LjUsMjg5elxcXCI+PC9wYXRoPjwvZz48L3N2Zz5cIiIsImltcG9ydCB7IEd1aSB9IGZyb20gXCIuLi9tb2R1bGVzL2d1aVwiO1xuaW1wb3J0IHsgTG9naWMgfSBmcm9tIFwiLi4vbW9kdWxlcy9sb2dpY1wiO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tIFwiLi4vbW9kdWxlcy9zdG9yYWdlXCI7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuLi9tb2R1bGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBUb2RvRm9ybSB9IGZyb20gXCIuL3RvZG9mb3JtXCI7XG5pbXBvcnQgeyBTaWRlYmFyIH0gZnJvbSBcIi4vc2lkZWJhclwiO1xuaW1wb3J0IHsgZm9ybWF0LCBpc1RvZGF5IH0gZnJvbSBcImRhdGUtZm5zXCI7XG5cbi8qKlxuICogSW50ZXJmYWNlIGNvbGxlY3RpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIGNhbGxlZCBmcm9tIHdpdGhpblxuICogb3Igc2hvdWxkIGhhZSBlZmZlY3Qgb24gYSBDYXJkIGRpc3BsYXlpbmcgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgVG9kby4gQWxzbyBoYW5kbGVzIGludGVyYWN0aXZlIGVsZW1lbnRzIHN1Y2ggYXNcbiAqIGJ1dHRvbnMgdG8gZWRpdCBvciBkZWxldGUgdG9kb3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYXJkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgICAvLyNyZWdpb24gSW1wbGVtZW50aW5nIHNpbmdsZXRvbiBwYXR0ZXJuXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIUNhcmQuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIENhcmQuaW5zdGFuY2UgPSBuZXcgQ2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYXJkLmluc3RhbmNlO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHN0YXR1cyBvZiBhIFRvZG8gYW5kIGl0cyBhcHBlYXJhbmNlIHRvIHJlZmxlY3QgdGhlIGNoYW5nZS5cbiAgICAgKiBAcGFyYW0geyp9IHRvZG9cbiAgICAgKiBAcGFyYW0geyp9IHRvZG9VSVxuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja1RvZG8odG9kbywgdG9kb1VJKSB7XG4gICAgICAgIHRvZG8udG9nZ2xlU3RhdHVzKCk7XG4gICAgICAgIHRvZG9VSS5jbGFzc0xpc3QudG9nZ2xlKFwiZG9uZVwiKTtcblxuICAgICAgICAvLyBUZXJuYXJ5IG9wZXJhdG9yIGluIGNhc2Ugd2UgYXJlIGluIHRoZSBcIkdlbmVyYWxcIiB2aWV3IG9yIGluIGEgZmlsdGVyZWQgb25lLlxuICAgICAgICBTdG9yZS5zYXZlUHJvamVjdChcbiAgICAgICAgICAgIEd1aS5nZXRDdXJyZW50UHJvamVjdCgpLmdldFVpZCgpID09PSB0b2RvLnByb2plY3RcbiAgICAgICAgICAgICAgICA/IEd1aS5nZXRDdXJyZW50UHJvamVjdCgpXG4gICAgICAgICAgICAgICAgOiBTdG9yZS5sb2FkUHJvamVjdCh0b2RvLnByb2plY3QpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdGhlIFVJIENhcmQgdG8gcmVmbGVjdCBjaGFuZ2VzIHRvIHRoZSBUb2RvIGl0ZW0uXG4gICAgICogQHBhcmFtIHsqfSBlbGVtZW50XG4gICAgICogQHBhcmFtIHsqfSB0b2RvVUlcbiAgICAgKi9cbiAgICBzdGF0aWMgZWRpdFRvZG9VSShlbGVtZW50LCB0b2RvVUkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFRvRWRpdCA9IHRvZG9VSS5xdWVyeVNlbGVjdG9yKGBbcHJvcD0ke2VsZW1lbnRbMF19XWApO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSBlbGVtZW50WzFdO1xuXG4gICAgICAgIGlmIChlbGVtZW50WzBdID09PSBcImR1ZURhdGVcIikge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBmb3JtYXQobmV3VmFsdWUsIFwiZCBNTU0geXl5eVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50VG9FZGl0KSBlbGVtZW50VG9FZGl0LnRleHRDb250ZW50ID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHRvZG8gZnJvbSB0aGUgaW4tbWVtb3J5IGxpc3QgYW5kIGZyb20gdGhlIFVJIHZpZXcuXG4gICAgICogQHBhcmFtIHsqfSB0b2RvXG4gICAgICogQHBhcmFtIHsqfSB0b2RvVUlcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlVG9kbyh0b2RvLCB0b2RvVUkpIHtcbiAgICAgICAgbGV0IHByb2plY3QgPVxuICAgICAgICAgICAgR3VpLmdldEN1cnJlbnRQcm9qZWN0KCkuZ2V0VWlkKCkgPT09IHRvZG8ucHJvamVjdFxuICAgICAgICAgICAgICAgID8gR3VpLmdldEN1cnJlbnRQcm9qZWN0KClcbiAgICAgICAgICAgICAgICA6IFN0b3JlLmxvYWRQcm9qZWN0KHRvZG8ucHJvamVjdCk7XG5cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b2RvVmlld1wiKS5yZW1vdmVDaGlsZCh0b2RvVUkpO1xuXG4gICAgICAgIExvZ2ljLmRlbGV0ZVRvZG8ocHJvamVjdCwgdG9kbyk7XG4gICAgICAgIFN0b3JlLnNhdmVQcm9qZWN0KHByb2plY3QpO1xuXG4gICAgICAgIEd1aS51cGRhdGUoKVxuICAgICAgICBHdWkuY2hlY2tJZkZpbHRlcmVkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVJIHRvZG8gZnJvbSB0aGUgc3VwcGxpZWQgVG9kbyBpbnN0YW5jZS4gQnVpbGRzXG4gICAgICogZnJvbSB0aGUgdG9kbyB0ZW1wbGF0ZSBpbnNpZGUgdGhlIG1haW4gaHRtbCBmaWxlIGFuZCBsb2FkcyBldmVudFxuICAgICAqIGxpc3RlbmVyZXMgZm9yIGJ1dHRvbnMgaW5zaWRlIHRoYSBjYXJkLiBBbHNvIGNoZWNrIGF0IGNyZWF0aW9uIHRpbWVcbiAgICAgKiBpZiB0aGUgdG9kbyBpcyBhbHJlYWR5IGRvbmUgb3Igbm90IGFuZCBhcHBsaWVzIHN0eWxlIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSB7Kn0gdG9kb1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNhcmQodG9kbykge1xuICAgICAgICAvLyBDbG9uZXMgdGhlIHRvZG8gdG8gZGlzcGxheSBmcm9tIHRoZSB0ZW1wbGF0ZS4gQ2xlYW5zIGl0cyBwcm9wZXJ0aWVzLlxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudG9kb1RlbXBsYXRlXCIpO1xuICAgICAgICBjb25zdCBuZXdDYXJkID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBuZXdDYXJkLmNsYXNzTGlzdC5yZW1vdmUoXCJ0b2RvVGVtcGxhdGVcIik7XG4gICAgICAgIG5ld0NhcmQuY2xhc3NMaXN0LmFkZChcInRvZG9cIik7XG4gICAgICAgIG5ld0NhcmQuc2V0QXR0cmlidXRlKFwidWlkXCIsIHRvZG8uZ2V0VWlkKCkpO1xuXG4gICAgICAgIC8vIENoZWNrYm94IGFjdGl2YXRpb24gYW5kIGNhcmQgc3R5bGluZyBhY2NvcmRpbmcgdG8gdG9kbyBzdGF0dXMuXG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gbmV3Q2FyZC5xdWVyeVNlbGVjdG9yKFwiLmRvbmVDaGVja1wiKTtcbiAgICAgICAgaWYgKHRvZG8uZ2V0U3RhdHVzKCkpIHtcbiAgICAgICAgICAgIG5ld0NhcmQuY2xhc3NMaXN0LmFkZChcImRvbmVcIik7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja2JveC5vbmNoYW5nZSA9ICgpID0+IHRoaXMuY2hlY2tUb2RvKHRvZG8sIG5ld0NhcmQpO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlcyB0aGUgVG9kbyBjYXJkIHdpdGggZGF0YSBmcm9tIHRoZSBwYXNzZWQgVG9kbyAgaW5zdGFuY2UuXG4gICAgICAgIG5ld0NhcmQucXVlcnlTZWxlY3RvcihcIi50b2RvVGl0bGVcIikudGV4dENvbnRlbnQgPSB0b2RvLnRpdGxlO1xuICAgICAgICBuZXdDYXJkLnF1ZXJ5U2VsZWN0b3IoXCIudG9kb0Rlc2NcIikudGV4dENvbnRlbnQgPSB0b2RvLmRlc2NyaXB0aW9uO1xuICAgICAgICBuZXdDYXJkLnF1ZXJ5U2VsZWN0b3IoXCIudG9kb1Byb2plY3RcIikudGV4dENvbnRlbnQgPSBVdGlscy50b1RpdGxlQ2FzZShcbiAgICAgICAgICAgIFN0b3JlLmxvYWRQcm9qZWN0KHRvZG8ucHJvamVjdCkubmFtZVxuICAgICAgICApO1xuICAgICAgICBuZXdDYXJkLnF1ZXJ5U2VsZWN0b3IoXCJ0aW1lXCIpLmRhdGV0aW1lID0gdG9kby5kdWVEYXRlO1xuICAgICAgICBuZXdDYXJkLnF1ZXJ5U2VsZWN0b3IoXCJ0aW1lXCIpLnRleHRDb250ZW50ID0gdG9kby5kdWVEYXRlO1xuXG4gICAgICAgIC8vIEFjdGl2YXRlcyBidXR0b25zIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgY29uc3QgZWRpdEJ1dHRvbiA9IG5ld0NhcmQucXVlcnlTZWxlY3RvcihcIi5lZGl0QnV0dG9uXCIpO1xuICAgICAgICBlZGl0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBUb2RvRm9ybS5vcGVuRm9ybShcImVkaXRcIiwgdG9kbyk7XG5cbiAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uID0gbmV3Q2FyZC5xdWVyeVNlbGVjdG9yKFwiLmRlbGV0ZUJ1dHRvblwiKTtcbiAgICAgICAgZGVsZXRlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmRlbGV0ZVRvZG8odG9kbywgbmV3Q2FyZCk7XG5cbiAgICAgICAgR3VpLnVwZGF0ZSgpXG5cbiAgICAgICAgcmV0dXJuIG5ld0NhcmQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgU3RvcmUgfSBmcm9tIFwiLi4vbW9kdWxlcy9zdG9yYWdlXCI7XG5pbXBvcnQgeyBTaWRlYmFyIH0gZnJvbSBcIi4vc2lkZWJhclwiOyBcbmltcG9ydCB7IExvZ2ljIH0gZnJvbSBcIi4uL21vZHVsZXMvbG9naWNcIjtcbmltcG9ydCB7IEd1aSB9IGZyb20gXCIuLi9tb2R1bGVzL2d1aVwiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi4vbW9kdWxlcy91dGlsc1wiO1xuXG4vKipcbiAqIENvbnRhaW5zIGZ1bmN0aW9uYWxpdGllcyBmb3IgdGhlIGRpYWxvZyBhbmQgaW5uZXIgZm9ybVxuICogZGVwbG95ZWQgdG8gY3JlYXRlIGFuZCBlZGl0IHByb2plY3RzIGluc2lkZSB0aGUgYXBwLlxuICovXG5leHBvcnQgY29uc3QgUHJvamVjdEZvcm0gPSAoKCkgPT4ge1xuICAgIFxuICAgIGNvbnN0IGRpYWxvZyA9IHtcbiAgICAgICAgbW9kYWw6ICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwcm9qZWN0Rm9ybVwiKSxcbiAgICAgICAgY2xvc2VidG46ICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjbG9zZVByb2plY3RGb3JtXCIpLFxuICAgICAgICBzYXZlYnRuOiAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3NhdmVQcm9qZWN0XCIpLFxuICAgICAgICBuYW1lOiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Byb2plY3RGb3JtTmFtZVwiKSxcbiAgICAgICAgZGVzY3JpcHRpb246ICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwcm9qZWN0RGVzY1wiKSxcbiAgICAgICAgdWljb2xvcjogICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwcm9qZWN0Q29sb3JcIiksXG4gICAgICAgIGNpcmNsZTogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY29sb3JDaXJjbGVcIilcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwcm9qZWN0IGNyZWF0aW9uIGRpYWxvZyBieSBncmFiYmluIHJlZmVyZWNlcyB0b1xuICAgICAqIGlucHV0cyBhbmQgYWN0aXZhdGVzIGJ1dHRvbnMgYW5kIG1lbnVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGRpYWxvZy5jbG9zZWJ0bi5vbmNsaWNrID0gKCkgPT4gY2xvc2VGb3JtKCk7XG4gICAgICAgIGRpYWxvZy51aWNvbG9yLm9uY2hhbmdlID0gKCkgPT4gdXBkYXRlQ29sb3JDaXJjbGUoZGlhbG9nLnVpY29sb3IudmFsdWUpXG4gICAgICAgIGRpYWxvZy5zYXZlYnRuLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgZGlhbG9nLm5hbWUub25pbnB1dCA9ICgpID0+IHByZXZlbnRFbXB0eVByb2plY3QoKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGZvcm0gY2hlY2tpbmcgdGhlIG1vZGU6IGVkaXRpbmcgb3IgY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHt9IG1vZGUgXG4gICAgICogQHBhcmFtIHsqfSBwcm9qZWN0IFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW5Gb3JtKG1vZGU9XCJjcmVhdGVcIiwgcHJvamVjdD1udWxsKSB7XG4gICAgICAgIGRpYWxvZy5tb2RhbC5zaG93KCk7XG4gICAgICAgIEd1aS50b2dnbGVPdmVybGF5KCk7XG4gICAgICAgIChtb2RlID09PSBcImVkaXRcIikgPyBvcGVuRm9yRWRpdGluZyhwcm9qZWN0KSA6IG9wZW5Gb3JDcmVhdGlvbigpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgUHJvamVjdCBmb3JtIGluIGNyZWF0aW9uIG1vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3BlbkZvckNyZWF0aW9uKCkge1xuICAgICAgICBkaWFsb2cuc2F2ZWJ0bi5vbmNsaWNrID0gKCkgPT4gc2F2ZU5ld1Byb2plY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgUHJvamVjdCBmb3JtIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3QgXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3BlbkZvckVkaXRpbmcocHJvamVjdCkge1xuXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXNUb1VwZGF0ZSA9IFtcIm5hbWVcIiwgXCJkZXNjcmlwdGlvblwiLCBcInVpY29sb3JcIiBdXG4gICAgICAgIC5mb3JFYWNoKChwcm9wZXJ0eSkgPT4gZGlhbG9nW3Byb3BlcnR5XS52YWx1ZSA9IHByb2plY3RbcHJvcGVydHldKVxuICAgICAgICB1cGRhdGVDb2xvckNpcmNsZShwcm9qZWN0LnVpY29sb3IpXG5cbiAgICAgICAgZGlhbG9nLnNhdmVidG4udGV4dENvbnRlbnQgPSBcIlNhdmUgY2hhbmdlc1wiO1xuXG4gICAgICAgIGRpYWxvZy5zYXZlYnRuLm9uY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgc2F2ZVByb2plY3RDaGFuZ2VzKHByb2plY3QpO1xuICAgICAgICAgICAgY2xvc2VGb3JtKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGlhbG9nLm1vZGFsLnNob3coKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgcHJvamVjdCBtb2RhbCBhbmQgcmVzZXRzIGZpZWxkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9zZUZvcm0oKSB7XG4gICAgICAgIGRpYWxvZy5tb2RhbC5jbG9zZSgpO1xuICAgICAgICBHdWkudG9nZ2xlT3ZlcmxheSgpO1xuICAgICAgICByZXNldEZvcm0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBmaWVsZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzZXRGb3JtKCkgeyAgICAgICAgXG4gICAgICAgIFtkaWFsb2cubmFtZSwgZGlhbG9nLmRlc2NyaXB0aW9uLCBkaWFsb2cudWljb2xvcl0uZm9yRWFjaChcbiAgICAgICAgICAgIChmaWVsZCkgPT4gZmllbGQudmFsdWUgPSBcIlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIG5ldyBwcm9qZWN0IHdpdGggZGF0YSBwcm92aWRlZCBpbiB0aGUgaW5wdXQgZm9ybS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXZlTmV3UHJvamVjdCgpIHtcblxuICAgICAgICBjb25zdCBuZXdQcm9qZWN0ID0gTG9naWMuY3JlYXRlUHJvamVjdChcbiAgICAgICAgICAgIGRpYWxvZy5uYW1lLnZhbHVlLFxuICAgICAgICAgICAgZGlhbG9nLmRlc2NyaXB0aW9uLnZhbHVlLFxuICAgICAgICAgICAgZGlhbG9nLnVpY29sb3IudmFsdWVcbiAgICAgICAgKTtcblxuICAgICAgICBjbG9zZUZvcm0oKTtcbiAgICAgICAgXG4gICAgICAgIFN0b3JlLnNhdmVQcm9qZWN0KG5ld1Byb2plY3QpO1xuICAgICAgICBTaWRlYmFyLnNob3dQcm9qZWN0cygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVQcm9qZWN0Q2hhbmdlcyhwcm9qZWN0KSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXNUb1dhdGNoID0gW1xuICAgICAgICAgICAgXCJuYW1lXCIsIFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiLCBcbiAgICAgICAgICAgIFwidWljb2xvclwiLCBcbiAgICAgICAgXVxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXNUb1dhdGNoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZGlhbG9nW3Byb3BlcnR5XS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gcHJvamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBMb2dpYy5lZGl0UHJvamVjdChwcm9qZWN0LCBwcm9wZXJ0eSwgbmV3VmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFN0b3JlLnNhdmVQcm9qZWN0KHByb2plY3QpO1xuICAgICAgICBTaWRlYmFyLnNob3dQcm9qZWN0cygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb2plY3QgPT09IEd1aS5nZXRDdXJyZW50UHJvamVjdCgpKSBHdWkuc3dpdGNoUHJvamVjdChwcm9qZWN0KVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY29sb3Igb2YgdGhlIGNpcmNsZSBuZXh0IHRvIGNvbG9yIHBpY2tlciB0b1xuICAgICAqIGdpdmUgdXNlciBhIHByZXZpZXcuXG4gICAgICogQHBhcmFtIHsqfSBjb2xvciBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVDb2xvckNpcmNsZShjb2xvcikge1xuICAgICAgICBkaWFsb2cuY2lyY2xlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIGNyZWF0aW9uIG9mIHVubmFtZWQgcHJvamVjdHMgYnkgZGlzYWJsaW5nIHRoZSBzYXZlIGJ1dHRvbiBpZlxuICAgICAqIHRoZSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgdGhlIG5hbWUuIFRoZSByZXN0IG9mIHZhbHVlcyBhcmUgc2V0IGJ5XG4gICAgICogdmFsaWRhdGlvbiBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHByZXZlbnRFbXB0eVByb2plY3QoKSB7XG4gICAgICAgICAgICBVdGlscy5pc1ZhbGlkU3RyaW5nKFwibmFtZVwiLCBkaWFsb2cubmFtZS52YWx1ZSkgXG4gICAgICAgICAgICA/IGRpYWxvZy5zYXZlYnRuLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpICBcbiAgICAgICAgICAgIDogZGlhbG9nLnNhdmVidG4uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgdHJ1ZSkgXG4gICAgICAgIH1cblxuICAgIHJldHVybiB7IGluaXQsIG9wZW5Gb3JtIH1cbn0pKCk7XG4iLCJpbXBvcnQgeyBHdWkgfSBmcm9tIFwiLi4vbW9kdWxlcy9ndWlcIjtcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSBcIi4uL21vZHVsZXMvc3RvcmFnZVwiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi4vbW9kdWxlcy91dGlsc1wiO1xuaW1wb3J0IHsgVG9kb0Zvcm0gfSBmcm9tIFwiLi90b2RvZm9ybVwiO1xuaW1wb3J0IHsgUHJvamVjdEZvcm0gfSBmcm9tIFwiLi9wcm9qZWN0Zm9ybVwiO1xuaW1wb3J0IHsgaXNUb2RheSwgZm9ybWF0IH0gZnJvbSBcImRhdGUtZm5zXCI7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tIFwiLi4vbW9kdWxlcy9maWx0ZXJcIjtcblxuZXhwb3J0IGNvbnN0IFNpZGViYXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBjb25zdCBzaWRlYmFyID0ge1xuICAgICAgICBzZWxmOiAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2lkZWJhclwiKSxcbiAgICAgICAgYWRkVG9kb0J1dHRvbjogICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FkZFRvZG9CdXR0b25cIiksXG4gICAgICAgIGFkZFByb2plY3RCdXR0b246ICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhZGRQcm9qZWN0XCIpLFxuICAgICAgICBpbmJveFRhYjogICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5ib3hcIiksXG4gICAgICAgIHRvZGF5VGFiOiAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b2RheVwiKSxcbiAgICAgICAgdG9kYXlOdW1iZXI6ICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RvZG9OdW1iZXJcIiksXG4gICAgICAgIHByb2plY3RMaXN0OiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwcm9qZWN0TGlzdFwiKSxcbiAgICAgICAgZm9sZEJ1dHRvbjogICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmZvbGRCdXR0b25cIiksXG4gICAgICAgIHVuZm9sZEJ1dHRvbjogICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5mb2xkQnV0dG9uLmNvbnRlbnRcIikgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRhbGl6ZXMgdGhlIFNpZGViYXIsIGdpdmVzIHRoZSBmaXJzdCB1cGRhdGUgdG8gZHluYW1pYyBzaWRlYmFyXG4gICAgICogZWxlbWVudHMgYW5kIGFjdGl2YXRlcyBidXR0b25zLFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRvZ2dsZVRhYlNlbGVjdGlvbigpXG4gICAgICAgIHVwZGF0ZVRvZGF5VG9kb3MoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzaWRlYmFyLnNlbGYuY2xhc3NMaXN0LmFkZChcImZvbGRhYmxlXCIpLDUwMCk7XG5cbiAgICAgICAgW3NpZGViYXIuZm9sZEJ1dHRvbiwgc2lkZWJhci51bmZvbGRCdXR0b25dXG4gICAgICAgIC5mb3JFYWNoKChidG4pID0+IGJ0bi5vbmNsaWNrID0gKCkgPT4gZm9sZFNpZGViYXIoKSlcbiAgICAgICAgc2lkZWJhci51bmZvbGRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBzaWRlYmFyLmFkZFRvZG9CdXR0b24ub25jbGljayA9ICgpID0+IFRvZG9Gb3JtLm9wZW5Gb3JtKCk7XG4gICAgICAgIHNpZGViYXIuYWRkUHJvamVjdEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4gUHJvamVjdEZvcm0ub3BlbkZvcm0oKTtcblxuICAgICAgICBzaWRlYmFyLmluYm94VGFiLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIpXG4gICAgICAgIHNpZGViYXIuaW5ib3hUYWIub25jbGljayA9ICgpID0+IFxuICAgICAgICAgICAgR3VpLnN3aXRjaFByb2plY3QoU3RvcmUubG9hZFByb2plY3QoXCJhYWEwMDBcIikpO1xuXG4gICAgICAgIHNpZGViYXIudG9kYXlUYWIub25jbGljayA9ICgpID0+IFxuICAgICAgICAgICAgR3VpLnJlbmRlckZpbHRlcmVkKFwiZHVlRGF0ZVwiLCBmb3JtYXQobmV3IERhdGUoKSwgXCJkIE1NTSB5eXl5XCIpKTtcbiAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBzaWRlYmFyIGFuZCBsZXRzIHRoZSBjb250ZW50IGFyZWEgdG8gZXhwYW5kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvbGRTaWRlYmFyKCkge1xuICAgICAgICBzaWRlYmFyLnNlbGYuY2xhc3NMaXN0LnRvZ2dsZShcImZvbGRlZFwiKTtcbiAgICAgICAgc2lkZWJhci51bmZvbGRCdXR0b24uc3R5bGUuZGlzcGxheSA9IChcbiAgICAgICAgICAgIHNpZGViYXIudW5mb2xkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykgXG4gICAgICAgICAgICA/ICdibG9jaycgXG4gICAgICAgICAgICA6ICdub25lJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBudW1iZXIgb2YgdG9kYXkgdG9kb3MgZGlzcGxheWVkIGluIHRoZSBTaWRlYmFyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVRvZGF5VG9kb3MoKSB7XG4gICAgICAgIGNvbnN0IHRvZGF5TnVtYmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b2RvTnVtYmVyXCIpO1xuICAgICAgICBjb25zdCB0b2RheVRvZG9zID0gU3RvcmUubG9hZEFsbFRvZG9zKCkuZmlsdGVyKCh0b2RvKSA9PlxuICAgICAgICAgICAgaXNUb2RheSh0b2RvLmR1ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIHRvZGF5TnVtYmVyLnRleHRDb250ZW50ID0gdG9kYXlUb2Rvcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBQcm9qZWN0IGxpc3QgaW4gdGhlIHNpZGViYXIgcGFuZWwgYnkgd2lwaW5nXG4gICAgICogdG9kbyBjaGlsZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhclByb2plY3RzKCkge1xuICAgICAgICB3aGlsZSAoc2lkZWJhci5wcm9qZWN0TGlzdC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBzaWRlYmFyLnByb2plY3RMaXN0LnJlbW92ZUNoaWxkKHByb2plY3RMaXN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgY2xpY2thYmxlIHByb2plY3RzIHRhYiB1bmRlciB0aGUgcG9yamVjdCBsaXN0IGluIHRoZSBzaWRlYmFyLlxuICAgICAqIFVzZXMgdGhlIHRlbXBsYXRlIGZyb20gdGhlIGhpZGRlbiAndGVtcGxhdGVzJyBodG1sIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvd1Byb2plY3RzKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcHJvamVjdFRhYlRlbXBsYXRlXCIpO1xuICAgICAgICBcbiAgICAgICAgY2xlYXJQcm9qZWN0cygpO1xuXG4gICAgICAgIGZvciAoY29uc3QgcHJvamVjdCBvZiBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpKSB7XG4gICAgICAgICAgICBpZiAocHJvamVjdCA9PT0gXCJhYWEwMDBcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSBTdG9yZS5sb2FkUHJvamVjdChwcm9qZWN0KVxuICAgICAgICAgICAgY29uc3QgdGFiID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0YWIuaWQgPSBwcm9qZWN0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0YWIucXVlcnlTZWxlY3RvcihcIi5wcm9qZWN0TmFtZVwiKS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgVXRpbHMudG9UaXRsZUNhc2UobG9hZGVkLm5hbWUpO1xuICAgICAgICAgICAgdGFiLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpLnN0eWxlLmNvbG9yID1cbiAgICAgICAgICAgICAgICBsb2FkZWQudWljb2xvcjtcbiAgICAgICAgICAgIHRhYi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIEd1aS5zd2l0Y2hQcm9qZWN0KFN0b3JlLmxvYWRQcm9qZWN0KHByb2plY3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZGViYXIucHJvamVjdExpc3QuYXBwZW5kQ2hpbGQodGFiKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVUYWJTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZ3JhcGhpY2FsIGZlZWRiYWNrIGZvciB0YWIgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZVRhYlNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgYWxsU2lkZWJhclRhYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhYlwiKVxuICAgICAgICBhbGxTaWRlYmFyVGFicy5mb3JFYWNoKCh0YWIpID0+IHtcbiAgICAgICAgICAgIHRhYi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFsbFNpZGViYXJUYWJzLmZvckVhY2godCA9PiB0LmNsYXNzTGlzdC5yZW1vdmUoXCJjdXJyZW50XCIpKVxuICAgICAgICAgICAgICAgIHRhYi5jbGFzc0xpc3QudG9nZ2xlKFwiY3VycmVudFwiKVxuICAgICAgICAgICAgICAgIGlmICh0YWIuaWQgIT09IFwiZmlsdGVyc1wiKSBGaWx0ZXIuaGlkZUZpbHRlclBhbmVsKClcbiAgICAgICAgICAgIH0pIFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBjbGljayBldmVudCB0byB0aGUgSW5ib3ggVGFiIHdoZW4gbmVlZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3dJbmJveCgpIHtcbiAgICAgICAgc2lkZWJhci5pbmJveFRhYi5jbGljaygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaW5pdCwgZm9sZFNpZGViYXIsIHVwZGF0ZVRvZGF5VG9kb3MsIHNob3dQcm9qZWN0cywgc2hvd0luYm94IH1cbn0pKCk7XG4iLCJpbXBvcnQgeyBMb2dpYyB9IGZyb20gXCIuLi9tb2R1bGVzL2xvZ2ljXCI7XG5pbXBvcnQgeyBHdWkgfSBmcm9tIFwiLi4vbW9kdWxlcy9ndWlcIjtcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSBcIi4uL21vZHVsZXMvc3RvcmFnZVwiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi4vbW9kdWxlcy91dGlsc1wiO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcImRhdGUtZm5zXCI7XG5pbXBvcnQgeyBDYXJkIH0gZnJvbSBcIi4vY2FyZFwiO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgZ2V0dGluZyBhbmQgbWFuaXB1bGF0aW9uIGRhdGEgYWJvdXQgYSB0b2RvLlxuICogSGFuZGxlcyBzdGF0aWMgYW5kIGludGVyYWN0aXZlIGVsZW1lbnRzIG9mIHRoZSBUb2RvIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNvbnN0IFRvZG9Gb3JtID0gKCAoKSA9PiB7XG4gICAgXG4gICAgY29uc3QgZGlhbG9nID0ge1xuICAgICAgICBtb2RhbDogICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpYWxvZ1wiKSxcbiAgICAgICAgZm9ybTogICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdG9kb0Zvcm1cIiksXG4gICAgICAgIHRpdGxlOiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvcm1UaXRsZVwiKSxcbiAgICAgICAgZGVzY3JpcHRpb246ICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9ybURlc2NcIiksXG4gICAgICAgIGR1ZURhdGU6ICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvcm1EYXRlXCIpLFxuICAgICAgICBwcmlvcml0eTogICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb3JtUHJpb3JpdHlcIiksXG4gICAgICAgIHByb2plY3Q6ICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvcm1Qcm9qZWN0XCIpLFxuICAgICAgICBjbG9zZWJ0bjogICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjbG9zZUZvcm1cIiksXG4gICAgICAgIHNhdmVidG46ICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3NhdmVUb2RvXCIpLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBmb3JtIGdldHRpbmcgbmVjZXNzYXJ5IHJlZmVyZW5jZXMgYW5kIGFkZGluZ1xuICAgICAqIGV2ZW50IGxpc3RlbmVycyBjb25uY2VjdCBmb3IgY3JlYXRpb24sIHNhdmluZyBhbmQgZGVsZXRpb24gb2ZcbiAgICAgKiB0b2RvcyBpbiBtZW1vcnkgYW5kIFVJLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGRpYWxvZy5mb3JtLm9uc3VibWl0ID0gKGUpID0+IGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBkaWFsb2cuY2xvc2VidG4ub25jbGljayA9ICgpID0+IGNsb3NlRm9ybSgpO1xuICAgICAgICBkaWFsb2cudGl0bGUub25pbnB1dCA9ICgpID0+IHByZXZlbnRFbXB0eVRvZG8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgZm9ybSBjaGVja2luZyB0aGUgbW9kZTogZWRpdGluZyBvciBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IG1vZGUgXG4gICAgICogQHBhcmFtIHsqfSB0b2RvIFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW5Gb3JtKG1vZGU9XCJjcmVhdGVcIiwgdG9kbz1udWxsKSB7XG4gICAgICAgIHVwZGF0ZVByb2plY3RTZWxlY3Rpb24oKTtcbiAgICAgICAgR3VpLnRvZ2dsZU92ZXJsYXkoKTtcbiAgICAgICAgKG1vZGUgPT09IFwiZWRpdFwiKSA/IG9wZW5Gb3JFZGl0aW5nKHRvZG8pIDogb3BlbkZvckNyZWF0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBUb2RvIGZvcm0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvc2VGb3JtKCkge1xuICAgICAgICBHdWkudG9nZ2xlT3ZlcmxheSgpO1xuICAgICAgICBkaWFsb2cubW9kYWwuY2xvc2UoKTtcbiAgICAgICAgY2xlYXJGb3JtKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdG9kbyBmb3JtIGluIGNyZWF0aW9uIG1vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3BlbkZvckNyZWF0aW9uKCkge1xuICAgICAgICBwcmV2ZW50RW1wdHlUb2RvKCk7XG5cbiAgICAgICAgZGlhbG9nLnByb2plY3QudmFsdWUgPSBcbiAgICAgICAgICAgICFHdWkuZ2V0Q3VycmVudFByb2plY3QoKS5maWx0ZXJlZCBcbiAgICAgICAgICAgID8gR3VpLmdldEN1cnJlbnRQcm9qZWN0KCkuZ2V0VWlkKCkgXG4gICAgICAgICAgICA6IFwiYWFhMDAwXCJcblxuICAgICAgICBkaWFsb2cuc2F2ZWJ0bi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIHNhdmVOZXdUb2RvKCk7XG4gICAgICAgICAgICBjbG9zZUZvcm0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGRpYWxvZy5tb2RhbC5zaG93KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0b2RvIGZvcm0gaW4gZWRpdGluZyBtb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW5Gb3JFZGl0aW5nKHRvZG8pIHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllc1RvVXBkYXRlID0gW1widGl0bGVcIiwgXCJkZXNjcmlwdGlvblwiLCBcInByaW9yaXR5XCIsIFwicHJvamVjdFwiIF1cbiAgICAgICAgLmZvckVhY2goKHByb3BlcnR5KSA9PiBkaWFsb2dbcHJvcGVydHldLnZhbHVlID0gdG9kb1twcm9wZXJ0eV0pXG5cbiAgICAgICAgZGlhbG9nLmR1ZURhdGUudmFsdWUgPSBmb3JtYXQodG9kby5kdWVEYXRlLCBcInl5eXktTU0tZGRcIik7XG4gICAgICAgIGRpYWxvZy5zYXZlYnRuLnRleHRDb250ZW50ID0gXCJTYXZlIGNoYW5nZXNcIjtcblxuICAgICAgICBkaWFsb2cuc2F2ZWJ0bi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIHNhdmVUb2RvQ2hhbmdlcyh0b2RvKTtcbiAgICAgICAgICAgIGNsb3NlRm9ybSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRpYWxvZy5tb2RhbC5zaG93KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWaXN1YWwgY29tbWFuZCB0byBzaWduYWwgdGhlIExvZ2ljIGNvbXBvbmVudCB0byBjcmVhdGUgYSBuZXcgdG9kb1xuICAgICAqIGluIG1lbW9yeSBhbmQgdGhlIFN0b3JlIHRvIHNhdmUgaXQgaW4gc3RvcmFnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXZlTmV3VG9kbygpIHsgICBcbiAgICAgICAgY29uc3QgdG9kb1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICB0aXRsZTogICAgICAgICAgZGlhbG9nLnRpdGxlLnZhbHVlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICAgIGRpYWxvZy5kZXNjcmlwdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGR1ZURhdGU6ICAgICAgICB2YWxpZGF0ZURhdGUoZGlhbG9nLmR1ZURhdGUudmFsdWUpLFxuICAgICAgICAgICAgcHJpb3JpdHk6ICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoZGlhbG9nLnByaW9yaXR5LnZhbHVlKSxcbiAgICAgICAgICAgIHByb2plY3RJRDogICAgICB2YWxpZGF0ZVByb2plY3QoZGlhbG9nLnByb2plY3QudmFsdWUpLFxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcHJvamVjdCB0byB1cGRhdGUgaXMgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgb25lIGl0IHdpbGxcbiAgICAgICAgICoganVzdCBzYXZlIGl0IGluc3RlYWQgb2YgcmVsb2FkaW5nIGFsbCB0b2Rvcy4gVGhpcyBjaGVjayBoYXMgYmVlblxuICAgICAgICAgKiBhZGRlZCB0byBoYW5kbGUgd2hlbiB0aGUgdXNlciBjcmVhdGVzIGEgdG9kbyBmcm9tIHRoZSBnZW5lcmFsIHZpZXcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcm9qZWN0VG9VcGRhdGUgPVxuICAgICAgICAgICAgR3VpLmdldEN1cnJlbnRQcm9qZWN0KCkuZ2V0VWlkKCkgPT09IHRvZG9Qcm9wZXJ0aWVzLnByb2plY3RJRFxuICAgICAgICAgICAgPyBHdWkuZ2V0Q3VycmVudFByb2plY3QoKVxuICAgICAgICAgICAgOiBTdG9yZS5sb2FkUHJvamVjdCh0b2RvUHJvcGVydGllcy5wcm9qZWN0SUQpO1xuXG4gICAgICAgIExvZ2ljLmNyZWF0ZVRvZG8odG9kb1Byb3BlcnRpZXMsIHByb2plY3RUb1VwZGF0ZSk7XG5cbiAgICAgICAgU3RvcmUuc2F2ZVByb2plY3QocHJvamVjdFRvVXBkYXRlKTtcblxuICAgICAgICBpZiAocHJvamVjdFRvVXBkYXRlID09PSBHdWkuZ2V0Q3VycmVudFByb2plY3QoKSkge1xuICAgICAgICAgICAgR3VpLnJlbmRlclByb2plY3QoR3VpLmdldEN1cnJlbnRQcm9qZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coR3VpLmdldEN1cnJlbnRQcm9qZWN0KCksIHRvZG9Qcm9wZXJ0aWVzKVxuXG4gICAgICAgIEd1aS51cGRhdGUoKVxuICAgICAgICBHdWkuY2hlY2tJZkZpbHRlcmVkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyB0aGUgdG9kbyBhY2NvcmRpbmcgdGhlIG1vZGlmaWVkIGZpZWxkcyBvZiB0aGUgVG9kbyBmb3JtLlxuICAgICAqIFdpbGwgb3ZlcndyaXRlIG9ubHkgdGhlIGVmZmVjdGl2ZSBjaGFuZ2VzIGJvdGggaW4gbWVtb3J5IGFuZCBVSS5cbiAgICAgKiBAcGFyYW0geyp9IHRvZG9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXZlVG9kb0NoYW5nZXModG9kbykge1xuICAgICAgICBjb25zdCB0b2RvVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdG9kb1ZpZXdcIik7XG4gICAgICAgIGNvbnN0IHRvZG9VSSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFt1aWQ9XCIke3RvZG8uZ2V0VWlkKCl9XCJdYCk7XG5cbiAgICAgICAgY29uc3QgcHJvamVjdFRvVXBkYXRlID1cbiAgICAgICAgICAgIEd1aS5nZXRDdXJyZW50UHJvamVjdCgpLmdldFVpZCgpID09PSB0b2RvLnByb2plY3RcbiAgICAgICAgICAgID8gR3VpLmdldEN1cnJlbnRQcm9qZWN0KClcbiAgICAgICAgICAgIDogU3RvcmUubG9hZFByb2plY3QodG9kby5wcm9qZWN0KTtcblxuICAgICAgICBsZXQgaGFzUHJvamVjdENoYW5nZWQ7XG5cbiAgICAgICAgY29uc3QgcHJvcGVydGllc1RvV2F0Y2ggPSBbXG4gICAgICAgICAgICBcInRpdGxlXCIsIFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiLCBcbiAgICAgICAgICAgIFwiZHVlRGF0ZVwiLCBcbiAgICAgICAgICAgIFwicHJpb3JpdHlcIiwgXG4gICAgICAgICAgICBcInByb2plY3RcIiBcbiAgICAgICAgXVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCB3aXRoIHVzZXIgaW5wdXQgaXQgd2lsbCBnZXRcbiAgICAgICAgICogdXBkYXRlZC4gVGhpcyBpbmNsdWRlcyBzd2FwcGluZyB0b2RvcyBiZXR3ZWVuIHByb2plY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzVG9XYXRjaCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGRpYWxvZ1twcm9wZXJ0eV0udmFsdWU7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRvZG9bcHJvcGVydHldO1xuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdG9kbyA9IExvZ2ljLmVkaXRUb2RvKFxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0VG9VcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHRvZG8sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dbcHJvcGVydHldLnZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBDYXJkLmVkaXRUb2RvVUkoW3Byb3BlcnR5LCBuZXdWYWx1ZV0sIHRvZG9VSSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IFwicHJvamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBMb2dpYy5tb3ZlVG9kbyhvbGRWYWx1ZSwgbmV3VmFsdWUsIHRvZG8pO1xuICAgICAgICAgICAgICAgICAgICBoYXNQcm9qZWN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRvZG9WaWV3LnJlbW92ZUNoaWxkKHRvZG9VSSk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0byBhdm9pZCBzYXZpbmcgdHdvIHRpbWVzIGFuZCBwcm92b2tlIGEgY2xvbmluZyBiZWhhdmlvdXIuXG4gICAgICAgIGlmICghaGFzUHJvamVjdENoYW5nZWQpIFN0b3JlLnNhdmVQcm9qZWN0KHByb2plY3RUb1VwZGF0ZSk7XG5cbiAgICAgICAgR3VpLnVwZGF0ZSgpXG4gICAgICAgIEd1aS5jaGVja0lmRmlsdGVyZWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmb3JtIHZhbHVlcyB0byBkZWZhdWx0IHNpbmNlIHRoZSBlZGl0aW5nIG1vZGVcbiAgICAgKiBvdmVyd3JpdGVzIHRoZW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJGb3JtKCkge1xuXG4gICAgICAgIFsgXG4gICAgICAgICAgICBkaWFsb2cudGl0bGUsIFxuICAgICAgICAgICAgZGlhbG9nLmRlc2NyaXB0aW9uLCBcbiAgICAgICAgICAgIGRpYWxvZy5kdWVEYXRlLCBcbiAgICAgICAgICAgIGRpYWxvZy5wcmlvcml0eSwgXG4gICAgICAgICAgICBkaWFsb2cucHJvamVjdFxuICAgICAgICBdLmZvckVhY2goIChpbnB1dCkgPT4gaW5wdXQudmFsdWUgPSBcIlwiIClcblxuICAgICAgICBkaWFsb2cuc2F2ZWJ0bi50ZXh0Q29udGVudCA9IFwiQWRkIHRvZG9cIjtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhldyBkcm9wZG93biBtZW51IHRvIHJlZmxlY3QgdGhlIGNyZWF0ZWQgcHJvamVjdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvamVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRpYWxvZy5wcm9qZWN0O1xuXG4gICAgICAgIGZvciAoY29uc3QgcHJvamVjdCBvZiBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBuZXdPcHRpb24udmFsdWUgPSBwcm9qZWN0O1xuICAgICAgICAgICAgbmV3T3B0aW9uLnRleHRDb250ZW50ID0gVXRpbHMudG9UaXRsZUNhc2UoU3RvcmUubG9hZFByb2plY3QocHJvamVjdCkubmFtZSk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmNvbnRhaW5zXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBvcHRpb25bdmFsdWU9XCIke25ld09wdGlvbi52YWx1ZX1cIl1gKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hcHBlbmRDaGlsZChuZXdPcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdGhlIGRhdGUgdG8gdG9kYXkgaWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFuIGlucHV0LlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0ZVRvVmFsaWRhdGVcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkIGRhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZURhdGUoZGF0ZVRvVmFsaWRhdGUpIHtcbiAgICAgICAgbGV0IGRhdGU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGUgPSBmb3JtYXQoZGF0ZVRvVmFsaWRhdGUsIFwiZCBNTU0geXl5eVwiKTtcbiAgICAgICAgfSBjYXRjaCAoRXJyb3IpIHtcbiAgICAgICAgICAgIGRhdGUgPSBmb3JtYXQobmV3IERhdGUoKSwgXCJkIE1NTSB5eXl5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRoZSBwcm9qZWN0IHRvIHRoZSBcImdlbmVyYWxcIiBvbmUgaWYgdGhlIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhbiBpbnB1dC5cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvamVjdChwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiAhcHJvamVjdCA/IFwiYWFhMDAwXCIgOiBwcm9qZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRoZSBwcmlvcml0eSB0byB0aGUgbG93ZXN0ICg0KSBpZiB0aGUgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFuIGlucHV0LlxuICAgICAqIEBwYXJhbSB7Kn0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByaW9yaXR5KHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAhcHJpb3JpdHkgPyBcIjRcIiA6IHByaW9yaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIGNyZWF0aW9uIG9mIHVudGl0bGVkIHRvZG9zIGJ5IGRpc2FibGluZyB0aGUgc2F2ZSBidXR0b24gaWZcbiAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBwcm92aWRlIHRoZSB0aXRsZS4gVGhlIHJlc3Qgb2YgdmFsdWVzIGFyZSBzZXQgYnlcbiAgICAgKiB2YWxpZGF0aW9uIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmV2ZW50RW1wdHlUb2RvKCkge1xuICAgICAgICBVdGlscy5pc1ZhbGlkU3RyaW5nKFwidGl0bGVcIiwgZGlhbG9nLnRpdGxlLnZhbHVlKSBcbiAgICAgICAgPyBkaWFsb2cuc2F2ZWJ0bi5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAgXG4gICAgICAgIDogZGlhbG9nLnNhdmVidG4uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgdHJ1ZSkgXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgIGluaXQsIG9wZW5Gb3JtICB9XG59KSgpOyIsImltcG9ydCB7IExvZ2ljIH0gZnJvbSBcIi4vbW9kdWxlcy9sb2dpY1wiO1xuaW1wb3J0IHsgR3VpIH0gZnJvbSBcIi4vbW9kdWxlcy9ndWlcIjtcbmltcG9ydCB7IFNpZGViYXIgfSBmcm9tIFwiLi9jb21wb25lbnRzL3NpZGViYXJcIjtcbmltcG9ydCB7IFRvZG9Gb3JtIH0gZnJvbSBcIi4vY29tcG9uZW50cy90b2RvZm9ybVwiO1xuaW1wb3J0IHsgUHJvamVjdEZvcm0gfSBmcm9tIFwiLi9jb21wb25lbnRzL3Byb2plY3Rmb3JtXCI7XG5pbXBvcnQgXCIuL3N0eWxlL21haW4uY3NzXCI7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tIFwiLi9tb2R1bGVzL2ZpbHRlclwiO1xuXG4vKipcbiAqIEhhbmRsZXMgc3RhcnR1cCBvZiB0aGUgVG9kbyBhcHAgYnkgbG9hZGluZyBldmVudCBsaXN0ZW5lcnNcbiAqIGFuZCBjYWxsaW5nIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAqL1xuY29uc3QgU3RhcnR1cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGdlbmVyYWw7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgIGdlbmVyYWwgPSBMb2dpYy5pbml0RGVmYXVsdFByb2plY3QoKTtcbiAgICAgICAgR3VpLnN3aXRjaFByb2plY3QoZ2VuZXJhbClcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpPT57XG4gICAgICAgIFNpZGViYXIuaW5pdCgpO1xuICAgICAgICBTaWRlYmFyLnNob3dQcm9qZWN0cygpO1xuICAgIH0pXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgIFRvZG9Gb3JtLmluaXQoKTtcbiAgICAgICAgUHJvamVjdEZvcm0uaW5pdCgpO1xuICAgIH0pXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgIEZpbHRlci5pbml0KClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHsgZ2VuZXJhbCB9O1xufSkoKTtcblxuXG5cblxuXG4iLCJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcbmltcG9ydCB7IEd1aSB9IGZyb20gXCIuL2d1aVwiO1xuXG5leHBvcnQgY29uc3QgRmlsdGVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEdVSSBlbGVtZW50cyB0aGF0IGludGVyYWN0IHdpdGggc2VhcmNoaW5mIGFuZCBmaWx0ZXJpbmdcbiAgICAgKiBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICBmaWx0ZXJUYWI6ICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmaWx0ZXJzXCIpLFxuICAgICAgICBwYW5lbDogICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmaWx0ZXJTZWxlY3Rpb25QYW5lbFwiKSxcbiAgICAgICAgc2VsZWN0b3I6ICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcHJvcFwiKSxcbiAgICAgICAgdmFsdWU6ICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdmFsdWVcIiksXG4gICAgICAgIHByb2plY3ROYW1lOiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Byb2plY3ROYW1lXCIpLFxuICAgICAgICBwcm9qZWN0RGVzYzogICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwcm9qZWN0RGVzY3JpcHRpb25cIiksXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZmlsdGVyaW5nIGZ1bmN0aW9uYWxpdGllcyBhbmQgbG9hZHMgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGZpbHRlci5maWx0ZXJUYWIub25jbGljayA9ICgpID0+IHNob3dGaWx0ZXJQYW5lbCgpXG5cbiAgICAgICAgZmlsdGVyLnNlbGVjdG9yLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGlucHV0VHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsdGVyLnNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImR1ZURhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnZhbHVlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmlvcml0eVwiOlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUuc2V0QXR0cmlidXRlKFwibWF4XCIsIDQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci52YWx1ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci52YWx1ZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcInRydWVcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHdWkuY2xlYXJUb2RvVmlldygpXG4gICAgICAgICAgICBmaWx0ZXIudmFsdWUudmFsdWUgPSBcIlwiXG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyLnZhbHVlLm9uaW5wdXQgPSAoKSA9PiBsb29rdXAoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBmaWx0ZXJpbmcgb3B0aW9ucyBpbiB0aGUgR1VJIG9uY2UgdGhlIHNlYXJjaCBwYW5lbCBpc1xuICAgICAqIGNsaWNrZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvd0ZpbHRlclBhbmVsKCkge1xuICAgICAgICBmaWx0ZXIucGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICBHdWkucmVuZGVyRmlsdGVyZWQoXCJ0aXRsZVwiLCB1bmRlZmluZWQpXG4gICAgICAgIGZpbHRlci5zZWxlY3Rvci52YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZpbHRlci5wcm9qZWN0TmFtZS50ZXh0Q29udGVudCA9IFwiU2VhcmNoICYgRmlsdGVyc1wiO1xuICAgICAgICBmaWx0ZXIucHJvamVjdERlc2MudGV4dENvbnRlbnQgPSBcIkZpbHRlciBUb2RvcyBieSBkZXNpcmVkIHZhbHVlLlwiO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZmlsdGVyc2QgcGFuZWwgb25jZSB0aGUgdXNlciBjbGlja3Mgb24gYW5vdGhlciB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhpZGVGaWx0ZXJQYW5lbCgpIHtcbiAgICAgICAgZmlsdGVyLnBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGlucHV0IHZhbGlkYXRpb24gYW5kIGNhbGxzIHRoZSBHVUkgZnVuY3Rpb24gdG8gcmVuZGVyIGZpbHRlcmVkXG4gICAgICogcmVzdWx0cy4gTWFrZXMgc3VyZSB0aGF0IHRoZSBHVUkgZG9lcyBub3QgZ2V0IG92ZXJ3cml0dGVuIHdoZW4gaW5zaWRlXG4gICAgICogdGhlIGZpbHRlciB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb2t1cCgpIHtcbiAgICAgICAgbGV0IHByb3BlcnR5ID0gZmlsdGVyLnNlbGVjdG9yLnZhbHVlO1xuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIudmFsdWUudmFsdWU7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBmaWx0ZXIudmFsdWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlID09PSBcImRhdGVcIikgeyB2YWx1ZSA9IGZvcm1hdCh2YWx1ZSwgXCJkIE1NTSB5eXl5XCIpOyB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7IHZhbHVlID0gdmFsdWUudHJpbSgpIH1cbiAgICAgICAgXG4gICAgICAgIEd1aS5yZW5kZXJGaWx0ZXJlZChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICBjaGVja0lmRW1wdHkoKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUGVyZm9tcyBlbXB0eW5lc3MgY2hla2luZyBmb3Igc2hvd2luZyB0aGUgRW1wdHkgUHJvamVjdCBncmFwaGljcyBhbmQgYXZvaWRcbiAgICAgKiBodG1sIGVsZW1lbnQgcGVyc2lzdGluZyBpbiB0aGUgZmlsdGVyZWQgdmlldyB3aGVuIHNlYXJjaCB2YWx1ZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0lmRW1wdHkoKSB7XG4gICAgICAgIGlmIChmaWx0ZXIudmFsdWUudmFsdWUgPT09IFwiXCIpIEd1aS5jbGVhclRvZG9WaWV3KClcbiAgICAgICAgR3VpLmNoZWNrRm9yRW1wdHlQcm9qZWN0KClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgaW5pdCwgaGlkZUZpbHRlclBhbmVsIH1cbn0pKCk7IiwiaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQgeyBDYXJkIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvY2FyZFwiO1xuaW1wb3J0IHsgU2lkZWJhciB9IGZyb20gXCIuLi9jb21wb25lbnRzL3NpZGViYXJcIjtcbmltcG9ydCBQcm9qZWN0IGZyb20gXCIuL3Byb2plY3RcIjtcbmltcG9ydCBjaGVja2xpc3QgZnJvbSBcIi4uLy4uL2Fzc2V0cy9jaGVja2xpc3QtNzEuc3ZnXCJcbmltcG9ydCBzY3J1bSBmcm9tIFwiLi4vLi4vYXNzZXRzL3NjcnVtLWJvYXJkLTI3LnN2Z1wiXG5pbXBvcnQgY29uc3RydWN0aW9uIGZyb20gXCIuLi8uLi9hc3NldHMvY29uc3RydWN0aW9uLXNpdGUtNTkuc3ZnXCJcbmltcG9ydCBub3Rmb3VuZCBmcm9tIFwiLi4vLi4vYXNzZXRzLzQwNC5zdmdcIlxuaW1wb3J0IHJlc3RpbmcgZnJvbSBcIi4uLy4uL2Fzc2V0cy9yZXN0aW5nLTQ5LnN2Z1wiXG5pbXBvcnQgeyBQcm9qZWN0Rm9ybSB9IGZyb20gXCIuLi9jb21wb25lbnRzL3Byb2plY3Rmb3JtXCI7XG5pbXBvcnQgeyBMb2dpYyB9IGZyb20gXCIuL2xvZ2ljXCI7XG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcblxuLyoqXG4gKiBPYmplY3QgdGhhdCBjb2xsZWN0cyByZWZlcmVuY2VzIGFuZCBmdW5jdGlvbnMgcmVsYXRlZCB0byB0aGUgQ29udGVudCBBcmVhXG4gKiBhbmQgdGhlIGdlbmVyYWwgYmVoYXZpb3VyIG9mIHRoZSBHVUkuIExlYXZlcyBhdXRvbm9teSB0byBtZXRob2RzIGZyb21cbiAqIHNtYWxsZXIgY29tcG9uZW50cyBsaWtlIFRvZG8gY2FyZHMgYW5kIHRoZSBTaWRlYmFyLCBpbiBzZXBhcmF0ZSBlbnRpdGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEd1aSA9IChmdW5jdGlvbigpIHtcbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHJlZmVyZW5jZXMgdG8gVUkgZWxlbWVudHMgbm90IGluY2x1ZGVkXG4gICAgICogaW4gc21hbGxlciBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IHVpID0ge1xuICAgICAgICB0b2RvVmlldzogICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RvZG9WaWV3XCIpLFxuICAgICAgICBwcm9qZWN0TmFtZTogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Byb2plY3ROYW1lXCIpLFxuICAgICAgICBwcm9qZWN0RGVzYzogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Byb2plY3REZXNjcmlwdGlvblwiKSxcbiAgICAgICAgZW1wdHlQYW5lbDogICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlbXB0eVByb2plY3RTY3JlZW5cIiksXG4gICAgICAgIGVtcHR5UGFuZWx0ZXh0OiAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZW1wdHlQcm9qZWN0VGV4dFwiKSxcbiAgICAgICAgZWRpdFByb2plY3RCdXR0b246ICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5lZGl0XCIpLFxuICAgICAgICBkZWxldGVQcm9qZWN0QnV0dG9uOiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRlbGV0ZVwiKSxcbiAgICAgICAgb3ZlcmxheTogICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkaWFsb2dPdmVybGF5XCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiBTVkcgaW1wb3J0cyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGNvbnRlbnQgcGFuZWxcbiAgICAgKiB3aXRoIHRoZSBtZXNzYWdlIHRvIGNyZWF0ZSBhIG5ldyBwcm9qZWN0LlxuICAgICAqL1xuICAgIGNvbnN0IHN2Z3MgPSBbY2hlY2tsaXN0LCBzY3J1bSwgY29uc3RydWN0aW9uLCBub3Rmb3VuZCwgcmVzdGluZ11cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHByb2plY3Qgc2hvd24gaW4gdGhlIGNvbnRlbnQgYXJlYS5cbiAgICAgKiBHZXRzIHVwZGF0ZWQgb24gcHJvamVjdCBzd2l0Y2hpbmcuXG4gICAgICovXG4gICAgbGV0IGN1cnJlbnRQcm9qZWN0O1xuXG4gICAgZnVuY3Rpb24gc2V0Q3VycmVudFByb2plY3QodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFByb2plY3QgPSB2YWx1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFByb2plY3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIFRvZG8gdmlldyBpbiB0aGUgY29udGVudCBwYW5lbCBieSB3aXBpbmdcbiAgICAgKiB0b2RvIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyVG9kb1ZpZXcoKSB7XG4gICAgICAgIHdoaWxlICh1aS50b2RvVmlldy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0b2RvVmlldy5yZW1vdmVDaGlsZCh0b2RvVmlldy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWaXN1YWwgY29tbWFuZCBmcm9tIEdVSSB0byBkZWxldGUgYSBwcm9qZWN0LiBVcGRhdGVzIGFsbCBkaXNwbGF5ZWRcbiAgICAgKiBkYXRhIHRoYXQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3QgXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsZXRlUHJvamVjdChwcm9qZWN0KSB7XG4gICAgICAgIExvZ2ljLmRlbGV0ZVByb2plY3QocHJvamVjdC5nZXRVaWQoKSk7XG4gICAgICAgIEd1aS51cGRhdGUoKTtcbiAgICAgICAgU2lkZWJhci5zaG93SW5ib3goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY2xpY2tlZCBwcm9qZWN0IGluIHRoZSBHVUkgYnkgY2FsbGluZyB0aGUgU3RvcmFnZSBjb21wb25lbnRcbiAgICAgKiB0byBhY3F1aXJlIHRoZSBwcm9qZWN0IGRhdGEgYW5kIGJ5IGNhbGxpbmcgdGhlIHJlbmRlcmluZyBtZXRob2Qgb250b1xuICAgICAqIHRoZSBjb2xsZWN0aW9uIG9mIHRvZG9zLlxuICAgICAqIEBwYXJhbSB7Kn0gcHJvamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlclByb2plY3QocHJvamVjdCkge1xuICAgICAgICBjbGVhclRvZG9WaWV3KCk7XG4gICAgICAgIHVpLnByb2plY3ROYW1lLnRleHRDb250ZW50ID0gVXRpbHMudG9UaXRsZUNhc2UocHJvamVjdC5uYW1lKTtcbiAgICAgICAgdWkucHJvamVjdERlc2MudGV4dENvbnRlbnQgPSBwcm9qZWN0LmRlc2NyaXB0aW9uXG5cbiAgICAgICAgZm9yIChjb25zdCB0b2RvIG9mIHByb2plY3QuZ2V0VG9kb3NMaXN0KCkpIHtcbiAgICAgICAgICAgIHRvZG9WaWV3LmFwcGVuZENoaWxkKENhcmQuY3JlYXRlQ2FyZCh0b2RvKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvamVjdC5nZXRVaWQoKSA9PT0gXCJhYWEwMDBcIiB8fCBwcm9qZWN0LmZpbHRlcmVkKSB7XG4gICAgICAgICAgICB1aS5lZGl0UHJvamVjdEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICAgICAgICAgIHVpLmRlbGV0ZVByb2plY3RCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVpLmVkaXRQcm9qZWN0QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIlxuICAgICAgICAgICAgdWkuZGVsZXRlUHJvamVjdEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCJcbiAgICAgICAgICAgIHVpLmVkaXRQcm9qZWN0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBQcm9qZWN0Rm9ybS5vcGVuRm9ybShcImVkaXRcIiwgcHJvamVjdClcbiAgICAgICAgICAgIHVpLmRlbGV0ZVByb2plY3RCdXR0b24ub25jbGljayA9ICgpID0+IGRlbGV0ZVByb2plY3QocHJvamVjdClcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgY29udGVudCB2aWV3IGJldHdlZW4gcHJvamVjdHMsIGZyb20gY3VycmVudFxuICAgICAqIHRvIHRhcmdldCBvbmUuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzd2l0Y2hQcm9qZWN0KHRhcmdldCkge1xuICAgICAgICBjdXJyZW50UHJvamVjdCA9IHRhcmdldDtcbiAgICAgICAgcmVuZGVyUHJvamVjdCh0YXJnZXQpO1xuICAgICAgICBjaGVja0ZvckVtcHR5UHJvamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IHByb2plY3QgdG8gc3RvcmUgZmlsdGVyZWQgdG9kb3MgYW5kIHJlbmRlciB0aGVtXG4gICAgICogaW4gdGhlIGRlZGljYXRlZCB0YWIuIENoZWNrcyBmb3IgcHJvcGVydHkgYW5kIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcGVydHkgXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJGaWx0ZXJlZChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyTmFtZSA9IHZhbHVlID09PSBmb3JtYXQobmV3IERhdGUoKSwgXCJkIE1NTSB5eXl5XCIpIFxuICAgICAgICA/IFwiVG9kYXlcIiBcbiAgICAgICAgOiBcIlNlYXJjaCAmIEZpbHRlcnNcIjtcblxuICAgICAgICBjb25zdCBmaWx0ZXJEZXNjID0gdmFsdWUgPT09IGZvcm1hdChuZXcgRGF0ZSgpLCBcImQgTU1NIHl5eXlcIikgXG4gICAgICAgID8gXCJBIGxpc3Qgb2YgVG9kYXkncyB0YXNrcy5cIiBcbiAgICAgICAgOiBcIkZpbHRlciBUb2RvcyBieSBkZXNpcmVkIHZhbHVlLlwiXG5cbiAgICAgICAgY29uc3QgZmlsdGVyZWRUb2RvcyA9IFN0b3JlLmxvYWRBbGxUb2RvcygpLmZpbHRlcihcbiAgICAgICAgICAgICh0b2RvKSA9PiBcbiAgICAgICAgICAgICAgICB0b2RvW3Byb3BlcnR5XSA9PT0gdmFsdWUgfHwgbmV3IFJlZ0V4cChgKD89Li4uKSR7dmFsdWV9YCwgXCJpXCIpLnRlc3QodG9kb1twcm9wZXJ0eV0pXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdGVtcFByb2plY3QgPSBuZXcgUHJvamVjdChcbiAgICAgICAgICAgIGZpbHRlck5hbWUsXG4gICAgICAgICAgICBmaWx0ZXJEZXNjLFxuICAgICAgICAgICAgXCJibGFja1wiLFxuICAgICAgICAgICAgW3Byb3BlcnR5LCB2YWx1ZV1cbiAgICAgICAgKTtcblxuICAgICAgICBmaWx0ZXJlZFRvZG9zLmZvckVhY2goKHRvZG8pID0+IHRlbXBQcm9qZWN0LmFkZCh0b2RvKSk7XG4gICAgICAgIHN3aXRjaFByb2plY3QodGVtcFByb2plY3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcHJvamVjdCBpcyBlbXB0eSBhbmQgc2hvd3NcbiAgICAgKiBjYWxsIHRvIGFjdGlvbiBncmFwaGljcyBpZiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yRW1wdHlQcm9qZWN0KCkge1xuICAgICAgICB1aS5lbXB0eVBhbmVsLnJlbW92ZUNoaWxkKHVpLmVtcHR5UGFuZWwuZmlyc3RDaGlsZClcblxuICAgICAgICBpZighY3VycmVudFByb2plY3QuZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGluc2VydFN2ZyhzdmdzW1V0aWxzLnJhbmRNYXgoMCwgMildKVxuICAgICAgICAgICAgdWkuZW1wdHlQYW5lbC5pbnNlcnRCZWZvcmUoc3ZnLCB1aS5lbXB0eVBhbmVsLmZpcnN0Q2hpbGQpIFxuICAgICAgICAgICAgdWkuZW1wdHlQYW5lbHRleHQudGV4dENvbnRlbnQgPSBcIkxvb2tzIGxpa2UgdGhpcyBwcm9qZWN0IGlzIGVtcHR5LCBcXG4gbGV0J3Mgc3RhcnQgc29tZXRoaW5nIG5ldyFcIlxuXG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UHJvamVjdC5maWx0ZXJlZCAmJiBjdXJyZW50UHJvamVjdC5uYW1lID09PSBcInRvZGF5XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RTdmcgPSBpbnNlcnRTdmcoc3Znc1s0XSlcbiAgICAgICAgICAgIHVpLmVtcHR5UGFuZWwuaW5zZXJ0QmVmb3JlKHJlc3RTdmcsIHVpLmVtcHR5UGFuZWwuZmlyc3RDaGlsZCkgXG4gICAgICAgICAgICB1aS5lbXB0eVBhbmVsdGV4dC50ZXh0Q29udGVudCA9IFwiTm90aGluZyB0byBkbyBmb3IgdG9kYXkuIEVuam95IHNvbWUgcmVzdCFcIlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hTdmcgPSBpbnNlcnRTdmcoc3Znc1szXSlcbiAgICAgICAgICAgIHVpLmVtcHR5UGFuZWwuaW5zZXJ0QmVmb3JlKHNlYXJjaFN2ZywgdWkuZW1wdHlQYW5lbC5maXJzdENoaWxkKSBcbiAgICAgICAgICAgIHVpLmVtcHR5UGFuZWx0ZXh0LnRleHRDb250ZW50ID0gXCJDb3VsZG4ndCBmaW5kIGFueXRoaW5nIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyFcIlxuXG4gICAgICAgIH1cbiAgICAgICAgdWkuZW1wdHlQYW5lbC5zdHlsZS5kaXNwbGF5ID0gdWkudG9kb1ZpZXcuZmlyc3RDaGlsZCA/IFwibm9uZVwiIDogXCJmbGV4XCJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYW4gU1ZHIGdyYXBoaWMgaW4gdGhlIENvbnRlbnQgQXJlYSBpZiB0aGUgcHJvamVjdCBpcyBlbXB0eVxuICAgICAqIGJ5IGdldHRpbmcgdGhlIGltcG9ydGVkIDxzdmc+IGVsZW1lbnQgYW5kIHBhcnNpbmcgaXQgaW50byBhIG5ldyBIVE1MXG4gICAgICogZWxlbWVudCB0byBiZSBsYXRlciBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgICAqIEBwYXJhbSB7Kn0gc3ZnIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFN2ZyhzdmcpIHtcbiAgICAgICAgY29uc3Qgc3ZnSW1nID0gKG5ldyBET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKHN2ZywgXCJpbWFnZS9zdmcreG1sXCIpXG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBzdmdJbWcuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgIHN2Z0VsZW1lbnQuaWQgPSBcImVtcHR5SW1hZ2VcIlxuICAgICAgICBzdmdFbGVtZW50LnN0eWxlID0gZmFsc2U7IC8vIFJlc2V0cyBzdHlsZSBiZWNhdXNlIHRoZSBvcmlnaW5hbCBoYXMgYSBzdHlsZSBhdHRyXG4gICAgICAgIHJldHVybiBzdmdFbGVtZW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHZpZXdlZCBwcm9qZWN0IGlzIGEgdGVtcG9yYXJ5IFwiZmlsdGVyXCJcbiAgICAgKiBwcm9qZWN0IGFuZCBpbiB0aGF0IGNhc2UgZmlsdGVycyBhZ2FpbiB0byB1cGRhdGUgZGlzcGxheWVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0lmRmlsdGVyZWQoKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBjdXJyZW50UHJvamVjdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb2plY3QuZmlsdGVyZWQpKSB7XG4gICAgICAgICAgICByZW5kZXJGaWx0ZXJlZChwcm9qZWN0LmZpbHRlcmVkLmF0KDApLCBwcm9qZWN0LmZpbHRlcmVkWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGR5bmFtaWMgVUkgZWxlbWVudHMgbGlrZSBjb3VudGVycyBhbmQgcGFubGUgdGhhdCBzaG91bGQgYmVcbiAgICAgKiBoaWRkZW4gb3IgdmlzaWJpbGUgYmFzZWQgb24gVG9kbyBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIFNpZGViYXIudXBkYXRlVG9kYXlUb2RvcygpO1xuICAgICAgICBTaWRlYmFyLnNob3dQcm9qZWN0cygpO1xuICAgICAgICBjaGVja0ZvckVtcHR5UHJvamVjdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbiBvdmVybGF5IHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSBjbGlja2luZyBhbnl0aGluZyB3aGlsZSBmb3Jtc1xuICAgICAqIGFyZSBvcGVuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZU92ZXJsYXkoKSB7XG4gICAgICAgIHVpLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IHVpLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9PT0gXCJibG9ja1wiID8gXCJub25lXCIgOiBcImJsb2NrXCJcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRDdXJyZW50UHJvamVjdCxcbiAgICAgICAgZ2V0Q3VycmVudFByb2plY3QsXG4gICAgICAgIHJlbmRlclByb2plY3QsXG4gICAgICAgIHN3aXRjaFByb2plY3QsXG4gICAgICAgIHJlbmRlckZpbHRlcmVkLFxuICAgICAgICBjaGVja0ZvckVtcHR5UHJvamVjdCxcbiAgICAgICAgY2hlY2tJZkZpbHRlcmVkLFxuICAgICAgICBjbGVhclRvZG9WaWV3LFxuICAgICAgICB0b2dnbGVPdmVybGF5LCAgIFxuICAgICAgICB1cGRhdGVcbiAgICB9XG59KSgpO1xuIiwiaW1wb3J0IFRvZG8gZnJvbSBcIi4vdG9kb1wiO1xuaW1wb3J0IFByb2plY3QgZnJvbSBcIi4vcHJvamVjdFwiO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5cbmV4cG9ydCBjbGFzcyBMb2dpYyB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxuXG4gICAgLy8gSW1wbGVtZW50aW5nIHNpbmdsZXRvbiBwYXR0ZXJuXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIUxvZ2ljLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBMb2dpYy5pbnN0YW5jZSA9IG5ldyBMb2dpYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb2dpYy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRvZG8gaXRlbSB3aXRoIHRoZSBkYXRhIGV4dHJhY3RlZCBmcm9tIHRoZVxuICAgICAqIFVJIGZpZWxkcyBwYXNzZWQgYXMgYW4gb2JqZWN0LiBJdCBhbHNvIGNhbGxzIHRoZSBUb2RvXG4gICAgICogY29uc3RydWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgVG9kbyBiZWxvbmdzIHRvIGFuIGV4aXN0aW5nXG4gICAgICogcHJvamVjdCwgaW4gdGhhdCBjYXNlIGl0IHB1c2hlcyBpdCBpbiBpdHMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcGVydGllcyB7dGl0bGUsIGRlc2NyaXB0aW9uLCBkdWVEYXRlLCBwcmlvcml0eX1cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3QgRGVmYXVsdHMgdG8gJ2dlbmVyYWwnIGZvciBub24gY2F0ZWdvcml6ZWQgVG9kb3MuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVRvZG8odG9kb1Byb3BlcnRpZXMsIHByb2plY3QpIHtcbiAgICAgICAgY29uc3QgbmV3VG9kbyA9IG5ldyBUb2RvKFxuICAgICAgICAgICAgdG9kb1Byb3BlcnRpZXMudGl0bGUsXG4gICAgICAgICAgICB0b2RvUHJvcGVydGllcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHRvZG9Qcm9wZXJ0aWVzLmR1ZURhdGUsXG4gICAgICAgICAgICB0b2RvUHJvcGVydGllcy5wcmlvcml0eSxcbiAgICAgICAgICAgIHRvZG9Qcm9wZXJ0aWVzLnByb2plY3RJRFxuICAgICAgICApO1xuXG4gICAgICAgIHByb2plY3QuYWRkKG5ld1RvZG8pO1xuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICBgQ3JlYXRlZCB0b2RvICcke25ld1RvZG8udGl0bGV9Jy4gQWRkZWQgdG8gcHJvamVjdCAnJHtwcm9qZWN0Lm5hbWV9Jy5gXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1RvZG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgcHJvdmlkZWQgVG9kbyBlbGVtZW50IGZyb20gdGhlIFByb2plY3QgYXJyYXkuXG4gICAgICogQ2hlY2tzIGZvciBUb2RvIGV4aXN0ZW5jZSBpbnNpZGUgUHJvamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3RcbiAgICAgKiBAcGFyYW0geyp9IHRvZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlVG9kbyhwcm9qZWN0LCB0b2RvKSB7XG4gICAgICAgIGlmICghcHJvamVjdC5oYXNUb2RvKHRvZG8pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhUb0RlbGV0ZSA9IHByb2plY3QudG9kb3MuZmluZEluZGV4KFxuICAgICAgICAgICAgKHQpID0+IHQuZ2V0VWlkKCkgPT09IHRvZG8uZ2V0VWlkKClcbiAgICAgICAgKTtcbiAgICAgICAgcHJvamVjdC50b2Rvcy5zcGxpY2UoaW5kZXhUb0RlbGV0ZSwgMSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgIGBEZWxldGVkIHRvZG8gJyR7dG9kby50aXRsZX0nIGZyb20gcHJvamVjdCAnJHtwcm9qZWN0Lm5hbWV9Jy5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWRpdHMgdGhlIHBhc3NlZCBwcm9wZXJ0eSByZXBsYWNpbmcgaXRzIHZhbHVlIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICAgKiBDaGVja3MgaWYgdGhlIHRvZG8gYmVsb25ncyB0byB0aGUgcHJvamVjdCBhbmQgaWYgdGhlIHByb3BlcnR5IGlzXG4gICAgICogb25lIG9mIHRoZSBUb2RvIHR5cGUuXG4gICAgICogQHBhcmFtIHsqfSBwcm9qZWN0XG4gICAgICogQHBhcmFtIHsqfSB0b2RvXG4gICAgICogQHBhcmFtIHsqfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgZWRpdGVkIHRvZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgZWRpdFRvZG8ocHJvamVjdCwgdG9kbywgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmICghcHJvamVjdC5oYXNUb2RvKHRvZG8pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNoZWNrIGlmIHByb2plY3QgaGFzIHRvZG9cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBwcm9qZWN0LnRvZG9zLmZpbmQoXG4gICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5nZXRVaWQoKSA9PT0gdG9kby5nZXRVaWQoKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiB0b2RvKSB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgIGBFZGl0ZWQgdG9kbyAnJHt0b2RvLnRpdGxlfScgaW5zaWRlIHByb2plY3QgJyR7cHJvamVjdC5uYW1lfS4nICgnJHtwcm9wZXJ0eX06IG9sZDogJHtvbGRWYWx1ZX0gbmV3OiR7dmFsdWV9JylgXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgVG9kbyBvYmplY3QgZnJvbSBzb3VyY2UgcHJvamVjdCB0byB0YXJnZXQgcHJvamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSB0b2RvXG4gICAgICovXG4gICAgc3RhdGljIG1vdmVUb2RvKHNvdXJjZSwgdGFyZ2V0LCB0b2RvKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBTdG9yZS5sb2FkUHJvamVjdChzb3VyY2UpO1xuICAgICAgICBjb25zdCB0byA9IFN0b3JlLmxvYWRQcm9qZWN0KHRhcmdldCk7XG5cbiAgICAgICAgdGhpcy5kZWxldGVUb2RvKGZyb20sIHRvZG8pO1xuICAgICAgICBTdG9yZS5zYXZlUHJvamVjdChmcm9tKTtcblxuICAgICAgICB0by5hZGQodG9kbyk7XG4gICAgICAgIFN0b3JlLnNhdmVQcm9qZWN0KHRvKTtcblxuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICBgTW92ZWQgdG9kbyAke3RvZG8udGl0bGV9IGZyb20gJyR7ZnJvbS5uYW1lfSB0byAnJHt0by5uYW1lfSdgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBhIFByb2plY3QuIENoZWNrc1xuICAgICAqIGlmIHRoZSBwcm9qZWN0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBzdG9yYWdlLlxuICAgICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUgbmV3IFByb2plY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvamVjdChuYW1lLCBkZXNjcmlwdGlvbiwgY29sb3IpIHtcbiAgICAgICAgY29uc3QgbmV3UHJvamVjdCA9IG5ldyBQcm9qZWN0KG5hbWUsIGRlc2NyaXB0aW9uLCBjb2xvcik7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgQ3JlYXRlZCBwcm9qZWN0ICcke25hbWV9Jy5gKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb2plY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZ2l2ZW4gcHJvamVjdCBmcm9tIHN0b3JhZ2UuIERlbGVnYXRlcyB0b1xuICAgICAqIHRoZSBTdG9yZSBjb21wb25lbnQgdGhlIGVmZmVjdGl2ZSByZW1vdmluZyBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVQcm9qZWN0KHVpZCkge1xuICAgICAgICBpZiAoIVN0b3JlLmRvUHJvamVjdEV4aXN0QnlJZCh1aWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmUucmVtb3ZlUHJvamVjdCh1aWQpO1xuICAgICAgICBjb25zb2xlLmluZm8oYERlbGV0ZWQgcHJvamVjdCAnJHt1aWR9Jy5gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGRldGFpbHMgYWJvdXQgdGhlIGdpdmVuIHByb2plY3QgYnkgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogYW5kIGNhbGxpbmcgdGhlIHJpZ2h0IHNldHRlcnMuIENoZWNrcyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGluc2lkZVxuICAgICAqIHRoZSBnaXZlbiBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gcHJvamVjdFxuICAgICAqIEBwYXJhbSB7Kn0gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgZWRpdFByb2plY3QocHJvamVjdCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChTdG9yZS5kb1Byb2plY3RFeGlzdEJ5SWQocHJvamVjdC5nZXRVaWQoKSkpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gXCJ0b2Rvc1wiICYmIHByb3BlcnR5IGluIHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHByb2plY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIHByb2plY3RbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIGBFZGl0ZWQgcHJvamVjdCAnJHtwcm9qZWN0Lm5hbWV9LicgKCcke3Byb3BlcnR5fTogb2xkOiAke29sZFZhbHVlfSBuZXc6JHt2YWx1ZX0nKWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGFjY2VzcyBwcm9wZXJ0eSAnJHtwcm9wZXJ0eX0nIG9mIHByb2plY3QgJyR7cHJvamVjdC5uYW1lfScuYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBQcm9qZWN0ICcke3Byb2plY3QubmFtZX0nIGRvZXMgbm90IGV4aXN0IGluIHN0b3JhZ2UuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSAnZ2VuZXJhbCcgcHJvamVjdCBhdCBzdGFydHVwIHRvIGNvbnRhaW4gYW5kIHNlcnZlXG4gICAgICogdG9kb3MgdGhhdCBkbyBub3QgYmVsb25nIHRvIGEgbmFtZWQgcHJvamVjdC4gQ3JlYXRzIHRoZSBkZWZhdWx0XG4gICAgICogcHJvamVjdCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdERlZmF1bHRQcm9qZWN0KCkge1xuICAgICAgICBsZXQgZ2VuZXJhbCA9IFN0b3JlLmxvYWRQcm9qZWN0KFwiYWFhMDAwXCIpO1xuXG4gICAgICAgIGlmICghZ2VuZXJhbCkge1xuICAgICAgICAgICAgZ2VuZXJhbCA9IHRoaXMuY3JlYXRlUHJvamVjdChcbiAgICAgICAgICAgICAgICBcImdlbmVyYWxcIixcbiAgICAgICAgICAgICAgICBcIkNvbnRhaW5lciBwcm9qZWN0IGZvciB1bmNhdGVnb3JpemVkIHRvZG9zLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgU3RvcmUuc2F2ZVByb2plY3QoZ2VuZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYWw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IFRvZG8gZnJvbSBcIi4vdG9kby5qc1wiO1xuXG4vKipcbiAqXG4gKiBBIFByb2plY3QgaXMgYSBjb2xsZWN0aW9uIG9mIHRvZG9zIHRoYXQgc2hhcmUgYSBjb21tb25cbiAqIGVuZCBnb2FsLiBJdCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBncm91cGluZyBhbmRcbiAqIHRyYWNraW5nIG11bHRpcGxlIHRvZG9zIGF0IG9uY2UuXG4gKiBJdCBjb21lcyB3aXRoIG1ldGhvZHMgZm9yIHNlcmlhbGl6aW5nIGFuZCBwYXJzaW5nIGl0c2VsZiBmcm9tIEpTT04uXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkZXNjcmlwdGlvbiwgdWljb2xvciA9IFwiYmxhY2tcIiwgZmlsdGVyZWQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnVpY29sb3IgPSB1aWNvbG9yO1xuICAgICAgICB0aGlzLmZpbHRlcmVkID0gZmlsdGVyZWQ7XG4gICAgICAgIHRoaXMuI3VpZCA9IChuYW1lID09PSBcImdlbmVyYWxcIikgPyBcImFhYTAwMFwiICA6IFV0aWxzLmdlbmVyYXRlSGV4SWQoKVxuICAgIH1cblxuICAgIC8qKiBQcm9qZWN0IGNsYXNzIGZpZWxkcyAqL1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIHRvZG9zIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgcHJvamVjdC5cbiAgICAgKi9cbiAgICB0b2RvcyA9IFtdO1xuXG4gICAgI3VpZDtcblxuICAgIC8qKiBVTlVTRUQ/XG4gICAgICogRmxhZyB0byBjaGVjayB3aGV0aGVyIHRoZSBwcm9qZWN0IGlzIHBlbmRpbmcgb3IgY29tcGxldGUuXG4gICAgICovXG4gICAgY29tcGxldGUgPSBmYWxzZTtcblxuICAgIC8vI3JlZ2lvbiBHZXR0ZXJzIGFuZCBTZXR0ZXJzXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIGlmIChVdGlscy5pc1ZhbGlkU3RyaW5nKFwibmFtZVwiLCB2YWx1ZSkpIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdWljb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpY29sb3I7XG4gICAgfVxuXG4gICAgc2V0IHVpY29sb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdWljb2xvciA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldFVpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3VpZFxuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBQcm9qZWN0IG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEZsaXBzIHRoZSAnY29tcGxldGUnIHByb2plY3QgZmxhZy5cbiAgICAgKi9cbiAgICB0b2dnbGVTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSB0aGlzLmNvbXBsZXRlID09PSB0cnVlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGhhc1RvZG8odG9kbykge1xuICAgICAgICBpZiAoIXRoaXMudG9kb3MuZmluZCgoaXRlbSkgPT4gaXRlbS5nZXRVaWQoKSA9PT0gdG9kby5nZXRVaWQoKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRvZG8gaXMgbm90IGluc2lkZSBwcm9qZWN0ICcke3RoaXMubmFtZX0nLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VzIGNvbnRyb2wgb2Ygc2VyaWFsaXphdGlvbiBwcm9jZXNzIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHNhdmVkXG4gICAgICogcHJvamVjdHMgY2FuIGJlIHJlaW5zdGFudGlhdGVkIHNtb290aGx5IHdoaWxlIHByZXNlcnZpbmcgZ2V0dGVyIGFuZFxuICAgICAqIHNldHRlciBhcmNoaXRlY3R1cmUgYW5kIHByaXZhdGUgdmFyaWFibGVzLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLl9kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHRvZG9zOiB0aGlzLnRvZG9zLFxuICAgICAgICAgICAgY29tcGxldGU6IHRoaXMuY29tcGxldGUsXG4gICAgICAgICAgICB1aWNvbG9yOiB0aGlzLl91aWNvbG9yLFxuICAgICAgICAgICAgdWlkOiB0aGlzLiN1aWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBQcm9qZWN0IGluc3RhbmNlIGZyb20gSlNPTiBvbmNlIGxvYWRlZCBmcm9tXG4gICAgICogc3RvcmFnZS4gQWxzbyByZS1pbnN0YW50aWF0ZXMgdGhlIFRvZG9zIGluc2lkZSBvZiB0aGUgdG9kb3MgYXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgY29uc3QgcHJvamVjdCA9IG5ldyBQcm9qZWN0KG9iai5uYW1lLCBvYmouZGVzY3JpcHRpb24sIG9iai51aWNvbG9yKTtcblxuICAgICAgICBpZiAob2JqLmNvbXBsZXRlKSBwcm9qZWN0LnRvZ2dsZVN0YXR1cygpO1xuXG4gICAgICAgIG9iai50b2Rvcy5mb3JFYWNoKCh0b2RvKSA9PiB7XG4gICAgICAgICAgICBwcm9qZWN0LnRvZG9zLnB1c2goVG9kby5mcm9tSlNPTihKU09OLnN0cmluZ2lmeSh0b2RvKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9qZWN0LiN1aWQgPSBvYmoudWlkXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG5cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBNdWx0aXBsZSB0b2RvcyBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIEdldHRlciBtZXRob2QgZm9yIHRoZSBsaXN0IG9mIHRvZG9zLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0VG9kb3NMaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2RvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBkZXNpcmVkIFRvZG8gaXRlbSB0byB0aGUgcHJvamVjdCBjb2xsZXRpb24uXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgcGFzc2VkIGFzIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlXG4gICAgICogb2YgYSBUb2RvLlxuICAgICAqIEBwYXJhbSB7Kn0gdG9kb1xuICAgICAqL1xuICAgIGFkZCh0b2RvKSB7XG4gICAgICAgIGlmICh0b2RvIGluc3RhbmNlb2YgVG9kbykge1xuICAgICAgICAgICAgdGhpcy50b2Rvcy5wdXNoKHRvZG8pO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGBBZGRlZCB0b2RvICR7dG9kby50aXRsZX0gdG8gcHJvamVjdCAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSBpdGVtICR7dG9kby50aXRsZX0gaXMgbm90IGEgdmFsaWQgVG9kbyBpbnN0YW5jZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8jZW5kcmVnaW9uXG59XG4iLCJpbXBvcnQgUHJvamVjdCBmcm9tIFwiLi9wcm9qZWN0XCI7XG5cbmV4cG9ydCBjbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxuXG4gICAgLy8jcmVnaW9uIEltcGxlbWVudGluZyBzaW5nbGV0b24gcGF0dGVyblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCFTdG9yYWdlLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBTdG9yYWdlLmluc3RhbmNlID0gbmV3IFN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0b3JhZ2UuaW5zdGFuY2U7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBwcm9qZWN0IGluIGxvY2FsU3RvcmFnZSB1c2luZyB0aGUgbG9jYWxTdG9yYWdlIEFQSS5cbiAgICAgKiBAcGFyYW0geyp9IHByb2plY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgc2F2ZVByb2plY3QocHJvamVjdCkge1xuICAgICAgICBpZiAocHJvamVjdCBpbnN0YW5jZW9mIFByb2plY3QpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHByb2plY3QuZ2V0VWlkKCksIEpTT04uc3RyaW5naWZ5KHByb2plY3QpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgU2F2ZWQgcHJvamVjdCAke3Byb2plY3QubmFtZX0gaW4gc3RvcmFnZS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgcHJvamVjdCBieSBuYW1lIGZyb20gbG9jYWxTdG9yYWdlIGFuZCBwYXJzZXMgaXRzXG4gICAgICogZGF0YSB0byByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgUHJvamVjdCBjbGFzcyB3aXRoIHRoZSBzdG9yZWRcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBwcm9qZWN0TmFtZVxuICAgICAqIEByZXR1cm5zIGEgUHJvamVjdCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkUHJvamVjdCh1aWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvUHJvamVjdEV4aXN0QnlJZCh1aWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9qZWN0ID0gUHJvamVjdC5mcm9tSlNPTihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh1aWQpKTtcbiAgICAgICAgY29uc29sZS5pbmZvKGBMb2FkZWQgcHJvamVjdCAke3Byb2plY3QubmFtZX0gZnJvbSBzdG9yYWdlLmApO1xuXG4gICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCB0b2RvcyBmcm9tIGV2ZXJ5IHByb2plY3QgcHJlc2VudCBpbiBtZW1vcnkgdG8gbGV0XG4gICAgICogdGhlIHVzZXIgaW50ZXJhY3Qgd2l0aCBjb2xsZWN0aW9uIG9mIGFsbCB0YXNrcyB3aXRob3V0IGhhdmluZ1xuICAgICAqIHRvIHRyYXZlcnNlIGFsbCBwcm9qZWN0cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZEFsbFRvZG9zKCkge1xuICAgICAgICBsZXQgYWxsVG9kb3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9qZWN0IG9mIE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZFByb2plY3QgPSB0aGlzLmxvYWRQcm9qZWN0KHByb2plY3QpO1xuICAgICAgICAgICAgYWxsVG9kb3MucHVzaCguLi5sb2FkZWRQcm9qZWN0LmdldFRvZG9zTGlzdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGxUb2RvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGxvY2FsU3RvcmFnZSBBUEkgdG8gcmVtb3ZlIGEgcHJvamVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHVpZFxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVQcm9qZWN0KHVpZCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1aWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvb2sgdXAgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBwcm9qZWN0IGFscmVhZHkgZXhpc3RzIGluIHN0b3JhZ2UuXG4gICAgICogQHBhcmFtIHsqfSBwcm9qZWN0TmFtZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGRvUHJvamVjdEV4aXN0QnlJZCh1aWQpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh1aWQpO1xuICAgICAgICBpZiAoIWNoZWNrKSBjb25zb2xlLmluZm8oYFByb2plY3QgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgIHJldHVybiBjaGVjaztcbiAgICB9XG59XG4iLCJjb25zdCB7IGlzRGF0ZSwgZm9ybWF0IH0gPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gXCIuL3N0b3JhZ2UuanNcIjtcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIFRvZG8gaXRlbTogc3RvcmVzIGFsbCBkYXRhIHJlbGF0ZWQgdG8gdGhlXG4gKiB0b2RvIGluY2x1ZGluZyB1bmlxdWllIElELCB0aWxlLCBkZXNjcmlwdGlvbiwgZHVlIGRhdGUgYW5kIHByaW9yaXR5LlxuICogSGFzIGEgcHJpdmF0ZSBzdGF0dXMgZmllbGQgdGhhdCBjb250cm9sIHdoZXRlciB0aGUgdGFzayBpcyBkb25lLlxuICogSXQgY29tZXMgd2l0aCBtZXRob2RzIGZvciBzZXJpYWxpemluZyBhbmQgcGFyc2luZyBpdHNlbGYgZnJvbSBKU09OLlxuICogQHBhcmFtIHRpdGxlXG4gKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAqIEBwYXJhbSBkdWVEYXRlXG4gKiBAcGFyYW0gcHJpb3JpdHlcbiAqIEBwYXJhbSBwcm9qZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvZG8ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGR1ZURhdGUgPSBuZXcgRGF0ZSgpLFxuICAgICAgICBwcmlvcml0eSA9IFwiNFwiLFxuICAgICAgICBwcm9qZWN0SUQgPSBcImFhYTAwMFwiXG4gICAgKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmR1ZURhdGUgPSBmb3JtYXQobmV3IERhdGUoZHVlRGF0ZSksIFwiZCBNTU0geXl5eVwiKTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0SUQ7XG4gICAgfVxuXG4gICAgI3VpZCA9IFV0aWxzLmdlbmVyYXRlSGV4SWQoKTtcblxuICAgIC8qKiBDaGVja3Mgd2hldGVyIHRoZSB0YXNrIGlzIGRvbmUuICovXG4gICAgI2RvbmUgPSBmYWxzZTtcblxuICAgIC8vI3JlZ2lvbiBHZXR0ZXJzIGFuZCBTZXR0ZXJzXG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGU7XG4gICAgfVxuXG4gICAgc2V0IHRpdGxlKHZhbHVlKSB7XG4gICAgICAgIGlmIChVdGlscy5pc1ZhbGlkU3RyaW5nKFwidGl0bGVcIiwgdmFsdWUpKSB0aGlzLl90aXRsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHNldCBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGR1ZURhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kdWVEYXRlO1xuICAgIH1cblxuICAgIHNldCBkdWVEYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2R1ZURhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgICB9XG5cbiAgICBzZXQgcHJpb3JpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcHJvamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3Q7XG4gICAgfVxuXG4gICAgc2V0IHByb2plY3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJvamVjdCA9IFN0b3JlLmRvUHJvamVjdEV4aXN0QnlJZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX3Byb2plY3Q7XG4gICAgfVxuXG4gICAgZ2V0VWlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdWlkO1xuICAgIH1cblxuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2RvbmU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIEluc3RhbmNlIE1ldGhvZHNcbiAgICB0b2dnbGVTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuI2RvbmUgPSB0aGlzLiNkb25lID09PSB0cnVlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VzIGNvbnRyb2wgb2Ygc2VyaWFsaXphdGlvbiBwcm9jZXNzIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHNhdmVkXG4gICAgICogdG9kbyBjYW4gYmUgcmVpbnN0YW50aWF0ZWQgc21vb3RobHkgd2hpbGUgcHJlc2VydmluZyB0aGUgZ2V0dGVyIGFuZFxuICAgICAqIHNldHRlciBhcmNoaXRjdHVyZSBhbmQgcHJpdmF0ZSB2YXJpYWJsZXMuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1aWQ6IHRoaXMuI3VpZCxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLl90aXRsZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLl9kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGR1ZURhdGU6IHRoaXMuX2R1ZURhdGUsXG4gICAgICAgICAgICBwcmlvcml0eTogdGhpcy5fcHJpb3JpdHksXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgICAgZG9uZTogdGhpcy4jZG9uZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBUb2RvIGluc3RhbmNlIGZyb20gSlNPTiBvbmNlIGxvYWRlZCBmcm9tXG4gICAgICogc3RvcmFnZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBjb25zdCB0b2RvID0gbmV3IFRvZG8oXG4gICAgICAgICAgICBvYmoudGl0bGUsXG4gICAgICAgICAgICBvYmouZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBvYmouZHVlRGF0ZSxcbiAgICAgICAgICAgIG9iai5wcmlvcml0eSxcbiAgICAgICAgICAgIG9iai5wcm9qZWN0XG4gICAgICAgICk7XG4gICAgICAgIHRvZG8uI2RvbmUgPSBvYmouZG9uZTtcbiAgICAgICAgdG9kby4jdWlkID0gb2JqLnVpZDtcbiAgICAgICAgcmV0dXJuIHRvZG87XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxufVxuIiwiLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXNlZnVsIG1ldGhvZCB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBkaWZmZXJlbnRcbiAqIGNvbXBvbmVudHMgb2YgdGhlIEFwcCBidXQgZG8gbm90IGJlbG9uZyB0byBhIHNpbmdsZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxuXG4gICAgLy8gSW1wbGVtZW50aW5nIHNpbmdsZXRvbiBwYXR0ZXJuXG4gICAgc3RhdGljIGdldFV0aWxzSW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghVXRpbGl0eS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgVXRpbGl0eS5pbnN0YW5jZSA9IG5ldyBVdGlsaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxpdHkuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXRob2QgdG8gY2hlY2sgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyB2YWx1ZSBpcyBhXG4gICAgICogdmFsaWQgaW5wdXQgZm9yIHRoZSBwcm9wZXJ0eSB0aGUgdXNlciBpcyBlZGl0aW5nLlxuICAgICAqIEBwYXJhbSB7Kn0gZmllbGRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWRTdHJpbmcoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoL1xcUy8udGVzdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgVmFsdWUgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIGlucHV0IGZvciBmaWVsZCBcIiR7ZmllbGROYW1lfVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIGhleGFkZWNpbWFsIGlkZW50aWZpZXIuXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlSGV4SWQocHJvaikge1xuICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmROID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpO1xuICAgICAgICAgICAgaGV4ICs9IHJhbmROLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlucHV0IHRleHQgdG8gVGl0bGUgQ2FzZS5cbiAgICAgKiBAcGFyYW0geyp9IHRleHRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyB0b1RpdGxlQ2FzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICAgIC5tYXAoKHdvcmQpID0+IHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyByYW5kTWF4KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhZGRMZWFkaW5nWmVyb3MobnVtYmVyLCB0YXJnZXRMZW5ndGgpIHtcbiAgY29uc3Qgc2lnbiA9IG51bWJlciA8IDAgPyBcIi1cIiA6IFwiXCI7XG4gIGNvbnN0IG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKS5wYWRTdGFydCh0YXJnZXRMZW5ndGgsIFwiMFwiKTtcbiAgcmV0dXJuIHNpZ24gKyBvdXRwdXQ7XG59XG4iLCJsZXQgZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWZhdWx0T3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gIGRlZmF1bHRPcHRpb25zID0gbmV3T3B0aW9ucztcbn1cbiIsImltcG9ydCB7IGdldERheU9mWWVhciB9IGZyb20gXCIuLi8uLi9nZXREYXlPZlllYXIubWpzXCI7XG5pbXBvcnQgeyBnZXRJU09XZWVrIH0gZnJvbSBcIi4uLy4uL2dldElTT1dlZWsubWpzXCI7XG5pbXBvcnQgeyBnZXRJU09XZWVrWWVhciB9IGZyb20gXCIuLi8uLi9nZXRJU09XZWVrWWVhci5tanNcIjtcbmltcG9ydCB7IGdldFdlZWsgfSBmcm9tIFwiLi4vLi4vZ2V0V2Vlay5tanNcIjtcbmltcG9ydCB7IGdldFdlZWtZZWFyIH0gZnJvbSBcIi4uLy4uL2dldFdlZWtZZWFyLm1qc1wiO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1plcm9zIH0gZnJvbSBcIi4uL2FkZExlYWRpbmdaZXJvcy5tanNcIjtcbmltcG9ydCB7IGxpZ2h0Rm9ybWF0dGVycyB9IGZyb20gXCIuL2xpZ2h0Rm9ybWF0dGVycy5tanNcIjtcblxuY29uc3QgZGF5UGVyaW9kRW51bSA9IHtcbiAgYW06IFwiYW1cIixcbiAgcG06IFwicG1cIixcbiAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgbm9vbjogXCJub29uXCIsXG4gIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gIGV2ZW5pbmc6IFwiZXZlbmluZ1wiLFxuICBuaWdodDogXCJuaWdodFwiLFxufTtcblxuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8gIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHAhIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgIHwgIFAhIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgIHxcbiAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAqIHwgIHogIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgZm9ybWF0YCBkb2NzKVxuICogLSBgaWAgaXMgSVNPIGRheSBvZiB3ZWVrLiBGb3IgYGlgIGFuZCBgaWlgIGlzIHJldHVybnMgbnVtZXJpYyBJU08gd2VlayBkYXlzLFxuICogICBpLmUuIDcgZm9yIFN1bmRheSwgMSBmb3IgTW9uZGF5LCBldGMuXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXG4gKiAtIGBSYCBpcyBJU08gd2Vlay1udW1iZXJpbmcgeWVhciwgYXMgb3Bwb3NlZCB0byBgWWAgd2hpY2ggaXMgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqICAgYFJgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgSWAgYW5kIGBpYFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXG4gKiAgIGBZYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdgIGFuZCBgZWBcbiAqICAgZm9yIHdlZWstbnVtYmVyaW5nIGRhdGUgc3BlY2lmaWMgdG8gdGhlIGxvY2FsZS5cbiAqIC0gYFBgIGlzIGxvbmcgbG9jYWxpemVkIGRhdGUgZm9ybWF0XG4gKiAtIGBwYCBpcyBsb25nIGxvY2FsaXplZCB0aW1lIGZvcm1hdFxuICovXG5cbmV4cG9ydCBjb25zdCBmb3JtYXR0ZXJzID0ge1xuICAvLyBFcmFcbiAgRzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGVyYSA9IGRhdGUuZ2V0RnVsbFllYXIoKSA+IDAgPyAxIDogMDtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBBRCwgQkNcbiAgICAgIGNhc2UgXCJHXCI6XG4gICAgICBjYXNlIFwiR0dcIjpcbiAgICAgIGNhc2UgXCJHR0dcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHsgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIiB9KTtcbiAgICAgIC8vIEEsIEJcbiAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwgeyB3aWR0aDogXCJuYXJyb3dcIiB9KTtcbiAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG4gICAgICBjYXNlIFwiR0dHR1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHsgd2lkdGg6IFwid2lkZVwiIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICAvLyBPcmRpbmFsIG51bWJlclxuICAgIGlmICh0b2tlbiA9PT0gXCJ5b1wiKSB7XG4gICAgICBjb25zdCBzaWduZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcbiAgICAgIGNvbnN0IHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHllYXIsIHsgdW5pdDogXCJ5ZWFyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy55KGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaWduZWRXZWVrWWVhciA9IGdldFdlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xuICAgIC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG4gICAgY29uc3Qgd2Vla1llYXIgPSBzaWduZWRXZWVrWWVhciA+IDAgPyBzaWduZWRXZWVrWWVhciA6IDEgLSBzaWduZWRXZWVrWWVhcjtcblxuICAgIC8vIFR3byBkaWdpdCB5ZWFyXG4gICAgaWYgKHRva2VuID09PSBcIllZXCIpIHtcbiAgICAgIGNvbnN0IHR3b0RpZ2l0WWVhciA9IHdlZWtZZWFyICUgMTAwO1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0d29EaWdpdFllYXIsIDIpO1xuICAgIH1cblxuICAgIC8vIE9yZGluYWwgbnVtYmVyXG4gICAgaWYgKHRva2VuID09PSBcIllvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWtZZWFyLCB7IHVuaXQ6IFwieWVhclwiIH0pO1xuICAgIH1cblxuICAgIC8vIFBhZGRpbmdcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IGlzb1dlZWtZZWFyID0gZ2V0SVNPV2Vla1llYXIoZGF0ZSk7XG5cbiAgICAvLyBQYWRkaW5nXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBFeHRlbmRlZCB5ZWFyLiBUaGlzIGlzIGEgc2luZ2xlIG51bWJlciBkZXNpZ25hdGluZyB0aGUgeWVhciBvZiB0aGlzIGNhbGVuZGFyIHN5c3RlbS5cbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIGxvY2FsaXplcnMgYXJlIEIuQy4geWVhcnM6XG4gIC8vIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gIC8vIHwtLS0tLS18LS0tLS18LS0tLS18XG4gIC8vIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gIC8vIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gIC8vIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gIC8vIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAgLy8gd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkLlxuICB1OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBRdWFydGVyXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDMpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgY2FzZSBcIlFRXCI6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAgIGNhc2UgXCJRb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7IHVuaXQ6IFwicXVhcnRlclwiIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcbiAgICAgIGNhc2UgXCJRUVFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG4gICAgICBjYXNlIFwiUVFRUVFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG4gICAgICBjYXNlIFwiUVFRUVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0TW9udGgoKSArIDEpIC8gMyk7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuICAgICAgY2FzZSBcInFvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHsgdW5pdDogXCJxdWFydGVyXCIgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuICAgICAgY2FzZSBcInFxcVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcbiAgICAgIGNhc2UgXCJxcXFxcVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cbiAgICAgIGNhc2UgXCJxcXFxXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5NKGRhdGUsIHRva2VuKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAgIGNhc2UgXCJNb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHsgdW5pdDogXCJtb250aFwiIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG4gICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcobW9udGggKyAxKTtcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAgIGNhc2UgXCJMb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHsgdW5pdDogXCJtb250aFwiIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG4gICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gTG9jYWwgd2VlayBvZiB5ZWFyXG4gIHc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3ZWVrID0gZ2V0V2VlayhkYXRlLCBvcHRpb25zKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJ3b1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7IHVuaXQ6IFwid2Vla1wiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBJU08gd2VlayBvZiB5ZWFyXG4gIEk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBpc29XZWVrID0gZ2V0SVNPV2VlayhkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJJb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29XZWVrLCB7IHVuaXQ6IFwid2Vla1wiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwiZG9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXREYXRlKCksIHsgdW5pdDogXCJkYXRlXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5kKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhclxuICBEOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgZGF5T2ZZZWFyID0gZ2V0RGF5T2ZZZWFyKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSBcIkRvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRheU9mWWVhciwgeyB1bml0OiBcImRheU9mWWVhclwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF5T2ZZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJFRVwiOlxuICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJFRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcbiAgICAgIGNhc2UgXCJlZVwiOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuICAgICAgY2FzZSBcImVvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICBjYXNlIFwiZWVlXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiZWVlZWVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImVlZWVlZVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImVlZWVcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgY29uc3QgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG4gICAgICBjYXNlIFwiY2NcIjpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuICAgICAgY2FzZSBcImNvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImNjY2NjY1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGlzb0RheU9mV2VlayA9IGRheU9mV2VlayA9PT0gMCA/IDcgOiBkYXlPZldlZWs7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMlxuICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpc29EYXlPZldlZWspO1xuICAgICAgLy8gMDJcbiAgICAgIGNhc2UgXCJpaVwiOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb0RheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDJuZFxuICAgICAgY2FzZSBcImlvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb0RheU9mV2VlaywgeyB1bml0OiBcImRheVwiIH0pO1xuICAgICAgLy8gVHVlXG4gICAgICBjYXNlIFwiaWlpXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiaWlpaWlcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImlpaWlpaVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGNvbnN0IGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/IFwicG1cIiA6IFwiYW1cIjtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJhYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImFhYWFhXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImFhYWFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5taWRuaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJiXCI6XG4gICAgICBjYXNlIFwiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImJiYmJiXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImJiYmJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPj0gMTcpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmFmdGVybm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubW9ybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiQlwiOlxuICAgICAgY2FzZSBcIkJCXCI6XG4gICAgICBjYXNlIFwiQkJCXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQkJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQlwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSBcImhvXCIpIHtcbiAgICAgIGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuICAgICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDEyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5oKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSBcIkhvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0SG91cnMoKSwgeyB1bml0OiBcImhvdXJcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLkgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuXG4gICAgaWYgKHRva2VuID09PSBcIktvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gSG91ciBbMS0yNF1cbiAgazogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMjQ7XG5cbiAgICBpZiAodG9rZW4gPT09IFwia29cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gXCJtb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldE1pbnV0ZXMoKSwgeyB1bml0OiBcIm1pbnV0ZVwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMubShkYXRlLCB0b2tlbik7XG4gIH0sXG5cbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwic29cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRTZWNvbmRzKCksIHsgdW5pdDogXCJzZWNvbmRcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLnMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLlMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAodGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlpcIjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuICAgICAgY2FzZSBcIlhYWFhcIjpcbiAgICAgIGNhc2UgXCJYWFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxuICAgICAgY2FzZSBcIlhYWFhYXCI6XG4gICAgICBjYXNlIFwiWFhYXCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuICAgICAgY2FzZSBcInh4eHhcIjpcbiAgICAgIGNhc2UgXCJ4eFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxuICAgICAgY2FzZSBcInh4eHh4XCI6XG4gICAgICBjYXNlIFwieHh4XCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcIk9cIjpcbiAgICAgIGNhc2UgXCJPT1wiOlxuICAgICAgY2FzZSBcIk9PT1wiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJPT09PXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXRpb24pXG4gIHo6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcInpcIjpcbiAgICAgIGNhc2UgXCJ6elwiOlxuICAgICAgY2FzZSBcInp6elwiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJ6enp6XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAgVDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lU2hvcnQob2Zmc2V0LCBkZWxpbWl0ZXIgPSBcIlwiKSB7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQgPiAwID8gXCItXCIgOiBcIitcIjtcbiAgY29uc3QgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKTtcbiAgY29uc3QgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKTtcbiAgfVxuICByZXR1cm4gc2lnbiArIFN0cmluZyhob3VycykgKyBkZWxpbWl0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyhvZmZzZXQsIGRlbGltaXRlcikge1xuICBpZiAob2Zmc2V0ICUgNjAgPT09IDApIHtcbiAgICBjb25zdCBzaWduID0gb2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gICAgcmV0dXJuIHNpZ24gKyBhZGRMZWFkaW5nWmVyb3MoTWF0aC5hYnMob2Zmc2V0KSAvIDYwLCAyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkZWxpbWl0ZXIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRlbGltaXRlciA9IFwiXCIpIHtcbiAgY29uc3Qgc2lnbiA9IG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xuICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICBjb25zdCBob3VycyA9IGFkZExlYWRpbmdaZXJvcyhNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKSwgMik7XG4gIGNvbnN0IG1pbnV0ZXMgPSBhZGRMZWFkaW5nWmVyb3MoYWJzT2Zmc2V0ICUgNjAsIDIpO1xuICByZXR1cm4gc2lnbiArIGhvdXJzICsgZGVsaW1pdGVyICsgbWludXRlcztcbn1cbiIsImltcG9ydCB7IGFkZExlYWRpbmdaZXJvcyB9IGZyb20gXCIuLi9hZGRMZWFkaW5nWmVyb3MubWpzXCI7XG5cbi8qXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxuICovXG5cbmV4cG9ydCBjb25zdCBsaWdodEZvcm1hdHRlcnMgPSB7XG4gIC8vIFllYXJcbiAgeShkYXRlLCB0b2tlbikge1xuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfdG9rZW5zXG4gICAgLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxuICAgIC8vIHwtLS0tLS0tLS0tfC0tLS0tLS18LS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICAvLyB8IEFEIDEgICAgIHwgICAgIDEgfCAwMSB8ICAgMDAxIHwgIDAwMDEgfCAwMDAwMSB8XG4gICAgLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxuICAgIC8vIHwgQUQgMTIzICAgfCAgIDEyMyB8IDIzIHwgICAxMjMgfCAgMDEyMyB8IDAwMTIzIHxcbiAgICAvLyB8IEFEIDEyMzQgIHwgIDEyMzQgfCAzNCB8ICAxMjM0IHwgIDEyMzQgfCAwMTIzNCB8XG4gICAgLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxuXG4gICAgY29uc3Qgc2lnbmVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAvLyBSZXR1cm5zIDEgZm9yIDEgQkMgKHdoaWNoIGlzIHllYXIgMCBpbiBKYXZhU2NyaXB0KVxuICAgIGNvbnN0IHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRva2VuID09PSBcInl5XCIgPyB5ZWFyICUgMTAwIDogeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNb250aFxuICBNKGRhdGUsIHRva2VuKSB7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgcmV0dXJuIHRva2VuID09PSBcIk1cIiA/IFN0cmluZyhtb250aCArIDEpIDogYWRkTGVhZGluZ1plcm9zKG1vbnRoICsgMSwgMik7XG4gIH0sXG5cbiAgLy8gRGF5IG9mIHRoZSBtb250aFxuICBkKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldERhdGUoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBBTSBvciBQTVxuICBhKGRhdGUsIHRva2VuKSB7XG4gICAgY29uc3QgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF0ZS5nZXRIb3VycygpIC8gMTIgPj0gMSA/IFwicG1cIiA6IFwiYW1cIjtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgY2FzZSBcImFhYVwiOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlO1xuICAgICAgY2FzZSBcImFhYWFhXCI6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWVbMF07XG4gICAgICBjYXNlIFwiYWFhYVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZSA9PT0gXCJhbVwiID8gXCJhLm0uXCIgOiBcInAubS5cIjtcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91ciBbMS0xMl1cbiAgaChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRIb3VycygpICUgMTIgfHwgMTIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gSG91ciBbMC0yM11cbiAgSChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRIb3VycygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIE1pbnV0ZVxuICBtKGRhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldE1pbnV0ZXMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBTZWNvbmRcbiAgcyhkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRTZWNvbmRzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gRnJhY3Rpb24gb2Ygc2Vjb25kXG4gIFMoZGF0ZSwgdG9rZW4pIHtcbiAgICBjb25zdCBudW1iZXJPZkRpZ2l0cyA9IHRva2VuLmxlbmd0aDtcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIGNvbnN0IGZyYWN0aW9uYWxTZWNvbmRzID0gTWF0aC50cnVuYyhcbiAgICAgIG1pbGxpc2Vjb25kcyAqIE1hdGgucG93KDEwLCBudW1iZXJPZkRpZ2l0cyAtIDMpLFxuICAgICk7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmcmFjdGlvbmFsU2Vjb25kcywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbn07XG4iLCJjb25zdCBkYXRlTG9uZ0Zvcm1hdHRlciA9IChwYXR0ZXJuLCBmb3JtYXRMb25nKSA9PiB7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgXCJQXCI6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHsgd2lkdGg6IFwic2hvcnRcIiB9KTtcbiAgICBjYXNlIFwiUFBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJtZWRpdW1cIiB9KTtcbiAgICBjYXNlIFwiUFBQXCI6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy5kYXRlKHsgd2lkdGg6IFwibG9uZ1wiIH0pO1xuICAgIGNhc2UgXCJQUFBQXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJmdWxsXCIgfSk7XG4gIH1cbn07XG5cbmNvbnN0IHRpbWVMb25nRm9ybWF0dGVyID0gKHBhdHRlcm4sIGZvcm1hdExvbmcpID0+IHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSBcInBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoeyB3aWR0aDogXCJzaG9ydFwiIH0pO1xuICAgIGNhc2UgXCJwcFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcIm1lZGl1bVwiIH0pO1xuICAgIGNhc2UgXCJwcHBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgY2FzZSBcInBwcHBcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcImZ1bGxcIiB9KTtcbiAgfVxufTtcblxuY29uc3QgZGF0ZVRpbWVMb25nRm9ybWF0dGVyID0gKHBhdHRlcm4sIGZvcm1hdExvbmcpID0+IHtcbiAgY29uc3QgbWF0Y2hSZXN1bHQgPSBwYXR0ZXJuLm1hdGNoKC8oUCspKHArKT8vKSB8fCBbXTtcbiAgY29uc3QgZGF0ZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsxXTtcbiAgY29uc3QgdGltZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsyXTtcblxuICBpZiAoIXRpbWVQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcpO1xuICB9XG5cbiAgbGV0IGRhdGVUaW1lRm9ybWF0O1xuXG4gIHN3aXRjaCAoZGF0ZVBhdHRlcm4pIHtcbiAgICBjYXNlIFwiUFwiOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHsgd2lkdGg6IFwic2hvcnRcIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFwiOlxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHsgd2lkdGg6IFwibWVkaXVtXCIgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUFBQXCI6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUFBQUFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJmdWxsXCIgfSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBkYXRlVGltZUZvcm1hdFxuICAgIC5yZXBsYWNlKFwie3tkYXRlfX1cIiwgZGF0ZUxvbmdGb3JtYXR0ZXIoZGF0ZVBhdHRlcm4sIGZvcm1hdExvbmcpKVxuICAgIC5yZXBsYWNlKFwie3t0aW1lfX1cIiwgdGltZUxvbmdGb3JtYXR0ZXIodGltZVBhdHRlcm4sIGZvcm1hdExvbmcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsb25nRm9ybWF0dGVycyA9IHtcbiAgcDogdGltZUxvbmdGb3JtYXR0ZXIsXG4gIFA6IGRhdGVUaW1lTG9uZ0Zvcm1hdHRlcixcbn07XG4iLCJpbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi4vdG9EYXRlLm1qc1wiO1xuXG4vKipcbiAqIEdvb2dsZSBDaHJvbWUgYXMgb2YgNjcuMC4zMzk2Ljg3IGludHJvZHVjZWQgdGltZXpvbmVzIHdpdGggb2Zmc2V0IHRoYXQgaW5jbHVkZXMgc2Vjb25kcy5cbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxuICogYW5kIEdNVCswMTowMDowMCBhZnRlciB0aGF0IGRhdGUpXG4gKlxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcbiAqIHdoaWNoIHdvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSB0b0RhdGUoZGF0ZSk7XG4gIGNvbnN0IHV0Y0RhdGUgPSBuZXcgRGF0ZShcbiAgICBEYXRlLlVUQyhcbiAgICAgIF9kYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICBfZGF0ZS5nZXRNb250aCgpLFxuICAgICAgX2RhdGUuZ2V0RGF0ZSgpLFxuICAgICAgX2RhdGUuZ2V0SG91cnMoKSxcbiAgICAgIF9kYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgIF9kYXRlLmdldFNlY29uZHMoKSxcbiAgICAgIF9kYXRlLmdldE1pbGxpc2Vjb25kcygpLFxuICAgICksXG4gICk7XG4gIHV0Y0RhdGUuc2V0VVRDRnVsbFllYXIoX2RhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIHJldHVybiArZGF0ZSAtICt1dGNEYXRlO1xufVxuIiwiY29uc3QgZGF5T2ZZZWFyVG9rZW5SRSA9IC9eRCskLztcbmNvbnN0IHdlZWtZZWFyVG9rZW5SRSA9IC9eWSskLztcblxuY29uc3QgdGhyb3dUb2tlbnMgPSBbXCJEXCIsIFwiRERcIiwgXCJZWVwiLCBcIllZWVlcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBkYXlPZlllYXJUb2tlblJFLnRlc3QodG9rZW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiB3ZWVrWWVhclRva2VuUkUudGVzdCh0b2tlbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKHRva2VuLCBmb3JtYXQsIGlucHV0KSB7XG4gIGNvbnN0IF9tZXNzYWdlID0gbWVzc2FnZSh0b2tlbiwgZm9ybWF0LCBpbnB1dCk7XG4gIGNvbnNvbGUud2FybihfbWVzc2FnZSk7XG4gIGlmICh0aHJvd1Rva2Vucy5pbmNsdWRlcyh0b2tlbikpIHRocm93IG5ldyBSYW5nZUVycm9yKF9tZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gbWVzc2FnZSh0b2tlbiwgZm9ybWF0LCBpbnB1dCkge1xuICBjb25zdCBzdWJqZWN0ID0gdG9rZW5bMF0gPT09IFwiWVwiID8gXCJ5ZWFyc1wiIDogXCJkYXlzIG9mIHRoZSBtb250aFwiO1xuICByZXR1cm4gYFVzZSBcXGAke3Rva2VuLnRvTG93ZXJDYXNlKCl9XFxgIGluc3RlYWQgb2YgXFxgJHt0b2tlbn1cXGAgKGluIFxcYCR7Zm9ybWF0fVxcYCkgZm9yIGZvcm1hdHRpbmcgJHtzdWJqZWN0fSB0byB0aGUgaW5wdXQgXFxgJHtpbnB1dH1cXGA7IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZGA7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgY29uc3RhbnRzXG4gKiBAc3VtbWFyeSBVc2VmdWwgY29uc3RhbnRzXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbGxlY3Rpb24gb2YgdXNlZnVsIGRhdGUgY29uc3RhbnRzLlxuICpcbiAqIFRoZSBjb25zdGFudHMgY291bGQgYmUgaW1wb3J0ZWQgZnJvbSBgZGF0ZS1mbnMvY29uc3RhbnRzYDpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbWF4VGltZSwgbWluVGltZSB9IGZyb20gXCIuL2NvbnN0YW50cy9kYXRlLWZucy9jb25zdGFudHNcIjtcbiAqXG4gKiBmdW5jdGlvbiBpc0FsbG93ZWRUaW1lKHRpbWUpIHtcbiAqICAgcmV0dXJuIHRpbWUgPD0gbWF4VGltZSAmJiB0aW1lID49IG1pblRpbWU7XG4gKiB9XG4gKiBgYGBcbiAqL1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgZGF5c0luV2Vla1xuICogQHN1bW1hcnkgRGF5cyBpbiAxIHdlZWsuXG4gKi9cbmV4cG9ydCBjb25zdCBkYXlzSW5XZWVrID0gNztcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIGRheXNJblllYXJcbiAqIEBzdW1tYXJ5IERheXMgaW4gMSB5ZWFyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSG93IG1hbnkgZGF5cyBpbiBhIHllYXIuXG4gKlxuICogT25lIHllYXJzIGVxdWFscyAzNjUuMjQyNSBkYXlzIGFjY29yZGluZyB0byB0aGUgZm9ybXVsYTpcbiAqXG4gKiA+IExlYXAgeWVhciBvY2N1cmVzIGV2ZXJ5IDQgeWVhcnMsIGV4Y2VwdCBmb3IgeWVhcnMgdGhhdCBhcmUgZGl2aXNhYmxlIGJ5IDEwMCBhbmQgbm90IGRpdmlzYWJsZSBieSA0MDAuXG4gKiA+IDEgbWVhbiB5ZWFyID0gKDM2NSsxLzQtMS8xMDArMS80MDApIGRheXMgPSAzNjUuMjQyNSBkYXlzXG4gKi9cbmV4cG9ydCBjb25zdCBkYXlzSW5ZZWFyID0gMzY1LjI0MjU7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtYXhUaW1lXG4gKiBAc3VtbWFyeSBNYXhpbXVtIGFsbG93ZWQgdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbWF4VGltZSB9IGZyb20gXCIuL2NvbnN0YW50cy9kYXRlLWZucy9jb25zdGFudHNcIjtcbiAqXG4gKiBjb25zdCBpc1ZhbGlkID0gODY0MDAwMDAwMDAwMDAwMSA8PSBtYXhUaW1lO1xuICogLy89PiBmYWxzZVxuICpcbiAqIG5ldyBEYXRlKDg2NDAwMDAwMDAwMDAwMDEpO1xuICogLy89PiBJbnZhbGlkIERhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG1heFRpbWUgPSBNYXRoLnBvdygxMCwgOCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWluVGltZVxuICogQHN1bW1hcnkgTWluaW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IG1pblRpbWUgfSBmcm9tIFwiLi9jb25zdGFudHMvZGF0ZS1mbnMvY29uc3RhbnRzXCI7XG4gKlxuICogY29uc3QgaXNWYWxpZCA9IC04NjQwMDAwMDAwMDAwMDAxID49IG1pblRpbWU7XG4gKiAvLz0+IGZhbHNlXG4gKlxuICogbmV3IERhdGUoLTg2NDAwMDAwMDAwMDAwMDEpXG4gKiAvLz0+IEludmFsaWQgRGF0ZVxuICovXG5leHBvcnQgY29uc3QgbWluVGltZSA9IC1tYXhUaW1lO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5XZWVrXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSB3ZWVrLlxuICovXG5leHBvcnQgY29uc3QgbWlsbGlzZWNvbmRzSW5XZWVrID0gNjA0ODAwMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5EYXlcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIGRheS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbGxpc2Vjb25kc0luRGF5ID0gODY0MDAwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbk1pbnV0ZVxuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgbWludXRlXG4gKi9cbmV4cG9ydCBjb25zdCBtaWxsaXNlY29uZHNJbk1pbnV0ZSA9IDYwMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5Ib3VyXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBob3VyXG4gKi9cbmV4cG9ydCBjb25zdCBtaWxsaXNlY29uZHNJbkhvdXIgPSAzNjAwMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWlsbGlzZWNvbmRzSW5TZWNvbmRcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIHNlY29uZFxuICovXG5leHBvcnQgY29uc3QgbWlsbGlzZWNvbmRzSW5TZWNvbmQgPSAxMDAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luWWVhclxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIHllYXIuXG4gKi9cbmV4cG9ydCBjb25zdCBtaW51dGVzSW5ZZWFyID0gNTI1NjAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luTW9udGhcbiAqIEBzdW1tYXJ5IE1pbnV0ZXMgaW4gMSBtb250aC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbnV0ZXNJbk1vbnRoID0gNDMyMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW51dGVzSW5EYXlcbiAqIEBzdW1tYXJ5IE1pbnV0ZXMgaW4gMSBkYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBtaW51dGVzSW5EYXkgPSAxNDQwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbWludXRlc0luSG91clxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIGhvdXIuXG4gKi9cbmV4cG9ydCBjb25zdCBtaW51dGVzSW5Ib3VyID0gNjA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtb250aHNJblF1YXJ0ZXJcbiAqIEBzdW1tYXJ5IE1vbnRocyBpbiAxIHF1YXJ0ZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aHNJblF1YXJ0ZXIgPSAzO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgbW9udGhzSW5ZZWFyXG4gKiBAc3VtbWFyeSBNb250aHMgaW4gMSB5ZWFyLlxuICovXG5leHBvcnQgY29uc3QgbW9udGhzSW5ZZWFyID0gMTI7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBxdWFydGVyc0luWWVhclxuICogQHN1bW1hcnkgUXVhcnRlcnMgaW4gMSB5ZWFyXG4gKi9cbmV4cG9ydCBjb25zdCBxdWFydGVyc0luWWVhciA9IDQ7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5Ib3VyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgaG91ci5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJbkhvdXIgPSAzNjAwO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luTWludXRlXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgbWludXRlLlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luTWludXRlID0gNjA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5EYXlcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSBkYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5EYXkgPSBzZWNvbmRzSW5Ib3VyICogMjQ7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5XZWVrXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgd2Vlay5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJbldlZWsgPSBzZWNvbmRzSW5EYXkgKiA3O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luWWVhclxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIHllYXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5ZZWFyID0gc2Vjb25kc0luRGF5ICogZGF5c0luWWVhcjtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbk1vbnRoXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgbW9udGhcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJbk1vbnRoID0gc2Vjb25kc0luWWVhciAvIDEyO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luUXVhcnRlclxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIHF1YXJ0ZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5RdWFydGVyID0gc2Vjb25kc0luTW9udGggKiAzO1xuIiwiLyoqXG4gKiBAbmFtZSBjb25zdHJ1Y3RGcm9tXG4gKiBAY2F0ZWdvcnkgR2VuZXJpYyBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb25zdHJ1Y3RzIGEgZGF0ZSB1c2luZyB0aGUgcmVmZXJlbmNlIGRhdGUgYW5kIHRoZSB2YWx1ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGZ1bmN0aW9uIGNvbnN0cnVjdHMgYSBuZXcgZGF0ZSB1c2luZyB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgcmVmZXJlbmNlXG4gKiBkYXRlIGFuZCB0aGUgZ2l2ZW4gdmFsdWUuIEl0IGhlbHBzIHRvIGJ1aWxkIGdlbmVyaWMgZnVuY3Rpb25zIHRoYXQgYWNjZXB0XG4gKiBkYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogSXQgZGVmYXVsdHMgdG8gYERhdGVgIGlmIHRoZSBwYXNzZWQgcmVmZXJlbmNlIGRhdGUgaXMgYSBudW1iZXIgb3IgYSBzdHJpbmcuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgcmVmZXJlbmNlIGRhdGUgdG8gdGFrZSBjb25zdHJ1Y3RvciBmcm9tXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBkYXRlXG4gKlxuICogQHJldHVybnMgRGF0ZSBpbml0aWFsaXplZCB1c2luZyB0aGUgZ2l2ZW4gZGF0ZSBhbmQgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gJ2RhdGUtZm5zJ1xuICpcbiAqIC8vIEEgZnVuY3Rpb24gdGhhdCBjbG9uZXMgYSBkYXRlIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIHR5cGVcbiAqIGZ1bmN0aW9uIGNsb25lRGF0ZTxEYXRlVHlwZSBleHRlbmRzIERhdGUoZGF0ZTogRGF0ZVR5cGUpOiBEYXRlVHlwZSB7XG4gKiAgIHJldHVybiBjb25zdHJ1Y3RGcm9tKFxuICogICAgIGRhdGUsIC8vIFVzZSBjb250cnVzdG9yIGZyb20gdGhlIGdpdmVuIGRhdGVcbiAqICAgICBkYXRlLmdldFRpbWUoKSAvLyBVc2UgdGhlIGRhdGUgdmFsdWUgdG8gY3JlYXRlIGEgbmV3IGRhdGVcbiAqICAgKVxuICogfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0RnJvbShkYXRlLCB2YWx1ZSkge1xuICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbmV3IGRhdGUuY29uc3RydWN0b3IodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBjb25zdHJ1Y3RGcm9tO1xuIiwiaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20ubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgY29uc3RydWN0Tm93XG4gKiBAY2F0ZWdvcnkgR2VuZXJpYyBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb25zdHJ1Y3RzIGEgbmV3IGN1cnJlbnQgZGF0ZSB1c2luZyB0aGUgcGFzc2VkIHZhbHVlIGNvbnN0cnVjdG9yLlxuICogQHB1cmUgZmFsc2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgbmV3IGN1cnJlbnQgZGF0ZSB1c2luZyB0aGUgY29uc3RydWN0b3IgZnJvbVxuICogdGhlIHJlZmVyZW5jZSBkYXRlLiBJdCBoZWxwcyB0byBidWlsZCBnZW5lcmljIGZ1bmN0aW9ucyB0aGF0IGFjY2VwdCBkYXRlXG4gKiBleHRlbnNpb25zIGFuZCB1c2UgdGhlIGN1cnJlbnQgZGF0ZS5cbiAqXG4gKiBJdCBkZWZhdWx0cyB0byBgRGF0ZWAgaWYgdGhlIHBhc3NlZCByZWZlcmVuY2UgZGF0ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSByZWZlcmVuY2UgZGF0ZSB0byB0YWtlIGNvbnN0cnVjdG9yIGZyb21cbiAqXG4gKiBAcmV0dXJucyBDdXJyZW50IGRhdGUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGdpdmVuIGRhdGUgY29uc3RydWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uc3RydWN0Tm93LCBpc1NhbWVEYXkgfSBmcm9tICdkYXRlLWZucydcbiAqXG4gKiBmdW5jdGlvbiBpc1RvZGF5PERhdGVUeXBlIGV4dGVuZHMgRGF0ZT4oXG4gKiAgIGRhdGU6IERhdGVUeXBlIHwgbnVtYmVyIHwgc3RyaW5nLFxuICogKTogYm9vbGVhbiB7XG4gKiAgIC8vIElmIHdlIHdlcmUgdG8gdXNlIGBuZXcgRGF0ZSgpYCBkaXJlY3RseSwgdGhlIGZ1bmN0aW9uIHdvdWxkICBiZWhhdmVcbiAqICAgLy8gZGlmZmVyZW50bHkgaW4gZGlmZmVyZW50IHRpbWV6b25lcyBhbmQgcmV0dXJuIGZhbHNlIGZvciB0aGUgc2FtZSBkYXRlLlxuICogICByZXR1cm4gaXNTYW1lRGF5KGRhdGUsIGNvbnN0cnVjdE5vdyhkYXRlKSk7XG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3ROb3coZGF0ZSkge1xuICByZXR1cm4gY29uc3RydWN0RnJvbShkYXRlLCBEYXRlLm5vdygpKTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBjb25zdHJ1Y3ROb3c7XG4iLCJpbXBvcnQgeyBtaWxsaXNlY29uZHNJbkRheSB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZEYXkgfSBmcm9tIFwiLi9zdGFydE9mRGF5Lm1qc1wiO1xuaW1wb3J0IHsgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyB9IGZyb20gXCIuL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXNcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgZGF5cyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdGltZXMgYXJlIHJlbW92ZWRcbiAqIGZyb20gdGhlIGRhdGVzIGFuZCB0aGVuIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgaXMgY2FsY3VsYXRlZC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgbGF0ZXIgZGF0ZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBlYXJsaWVyIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTEgMjM6MDA6MDAgYW5kIDIgSnVseSAyMDEyIDAwOjAwOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKFxuICogICBuZXcgRGF0ZSgyMDEyLCA2LCAyLCAwLCAwKSxcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMiwgMjMsIDApXG4gKiApXG4gKiAvLz0+IDM2NlxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTEgMjM6NTk6MDAgYW5kIDMgSnVseSAyMDExIDAwOjAxOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKFxuICogICBuZXcgRGF0ZSgyMDExLCA2LCAzLCAwLCAxKSxcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMiwgMjMsIDU5KVxuICogKVxuICogLy89PiAxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBzdGFydE9mRGF5TGVmdCA9IHN0YXJ0T2ZEYXkoZGF0ZUxlZnQpO1xuICBjb25zdCBzdGFydE9mRGF5UmlnaHQgPSBzdGFydE9mRGF5KGRhdGVSaWdodCk7XG5cbiAgY29uc3QgdGltZXN0YW1wTGVmdCA9XG4gICAgK3N0YXJ0T2ZEYXlMZWZ0IC0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhzdGFydE9mRGF5TGVmdCk7XG4gIGNvbnN0IHRpbWVzdGFtcFJpZ2h0ID1cbiAgICArc3RhcnRPZkRheVJpZ2h0IC0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhzdGFydE9mRGF5UmlnaHQpO1xuXG4gIC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIGJlY2F1c2UgdGhlIG51bWJlciBvZlxuICAvLyBtaWxsaXNlY29uZHMgaW4gYSBkYXkgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKCh0aW1lc3RhbXBMZWZ0IC0gdGltZXN0YW1wUmlnaHQpIC8gbWlsbGlzZWNvbmRzSW5EYXkpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cztcbiIsImltcG9ydCB7IGRlZmF1bHRMb2NhbGUgfSBmcm9tIFwiLi9fbGliL2RlZmF1bHRMb2NhbGUubWpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuL19saWIvZGVmYXVsdE9wdGlvbnMubWpzXCI7XG5pbXBvcnQgeyBmb3JtYXR0ZXJzIH0gZnJvbSBcIi4vX2xpYi9mb3JtYXQvZm9ybWF0dGVycy5tanNcIjtcbmltcG9ydCB7IGxvbmdGb3JtYXR0ZXJzIH0gZnJvbSBcIi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMubWpzXCI7XG5pbXBvcnQge1xuICBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuLFxuICBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4sXG4gIHdhcm5PclRocm93UHJvdGVjdGVkRXJyb3IsXG59IGZyb20gXCIuL19saWIvcHJvdGVjdGVkVG9rZW5zLm1qc1wiO1xuaW1wb3J0IHsgaXNWYWxpZCB9IGZyb20gXCIuL2lzVmFsaWQubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8vIFJleHBvcnRzIG9mIGludGVybmFsIGZvciBsaWJyYXJpZXMgdG8gdXNlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM2MzgjaXNzdWVjb21tZW50LTE4NzcwODI4NzRcbmV4cG9ydCB7IGZvcm1hdHRlcnMsIGxvbmdGb3JtYXR0ZXJzIH07XG5cbi8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuY29uc3QgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9XG4gIC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuY29uc3QgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuY29uc3QgZXNjYXBlZFN0cmluZ1JlZ0V4cCA9IC9eJyhbXl0qPyknPyQvO1xuY29uc3QgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbmNvbnN0IHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwID0gL1thLXpBLVpdLztcblxuZXhwb3J0IHsgZm9ybWF0IGFzIGZvcm1hdERhdGUgfTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGZvcm1hdH0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGFsaWFzIGZvcm1hdERhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC4gVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqIChzZWUgdGhlIGxhc3QgZXhhbXBsZSlcbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIEFjY2VwdGVkIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCBSICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDAsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDAsIDAwMDEsIDE5MDAsIDIwMTcgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IHUgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8IDcgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWEgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8IGIuLmJiICAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmIgICAgIHwgYW0sIHBtLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBPT09PICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgIHwgei4uLnp6eiB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8IDYgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgUCAgICAgICB8IDA0LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBBcHIgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFAgICAgIHwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUCAgICB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwICAgICB8IDEyOjAwOjAwIEFNIEdNVCsyICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCBQcCAgICAgIHwgMDQvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBwcCAgICB8IEFwciAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQcHBwcHwgRnJpZGF5LCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgIHwgMiw3ICAgfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhcjpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXG4gKiAgICB0aGUgb3V0cHV0IHdpbGwgYmUgdGhlIHNhbWUgYXMgZGVmYXVsdCBwYXR0ZXJuIGZvciB0aGlzIHVuaXQsIHVzdWFsbHlcbiAqICAgIHRoZSBsb25nZXN0IG9uZSAoaW4gY2FzZSBvZiBJU08gd2Vla2RheXMsIGBFRUVFYCkuIERlZmF1bHQgcGF0dGVybnMgZm9yIHVuaXRzXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU0nKSAvLz0+ICdOJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogMy4gU29tZSBwYXR0ZXJucyBjb3VsZCBiZSB1bmxpbWl0ZWQgbGVuZ3RoIChzdWNoIGFzIGB5eXl5eXl5eWApLlxuICogICAgVGhlIG91dHB1dCB3aWxsIGJlIHBhZGRlZCB3aXRoIHplcm9zIHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICd5eXl5eXl5eScpIC8vPT4gJzAwMDAyMDE3J2BcbiAqXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxuICpcbiAqICAgIHwgWWVhciB8IGB5eWAgfCBgdXVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcbiAqICAgIHwgMSAgICB8ICAgMDEgfCAgIDAxIHxcbiAqICAgIHwgMTQgICB8ICAgMTQgfCAgIDE0IHxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcbiAqICAgIHwgMTQ1MyB8ICAgNTMgfCAxNDUzIHxcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtnZXRJU09XZWVrWWVhcl0oaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRJU09XZWVrWWVhcilcbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXIpKS5cbiAqXG4gKiA2LiBTcGVjaWZpYyBub24tbG9jYXRpb24gdGltZXpvbmVzIGFyZSBjdXJyZW50bHkgdW5hdmFpbGFibGUgaW4gYGRhdGUtZm5zYCxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXG4gKlxuICogNy4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBUYDogbWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA4LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICpcbiAqIDkuIGBEYCBhbmQgYEREYCB0b2tlbnMgcmVwcmVzZW50IGRheXMgb2YgdGhlIHllYXIgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggZGF5cyBvZiB0aGUgbW9udGguXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBzdHJpbmcgb2YgdG9rZW5zXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdExvbmdgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyB1c2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgZm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDEsIDExKSwgJ01NL2RkL3l5eXknKVxuICogLy89PiAnMDIvMTEvMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDIgSnVseSAyMDE0IGluIEVzcGVyYW50bzpcbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBcImRvICdkZScgTU1NTSB5eXl5XCIsIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFc2NhcGUgc3RyaW5nIGJ5IHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzOlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIsIDE1KSwgXCJoICdvJydjbG9jaydcIilcbiAqIC8vPT4gXCIzIG8nY2xvY2tcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGRhdGUsIGZvcm1hdFN0ciwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGxvY2FsZSA9IG9wdGlvbnM/LmxvY2FsZSA/PyBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgPz8gZGVmYXVsdExvY2FsZTtcblxuICBjb25zdCBmaXJzdFdlZWtDb250YWluc0RhdGUgPVxuICAgIG9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgZGVmYXVsdE9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICAxO1xuXG4gIGNvbnN0IHdlZWtTdGFydHNPbiA9XG4gICAgb3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIDA7XG5cbiAgY29uc3Qgb3JpZ2luYWxEYXRlID0gdG9EYXRlKGRhdGUpO1xuXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBsZXQgcGFydHMgPSBmb3JtYXRTdHJcbiAgICAubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHApXG4gICAgLm1hcCgoc3Vic3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcbiAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCJwXCIgfHwgZmlyc3RDaGFyYWN0ZXIgPT09IFwiUFwiKSB7XG4gICAgICAgIGNvbnN0IGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlLmZvcm1hdExvbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YnN0cmluZztcbiAgICB9KVxuICAgIC5qb2luKFwiXCIpXG4gICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApXG4gICAgLm1hcCgoc3Vic3RyaW5nKSA9PiB7XG4gICAgICAvLyBSZXBsYWNlIHR3byBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyB3aXRoIG9uZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyXG4gICAgICBpZiAoc3Vic3RyaW5nID09PSBcIicnXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBcIidcIiB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcbiAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl0pIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogdHJ1ZSwgdmFsdWU6IHN1YnN0cmluZyB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgIFwiRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGBcIiArXG4gICAgICAgICAgICBmaXJzdENoYXJhY3RlciArXG4gICAgICAgICAgICBcImBcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBzdWJzdHJpbmcgfTtcbiAgICB9KTtcblxuICAvLyBpbnZva2UgbG9jYWxpemUgcHJlcHJvY2Vzc29yIChvbmx5IGZvciBmcmVuY2ggbG9jYWxlcyBhdCB0aGUgbW9tZW50KVxuICBpZiAobG9jYWxlLmxvY2FsaXplLnByZXByb2Nlc3Nvcikge1xuICAgIHBhcnRzID0gbG9jYWxlLmxvY2FsaXplLnByZXByb2Nlc3NvcihvcmlnaW5hbERhdGUsIHBhcnRzKTtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlLFxuICAgIHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGUsXG4gIH07XG5cbiAgcmV0dXJuIHBhcnRzXG4gICAgLm1hcCgocGFydCkgPT4ge1xuICAgICAgaWYgKCFwYXJ0LmlzVG9rZW4pIHJldHVybiBwYXJ0LnZhbHVlO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IHBhcnQudmFsdWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zPy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMgJiZcbiAgICAgICAgICBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4odG9rZW4pKSB8fFxuICAgICAgICAoIW9wdGlvbnM/LnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiZcbiAgICAgICAgICBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSlcbiAgICAgICkge1xuICAgICAgICB3YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKHRva2VuLCBmb3JtYXRTdHIsIFN0cmluZyhkYXRlKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNbdG9rZW5bMF1dO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcmlnaW5hbERhdGUsIHRva2VuLCBsb2NhbGUubG9jYWxpemUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH0pXG4gICAgLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICBjb25zdCBtYXRjaGVkID0gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cCk7XG5cbiAgaWYgKCFtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdDtcbiIsImltcG9ydCB7IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyB9IGZyb20gXCIuL2RpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZZZWFyIH0gZnJvbSBcIi4vc3RhcnRPZlllYXIubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgZ2V0RGF5T2ZZZWFyXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgZGF5IG9mIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBkYXkgb2YgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBkYXkgb2YgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBkYXkgb2YgdGhlIHllYXIgaXMgMiBKdWx5IDIwMTQ/XG4gKiBjb25zdCByZXN1bHQgPSBnZXREYXlPZlllYXIobmV3IERhdGUoMjAxNCwgNiwgMikpXG4gKiAvLz0+IDE4M1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF5T2ZZZWFyKGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSB0b0RhdGUoZGF0ZSk7XG4gIGNvbnN0IGRpZmYgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoX2RhdGUsIHN0YXJ0T2ZZZWFyKF9kYXRlKSk7XG4gIGNvbnN0IGRheU9mWWVhciA9IGRpZmYgKyAxO1xuICByZXR1cm4gZGF5T2ZZZWFyO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGdldERheU9mWWVhcjtcbiIsImltcG9ydCB7IG1pbGxpc2Vjb25kc0luV2VlayB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZJU09XZWVrIH0gZnJvbSBcIi4vc3RhcnRPZklTT1dlZWsubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mSVNPV2Vla1llYXIgfSBmcm9tIFwiLi9zdGFydE9mSVNPV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgZ2V0SVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgSVNPIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIElTTyB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIElTTy13ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDIgSmFudWFyeSAyMDA1P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0SVNPV2VlayhuZXcgRGF0ZSgyMDA1LCAwLCAyKSlcbiAqIC8vPT4gNTNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElTT1dlZWsoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgZGlmZiA9ICtzdGFydE9mSVNPV2VlayhfZGF0ZSkgLSArc3RhcnRPZklTT1dlZWtZZWFyKF9kYXRlKTtcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIHdlZWtzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgYmVjYXVzZSB0aGUgbnVtYmVyIG9mXG4gIC8vIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBtaWxsaXNlY29uZHNJbldlZWspICsgMTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBnZXRJU09XZWVrO1xuIiwiaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20ubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mSVNPV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZJU09XZWVrLm1qc1wiO1xuaW1wb3J0IHsgdG9EYXRlIH0gZnJvbSBcIi4vdG9EYXRlLm1qc1wiO1xuXG4vKipcbiAqIEBuYW1lIGdldElTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUsXG4gKiB3aGljaCBhbHdheXMgc3RhcnRzIDMgZGF5cyBiZWZvcmUgdGhlIHllYXIncyBmaXJzdCBUaHVyc2RheS5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBJU08td2VlayBudW1iZXJpbmcgeWVhciBpcyAyIEphbnVhcnkgMjAwNT9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldElTT1dlZWtZZWFyKG5ldyBEYXRlKDIwMDUsIDAsIDIpKVxuICogLy89PiAyMDA0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJU09XZWVrWWVhcihkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuICBjb25zdCBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyID0gY29uc3RydWN0RnJvbShkYXRlLCAwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRGdWxsWWVhcih5ZWFyICsgMSwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIpO1xuXG4gIGNvbnN0IGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldEZ1bGxZZWFyKHllYXIsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyKTtcblxuICBpZiAoX2RhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZOZXh0WWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhciArIDE7XG4gIH0gZWxzZSBpZiAoX2RhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciAtIDE7XG4gIH1cbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBnZXRJU09XZWVrWWVhcjtcbiIsImltcG9ydCB7IG1pbGxpc2Vjb25kc0luV2VlayB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZXZWVrIH0gZnJvbSBcIi4vc3RhcnRPZldlZWsubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mV2Vla1llYXIgfSBmcm9tIFwiLi9zdGFydE9mV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogVGhlIHtAbGluayBnZXRXZWVrfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZ2V0V2Vla1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBsb2NhbCB3ZWVrIGluZGV4IG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBsb2NhbCB3ZWVrIGluZGV4IG9mIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIGV4YWN0IGNhbGN1bGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlcyBvZlxuICogYG9wdGlvbnMud2Vla1N0YXJ0c09uYCAod2hpY2ggaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWspXG4gKiBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAod2hpY2ggaXMgdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW5cbiAqIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyKVxuICpcbiAqIFdlZWsgbnVtYmVyaW5nOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWVrI1RoZV9JU09fd2Vla19kYXRlX3N5c3RlbVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIGxvY2FsIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDUgd2l0aCBkZWZhdWx0IG9wdGlvbnM/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrKG5ldyBEYXRlKDIwMDUsIDAsIDIpKVxuICogLy89PiAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIGxvY2FsIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDUsXG4gKiAvLyBpZiBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayxcbiAqIC8vIGFuZCB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBhbHdheXMgY29udGFpbnMgNCBKYW51YXJ5P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2VlayhuZXcgRGF0ZSgyMDA1LCAwLCAyKSwge1xuICogICB3ZWVrU3RhcnRzT246IDEsXG4gKiAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICogfSlcbiAqIC8vPT4gNTNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2VlayhkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCBkaWZmID0gK3N0YXJ0T2ZXZWVrKF9kYXRlLCBvcHRpb25zKSAtICtzdGFydE9mV2Vla1llYXIoX2RhdGUsIG9wdGlvbnMpO1xuXG4gIC8vIFJvdW5kIHRoZSBudW1iZXIgb2Ygd2Vla3MgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciBiZWNhdXNlIHRoZSBudW1iZXIgb2ZcbiAgLy8gbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnQgKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2ZcbiAgLy8gdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KS5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIG1pbGxpc2Vjb25kc0luV2VlaykgKyAxO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGdldFdlZWs7XG4iLCJpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSBcIi4vY29uc3RydWN0RnJvbS5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZXZWVrIH0gZnJvbSBcIi4vc3RhcnRPZldlZWsubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuL19saWIvZGVmYXVsdE9wdGlvbnMubWpzXCI7XG5cbi8qKlxuICogVGhlIHtAbGluayBnZXRXZWVrWWVhcn0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGdldFdlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgZXhhY3QgY2FsY3VsYXRpb24gZGVwZW5kcyBvbiB0aGUgdmFsdWVzIG9mXG4gKiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gICh3aGljaCBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaylcbiAqIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgICh3aGljaCBpcyB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzIGFsd2F5cyBpblxuICogdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIpXG4gKlxuICogV2VlayBudW1iZXJpbmc6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlZWsjVGhlX0lTT193ZWVrX2RhdGVfc3lzdGVtXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMjYgRGVjZW1iZXIgMjAwNCB3aXRoIHRoZSBkZWZhdWx0IHNldHRpbmdzP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla1llYXIobmV3IERhdGUoMjAwNCwgMTEsIDI2KSlcbiAqIC8vPT4gMjAwNVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB3ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDI2IERlY2VtYmVyIDIwMDQgaWYgd2VlayBzdGFydHMgb24gU2F0dXJkYXk/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDA0LCAxMSwgMjYpLCB7IHdlZWtTdGFydHNPbjogNiB9KVxuICogLy89PiAyMDA0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMjYgRGVjZW1iZXIgMjAwNCBpZiB0aGUgZmlyc3Qgd2VlayBjb250YWlucyA0IEphbnVhcnk/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDA0LCAxMSwgMjYpLCB7IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNCB9KVxuICogLy89PiAyMDA0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrWWVhcihkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XG4gICAgb3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIDE7XG5cbiAgY29uc3QgZmlyc3RXZWVrT2ZOZXh0WWVhciA9IGNvbnN0cnVjdEZyb20oZGF0ZSwgMCk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0RnVsbFllYXIoeWVhciArIDEsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vla09mTmV4dFllYXIsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZpcnN0V2Vla09mVGhpc1llYXIgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldEZ1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vla09mVGhpc1llYXIsIG9wdGlvbnMpO1xuXG4gIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGdldFdlZWtZZWFyO1xuIiwiLyoqXG4gKiBAbmFtZSBpc0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIHZhbHVlIGEgZGF0ZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZS4gVGhlIGZ1bmN0aW9uIHdvcmtzIGZvciBkYXRlcyB0cmFuc2ZlcnJlZCBhY3Jvc3MgaWZyYW1lcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGEgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZSgpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUobmV3IERhdGUoTmFOKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3Igc29tZSB2YWx1ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZSgnMjAxNC0wMi0zMScpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBvYmplY3Q6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUoe30pXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIilcbiAgKTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBpc0RhdGU7XG4iLCJpbXBvcnQgeyBzdGFydE9mRGF5IH0gZnJvbSBcIi4vc3RhcnRPZkRheS5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVEYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBkYXkgKGFuZCB5ZWFyIGFuZCBtb250aCk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuXG4gKiBAcmV0dXJucyBUaGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMDY6MDA6MDAgYW5kIDQgU2VwdGVtYmVyIDE4OjAwOjAwIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAwKSwgbmV3IERhdGUoMjAxNCwgOCwgNCwgMTgsIDApKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciBhbmQgNCBPY3RvYmVyIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0KSwgbmV3IERhdGUoMjAxNCwgOSwgNCkpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciwgMjAxNCBhbmQgNCBTZXB0ZW1iZXIsIDIwMTUgaW4gdGhlIHNhbWUgZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDQpLCBuZXcgRGF0ZSgyMDE1LCA4LCA0KSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FtZURheShkYXRlTGVmdCwgZGF0ZVJpZ2h0KSB7XG4gIGNvbnN0IGRhdGVMZWZ0U3RhcnRPZkRheSA9IHN0YXJ0T2ZEYXkoZGF0ZUxlZnQpO1xuICBjb25zdCBkYXRlUmlnaHRTdGFydE9mRGF5ID0gc3RhcnRPZkRheShkYXRlUmlnaHQpO1xuXG4gIHJldHVybiArZGF0ZUxlZnRTdGFydE9mRGF5ID09PSArZGF0ZVJpZ2h0U3RhcnRPZkRheTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBpc1NhbWVEYXk7XG4iLCJpbXBvcnQgeyBjb25zdHJ1Y3ROb3cgfSBmcm9tIFwiLi9jb25zdHJ1Y3ROb3cubWpzXCI7XG5pbXBvcnQgeyBpc1NhbWVEYXkgfSBmcm9tIFwiLi9pc1NhbWVEYXkubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgaXNUb2RheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgdG9kYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgNiBPY3RvYmVyIDIwMTQsIGlzIDYgT2N0b2JlciAxNDowMDowMCB0b2RheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVG9kYXkobmV3IERhdGUoMjAxNCwgOSwgNiwgMTQsIDApKVxuICogLy89PiB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RvZGF5KGRhdGUpIHtcbiAgcmV0dXJuIGlzU2FtZURheShkYXRlLCBjb25zdHJ1Y3ROb3coZGF0ZSkpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGlzVG9kYXk7XG4iLCJpbXBvcnQgeyBpc0RhdGUgfSBmcm9tIFwiLi9pc0RhdGUubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgaXNWYWxpZFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAqIEFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBEYXRlIHVzaW5nIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV0oaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGUpXG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cbiAqXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMgVGhlIGRhdGUgaXMgdmFsaWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWxpZCBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgyMDE0LCAxLCAzMSkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWx1ZSwgY29udmVydGFibGUgaW50byBhIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKDEzOTM4MDQ4MDAwMDApXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQoZGF0ZSkge1xuICBpZiAoIWlzRGF0ZShkYXRlKSAmJiB0eXBlb2YgZGF0ZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgcmV0dXJuICFpc05hTihOdW1iZXIoX2RhdGUpKTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBpc1ZhbGlkO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRm9ybWF0TG9uZ0ZuKGFyZ3MpIHtcbiAgcmV0dXJuIChvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgU3RyaW5nKClcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcbiAgICBjb25zdCBmb3JtYXQgPSBhcmdzLmZvcm1hdHNbd2lkdGhdIHx8IGFyZ3MuZm9ybWF0c1thcmdzLmRlZmF1bHRXaWR0aF07XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogVGhlIGxvY2FsaXplIGZ1bmN0aW9uIGFyZ3VtZW50IGNhbGxiYWNrIHdoaWNoIGFsbG93cyB0byBjb252ZXJ0IHJhdyB2YWx1ZSB0b1xuICogdGhlIGFjdHVhbCB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB2YWx1ZVxuICovXG5cbi8qKlxuICogVGhlIG1hcCBvZiBsb2NhbGl6ZWQgdmFsdWVzIGZvciBlYWNoIHdpZHRoLlxuICovXG5cbi8qKlxuICogVGhlIGluZGV4IHR5cGUgb2YgdGhlIGxvY2FsZSB1bml0IHZhbHVlLiBJdCB0eXBlcyBjb252ZXJzaW9uIG9mIHVuaXRzIG9mXG4gKiB2YWx1ZXMgdGhhdCBkb24ndCBzdGFydCBhdCAwIChpLmUuIHF1YXJ0ZXJzKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB1bml0IHZhbHVlIHRvIHRoZSB0dXBsZSBvZiB2YWx1ZXMuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGVyYSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgQkMsXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgcmVwcmVzZW50cyBBRC5cbiAqL1xuXG4vKipcbiAqIFRoZSB0dXBsZSBvZiBsb2NhbGl6ZWQgcXVhcnRlciB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgUTEuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGRheSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgU3VuZGF5LlxuICovXG5cbi8qKlxuICogVGhlIHR1cGxlIG9mIGxvY2FsaXplZCBtb250aCB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgSmFudWFyeS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb2NhbGl6ZUZuKGFyZ3MpIHtcbiAgcmV0dXJuICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zPy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiBcInN0YW5kYWxvbmVcIjtcblxuICAgIGxldCB2YWx1ZXNBcnJheTtcbiAgICBpZiAoY29udGV4dCA9PT0gXCJmb3JtYXR0aW5nXCIgJiYgYXJncy5mb3JtYXR0aW5nVmFsdWVzKSB7XG4gICAgICBjb25zdCBkZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRGb3JtYXR0aW5nV2lkdGggfHwgYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnM/LndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9XG4gICAgICAgIGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1t3aWR0aF0gfHwgYXJncy5mb3JtYXR0aW5nVmFsdWVzW2RlZmF1bHRXaWR0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zPy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MudmFsdWVzW3dpZHRoXSB8fCBhcmdzLnZhbHVlc1tkZWZhdWx0V2lkdGhdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGFyZ3MuYXJndW1lbnRDYWxsYmFjayA/IGFyZ3MuYXJndW1lbnRDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBGb3Igc29tZSByZWFzb24gVHlwZVNjcmlwdCBqdXN0IGRvbid0IHdhbnQgdG8gbWF0Y2ggaXQsIG5vIG1hdHRlciBob3cgaGFyZCB3ZSB0cnkuIEkgY2hhbGxlbmdlIHlvdSB0byB0cnkgdG8gcmVtb3ZlIGl0IVxuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF07XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYnVpbGRNYXRjaEZuKGFyZ3MpIHtcbiAgcmV0dXJuIChzdHJpbmcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucy53aWR0aDtcblxuICAgIGNvbnN0IG1hdGNoUGF0dGVybiA9XG4gICAgICAod2lkdGggJiYgYXJncy5tYXRjaFBhdHRlcm5zW3dpZHRoXSkgfHxcbiAgICAgIGFyZ3MubWF0Y2hQYXR0ZXJuc1thcmdzLmRlZmF1bHRNYXRjaFdpZHRoXTtcbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChtYXRjaFBhdHRlcm4pO1xuXG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcblxuICAgIGNvbnN0IHBhcnNlUGF0dGVybnMgPVxuICAgICAgKHdpZHRoICYmIGFyZ3MucGFyc2VQYXR0ZXJuc1t3aWR0aF0pIHx8XG4gICAgICBhcmdzLnBhcnNlUGF0dGVybnNbYXJncy5kZWZhdWx0UGFyc2VXaWR0aF07XG5cbiAgICBjb25zdCBrZXkgPSBBcnJheS5pc0FycmF5KHBhcnNlUGF0dGVybnMpXG4gICAgICA/IGZpbmRJbmRleChwYXJzZVBhdHRlcm5zLCAocGF0dGVybikgPT4gcGF0dGVybi50ZXN0KG1hdGNoZWRTdHJpbmcpKVxuICAgICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgICAgIGZpbmRLZXkocGFyc2VQYXR0ZXJucywgKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChtYXRjaGVkU3RyaW5nKSk7XG5cbiAgICBsZXQgdmFsdWU7XG5cbiAgICB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhrZXkpIDoga2V5O1xuICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZUNhbGxiYWNrXG4gICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEkgY2hhbGxhbmdlIHlvdSB0byBmaXggdGhlIHR5cGVcbiAgICAgICAgb3B0aW9ucy52YWx1ZUNhbGxiYWNrKHZhbHVlKVxuICAgICAgOiB2YWx1ZTtcblxuICAgIGNvbnN0IHJlc3QgPSBzdHJpbmcuc2xpY2UobWF0Y2hlZFN0cmluZy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHsgdmFsdWUsIHJlc3QgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmXG4gICAgICBwcmVkaWNhdGUob2JqZWN0W2tleV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBhcnJheS5sZW5ndGg7IGtleSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtrZXldKSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuKGFyZ3MpIHtcbiAgcmV0dXJuIChzdHJpbmcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MubWF0Y2hQYXR0ZXJuKTtcbiAgICBpZiAoIW1hdGNoUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG5cbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLnBhcnNlUGF0dGVybik7XG4gICAgaWYgKCFwYXJzZVJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgbGV0IHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrXG4gICAgICA/IGFyZ3MudmFsdWVDYWxsYmFjayhwYXJzZVJlc3VsdFswXSlcbiAgICAgIDogcGFyc2VSZXN1bHRbMF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG5cbiAgICBjb25zdCByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcblxuICAgIHJldHVybiB7IHZhbHVlLCByZXN0IH07XG4gIH07XG59XG4iLCJpbXBvcnQgeyBmb3JtYXREaXN0YW5jZSB9IGZyb20gXCIuL2VuLVVTL19saWIvZm9ybWF0RGlzdGFuY2UubWpzXCI7XG5pbXBvcnQgeyBmb3JtYXRMb25nIH0gZnJvbSBcIi4vZW4tVVMvX2xpYi9mb3JtYXRMb25nLm1qc1wiO1xuaW1wb3J0IHsgZm9ybWF0UmVsYXRpdmUgfSBmcm9tIFwiLi9lbi1VUy9fbGliL2Zvcm1hdFJlbGF0aXZlLm1qc1wiO1xuaW1wb3J0IHsgbG9jYWxpemUgfSBmcm9tIFwiLi9lbi1VUy9fbGliL2xvY2FsaXplLm1qc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi9lbi1VUy9fbGliL21hdGNoLm1qc1wiO1xuXG4vKipcbiAqIEBjYXRlZ29yeSBMb2NhbGVzXG4gKiBAc3VtbWFyeSBFbmdsaXNoIGxvY2FsZSAoVW5pdGVkIFN0YXRlcykuXG4gKiBAbGFuZ3VhZ2UgRW5nbGlzaFxuICogQGlzby02MzktMiBlbmdcbiAqIEBhdXRob3IgU2FzaGEgS29zcyBbQGtvc3Nub2NvcnBdKGh0dHBzOi8vZ2l0aHViLmNvbS9rb3Nzbm9jb3JwKVxuICogQGF1dGhvciBMZXNoYSBLb3NzIFtAbGVzaGFrb3NzXShodHRwczovL2dpdGh1Yi5jb20vbGVzaGFrb3NzKVxuICovXG5leHBvcnQgY29uc3QgZW5VUyA9IHtcbiAgY29kZTogXCJlbi1VU1wiLFxuICBmb3JtYXREaXN0YW5jZTogZm9ybWF0RGlzdGFuY2UsXG4gIGZvcm1hdExvbmc6IGZvcm1hdExvbmcsXG4gIGZvcm1hdFJlbGF0aXZlOiBmb3JtYXRSZWxhdGl2ZSxcbiAgbG9jYWxpemU6IGxvY2FsaXplLFxuICBtYXRjaDogbWF0Y2gsXG4gIG9wdGlvbnM6IHtcbiAgICB3ZWVrU3RhcnRzT246IDAgLyogU3VuZGF5ICovLFxuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogMSxcbiAgfSxcbn07XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgZW5VUztcbiIsImNvbnN0IGZvcm1hdERpc3RhbmNlTG9jYWxlID0ge1xuICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgb25lOiBcImxlc3MgdGhhbiBhIHNlY29uZFwiLFxuICAgIG90aGVyOiBcImxlc3MgdGhhbiB7e2NvdW50fX0gc2Vjb25kc1wiLFxuICB9LFxuXG4gIHhTZWNvbmRzOiB7XG4gICAgb25lOiBcIjEgc2Vjb25kXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IHNlY29uZHNcIixcbiAgfSxcblxuICBoYWxmQU1pbnV0ZTogXCJoYWxmIGEgbWludXRlXCIsXG5cbiAgbGVzc1RoYW5YTWludXRlczoge1xuICAgIG9uZTogXCJsZXNzIHRoYW4gYSBtaW51dGVcIixcbiAgICBvdGhlcjogXCJsZXNzIHRoYW4ge3tjb3VudH19IG1pbnV0ZXNcIixcbiAgfSxcblxuICB4TWludXRlczoge1xuICAgIG9uZTogXCIxIG1pbnV0ZVwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSBtaW51dGVzXCIsXG4gIH0sXG5cbiAgYWJvdXRYSG91cnM6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSBob3VyXCIsXG4gICAgb3RoZXI6IFwiYWJvdXQge3tjb3VudH19IGhvdXJzXCIsXG4gIH0sXG5cbiAgeEhvdXJzOiB7XG4gICAgb25lOiBcIjEgaG91clwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSBob3Vyc1wiLFxuICB9LFxuXG4gIHhEYXlzOiB7XG4gICAgb25lOiBcIjEgZGF5XCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IGRheXNcIixcbiAgfSxcblxuICBhYm91dFhXZWVrczoge1xuICAgIG9uZTogXCJhYm91dCAxIHdlZWtcIixcbiAgICBvdGhlcjogXCJhYm91dCB7e2NvdW50fX0gd2Vla3NcIixcbiAgfSxcblxuICB4V2Vla3M6IHtcbiAgICBvbmU6IFwiMSB3ZWVrXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IHdlZWtzXCIsXG4gIH0sXG5cbiAgYWJvdXRYTW9udGhzOiB7XG4gICAgb25lOiBcImFib3V0IDEgbW9udGhcIixcbiAgICBvdGhlcjogXCJhYm91dCB7e2NvdW50fX0gbW9udGhzXCIsXG4gIH0sXG5cbiAgeE1vbnRoczoge1xuICAgIG9uZTogXCIxIG1vbnRoXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IG1vbnRoc1wiLFxuICB9LFxuXG4gIGFib3V0WFllYXJzOiB7XG4gICAgb25lOiBcImFib3V0IDEgeWVhclwiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxuXG4gIHhZZWFyczoge1xuICAgIG9uZTogXCIxIHllYXJcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0geWVhcnNcIixcbiAgfSxcblxuICBvdmVyWFllYXJzOiB7XG4gICAgb25lOiBcIm92ZXIgMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwib3ZlciB7e2NvdW50fX0geWVhcnNcIixcbiAgfSxcblxuICBhbG1vc3RYWWVhcnM6IHtcbiAgICBvbmU6IFwiYWxtb3N0IDEgeWVhclwiLFxuICAgIG90aGVyOiBcImFsbW9zdCB7e2NvdW50fX0geWVhcnNcIixcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXREaXN0YW5jZSA9ICh0b2tlbiwgY291bnQsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdDtcblxuICBjb25zdCB0b2tlblZhbHVlID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dO1xuICBpZiAodHlwZW9mIHRva2VuVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlO1xuICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgcmVzdWx0ID0gdG9rZW5WYWx1ZS5vbmU7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdG9rZW5WYWx1ZS5vdGhlci5yZXBsYWNlKFwie3tjb3VudH19XCIsIGNvdW50LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnM/LmFkZFN1ZmZpeCkge1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gJiYgb3B0aW9ucy5jb21wYXJpc29uID4gMCkge1xuICAgICAgcmV0dXJuIFwiaW4gXCIgKyByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBcIiBhZ29cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsImltcG9ydCB7IGJ1aWxkRm9ybWF0TG9uZ0ZuIH0gZnJvbSBcIi4uLy4uL19saWIvYnVpbGRGb3JtYXRMb25nRm4ubWpzXCI7XG5cbmNvbnN0IGRhdGVGb3JtYXRzID0ge1xuICBmdWxsOiBcIkVFRUUsIE1NTU0gZG8sIHlcIixcbiAgbG9uZzogXCJNTU1NIGRvLCB5XCIsXG4gIG1lZGl1bTogXCJNTU0gZCwgeVwiLFxuICBzaG9ydDogXCJNTS9kZC95eXl5XCIsXG59O1xuXG5jb25zdCB0aW1lRm9ybWF0cyA9IHtcbiAgZnVsbDogXCJoOm1tOnNzIGEgenp6elwiLFxuICBsb25nOiBcImg6bW06c3MgYSB6XCIsXG4gIG1lZGl1bTogXCJoOm1tOnNzIGFcIixcbiAgc2hvcnQ6IFwiaDptbSBhXCIsXG59O1xuXG5jb25zdCBkYXRlVGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVwiLFxuICBsb25nOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbWVkaXVtOiBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiLFxuICBzaG9ydDogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRMb25nID0ge1xuICBkYXRlOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXG4gICAgZGVmYXVsdFdpZHRoOiBcImZ1bGxcIixcbiAgfSksXG5cbiAgdGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IHRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJmdWxsXCIsXG4gIH0pLFxuXG4gIGRhdGVUaW1lOiBidWlsZEZvcm1hdExvbmdGbih7XG4gICAgZm9ybWF0czogZGF0ZVRpbWVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJmdWxsXCIsXG4gIH0pLFxufTtcbiIsImNvbnN0IGZvcm1hdFJlbGF0aXZlTG9jYWxlID0ge1xuICBsYXN0V2VlazogXCInbGFzdCcgZWVlZSAnYXQnIHBcIixcbiAgeWVzdGVyZGF5OiBcIid5ZXN0ZXJkYXkgYXQnIHBcIixcbiAgdG9kYXk6IFwiJ3RvZGF5IGF0JyBwXCIsXG4gIHRvbW9ycm93OiBcIid0b21vcnJvdyBhdCcgcFwiLFxuICBuZXh0V2VlazogXCJlZWVlICdhdCcgcFwiLFxuICBvdGhlcjogXCJQXCIsXG59O1xuXG5leHBvcnQgY29uc3QgZm9ybWF0UmVsYXRpdmUgPSAodG9rZW4sIF9kYXRlLCBfYmFzZURhdGUsIF9vcHRpb25zKSA9PlxuICBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl07XG4iLCJpbXBvcnQgeyBidWlsZExvY2FsaXplRm4gfSBmcm9tIFwiLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4ubWpzXCI7XG5cbmNvbnN0IGVyYVZhbHVlcyA9IHtcbiAgbmFycm93OiBbXCJCXCIsIFwiQVwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcIkJDXCIsIFwiQURcIl0sXG4gIHdpZGU6IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXSxcbn07XG5cbmNvbnN0IHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcIlExXCIsIFwiUTJcIiwgXCJRM1wiLCBcIlE0XCJdLFxuICB3aWRlOiBbXCIxc3QgcXVhcnRlclwiLCBcIjJuZCBxdWFydGVyXCIsIFwiM3JkIHF1YXJ0ZXJcIiwgXCI0dGggcXVhcnRlclwiXSxcbn07XG5cbi8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cbmNvbnN0IG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIixcbiAgXSxcblxuICB3aWRlOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIixcbiAgXSxcbn07XG5cbmNvbnN0IGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbXCJTXCIsIFwiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCJdLFxuICBzaG9ydDogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXG4gIGFiYnJldmlhdGVkOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIHdpZGU6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCIsXG4gIF0sXG59O1xuXG5jb25zdCBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogXCJBTVwiLFxuICAgIHBtOiBcIlBNXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiBcImEubS5cIixcbiAgICBwbTogXCJwLm0uXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbn07XG5cbmNvbnN0IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogXCJBTVwiLFxuICAgIHBtOiBcIlBNXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiBcImEubS5cIixcbiAgICBwbTogXCJwLm0uXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbn07XG5cbmNvbnN0IG9yZGluYWxOdW1iZXIgPSAoZGlydHlOdW1iZXIsIF9vcHRpb25zKSA9PiB7XG4gIGNvbnN0IG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG5cbiAgLy8gSWYgb3JkaW5hbCBudW1iZXJzIGRlcGVuZCBvbiBjb250ZXh0LCBmb3IgZXhhbXBsZSxcbiAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgLlxuICAvL1xuICAvLyBgdW5pdGAgY2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2RheU9mWWVhcicsXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJy5cblxuICBjb25zdCByZW0xMDAgPSBudW1iZXIgJSAxMDA7XG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwic3RcIjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwibmRcIjtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwicmRcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlciArIFwidGhcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBsb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcixcblxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgICBhcmd1bWVudENhbGxiYWNrOiAocXVhcnRlcikgPT4gcXVhcnRlciAtIDEsXG4gIH0pLFxuXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgZGF5OiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5VmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxuXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6IFwid2lkZVwiLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxufTtcbiIsImltcG9ydCB7IGJ1aWxkTWF0Y2hGbiB9IGZyb20gXCIuLi8uLi9fbGliL2J1aWxkTWF0Y2hGbi5tanNcIjtcbmltcG9ydCB7IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4gfSBmcm9tIFwiLi4vLi4vX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuLm1qc1wiO1xuXG5jb25zdCBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pO1xuY29uc3QgcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybiA9IC9cXGQrL2k7XG5cbmNvbnN0IG1hdGNoRXJhUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYnxhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oYlxcLj9cXHM/Y1xcLj98YlxcLj9cXHM/Y1xcLj9cXHM/ZVxcLj98YVxcLj9cXHM/ZFxcLj98Y1xcLj9cXHM/ZVxcLj8pL2ksXG4gIHdpZGU6IC9eKGJlZm9yZSBjaHJpc3R8YmVmb3JlIGNvbW1vbiBlcmF8YW5ubyBkb21pbml8Y29tbW9uIGVyYSkvaSxcbn07XG5jb25zdCBwYXJzZUVyYVBhdHRlcm5zID0ge1xuICBhbnk6IFsvXmIvaSwgL14oYXxjKS9pXSxcbn07XG5cbmNvbnN0IG1hdGNoUXVhcnRlclBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eWzEyMzRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXnFbMTIzNF0vaSxcbiAgd2lkZTogL15bMTIzNF0odGh8c3R8bmR8cmQpPyBxdWFydGVyL2ksXG59O1xuY29uc3QgcGFyc2VRdWFydGVyUGF0dGVybnMgPSB7XG4gIGFueTogWy8xL2ksIC8yL2ksIC8zL2ksIC80L2ldLFxufTtcblxuY29uc3QgbWF0Y2hNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW2pmbWFzb25kXS9pLFxuICBhYmJyZXZpYXRlZDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXG4gIHdpZGU6IC9eKGphbnVhcnl8ZmVicnVhcnl8bWFyY2h8YXByaWx8bWF5fGp1bmV8anVseXxhdWd1c3R8c2VwdGVtYmVyfG9jdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2ksXG59O1xuY29uc3QgcGFyc2VNb250aFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFtcbiAgICAvXmovaSxcbiAgICAvXmYvaSxcbiAgICAvXm0vaSxcbiAgICAvXmEvaSxcbiAgICAvXm0vaSxcbiAgICAvXmovaSxcbiAgICAvXmovaSxcbiAgICAvXmEvaSxcbiAgICAvXnMvaSxcbiAgICAvXm8vaSxcbiAgICAvXm4vaSxcbiAgICAvXmQvaSxcbiAgXSxcblxuICBhbnk6IFtcbiAgICAvXmphL2ksXG4gICAgL15mL2ksXG4gICAgL15tYXIvaSxcbiAgICAvXmFwL2ksXG4gICAgL15tYXkvaSxcbiAgICAvXmp1bi9pLFxuICAgIC9eanVsL2ksXG4gICAgL15hdS9pLFxuICAgIC9ecy9pLFxuICAgIC9eby9pLFxuICAgIC9ebi9pLFxuICAgIC9eZC9pLFxuICBdLFxufTtcblxuY29uc3QgbWF0Y2hEYXlQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXltzbXR3Zl0vaSxcbiAgc2hvcnQ6IC9eKHN1fG1vfHR1fHdlfHRofGZyfHNhKS9pLFxuICBhYmJyZXZpYXRlZDogL14oc3VufG1vbnx0dWV8d2VkfHRodXxmcml8c2F0KS9pLFxuICB3aWRlOiAvXihzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSkvaSxcbn07XG5jb25zdCBwYXJzZURheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IFsvXnMvaSwgL15tL2ksIC9edC9pLCAvXncvaSwgL150L2ksIC9eZi9pLCAvXnMvaV0sXG4gIGFueTogWy9ec3UvaSwgL15tL2ksIC9edHUvaSwgL153L2ksIC9edGgvaSwgL15mL2ksIC9ec2EvaV0sXG59O1xuXG5jb25zdCBtYXRjaERheVBlcmlvZFBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eKGF8cHxtaXxufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcbiAgYW55OiAvXihbYXBdXFwuP1xccz9tXFwuP3xtaWRuaWdodHxub29ufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcbn07XG5jb25zdCBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xuICBhbnk6IHtcbiAgICBhbTogL15hL2ksXG4gICAgcG06IC9ecC9pLFxuICAgIG1pZG5pZ2h0OiAvXm1pL2ksXG4gICAgbm9vbjogL15uby9pLFxuICAgIG1vcm5pbmc6IC9tb3JuaW5nL2ksXG4gICAgYWZ0ZXJub29uOiAvYWZ0ZXJub29uL2ksXG4gICAgZXZlbmluZzogL2V2ZW5pbmcvaSxcbiAgICBuaWdodDogL25pZ2h0L2ksXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgbWF0Y2ggPSB7XG4gIG9yZGluYWxOdW1iZXI6IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oe1xuICAgIG1hdGNoUGF0dGVybjogbWF0Y2hPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICBwYXJzZVBhdHRlcm46IHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4sXG4gICAgdmFsdWVDYWxsYmFjazogKHZhbHVlKSA9PiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICB9KSxcblxuICBlcmE6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJ3aWRlXCIsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VFcmFQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgfSksXG5cbiAgcXVhcnRlcjogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJ3aWRlXCIsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VRdWFydGVyUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCIsXG4gICAgdmFsdWVDYWxsYmFjazogKGluZGV4KSA9PiBpbmRleCArIDEsXG4gIH0pLFxuXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoTW9udGhQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJ3aWRlXCIsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiLFxuICB9KSxcblxuICBkYXk6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJ3aWRlXCIsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgfSksXG5cbiAgZGF5UGVyaW9kOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMsXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6IFwiYW55XCIsXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgfSksXG59O1xuIiwiaW1wb3J0IHsgdG9EYXRlIH0gZnJvbSBcIi4vdG9EYXRlLm1qc1wiO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZEYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgZGF5IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIGRheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBkYXkgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCkpXG4gKiAvLz0+IFR1ZSBTZXAgMDIgMjAxNCAwMDowMDowMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZkRheShkYXRlKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IHN0YXJ0T2ZEYXk7XG4iLCJpbXBvcnQgeyBzdGFydE9mV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZXZWVrLm1qc1wiO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZJU09XZWVrXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYW4gSVNPIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZklTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mSVNPV2VlayhkYXRlKSB7XG4gIHJldHVybiBzdGFydE9mV2VlayhkYXRlLCB7IHdlZWtTdGFydHNPbjogMSB9KTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBzdGFydE9mSVNPV2VlaztcbiIsImltcG9ydCB7IGdldElTT1dlZWtZZWFyIH0gZnJvbSBcIi4vZ2V0SVNPV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mSVNPV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZJU09XZWVrLm1qc1wiO1xuaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20ubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZklTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLFxuICogd2hpY2ggYWx3YXlzIHN0YXJ0cyAzIGRheXMgYmVmb3JlIHRoZSB5ZWFyJ3MgZmlyc3QgVGh1cnNkYXkuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgMiBKdWx5IDIwMDU6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mSVNPV2Vla1llYXIobmV3IERhdGUoMjAwNSwgNiwgMikpXG4gKiAvLz0+IE1vbiBKYW4gMDMgMjAwNSAwMDowMDowMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZklTT1dlZWtZZWFyKGRhdGUpIHtcbiAgY29uc3QgeWVhciA9IGdldElTT1dlZWtZZWFyKGRhdGUpO1xuICBjb25zdCBmb3VydGhPZkphbnVhcnkgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmb3VydGhPZkphbnVhcnkuc2V0RnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIHN0YXJ0T2ZJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSk7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgc3RhcnRPZklTT1dlZWtZZWFyO1xuIiwiaW1wb3J0IHsgdG9EYXRlIH0gZnJvbSBcIi4vdG9EYXRlLm1qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdE9wdGlvbnMgfSBmcm9tIFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLm1qc1wiO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgc3RhcnRPZldlZWt9IGZ1bmN0aW9uIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mV2Vla1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYSB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBTdW4gQXVnIDMxIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdGhlIHdlZWsgc3RhcnRzIG9uIE1vbmRheSwgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mV2VlayhkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgY29uc3Qgd2Vla1N0YXJ0c09uID1cbiAgICBvcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICBvcHRpb25zPy5sb2NhbGU/Lm9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIGRlZmF1bHRPcHRpb25zLndlZWtTdGFydHNPbiA/P1xuICAgIGRlZmF1bHRPcHRpb25zLmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgMDtcblxuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgZGF5ID0gX2RhdGUuZ2V0RGF5KCk7XG4gIGNvbnN0IGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuXG4gIF9kYXRlLnNldERhdGUoX2RhdGUuZ2V0RGF0ZSgpIC0gZGlmZik7XG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgc3RhcnRPZldlZWs7XG4iLCJpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSBcIi4vY29uc3RydWN0RnJvbS5tanNcIjtcbmltcG9ydCB7IGdldFdlZWtZZWFyIH0gZnJvbSBcIi4vZ2V0V2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZXZWVrLm1qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdE9wdGlvbnMgfSBmcm9tIFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLm1qc1wiO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgc3RhcnRPZldlZWtZZWFyfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZldlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqIFRoZSBleGFjdCBjYWxjdWxhdGlvbiBkZXBlbmRzIG9uIHRoZSB2YWx1ZXMgb2ZcbiAqIGBvcHRpb25zLndlZWtTdGFydHNPbmAgKHdoaWNoIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrKVxuICogYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKHdoaWNoIGlzIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXMgYWx3YXlzIGluXG4gKiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhcilcbiAqXG4gKiBXZWVrIG51bWJlcmluZzogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VlayNUaGVfSVNPX3dlZWtfZGF0ZV9zeXN0ZW1cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYSB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBhIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1IHdpdGggZGVmYXVsdCBzZXR0aW5nczpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCA2LCAyKSlcbiAqIC8vPT4gU3VuIERlYyAyNiAyMDA0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1XG4gKiAvLyBpZiBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB3ZWVrXG4gKiAvLyBhbmQgNCBKYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhcjpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCA2LCAyKSwge1xuICogICB3ZWVrU3RhcnRzT246IDEsXG4gKiAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICogfSlcbiAqIC8vPT4gTW9uIEphbiAwMyAyMDA1IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mV2Vla1llYXIoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XG4gICAgb3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIDE7XG5cbiAgY29uc3QgeWVhciA9IGdldFdlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdFdlZWsgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmaXJzdFdlZWsuc2V0RnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBfZGF0ZSA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vlaywgb3B0aW9ucyk7XG4gIHJldHVybiBfZGF0ZTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBzdGFydE9mV2Vla1llYXI7XG4iLCJpbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5pbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSBcIi4vY29uc3RydWN0RnJvbS5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBzdGFydE9mWWVhclxuICogQGNhdGVnb3J5IFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIHllYXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIHllYXIgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGEgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSB5ZWFyIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZlllYXIobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwMCkpXG4gKiAvLz0+IFdlZCBKYW4gMDEgMjAxNCAwMDowMDowMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZlllYXIoZGF0ZSkge1xuICBjb25zdCBjbGVhbkRhdGUgPSB0b0RhdGUoZGF0ZSk7XG4gIGNvbnN0IF9kYXRlID0gY29uc3RydWN0RnJvbShkYXRlLCAwKTtcbiAgX2RhdGUuc2V0RnVsbFllYXIoY2xlYW5EYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICBfZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIF9kYXRlO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IHN0YXJ0T2ZZZWFyO1xuIiwiLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGFyZ3VtZW50IC0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCkge1xuICBjb25zdCBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpO1xuXG4gIC8vIENsb25lIHRoZSBkYXRlXG4gIGlmIChcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAodHlwZW9mIGFyZ3VtZW50ID09PSBcIm9iamVjdFwiICYmIGFyZ1N0ciA9PT0gXCJbb2JqZWN0IERhdGVdXCIpXG4gICkge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgYXJndW1lbnQuY29uc3RydWN0b3IoK2FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09IFwibnVtYmVyXCIgfHxcbiAgICBhcmdTdHIgPT09IFwiW29iamVjdCBOdW1iZXJdXCIgfHxcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBhcmdTdHIgPT09IFwiW29iamVjdCBTdHJpbmddXCJcbiAgKSB7XG4gICAgLy8gVE9ETzogQ2FuIHdlIGdldCByaWQgb2YgYXM/XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBDYW4gd2UgZ2V0IHJpZCBvZiBhcz9cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IHRvRGF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==